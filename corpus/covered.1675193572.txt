/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | interface AggregatorV3Interface {
  5 |     |   function decimals() external view returns (uint8);
  6 |     | 
  7 |     |   function description() external view returns (string memory);
  8 |     | 
  9 |     |   function version() external view returns (uint256);
 10 |     | 
 11 |     |   function getRoundData(uint80 _roundId)
 12 |     |     external
 13 |     |     view
 14 |     |     returns (
 15 |     |       uint80 roundId,
 16 |     |       int256 answer,
 17 |     |       uint256 startedAt,
 18 |     |       uint256 updatedAt,
 19 |     |       uint80 answeredInRound
 20 |     |     );
 21 |     | 
 22 |     |   function latestRoundData()
 23 |     |     external
 24 |     |     view
 25 |     |     returns (
 26 |     |       uint80 roundId,
 27 |     |       int256 answer,
 28 |     |       uint256 startedAt,
 29 |     |       uint256 updatedAt,
 30 |     |       uint80 answeredInRound
 31 |     |     );
 32 |     | }
 33 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/access/Ownable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../utils/Context.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Contract module which provides a basic access control mechanism, where
 10 |     |  * there is an account (an owner) that can be granted exclusive access to
 11 |     |  * specific functions.
 12 |     |  *
 13 |     |  * By default, the owner account will be the one that deploys the contract. This
 14 |     |  * can later be changed with {transferOwnership}.
 15 |     |  *
 16 |     |  * This module is used through inheritance. It will make available the modifier
 17 |     |  * `onlyOwner`, which can be applied to your functions to restrict their use to
 18 |     |  * the owner.
 19 |     |  */
 20 |     | abstract contract Ownable is Context {
 21 |     |     address private _owner;
 22 |     | 
 23 |     |     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
 24 |     | 
 25 |     |     /**
 26 |     |      * @dev Initializes the contract setting the deployer as the initial owner.
 27 |     |      */
 28 |     |     constructor() {
 29 |     |         _transferOwnership(_msgSender());
 30 |     |     }
 31 |     | 
 32 |     |     /**
 33 |     |      * @dev Throws if called by any account other than the owner.
 34 |     |      */
 35 |     |     modifier onlyOwner() {
 36 |     |         _checkOwner();
 37 |     |         _;
 38 |     |     }
 39 |     | 
 40 |     |     /**
 41 |     |      * @dev Returns the address of the current owner.
 42 |     |      */
 43 |     |     function owner() public view virtual returns (address) {
 44 |     |         return _owner;
 45 |     |     }
 46 |     | 
 47 |     |     /**
 48 |     |      * @dev Throws if the sender is not the owner.
 49 |     |      */
 50 |     |     function _checkOwner() internal view virtual {
 51 |     |         require(owner() == _msgSender(), "Ownable: caller is not the owner");
 52 |     |     }
 53 |     | 
 54 |     |     /**
 55 |     |      * @dev Leaves the contract without owner. It will not be possible to call
 56 |     |      * `onlyOwner` functions anymore. Can only be called by the current owner.
 57 |     |      *
 58 |     |      * NOTE: Renouncing ownership will leave the contract without an owner,
 59 |     |      * thereby removing any functionality that is only available to the owner.
 60 |     |      */
 61 |     |     function renounceOwnership() public virtual onlyOwner {
 62 |     |         _transferOwnership(address(0));
 63 |     |     }
 64 |     | 
 65 |     |     /**
 66 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
 67 |     |      * Can only be called by the current owner.
 68 |     |      */
 69 |     |     function transferOwnership(address newOwner) public virtual onlyOwner {
 70 |     |         require(newOwner != address(0), "Ownable: new owner is the zero address");
 71 |     |         _transferOwnership(newOwner);
 72 |     |     }
 73 |     | 
 74 |     |     /**
 75 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
 76 |     |      * Internal function without access restriction.
 77 |     |      */
 78 |     |     function _transferOwnership(address newOwner) internal virtual {
 79 |     |         address oldOwner = _owner;
 80 |     |         _owner = newOwner;
 81 |     |         emit OwnershipTransferred(oldOwner, newOwner);
 82 |     |     }
 83 |     | }
 84 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/access/Ownable2Step.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (access/Ownable2Step.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "./Ownable.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Contract module which provides access control mechanism, where
 10 |     |  * there is an account (an owner) that can be granted exclusive access to
 11 |     |  * specific functions.
 12 |     |  *
 13 |     |  * By default, the owner account will be the one that deploys the contract. This
 14 |     |  * can later be changed with {transferOwnership} and {acceptOwnership}.
 15 |     |  *
 16 |     |  * This module is used through inheritance. It will make available all functions
 17 |     |  * from parent (Ownable).
 18 |     |  */
 19 |     | abstract contract Ownable2Step is Ownable {
 20 |     |     address private _pendingOwner;
 21 |     | 
 22 |     |     event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the address of the pending owner.
 26 |     |      */
 27 |     |     function pendingOwner() public view virtual returns (address) {
 28 |     |         return _pendingOwner;
 29 |     |     }
 30 |     | 
 31 |     |     /**
 32 |     |      * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.
 33 |     |      * Can only be called by the current owner.
 34 |     |      */
 35 |     |     function transferOwnership(address newOwner) public virtual override onlyOwner {
 36 |     |         _pendingOwner = newOwner;
 37 |     |         emit OwnershipTransferStarted(owner(), newOwner);
 38 |     |     }
 39 |     | 
 40 |     |     /**
 41 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.
 42 |     |      * Internal function without access restriction.
 43 |     |      */
 44 |     |     function _transferOwnership(address newOwner) internal virtual override {
 45 |     |         delete _pendingOwner;
 46 |     |         super._transferOwnership(newOwner);
 47 |     |     }
 48 |     | 
 49 |     |     /**
 50 |     |      * @dev The new owner accepts the ownership transfer.
 51 |     |      */
 52 |     |     function acceptOwnership() external {
 53 |     |         address sender = _msgSender();
 54 |     |         require(pendingOwner() == sender, "Ownable2Step: caller is not the new owner");
 55 |     |         _transferOwnership(sender);
 56 |     |     }
 57 |     | }
 58 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/interfaces/IERC1271.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC1271 standard signature validation method for
  8 |     |  * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].
  9 |     |  *
 10 |     |  * _Available since v4.1._
 11 |     |  */
 12 |     | interface IERC1271 {
 13 |     |     /**
 14 |     |      * @dev Should return whether the signature provided is valid for the provided data
 15 |     |      * @param hash      Hash of the data to be signed
 16 |     |      * @param signature Signature byte array associated with _data
 17 |     |      */
 18 |     |     function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);
 19 |     | }
 20 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/interfaces/IERC1363Receiver.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (interfaces/IERC1363Receiver.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | interface IERC1363Receiver {
  7 |     |     /*
  8 |     |      * Note: the ERC-165 identifier for this interface is 0x88a7ca5c.
  9 |     |      * 0x88a7ca5c === bytes4(keccak256("onTransferReceived(address,address,uint256,bytes)"))
 10 |     |      */
 11 |     | 
 12 |     |     /**
 13 |     |      * @notice Handle the receipt of ERC1363 tokens
 14 |     |      * @dev Any ERC1363 smart contract calls this function on the recipient
 15 |     |      * after a `transfer` or a `transferFrom`. This function MAY throw to revert and reject the
 16 |     |      * transfer. Return of other than the magic value MUST result in the
 17 |     |      * transaction being reverted.
 18 |     |      * Note: the token contract address is always the message sender.
 19 |     |      * @param operator address The address which called `transferAndCall` or `transferFromAndCall` function
 20 |     |      * @param from address The address which are token transferred from
 21 |     |      * @param value uint256 The amount of tokens transferred
 22 |     |      * @param data bytes Additional data with no specified format
 23 |     |      * @return `bytes4(keccak256("onTransferReceived(address,address,uint256,bytes)"))`
 24 |     |      *  unless throwing
 25 |     |      */
 26 |     |     function onTransferReceived(
 27 |     |         address operator,
 28 |     |         address from,
 29 |     |         uint256 value,
 30 |     |         bytes memory data
 31 |     |     ) external returns (bytes4);
 32 |     | }
 33 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/proxy/Proxy.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM
  8 |     |  * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to
  9 |     |  * be specified by overriding the virtual {_implementation} function.
 10 |     |  *
 11 |     |  * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a
 12 |     |  * different contract through the {_delegate} function.
 13 |     |  *
 14 |     |  * The success and return data of the delegated call will be returned back to the caller of the proxy.
 15 |     |  */
 16 |     | abstract contract Proxy {
 17 |     |     /**
 18 |     |      * @dev Delegates the current call to `implementation`.
 19 |     |      *
 20 |     |      * This function does not return to its internal call site, it will return directly to the external caller.
 21 |     |      */
 22 |     |     function _delegate(address implementation) internal virtual {
 23 |     |         assembly {
 24 |     |             // Copy msg.data. We take full control of memory in this inline assembly
 25 |     |             // block because it will not return to Solidity code. We overwrite the
 26 |     |             // Solidity scratch pad at memory position 0.
 27 |     |             calldatacopy(0, 0, calldatasize())
 28 |     | 
 29 |     |             // Call the implementation.
 30 |     |             // out and outsize are 0 because we don't know the size yet.
 31 |     |             let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)
 32 |     | 
 33 |     |             // Copy the returned data.
 34 |     |             returndatacopy(0, 0, returndatasize())
 35 |     | 
 36 |     |             switch result
 37 |     |             // delegatecall returns 0 on error.
 38 |     |             case 0 {
 39 |     |                 revert(0, returndatasize())
 40 |     |             }
 41 |     |             default {
 42 |     |                 return(0, returndatasize())
 43 |     |             }
 44 |     |         }
 45 |     |     }
 46 |     | 
 47 |     |     /**
 48 |     |      * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function
 49 |     |      * and {_fallback} should delegate.
 50 |     |      */
 51 |     |     function _implementation() internal view virtual returns (address);
 52 |     | 
 53 |     |     /**
 54 |     |      * @dev Delegates the current call to the address returned by `_implementation()`.
 55 |     |      *
 56 |     |      * This function does not return to its internal call site, it will return directly to the external caller.
 57 |     |      */
 58 |     |     function _fallback() internal virtual {
 59 |     |         _beforeFallback();
 60 |     |         _delegate(_implementation());
 61 |     |     }
 62 |     | 
 63 |     |     /**
 64 |     |      * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other
 65 |     |      * function in the contract matches the call data.
 66 |     |      */
 67 |     |     fallback() external payable virtual {
 68 |     |         _fallback();
 69 |     |     }
 70 |     | 
 71 |     |     /**
 72 |     |      * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data
 73 |     |      * is empty.
 74 |     |      */
 75 |     |     receive() external payable virtual {
 76 |     |         _fallback();
 77 |     |     }
 78 |     | 
 79 |     |     /**
 80 |     |      * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`
 81 |     |      * call, or as part of the Solidity `fallback` or `receive` functions.
 82 |     |      *
 83 |     |      * If overridden should call `super._beforeFallback()`.
 84 |     |      */
 85 |     |     function _beforeFallback() internal virtual {}
 86 |     | }
 87 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/security/Pausable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "../utils/Context.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev Contract module which allows children to implement an emergency stop
  10 |     |  * mechanism that can be triggered by an authorized account.
  11 |     |  *
  12 |     |  * This module is used through inheritance. It will make available the
  13 |     |  * modifiers `whenNotPaused` and `whenPaused`, which can be applied to
  14 |     |  * the functions of your contract. Note that they will not be pausable by
  15 |     |  * simply including this module, only once the modifiers are put in place.
  16 |     |  */
  17 |     | abstract contract Pausable is Context {
  18 |     |     /**
  19 |     |      * @dev Emitted when the pause is triggered by `account`.
  20 |     |      */
  21 |     |     event Paused(address account);
  22 |     | 
  23 |     |     /**
  24 |     |      * @dev Emitted when the pause is lifted by `account`.
  25 |     |      */
  26 |     |     event Unpaused(address account);
  27 |     | 
  28 |     |     bool private _paused;
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Initializes the contract in unpaused state.
  32 |     |      */
  33 |     |     constructor() {
  34 |     |         _paused = false;
  35 |     |     }
  36 |     | 
  37 |     |     /**
  38 |     |      * @dev Modifier to make a function callable only when the contract is not paused.
  39 |     |      *
  40 |     |      * Requirements:
  41 |     |      *
  42 |     |      * - The contract must not be paused.
  43 |     |      */
  44 |     |     modifier whenNotPaused() {
  45 |     |         _requireNotPaused();
  46 |     |         _;
  47 |     |     }
  48 |     | 
  49 |     |     /**
  50 |     |      * @dev Modifier to make a function callable only when the contract is paused.
  51 |     |      *
  52 |     |      * Requirements:
  53 |     |      *
  54 |     |      * - The contract must be paused.
  55 |     |      */
  56 |     |     modifier whenPaused() {
  57 |     |         _requirePaused();
  58 |     |         _;
  59 |     |     }
  60 |     | 
  61 |     |     /**
  62 |     |      * @dev Returns true if the contract is paused, and false otherwise.
  63 |     |      */
  64 |     |     function paused() public view virtual returns (bool) {
  65 |     |         return _paused;
  66 |     |     }
  67 |     | 
  68 |     |     /**
  69 |     |      * @dev Throws if the contract is paused.
  70 |     |      */
  71 |     |     function _requireNotPaused() internal view virtual {
  72 |     |         require(!paused(), "Pausable: paused");
  73 |     |     }
  74 |     | 
  75 |     |     /**
  76 |     |      * @dev Throws if the contract is not paused.
  77 |     |      */
  78 |     |     function _requirePaused() internal view virtual {
  79 |     |         require(paused(), "Pausable: not paused");
  80 |     |     }
  81 |     | 
  82 |     |     /**
  83 |     |      * @dev Triggers stopped state.
  84 |     |      *
  85 |     |      * Requirements:
  86 |     |      *
  87 |     |      * - The contract must not be paused.
  88 |     |      */
  89 |     |     function _pause() internal virtual whenNotPaused {
  90 |     |         _paused = true;
  91 |     |         emit Paused(_msgSender());
  92 |     |     }
  93 |     | 
  94 |     |     /**
  95 |     |      * @dev Returns to normal state.
  96 |     |      *
  97 |     |      * Requirements:
  98 |     |      *
  99 |     |      * - The contract must be paused.
 100 |     |      */
 101 |     |     function _unpause() internal virtual whenPaused {
 102 |     |         _paused = false;
 103 |     |         emit Unpaused(_msgSender());
 104 |     |     }
 105 |     | }
 106 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/token/ERC1155/ERC1155.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (token/ERC1155/ERC1155.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "./IERC1155.sol";
   7 |     | import "./IERC1155Receiver.sol";
   8 |     | import "./extensions/IERC1155MetadataURI.sol";
   9 |     | import "../../utils/Address.sol";
  10 |     | import "../../utils/Context.sol";
  11 |     | import "../../utils/introspection/ERC165.sol";
  12 |     | 
  13 |     | /**
  14 |     |  * @dev Implementation of the basic standard multi-token.
  15 |     |  * See https://eips.ethereum.org/EIPS/eip-1155
  16 |     |  * Originally based on code by Enjin: https://github.com/enjin/erc-1155
  17 |     |  *
  18 |     |  * _Available since v3.1._
  19 |     |  */
  20 |     | contract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {
  21 |     |     using Address for address;
  22 |     | 
  23 |     |     // Mapping from token ID to account balances
  24 |     |     mapping(uint256 => mapping(address => uint256)) private _balances;
  25 |     | 
  26 |     |     // Mapping from account to operator approvals
  27 |     |     mapping(address => mapping(address => bool)) private _operatorApprovals;
  28 |     | 
  29 |     |     // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json
  30 |     |     string private _uri;
  31 |     | 
  32 |     |     /**
  33 |     |      * @dev See {_setURI}.
  34 |     |      */
  35 |     |     constructor(string memory uri_) {
  36 |     |         _setURI(uri_);
  37 |     |     }
  38 |     | 
  39 |     |     /**
  40 |     |      * @dev See {IERC165-supportsInterface}.
  41 |     |      */
  42 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
  43 |     |         return
  44 |     |             interfaceId == type(IERC1155).interfaceId ||
  45 |     |             interfaceId == type(IERC1155MetadataURI).interfaceId ||
  46 |     |             super.supportsInterface(interfaceId);
  47 |     |     }
  48 |     | 
  49 |     |     /**
  50 |     |      * @dev See {IERC1155MetadataURI-uri}.
  51 |     |      *
  52 |     |      * This implementation returns the same URI for *all* token types. It relies
  53 |     |      * on the token type ID substitution mechanism
  54 |     |      * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].
  55 |     |      *
  56 |     |      * Clients calling this function must replace the `\{id\}` substring with the
  57 |     |      * actual token type ID.
  58 |     |      */
  59 |     |     function uri(uint256) public view virtual override returns (string memory) {
  60 |     |         return _uri;
  61 |     |     }
  62 |     | 
  63 |     |     /**
  64 |     |      * @dev See {IERC1155-balanceOf}.
  65 |     |      *
  66 |     |      * Requirements:
  67 |     |      *
  68 |     |      * - `account` cannot be the zero address.
  69 |     |      */
  70 |     |     function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
  71 |     |         require(account != address(0), "ERC1155: address zero is not a valid owner");
  72 |     |         return _balances[id][account];
  73 |     |     }
  74 |     | 
  75 |     |     /**
  76 |     |      * @dev See {IERC1155-balanceOfBatch}.
  77 |     |      *
  78 |     |      * Requirements:
  79 |     |      *
  80 |     |      * - `accounts` and `ids` must have the same length.
  81 |     |      */
  82 |     |     function balanceOfBatch(address[] memory accounts, uint256[] memory ids)
  83 |     |         public
  84 |     |         view
  85 |     |         virtual
  86 |     |         override
  87 |     |         returns (uint256[] memory)
  88 |     |     {
  89 |     |         require(accounts.length == ids.length, "ERC1155: accounts and ids length mismatch");
  90 |     | 
  91 |     |         uint256[] memory batchBalances = new uint256[](accounts.length);
  92 |     | 
  93 |     |         for (uint256 i = 0; i < accounts.length; ++i) {
  94 |     |             batchBalances[i] = balanceOf(accounts[i], ids[i]);
  95 |     |         }
  96 |     | 
  97 |     |         return batchBalances;
  98 |     |     }
  99 |     | 
 100 |     |     /**
 101 |     |      * @dev See {IERC1155-setApprovalForAll}.
 102 |     |      */
 103 |     |     function setApprovalForAll(address operator, bool approved) public virtual override {
 104 |     |         _setApprovalForAll(_msgSender(), operator, approved);
 105 |     |     }
 106 |     | 
 107 |     |     /**
 108 |     |      * @dev See {IERC1155-isApprovedForAll}.
 109 |     |      */
 110 |     |     function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {
 111 |     |         return _operatorApprovals[account][operator];
 112 |     |     }
 113 |     | 
 114 |     |     /**
 115 |     |      * @dev See {IERC1155-safeTransferFrom}.
 116 |     |      */
 117 |     |     function safeTransferFrom(
 118 |     |         address from,
 119 |     |         address to,
 120 |     |         uint256 id,
 121 |     |         uint256 amount,
 122 |     |         bytes memory data
 123 |     |     ) public virtual override {
 124 |     |         require(
 125 |     |             from == _msgSender() || isApprovedForAll(from, _msgSender()),
 126 |     |             "ERC1155: caller is not token owner or approved"
 127 |     |         );
 128 |     |         _safeTransferFrom(from, to, id, amount, data);
 129 |     |     }
 130 |     | 
 131 |     |     /**
 132 |     |      * @dev See {IERC1155-safeBatchTransferFrom}.
 133 |     |      */
 134 |     |     function safeBatchTransferFrom(
 135 |     |         address from,
 136 |     |         address to,
 137 |     |         uint256[] memory ids,
 138 |     |         uint256[] memory amounts,
 139 |     |         bytes memory data
 140 |     |     ) public virtual override {
 141 |     |         require(
 142 |     |             from == _msgSender() || isApprovedForAll(from, _msgSender()),
 143 |     |             "ERC1155: caller is not token owner or approved"
 144 |     |         );
 145 |     |         _safeBatchTransferFrom(from, to, ids, amounts, data);
 146 |     |     }
 147 |     | 
 148 |     |     /**
 149 |     |      * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.
 150 |     |      *
 151 |     |      * Emits a {TransferSingle} event.
 152 |     |      *
 153 |     |      * Requirements:
 154 |     |      *
 155 |     |      * - `to` cannot be the zero address.
 156 |     |      * - `from` must have a balance of tokens of type `id` of at least `amount`.
 157 |     |      * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
 158 |     |      * acceptance magic value.
 159 |     |      */
 160 |     |     function _safeTransferFrom(
 161 |     |         address from,
 162 |     |         address to,
 163 |     |         uint256 id,
 164 |     |         uint256 amount,
 165 |     |         bytes memory data
 166 |     |     ) internal virtual {
 167 |     |         require(to != address(0), "ERC1155: transfer to the zero address");
 168 |     | 
 169 |     |         address operator = _msgSender();
 170 |     |         uint256[] memory ids = _asSingletonArray(id);
 171 |     |         uint256[] memory amounts = _asSingletonArray(amount);
 172 |     | 
 173 |     |         _beforeTokenTransfer(operator, from, to, ids, amounts, data);
 174 |     | 
 175 |     |         uint256 fromBalance = _balances[id][from];
 176 |     |         require(fromBalance >= amount, "ERC1155: insufficient balance for transfer");
 177 |     |         unchecked {
 178 |     |             _balances[id][from] = fromBalance - amount;
 179 |     |         }
 180 |     |         _balances[id][to] += amount;
 181 |     | 
 182 |     |         emit TransferSingle(operator, from, to, id, amount);
 183 |     | 
 184 |     |         _afterTokenTransfer(operator, from, to, ids, amounts, data);
 185 |     | 
 186 |     |         _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);
 187 |     |     }
 188 |     | 
 189 |     |     /**
 190 |     |      * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.
 191 |     |      *
 192 |     |      * Emits a {TransferBatch} event.
 193 |     |      *
 194 |     |      * Requirements:
 195 |     |      *
 196 |     |      * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the
 197 |     |      * acceptance magic value.
 198 |     |      */
 199 |     |     function _safeBatchTransferFrom(
 200 |     |         address from,
 201 |     |         address to,
 202 |     |         uint256[] memory ids,
 203 |     |         uint256[] memory amounts,
 204 |     |         bytes memory data
 205 |     |     ) internal virtual {
 206 |     |         require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");
 207 |     |         require(to != address(0), "ERC1155: transfer to the zero address");
 208 |     | 
 209 |     |         address operator = _msgSender();
 210 |     | 
 211 |     |         _beforeTokenTransfer(operator, from, to, ids, amounts, data);
 212 |     | 
 213 |     |         for (uint256 i = 0; i < ids.length; ++i) {
 214 |     |             uint256 id = ids[i];
 215 |     |             uint256 amount = amounts[i];
 216 |     | 
 217 |     |             uint256 fromBalance = _balances[id][from];
 218 |     |             require(fromBalance >= amount, "ERC1155: insufficient balance for transfer");
 219 |     |             unchecked {
 220 |     |                 _balances[id][from] = fromBalance - amount;
 221 |     |             }
 222 |     |             _balances[id][to] += amount;
 223 |     |         }
 224 |     | 
 225 |     |         emit TransferBatch(operator, from, to, ids, amounts);
 226 |     | 
 227 |     |         _afterTokenTransfer(operator, from, to, ids, amounts, data);
 228 |     | 
 229 |     |         _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);
 230 |     |     }
 231 |     | 
 232 |     |     /**
 233 |     |      * @dev Sets a new URI for all token types, by relying on the token type ID
 234 |     |      * substitution mechanism
 235 |     |      * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].
 236 |     |      *
 237 |     |      * By this mechanism, any occurrence of the `\{id\}` substring in either the
 238 |     |      * URI or any of the amounts in the JSON file at said URI will be replaced by
 239 |     |      * clients with the token type ID.
 240 |     |      *
 241 |     |      * For example, the `https://token-cdn-domain/\{id\}.json` URI would be
 242 |     |      * interpreted by clients as
 243 |     |      * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`
 244 |     |      * for token type ID 0x4cce0.
 245 |     |      *
 246 |     |      * See {uri}.
 247 |     |      *
 248 |     |      * Because these URIs cannot be meaningfully represented by the {URI} event,
 249 |     |      * this function emits no events.
 250 |     |      */
 251 |     |     function _setURI(string memory newuri) internal virtual {
 252 |     |         _uri = newuri;
 253 |     |     }
 254 |     | 
 255 |     |     /**
 256 |     |      * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.
 257 |     |      *
 258 |     |      * Emits a {TransferSingle} event.
 259 |     |      *
 260 |     |      * Requirements:
 261 |     |      *
 262 |     |      * - `to` cannot be the zero address.
 263 |     |      * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
 264 |     |      * acceptance magic value.
 265 |     |      */
 266 |     |     function _mint(
 267 |     |         address to,
 268 |     |         uint256 id,
 269 |     |         uint256 amount,
 270 |     |         bytes memory data
 271 |     |     ) internal virtual {
 272 |     |         require(to != address(0), "ERC1155: mint to the zero address");
 273 |     | 
 274 |     |         address operator = _msgSender();
 275 |     |         uint256[] memory ids = _asSingletonArray(id);
 276 |     |         uint256[] memory amounts = _asSingletonArray(amount);
 277 |     | 
 278 |     |         _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);
 279 |     | 
 280 |     |         _balances[id][to] += amount;
 281 |     |         emit TransferSingle(operator, address(0), to, id, amount);
 282 |     | 
 283 |     |         _afterTokenTransfer(operator, address(0), to, ids, amounts, data);
 284 |     | 
 285 |     |         _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);
 286 |     |     }
 287 |     | 
 288 |     |     /**
 289 |     |      * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.
 290 |     |      *
 291 |     |      * Emits a {TransferBatch} event.
 292 |     |      *
 293 |     |      * Requirements:
 294 |     |      *
 295 |     |      * - `ids` and `amounts` must have the same length.
 296 |     |      * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the
 297 |     |      * acceptance magic value.
 298 |     |      */
 299 |     |     function _mintBatch(
 300 |     |         address to,
 301 |     |         uint256[] memory ids,
 302 |     |         uint256[] memory amounts,
 303 |     |         bytes memory data
 304 |     |     ) internal virtual {
 305 |     |         require(to != address(0), "ERC1155: mint to the zero address");
 306 |     |         require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");
 307 |     | 
 308 |     |         address operator = _msgSender();
 309 |     | 
 310 |     |         _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);
 311 |     | 
 312 |     |         for (uint256 i = 0; i < ids.length; i++) {
 313 |     |             _balances[ids[i]][to] += amounts[i];
 314 |     |         }
 315 |     | 
 316 |     |         emit TransferBatch(operator, address(0), to, ids, amounts);
 317 |     | 
 318 |     |         _afterTokenTransfer(operator, address(0), to, ids, amounts, data);
 319 |     | 
 320 |     |         _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);
 321 |     |     }
 322 |     | 
 323 |     |     /**
 324 |     |      * @dev Destroys `amount` tokens of token type `id` from `from`
 325 |     |      *
 326 |     |      * Emits a {TransferSingle} event.
 327 |     |      *
 328 |     |      * Requirements:
 329 |     |      *
 330 |     |      * - `from` cannot be the zero address.
 331 |     |      * - `from` must have at least `amount` tokens of token type `id`.
 332 |     |      */
 333 |     |     function _burn(
 334 |     |         address from,
 335 |     |         uint256 id,
 336 |     |         uint256 amount
 337 |     |     ) internal virtual {
 338 |     |         require(from != address(0), "ERC1155: burn from the zero address");
 339 |     | 
 340 |     |         address operator = _msgSender();
 341 |     |         uint256[] memory ids = _asSingletonArray(id);
 342 |     |         uint256[] memory amounts = _asSingletonArray(amount);
 343 |     | 
 344 |     |         _beforeTokenTransfer(operator, from, address(0), ids, amounts, "");
 345 |     | 
 346 |     |         uint256 fromBalance = _balances[id][from];
 347 |     |         require(fromBalance >= amount, "ERC1155: burn amount exceeds balance");
 348 |     |         unchecked {
 349 |     |             _balances[id][from] = fromBalance - amount;
 350 |     |         }
 351 |     | 
 352 |     |         emit TransferSingle(operator, from, address(0), id, amount);
 353 |     | 
 354 |     |         _afterTokenTransfer(operator, from, address(0), ids, amounts, "");
 355 |     |     }
 356 |     | 
 357 |     |     /**
 358 |     |      * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.
 359 |     |      *
 360 |     |      * Emits a {TransferBatch} event.
 361 |     |      *
 362 |     |      * Requirements:
 363 |     |      *
 364 |     |      * - `ids` and `amounts` must have the same length.
 365 |     |      */
 366 |     |     function _burnBatch(
 367 |     |         address from,
 368 |     |         uint256[] memory ids,
 369 |     |         uint256[] memory amounts
 370 |     |     ) internal virtual {
 371 |     |         require(from != address(0), "ERC1155: burn from the zero address");
 372 |     |         require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");
 373 |     | 
 374 |     |         address operator = _msgSender();
 375 |     | 
 376 |     |         _beforeTokenTransfer(operator, from, address(0), ids, amounts, "");
 377 |     | 
 378 |     |         for (uint256 i = 0; i < ids.length; i++) {
 379 |     |             uint256 id = ids[i];
 380 |     |             uint256 amount = amounts[i];
 381 |     | 
 382 |     |             uint256 fromBalance = _balances[id][from];
 383 |     |             require(fromBalance >= amount, "ERC1155: burn amount exceeds balance");
 384 |     |             unchecked {
 385 |     |                 _balances[id][from] = fromBalance - amount;
 386 |     |             }
 387 |     |         }
 388 |     | 
 389 |     |         emit TransferBatch(operator, from, address(0), ids, amounts);
 390 |     | 
 391 |     |         _afterTokenTransfer(operator, from, address(0), ids, amounts, "");
 392 |     |     }
 393 |     | 
 394 |     |     /**
 395 |     |      * @dev Approve `operator` to operate on all of `owner` tokens
 396 |     |      *
 397 |     |      * Emits an {ApprovalForAll} event.
 398 |     |      */
 399 |     |     function _setApprovalForAll(
 400 |     |         address owner,
 401 |     |         address operator,
 402 |     |         bool approved
 403 |     |     ) internal virtual {
 404 |     |         require(owner != operator, "ERC1155: setting approval status for self");
 405 |     |         _operatorApprovals[owner][operator] = approved;
 406 |     |         emit ApprovalForAll(owner, operator, approved);
 407 |     |     }
 408 |     | 
 409 |     |     /**
 410 |     |      * @dev Hook that is called before any token transfer. This includes minting
 411 |     |      * and burning, as well as batched variants.
 412 |     |      *
 413 |     |      * The same hook is called on both single and batched variants. For single
 414 |     |      * transfers, the length of the `ids` and `amounts` arrays will be 1.
 415 |     |      *
 416 |     |      * Calling conditions (for each `id` and `amount` pair):
 417 |     |      *
 418 |     |      * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 419 |     |      * of token type `id` will be  transferred to `to`.
 420 |     |      * - When `from` is zero, `amount` tokens of token type `id` will be minted
 421 |     |      * for `to`.
 422 |     |      * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`
 423 |     |      * will be burned.
 424 |     |      * - `from` and `to` are never both zero.
 425 |     |      * - `ids` and `amounts` have the same, non-zero length.
 426 |     |      *
 427 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 428 |     |      */
 429 |     |     function _beforeTokenTransfer(
 430 |     |         address operator,
 431 |     |         address from,
 432 |     |         address to,
 433 |     |         uint256[] memory ids,
 434 |     |         uint256[] memory amounts,
 435 |     |         bytes memory data
 436 |     |     ) internal virtual {}
 437 |     | 
 438 |     |     /**
 439 |     |      * @dev Hook that is called after any token transfer. This includes minting
 440 |     |      * and burning, as well as batched variants.
 441 |     |      *
 442 |     |      * The same hook is called on both single and batched variants. For single
 443 |     |      * transfers, the length of the `id` and `amount` arrays will be 1.
 444 |     |      *
 445 |     |      * Calling conditions (for each `id` and `amount` pair):
 446 |     |      *
 447 |     |      * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 448 |     |      * of token type `id` will be  transferred to `to`.
 449 |     |      * - When `from` is zero, `amount` tokens of token type `id` will be minted
 450 |     |      * for `to`.
 451 |     |      * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`
 452 |     |      * will be burned.
 453 |     |      * - `from` and `to` are never both zero.
 454 |     |      * - `ids` and `amounts` have the same, non-zero length.
 455 |     |      *
 456 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 457 |     |      */
 458 |     |     function _afterTokenTransfer(
 459 |     |         address operator,
 460 |     |         address from,
 461 |     |         address to,
 462 |     |         uint256[] memory ids,
 463 |     |         uint256[] memory amounts,
 464 |     |         bytes memory data
 465 |     |     ) internal virtual {}
 466 |     | 
 467 |     |     function _doSafeTransferAcceptanceCheck(
 468 |     |         address operator,
 469 |     |         address from,
 470 |     |         address to,
 471 |     |         uint256 id,
 472 |     |         uint256 amount,
 473 |     |         bytes memory data
 474 |     |     ) private {
 475 |     |         if (to.isContract()) {
 476 |     |             try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {
 477 |     |                 if (response != IERC1155Receiver.onERC1155Received.selector) {
 478 |     |                     revert("ERC1155: ERC1155Receiver rejected tokens");
 479 |     |                 }
 480 |     |             } catch Error(string memory reason) {
 481 |     |                 revert(reason);
 482 |     |             } catch {
 483 |     |                 revert("ERC1155: transfer to non-ERC1155Receiver implementer");
 484 |     |             }
 485 |     |         }
 486 |     |     }
 487 |     | 
 488 |     |     function _doSafeBatchTransferAcceptanceCheck(
 489 |     |         address operator,
 490 |     |         address from,
 491 |     |         address to,
 492 |     |         uint256[] memory ids,
 493 |     |         uint256[] memory amounts,
 494 |     |         bytes memory data
 495 |     |     ) private {
 496 |     |         if (to.isContract()) {
 497 |     |             try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (
 498 |     |                 bytes4 response
 499 |     |             ) {
 500 |     |                 if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {
 501 |     |                     revert("ERC1155: ERC1155Receiver rejected tokens");
 502 |     |                 }
 503 |     |             } catch Error(string memory reason) {
 504 |     |                 revert(reason);
 505 |     |             } catch {
 506 |     |                 revert("ERC1155: transfer to non-ERC1155Receiver implementer");
 507 |     |             }
 508 |     |         }
 509 |     |     }
 510 |     | 
 511 |     |     function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {
 512 |     |         uint256[] memory array = new uint256[](1);
 513 |     |         array[0] = element;
 514 |     | 
 515 |     |         return array;
 516 |     |     }
 517 |     | }
 518 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/token/ERC1155/IERC1155.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "../../utils/introspection/IERC165.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev Required interface of an ERC1155 compliant contract, as defined in the
  10 |     |  * https://eips.ethereum.org/EIPS/eip-1155[EIP].
  11 |     |  *
  12 |     |  * _Available since v3.1._
  13 |     |  */
  14 |     | interface IERC1155 is IERC165 {
  15 |     |     /**
  16 |     |      * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.
  17 |     |      */
  18 |     |     event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);
  19 |     | 
  20 |     |     /**
  21 |     |      * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all
  22 |     |      * transfers.
  23 |     |      */
  24 |     |     event TransferBatch(
  25 |     |         address indexed operator,
  26 |     |         address indexed from,
  27 |     |         address indexed to,
  28 |     |         uint256[] ids,
  29 |     |         uint256[] values
  30 |     |     );
  31 |     | 
  32 |     |     /**
  33 |     |      * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to
  34 |     |      * `approved`.
  35 |     |      */
  36 |     |     event ApprovalForAll(address indexed account, address indexed operator, bool approved);
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.
  40 |     |      *
  41 |     |      * If an {URI} event was emitted for `id`, the standard
  42 |     |      * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value
  43 |     |      * returned by {IERC1155MetadataURI-uri}.
  44 |     |      */
  45 |     |     event URI(string value, uint256 indexed id);
  46 |     | 
  47 |     |     /**
  48 |     |      * @dev Returns the amount of tokens of token type `id` owned by `account`.
  49 |     |      *
  50 |     |      * Requirements:
  51 |     |      *
  52 |     |      * - `account` cannot be the zero address.
  53 |     |      */
  54 |     |     function balanceOf(address account, uint256 id) external view returns (uint256);
  55 |     | 
  56 |     |     /**
  57 |     |      * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.
  58 |     |      *
  59 |     |      * Requirements:
  60 |     |      *
  61 |     |      * - `accounts` and `ids` must have the same length.
  62 |     |      */
  63 |     |     function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)
  64 |     |         external
  65 |     |         view
  66 |     |         returns (uint256[] memory);
  67 |     | 
  68 |     |     /**
  69 |     |      * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,
  70 |     |      *
  71 |     |      * Emits an {ApprovalForAll} event.
  72 |     |      *
  73 |     |      * Requirements:
  74 |     |      *
  75 |     |      * - `operator` cannot be the caller.
  76 |     |      */
  77 |     |     function setApprovalForAll(address operator, bool approved) external;
  78 |     | 
  79 |     |     /**
  80 |     |      * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.
  81 |     |      *
  82 |     |      * See {setApprovalForAll}.
  83 |     |      */
  84 |     |     function isApprovedForAll(address account, address operator) external view returns (bool);
  85 |     | 
  86 |     |     /**
  87 |     |      * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.
  88 |     |      *
  89 |     |      * Emits a {TransferSingle} event.
  90 |     |      *
  91 |     |      * Requirements:
  92 |     |      *
  93 |     |      * - `to` cannot be the zero address.
  94 |     |      * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.
  95 |     |      * - `from` must have a balance of tokens of type `id` of at least `amount`.
  96 |     |      * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
  97 |     |      * acceptance magic value.
  98 |     |      */
  99 |     |     function safeTransferFrom(
 100 |     |         address from,
 101 |     |         address to,
 102 |     |         uint256 id,
 103 |     |         uint256 amount,
 104 |     |         bytes calldata data
 105 |     |     ) external;
 106 |     | 
 107 |     |     /**
 108 |     |      * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.
 109 |     |      *
 110 |     |      * Emits a {TransferBatch} event.
 111 |     |      *
 112 |     |      * Requirements:
 113 |     |      *
 114 |     |      * - `ids` and `amounts` must have the same length.
 115 |     |      * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the
 116 |     |      * acceptance magic value.
 117 |     |      */
 118 |     |     function safeBatchTransferFrom(
 119 |     |         address from,
 120 |     |         address to,
 121 |     |         uint256[] calldata ids,
 122 |     |         uint256[] calldata amounts,
 123 |     |         bytes calldata data
 124 |     |     ) external;
 125 |     | }
 126 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../../utils/introspection/IERC165.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev _Available since v3.1._
 10 |     |  */
 11 |     | interface IERC1155Receiver is IERC165 {
 12 |     |     /**
 13 |     |      * @dev Handles the receipt of a single ERC1155 token type. This function is
 14 |     |      * called at the end of a `safeTransferFrom` after the balance has been updated.
 15 |     |      *
 16 |     |      * NOTE: To accept the transfer, this must return
 17 |     |      * `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`
 18 |     |      * (i.e. 0xf23a6e61, or its own function selector).
 19 |     |      *
 20 |     |      * @param operator The address which initiated the transfer (i.e. msg.sender)
 21 |     |      * @param from The address which previously owned the token
 22 |     |      * @param id The ID of the token being transferred
 23 |     |      * @param value The amount of tokens being transferred
 24 |     |      * @param data Additional data with no specified format
 25 |     |      * @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed
 26 |     |      */
 27 |     |     function onERC1155Received(
 28 |     |         address operator,
 29 |     |         address from,
 30 |     |         uint256 id,
 31 |     |         uint256 value,
 32 |     |         bytes calldata data
 33 |     |     ) external returns (bytes4);
 34 |     | 
 35 |     |     /**
 36 |     |      * @dev Handles the receipt of a multiple ERC1155 token types. This function
 37 |     |      * is called at the end of a `safeBatchTransferFrom` after the balances have
 38 |     |      * been updated.
 39 |     |      *
 40 |     |      * NOTE: To accept the transfer(s), this must return
 41 |     |      * `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`
 42 |     |      * (i.e. 0xbc197c81, or its own function selector).
 43 |     |      *
 44 |     |      * @param operator The address which initiated the batch transfer (i.e. msg.sender)
 45 |     |      * @param from The address which previously owned the token
 46 |     |      * @param ids An array containing ids of each token being transferred (order and length must match values array)
 47 |     |      * @param values An array containing amounts of each token being transferred (order and length must match ids array)
 48 |     |      * @param data Additional data with no specified format
 49 |     |      * @return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` if transfer is allowed
 50 |     |      */
 51 |     |     function onERC1155BatchReceived(
 52 |     |         address operator,
 53 |     |         address from,
 54 |     |         uint256[] calldata ids,
 55 |     |         uint256[] calldata values,
 56 |     |         bytes calldata data
 57 |     |     ) external returns (bytes4);
 58 |     | }
 59 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Burnable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (token/ERC1155/extensions/ERC1155Burnable.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../ERC1155.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Extension of {ERC1155} that allows token holders to destroy both their
 10 |     |  * own tokens and those that they have been approved to use.
 11 |     |  *
 12 |     |  * _Available since v3.1._
 13 |     |  */
 14 |     | abstract contract ERC1155Burnable is ERC1155 {
 15 |     |     function burn(
 16 |     |         address account,
 17 |     |         uint256 id,
 18 |     |         uint256 value
 19 |     |     ) public virtual {
 20 |     |         require(
 21 |     |             account == _msgSender() || isApprovedForAll(account, _msgSender()),
 22 |     |             "ERC1155: caller is not token owner or approved"
 23 |     |         );
 24 |     | 
 25 |     |         _burn(account, id, value);
 26 |     |     }
 27 |     | 
 28 |     |     function burnBatch(
 29 |     |         address account,
 30 |     |         uint256[] memory ids,
 31 |     |         uint256[] memory values
 32 |     |     ) public virtual {
 33 |     |         require(
 34 |     |             account == _msgSender() || isApprovedForAll(account, _msgSender()),
 35 |     |             "ERC1155: caller is not token owner or approved"
 36 |     |         );
 37 |     | 
 38 |     |         _burnBatch(account, ids, values);
 39 |     |     }
 40 |     | }
 41 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../IERC1155.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Interface of the optional ERC1155MetadataExtension interface, as defined
 10 |     |  * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].
 11 |     |  *
 12 |     |  * _Available since v3.1._
 13 |     |  */
 14 |     | interface IERC1155MetadataURI is IERC1155 {
 15 |     |     /**
 16 |     |      * @dev Returns the URI for token type `id`.
 17 |     |      *
 18 |     |      * If the `\{id\}` substring is present in the URI, it must be replaced by
 19 |     |      * clients with the actual token type ID.
 20 |     |      */
 21 |     |     function uri(uint256 id) external view returns (string memory);
 22 |     | }
 23 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../IERC1155Receiver.sol";
  7 |     | import "../../../utils/introspection/ERC165.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev _Available since v3.1._
 11 |     |  */
 12 |     | abstract contract ERC1155Receiver is ERC165, IERC1155Receiver {
 13 |     |     /**
 14 |     |      * @dev See {IERC165-supportsInterface}.
 15 |     |      */
 16 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
 17 |     |         return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);
 18 |     |     }
 19 |     | }
 20 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "./IERC20.sol";
   7 |     | import "./extensions/IERC20Metadata.sol";
   8 |     | import "../../utils/Context.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev Implementation of the {IERC20} interface.
  12 |     |  *
  13 |     |  * This implementation is agnostic to the way tokens are created. This means
  14 |     |  * that a supply mechanism has to be added in a derived contract using {_mint}.
  15 |     |  * For a generic mechanism see {ERC20PresetMinterPauser}.
  16 |     |  *
  17 |     |  * TIP: For a detailed writeup see our guide
  18 |     |  * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
  19 |     |  * to implement supply mechanisms].
  20 |     |  *
  21 |     |  * We have followed general OpenZeppelin Contracts guidelines: functions revert
  22 |     |  * instead returning `false` on failure. This behavior is nonetheless
  23 |     |  * conventional and does not conflict with the expectations of ERC20
  24 |     |  * applications.
  25 |     |  *
  26 |     |  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
  27 |     |  * This allows applications to reconstruct the allowance for all accounts just
  28 |     |  * by listening to said events. Other implementations of the EIP may not emit
  29 |     |  * these events, as it isn't required by the specification.
  30 |     |  *
  31 |     |  * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
  32 |     |  * functions have been added to mitigate the well-known issues around setting
  33 |     |  * allowances. See {IERC20-approve}.
  34 |     |  */
  35 |     | contract ERC20 is Context, IERC20, IERC20Metadata {
  36 |     |     mapping(address => uint256) private _balances;
  37 |     | 
  38 |     |     mapping(address => mapping(address => uint256)) private _allowances;
  39 |     | 
  40 |     |     uint256 private _totalSupply;
  41 |     | 
  42 |     |     string private _name;
  43 |     |     string private _symbol;
  44 |     | 
  45 |     |     /**
  46 |     |      * @dev Sets the values for {name} and {symbol}.
  47 |     |      *
  48 |     |      * The default value of {decimals} is 18. To select a different value for
  49 |     |      * {decimals} you should overload it.
  50 |     |      *
  51 |     |      * All two of these values are immutable: they can only be set once during
  52 |     |      * construction.
  53 |     |      */
  54 |     |     constructor(string memory name_, string memory symbol_) {
  55 |     |         _name = name_;
  56 |     |         _symbol = symbol_;
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Returns the name of the token.
  61 |     |      */
  62 |     |     function name() public view virtual override returns (string memory) {
  63 |     |         return _name;
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Returns the symbol of the token, usually a shorter version of the
  68 |     |      * name.
  69 |     |      */
  70 |     |     function symbol() public view virtual override returns (string memory) {
  71 |     |         return _symbol;
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @dev Returns the number of decimals used to get its user representation.
  76 |     |      * For example, if `decimals` equals `2`, a balance of `505` tokens should
  77 |     |      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
  78 |     |      *
  79 |     |      * Tokens usually opt for a value of 18, imitating the relationship between
  80 |     |      * Ether and Wei. This is the value {ERC20} uses, unless this function is
  81 |     |      * overridden;
  82 |     |      *
  83 |     |      * NOTE: This information is only used for _display_ purposes: it in
  84 |     |      * no way affects any of the arithmetic of the contract, including
  85 |     |      * {IERC20-balanceOf} and {IERC20-transfer}.
  86 |     |      */
  87 |     |     function decimals() public view virtual override returns (uint8) {
  88 |     |         return 18;
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev See {IERC20-totalSupply}.
  93 |     |      */
  94 |     |     function totalSupply() public view virtual override returns (uint256) {
  95 |     |         return _totalSupply;
  96 |     |     }
  97 |     | 
  98 |     |     /**
  99 |     |      * @dev See {IERC20-balanceOf}.
 100 |     |      */
 101 |     |     function balanceOf(address account) public view virtual override returns (uint256) {
 102 |     |         return _balances[account];
 103 |     |     }
 104 |     | 
 105 |     |     /**
 106 |     |      * @dev See {IERC20-transfer}.
 107 |     |      *
 108 |     |      * Requirements:
 109 |     |      *
 110 |     |      * - `to` cannot be the zero address.
 111 |     |      * - the caller must have a balance of at least `amount`.
 112 |     |      */
 113 |     |     function transfer(address to, uint256 amount) public virtual override returns (bool) {
 114 |     |         address owner = _msgSender();
 115 |     |         _transfer(owner, to, amount);
 116 |     |         return true;
 117 |     |     }
 118 |     | 
 119 |     |     /**
 120 |     |      * @dev See {IERC20-allowance}.
 121 |     |      */
 122 |     |     function allowance(address owner, address spender) public view virtual override returns (uint256) {
 123 |     |         return _allowances[owner][spender];
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev See {IERC20-approve}.
 128 |     |      *
 129 |     |      * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on
 130 |     |      * `transferFrom`. This is semantically equivalent to an infinite approval.
 131 |     |      *
 132 |     |      * Requirements:
 133 |     |      *
 134 |     |      * - `spender` cannot be the zero address.
 135 |     |      */
 136 |     |     function approve(address spender, uint256 amount) public virtual override returns (bool) {
 137 |     |         address owner = _msgSender();
 138 |     |         _approve(owner, spender, amount);
 139 |     |         return true;
 140 |     |     }
 141 |     | 
 142 |     |     /**
 143 |     |      * @dev See {IERC20-transferFrom}.
 144 |     |      *
 145 |     |      * Emits an {Approval} event indicating the updated allowance. This is not
 146 |     |      * required by the EIP. See the note at the beginning of {ERC20}.
 147 |     |      *
 148 |     |      * NOTE: Does not update the allowance if the current allowance
 149 |     |      * is the maximum `uint256`.
 150 |     |      *
 151 |     |      * Requirements:
 152 |     |      *
 153 |     |      * - `from` and `to` cannot be the zero address.
 154 |     |      * - `from` must have a balance of at least `amount`.
 155 |     |      * - the caller must have allowance for ``from``'s tokens of at least
 156 |     |      * `amount`.
 157 |     |      */
 158 |     |     function transferFrom(
 159 |     |         address from,
 160 |     |         address to,
 161 |     |         uint256 amount
 162 |     |     ) public virtual override returns (bool) {
 163 |     |         address spender = _msgSender();
 164 |     |         _spendAllowance(from, spender, amount);
 165 |     |         _transfer(from, to, amount);
 166 |     |         return true;
 167 |     |     }
 168 |     | 
 169 |     |     /**
 170 |     |      * @dev Atomically increases the allowance granted to `spender` by the caller.
 171 |     |      *
 172 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 173 |     |      * problems described in {IERC20-approve}.
 174 |     |      *
 175 |     |      * Emits an {Approval} event indicating the updated allowance.
 176 |     |      *
 177 |     |      * Requirements:
 178 |     |      *
 179 |     |      * - `spender` cannot be the zero address.
 180 |     |      */
 181 |     |     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
 182 |     |         address owner = _msgSender();
 183 |     |         _approve(owner, spender, allowance(owner, spender) + addedValue);
 184 |     |         return true;
 185 |     |     }
 186 |     | 
 187 |     |     /**
 188 |     |      * @dev Atomically decreases the allowance granted to `spender` by the caller.
 189 |     |      *
 190 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 191 |     |      * problems described in {IERC20-approve}.
 192 |     |      *
 193 |     |      * Emits an {Approval} event indicating the updated allowance.
 194 |     |      *
 195 |     |      * Requirements:
 196 |     |      *
 197 |     |      * - `spender` cannot be the zero address.
 198 |     |      * - `spender` must have allowance for the caller of at least
 199 |     |      * `subtractedValue`.
 200 |     |      */
 201 |     |     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
 202 |     |         address owner = _msgSender();
 203 |     |         uint256 currentAllowance = allowance(owner, spender);
 204 |     |         require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
 205 |     |         unchecked {
 206 |     |             _approve(owner, spender, currentAllowance - subtractedValue);
 207 |     |         }
 208 |     | 
 209 |     |         return true;
 210 |     |     }
 211 |     | 
 212 |     |     /**
 213 |     |      * @dev Moves `amount` of tokens from `from` to `to`.
 214 |     |      *
 215 |     |      * This internal function is equivalent to {transfer}, and can be used to
 216 |     |      * e.g. implement automatic token fees, slashing mechanisms, etc.
 217 |     |      *
 218 |     |      * Emits a {Transfer} event.
 219 |     |      *
 220 |     |      * Requirements:
 221 |     |      *
 222 |     |      * - `from` cannot be the zero address.
 223 |     |      * - `to` cannot be the zero address.
 224 |     |      * - `from` must have a balance of at least `amount`.
 225 |     |      */
 226 |     |     function _transfer(
 227 |     |         address from,
 228 |     |         address to,
 229 |     |         uint256 amount
 230 |     |     ) internal virtual {
 231 |     |         require(from != address(0), "ERC20: transfer from the zero address");
 232 |     |         require(to != address(0), "ERC20: transfer to the zero address");
 233 |     | 
 234 |     |         _beforeTokenTransfer(from, to, amount);
 235 |     | 
 236 |     |         uint256 fromBalance = _balances[from];
 237 |     |         require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
 238 |     |         unchecked {
 239 |     |             _balances[from] = fromBalance - amount;
 240 |     |             // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by
 241 |     |             // decrementing then incrementing.
 242 |     |             _balances[to] += amount;
 243 |     |         }
 244 |     | 
 245 |     |         emit Transfer(from, to, amount);
 246 |     | 
 247 |     |         _afterTokenTransfer(from, to, amount);
 248 |     |     }
 249 |     | 
 250 |     |     /** @dev Creates `amount` tokens and assigns them to `account`, increasing
 251 |     |      * the total supply.
 252 |     |      *
 253 |     |      * Emits a {Transfer} event with `from` set to the zero address.
 254 |     |      *
 255 |     |      * Requirements:
 256 |     |      *
 257 |     |      * - `account` cannot be the zero address.
 258 |     |      */
 259 |     |     function _mint(address account, uint256 amount) internal virtual {
 260 |     |         require(account != address(0), "ERC20: mint to the zero address");
 261 |     | 
 262 |     |         _beforeTokenTransfer(address(0), account, amount);
 263 |     | 
 264 |     |         _totalSupply += amount;
 265 |     |         unchecked {
 266 |     |             // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.
 267 |     |             _balances[account] += amount;
 268 |     |         }
 269 |     |         emit Transfer(address(0), account, amount);
 270 |     | 
 271 |     |         _afterTokenTransfer(address(0), account, amount);
 272 |     |     }
 273 |     | 
 274 |     |     /**
 275 |     |      * @dev Destroys `amount` tokens from `account`, reducing the
 276 |     |      * total supply.
 277 |     |      *
 278 |     |      * Emits a {Transfer} event with `to` set to the zero address.
 279 |     |      *
 280 |     |      * Requirements:
 281 |     |      *
 282 |     |      * - `account` cannot be the zero address.
 283 |     |      * - `account` must have at least `amount` tokens.
 284 |     |      */
 285 |     |     function _burn(address account, uint256 amount) internal virtual {
 286 |     |         require(account != address(0), "ERC20: burn from the zero address");
 287 |     | 
 288 |     |         _beforeTokenTransfer(account, address(0), amount);
 289 |     | 
 290 |     |         uint256 accountBalance = _balances[account];
 291 |     |         require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
 292 |     |         unchecked {
 293 |     |             _balances[account] = accountBalance - amount;
 294 |     |             // Overflow not possible: amount <= accountBalance <= totalSupply.
 295 |     |             _totalSupply -= amount;
 296 |     |         }
 297 |     | 
 298 |     |         emit Transfer(account, address(0), amount);
 299 |     | 
 300 |     |         _afterTokenTransfer(account, address(0), amount);
 301 |     |     }
 302 |     | 
 303 |     |     /**
 304 |     |      * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
 305 |     |      *
 306 |     |      * This internal function is equivalent to `approve`, and can be used to
 307 |     |      * e.g. set automatic allowances for certain subsystems, etc.
 308 |     |      *
 309 |     |      * Emits an {Approval} event.
 310 |     |      *
 311 |     |      * Requirements:
 312 |     |      *
 313 |     |      * - `owner` cannot be the zero address.
 314 |     |      * - `spender` cannot be the zero address.
 315 |     |      */
 316 |     |     function _approve(
 317 |     |         address owner,
 318 |     |         address spender,
 319 |     |         uint256 amount
 320 |     |     ) internal virtual {
 321 |     |         require(owner != address(0), "ERC20: approve from the zero address");
 322 |     |         require(spender != address(0), "ERC20: approve to the zero address");
 323 |     | 
 324 |     |         _allowances[owner][spender] = amount;
 325 |     |         emit Approval(owner, spender, amount);
 326 |     |     }
 327 |     | 
 328 |     |     /**
 329 |     |      * @dev Updates `owner` s allowance for `spender` based on spent `amount`.
 330 |     |      *
 331 |     |      * Does not update the allowance amount in case of infinite allowance.
 332 |     |      * Revert if not enough allowance is available.
 333 |     |      *
 334 |     |      * Might emit an {Approval} event.
 335 |     |      */
 336 |     |     function _spendAllowance(
 337 |     |         address owner,
 338 |     |         address spender,
 339 |     |         uint256 amount
 340 |     |     ) internal virtual {
 341 |     |         uint256 currentAllowance = allowance(owner, spender);
 342 |     |         if (currentAllowance != type(uint256).max) {
 343 |     |             require(currentAllowance >= amount, "ERC20: insufficient allowance");
 344 |     |             unchecked {
 345 |     |                 _approve(owner, spender, currentAllowance - amount);
 346 |     |             }
 347 |     |         }
 348 |     |     }
 349 |     | 
 350 |     |     /**
 351 |     |      * @dev Hook that is called before any transfer of tokens. This includes
 352 |     |      * minting and burning.
 353 |     |      *
 354 |     |      * Calling conditions:
 355 |     |      *
 356 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 357 |     |      * will be transferred to `to`.
 358 |     |      * - when `from` is zero, `amount` tokens will be minted for `to`.
 359 |     |      * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
 360 |     |      * - `from` and `to` are never both zero.
 361 |     |      *
 362 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 363 |     |      */
 364 |     |     function _beforeTokenTransfer(
 365 |     |         address from,
 366 |     |         address to,
 367 |     |         uint256 amount
 368 |     |     ) internal virtual {}
 369 |     | 
 370 |     |     /**
 371 |     |      * @dev Hook that is called after any transfer of tokens. This includes
 372 |     |      * minting and burning.
 373 |     |      *
 374 |     |      * Calling conditions:
 375 |     |      *
 376 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 377 |     |      * has been transferred to `to`.
 378 |     |      * - when `from` is zero, `amount` tokens have been minted for `to`.
 379 |     |      * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
 380 |     |      * - `from` and `to` are never both zero.
 381 |     |      *
 382 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 383 |     |      */
 384 |     |     function _afterTokenTransfer(
 385 |     |         address from,
 386 |     |         address to,
 387 |     |         uint256 amount
 388 |     |     ) internal virtual {}
 389 |     | }
 390 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 standard as defined in the EIP.
  8 |     |  */
  9 |     | interface IERC20 {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the amount of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the amount of tokens owned by `account`.
 31 |     |      */
 32 |     |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves `amount` tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 |     |     function transfer(address to, uint256 amount) external returns (bool);
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 |     |      * zero by default.
 47 |     |      *
 48 |     |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 |     |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
 54 |     |      *
 55 |     |      * Returns a boolean value indicating whether the operation succeeded.
 56 |     |      *
 57 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 58 |     |      * that someone may use both the old and the new allowance by unfortunate
 59 |     |      * transaction ordering. One possible solution to mitigate this race
 60 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 61 |     |      * desired value afterwards:
 62 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 63 |     |      *
 64 |     |      * Emits an {Approval} event.
 65 |     |      */
 66 |     |     function approve(address spender, uint256 amount) external returns (bool);
 67 |     | 
 68 |     |     /**
 69 |     |      * @dev Moves `amount` tokens from `from` to `to` using the
 70 |     |      * allowance mechanism. `amount` is then deducted from the caller's
 71 |     |      * allowance.
 72 |     |      *
 73 |     |      * Returns a boolean value indicating whether the operation succeeded.
 74 |     |      *
 75 |     |      * Emits a {Transfer} event.
 76 |     |      */
 77 |     |     function transferFrom(
 78 |     |         address from,
 79 |     |         address to,
 80 |     |         uint256 amount
 81 |     |     ) external returns (bool);
 82 |     | }
 83 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../IERC20.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Interface for the optional metadata functions from the ERC20 standard.
 10 |     |  *
 11 |     |  * _Available since v4.1._
 12 |     |  */
 13 |     | interface IERC20Metadata is IERC20 {
 14 |     |     /**
 15 |     |      * @dev Returns the name of the token.
 16 |     |      */
 17 |     |     function name() external view returns (string memory);
 18 |     | 
 19 |     |     /**
 20 |     |      * @dev Returns the symbol of the token.
 21 |     |      */
 22 |     |     function symbol() external view returns (string memory);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the decimals places of the token.
 26 |     |      */
 27 |     |     function decimals() external view returns (uint8);
 28 |     | }
 29 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
  8 |     |  * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
  9 |     |  *
 10 |     |  * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 11 |     |  * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 12 |     |  * need to send a transaction, and thus is not required to hold Ether at all.
 13 |     |  */
 14 |     | interface IERC20Permit {
 15 |     |     /**
 16 |     |      * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
 17 |     |      * given ``owner``'s signed approval.
 18 |     |      *
 19 |     |      * IMPORTANT: The same issues {IERC20-approve} has related to transaction
 20 |     |      * ordering also apply here.
 21 |     |      *
 22 |     |      * Emits an {Approval} event.
 23 |     |      *
 24 |     |      * Requirements:
 25 |     |      *
 26 |     |      * - `spender` cannot be the zero address.
 27 |     |      * - `deadline` must be a timestamp in the future.
 28 |     |      * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
 29 |     |      * over the EIP712-formatted function arguments.
 30 |     |      * - the signature must use ``owner``'s current nonce (see {nonces}).
 31 |     |      *
 32 |     |      * For more information on the signature format, see the
 33 |     |      * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
 34 |     |      * section].
 35 |     |      */
 36 |     |     function permit(
 37 |     |         address owner,
 38 |     |         address spender,
 39 |     |         uint256 value,
 40 |     |         uint256 deadline,
 41 |     |         uint8 v,
 42 |     |         bytes32 r,
 43 |     |         bytes32 s
 44 |     |     ) external;
 45 |     | 
 46 |     |     /**
 47 |     |      * @dev Returns the current nonce for `owner`. This value must be
 48 |     |      * included whenever a signature is generated for {permit}.
 49 |     |      *
 50 |     |      * Every successful call to {permit} increases ``owner``'s nonce by one. This
 51 |     |      * prevents a signature from being used multiple times.
 52 |     |      */
 53 |     |     function nonces(address owner) external view returns (uint256);
 54 |     | 
 55 |     |     /**
 56 |     |      * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
 57 |     |      */
 58 |     |     // solhint-disable-next-line func-name-mixedcase
 59 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32);
 60 |     | }
 61 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "../IERC20.sol";
   7 |     | import "../extensions/draft-IERC20Permit.sol";
   8 |     | import "../../../utils/Address.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @title SafeERC20
  12 |     |  * @dev Wrappers around ERC20 operations that throw on failure (when the token
  13 |     |  * contract returns false). Tokens that return no value (and instead revert or
  14 |     |  * throw on failure) are also supported, non-reverting calls are assumed to be
  15 |     |  * successful.
  16 |     |  * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
  17 |     |  * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
  18 |     |  */
  19 |     | library SafeERC20 {
  20 |     |     using Address for address;
  21 |     | 
  22 |     |     function safeTransfer(
  23 |     |         IERC20 token,
  24 |     |         address to,
  25 |     |         uint256 value
  26 |     |     ) internal {
  27 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
  28 |     |     }
  29 |     | 
  30 |     |     function safeTransferFrom(
  31 |     |         IERC20 token,
  32 |     |         address from,
  33 |     |         address to,
  34 |     |         uint256 value
  35 |     |     ) internal {
  36 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
  37 |     |     }
  38 |     | 
  39 |     |     /**
  40 |     |      * @dev Deprecated. This function has issues similar to the ones found in
  41 |     |      * {IERC20-approve}, and its usage is discouraged.
  42 |     |      *
  43 |     |      * Whenever possible, use {safeIncreaseAllowance} and
  44 |     |      * {safeDecreaseAllowance} instead.
  45 |     |      */
  46 |     |     function safeApprove(
  47 |     |         IERC20 token,
  48 |     |         address spender,
  49 |     |         uint256 value
  50 |     |     ) internal {
  51 |     |         // safeApprove should only be called when setting an initial allowance,
  52 |     |         // or when resetting it to zero. To increase and decrease it, use
  53 |     |         // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
  54 |     |         require(
  55 |     |             (value == 0) || (token.allowance(address(this), spender) == 0),
  56 |     |             "SafeERC20: approve from non-zero to non-zero allowance"
  57 |     |         );
  58 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
  59 |     |     }
  60 |     | 
  61 |     |     function safeIncreaseAllowance(
  62 |     |         IERC20 token,
  63 |     |         address spender,
  64 |     |         uint256 value
  65 |     |     ) internal {
  66 |     |         uint256 newAllowance = token.allowance(address(this), spender) + value;
  67 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
  68 |     |     }
  69 |     | 
  70 |     |     function safeDecreaseAllowance(
  71 |     |         IERC20 token,
  72 |     |         address spender,
  73 |     |         uint256 value
  74 |     |     ) internal {
  75 |     |         unchecked {
  76 |     |             uint256 oldAllowance = token.allowance(address(this), spender);
  77 |     |             require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
  78 |     |             uint256 newAllowance = oldAllowance - value;
  79 |     |             _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
  80 |     |         }
  81 |     |     }
  82 |     | 
  83 |     |     function safePermit(
  84 |     |         IERC20Permit token,
  85 |     |         address owner,
  86 |     |         address spender,
  87 |     |         uint256 value,
  88 |     |         uint256 deadline,
  89 |     |         uint8 v,
  90 |     |         bytes32 r,
  91 |     |         bytes32 s
  92 |     |     ) internal {
  93 |     |         uint256 nonceBefore = token.nonces(owner);
  94 |     |         token.permit(owner, spender, value, deadline, v, r, s);
  95 |     |         uint256 nonceAfter = token.nonces(owner);
  96 |     |         require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");
  97 |     |     }
  98 |     | 
  99 |     |     /**
 100 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
 101 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
 102 |     |      * @param token The token targeted by the call.
 103 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
 104 |     |      */
 105 |     |     function _callOptionalReturn(IERC20 token, bytes memory data) private {
 106 |     |         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
 107 |     |         // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that
 108 |     |         // the target address contains contract code and also asserts for success in the low-level call.
 109 |     | 
 110 |     |         bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
 111 |     |         if (returndata.length > 0) {
 112 |     |             // Return data is optional
 113 |     |             require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
 114 |     |         }
 115 |     |     }
 116 |     | }
 117 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/ERC721.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "./IERC721.sol";
   7 |     | import "./IERC721Receiver.sol";
   8 |     | import "./extensions/IERC721Metadata.sol";
   9 |     | import "../../utils/Address.sol";
  10 |     | import "../../utils/Context.sol";
  11 |     | import "../../utils/Strings.sol";
  12 |     | import "../../utils/introspection/ERC165.sol";
  13 |     | 
  14 |     | /**
  15 |     |  * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
  16 |     |  * the Metadata extension, but not including the Enumerable extension, which is available separately as
  17 |     |  * {ERC721Enumerable}.
  18 |     |  */
  19 |     | contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {
  20 |     |     using Address for address;
  21 |     |     using Strings for uint256;
  22 |     | 
  23 |     |     // Token name
  24 |     |     string private _name;
  25 |     | 
  26 |     |     // Token symbol
  27 |     |     string private _symbol;
  28 |     | 
  29 |     |     // Mapping from token ID to owner address
  30 |     |     mapping(uint256 => address) private _owners;
  31 |     | 
  32 |     |     // Mapping owner address to token count
  33 |     |     mapping(address => uint256) private _balances;
  34 |     | 
  35 |     |     // Mapping from token ID to approved address
  36 |     |     mapping(uint256 => address) private _tokenApprovals;
  37 |     | 
  38 |     |     // Mapping from owner to operator approvals
  39 |     |     mapping(address => mapping(address => bool)) private _operatorApprovals;
  40 |     | 
  41 |     |     /**
  42 |     |      * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.
  43 |     |      */
  44 |     |     constructor(string memory name_, string memory symbol_) {
  45 |     |         _name = name_;
  46 |     |         _symbol = symbol_;
  47 |     |     }
  48 |     | 
  49 |     |     /**
  50 |     |      * @dev See {IERC165-supportsInterface}.
  51 |     |      */
  52 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
  53 |     |         return
  54 |     |             interfaceId == type(IERC721).interfaceId ||
  55 |     |             interfaceId == type(IERC721Metadata).interfaceId ||
  56 |     |             super.supportsInterface(interfaceId);
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev See {IERC721-balanceOf}.
  61 |     |      */
  62 |     |     function balanceOf(address owner) public view virtual override returns (uint256) {
  63 |     |         require(owner != address(0), "ERC721: address zero is not a valid owner");
  64 |     |         return _balances[owner];
  65 |     |     }
  66 |     | 
  67 |     |     /**
  68 |     |      * @dev See {IERC721-ownerOf}.
  69 |     |      */
  70 |     |     function ownerOf(uint256 tokenId) public view virtual override returns (address) {
  71 |     |         address owner = _ownerOf(tokenId);
  72 |     |         require(owner != address(0), "ERC721: invalid token ID");
  73 |     |         return owner;
  74 |     |     }
  75 |     | 
  76 |     |     /**
  77 |     |      * @dev See {IERC721Metadata-name}.
  78 |     |      */
  79 |     |     function name() public view virtual override returns (string memory) {
  80 |     |         return _name;
  81 |     |     }
  82 |     | 
  83 |     |     /**
  84 |     |      * @dev See {IERC721Metadata-symbol}.
  85 |     |      */
  86 |     |     function symbol() public view virtual override returns (string memory) {
  87 |     |         return _symbol;
  88 |     |     }
  89 |     | 
  90 |     |     /**
  91 |     |      * @dev See {IERC721Metadata-tokenURI}.
  92 |     |      */
  93 |     |     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
  94 |     |         _requireMinted(tokenId);
  95 |     | 
  96 |     |         string memory baseURI = _baseURI();
  97 |     |         return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
  98 |     |     }
  99 |     | 
 100 |     |     /**
 101 |     |      * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
 102 |     |      * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
 103 |     |      * by default, can be overridden in child contracts.
 104 |     |      */
 105 |     |     function _baseURI() internal view virtual returns (string memory) {
 106 |     |         return "";
 107 |     |     }
 108 |     | 
 109 |     |     /**
 110 |     |      * @dev See {IERC721-approve}.
 111 |     |      */
 112 |     |     function approve(address to, uint256 tokenId) public virtual override {
 113 |     |         address owner = ERC721.ownerOf(tokenId);
 114 |     |         require(to != owner, "ERC721: approval to current owner");
 115 |     | 
 116 |     |         require(
 117 |     |             _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
 118 |     |             "ERC721: approve caller is not token owner or approved for all"
 119 |     |         );
 120 |     | 
 121 |     |         _approve(to, tokenId);
 122 |     |     }
 123 |     | 
 124 |     |     /**
 125 |     |      * @dev See {IERC721-getApproved}.
 126 |     |      */
 127 |     |     function getApproved(uint256 tokenId) public view virtual override returns (address) {
 128 |     |         _requireMinted(tokenId);
 129 |     | 
 130 |     |         return _tokenApprovals[tokenId];
 131 |     |     }
 132 |     | 
 133 |     |     /**
 134 |     |      * @dev See {IERC721-setApprovalForAll}.
 135 |     |      */
 136 |     |     function setApprovalForAll(address operator, bool approved) public virtual override {
 137 |     |         _setApprovalForAll(_msgSender(), operator, approved);
 138 |     |     }
 139 |     | 
 140 |     |     /**
 141 |     |      * @dev See {IERC721-isApprovedForAll}.
 142 |     |      */
 143 |     |     function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
 144 |     |         return _operatorApprovals[owner][operator];
 145 |     |     }
 146 |     | 
 147 |     |     /**
 148 |     |      * @dev See {IERC721-transferFrom}.
 149 |     |      */
 150 |     |     function transferFrom(
 151 |     |         address from,
 152 |     |         address to,
 153 |     |         uint256 tokenId
 154 |     |     ) public virtual override {
 155 |     |         //solhint-disable-next-line max-line-length
 156 |     |         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");
 157 |     | 
 158 |     |         _transfer(from, to, tokenId);
 159 |     |     }
 160 |     | 
 161 |     |     /**
 162 |     |      * @dev See {IERC721-safeTransferFrom}.
 163 |     |      */
 164 |     |     function safeTransferFrom(
 165 |     |         address from,
 166 |     |         address to,
 167 |     |         uint256 tokenId
 168 |     |     ) public virtual override {
 169 |     |         safeTransferFrom(from, to, tokenId, "");
 170 |     |     }
 171 |     | 
 172 |     |     /**
 173 |     |      * @dev See {IERC721-safeTransferFrom}.
 174 |     |      */
 175 |     |     function safeTransferFrom(
 176 |     |         address from,
 177 |     |         address to,
 178 |     |         uint256 tokenId,
 179 |     |         bytes memory data
 180 |     |     ) public virtual override {
 181 |     |         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");
 182 |     |         _safeTransfer(from, to, tokenId, data);
 183 |     |     }
 184 |     | 
 185 |     |     /**
 186 |     |      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
 187 |     |      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
 188 |     |      *
 189 |     |      * `data` is additional data, it has no specified format and it is sent in call to `to`.
 190 |     |      *
 191 |     |      * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.
 192 |     |      * implement alternative mechanisms to perform token transfer, such as signature-based.
 193 |     |      *
 194 |     |      * Requirements:
 195 |     |      *
 196 |     |      * - `from` cannot be the zero address.
 197 |     |      * - `to` cannot be the zero address.
 198 |     |      * - `tokenId` token must exist and be owned by `from`.
 199 |     |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
 200 |     |      *
 201 |     |      * Emits a {Transfer} event.
 202 |     |      */
 203 |     |     function _safeTransfer(
 204 |     |         address from,
 205 |     |         address to,
 206 |     |         uint256 tokenId,
 207 |     |         bytes memory data
 208 |     |     ) internal virtual {
 209 |     |         _transfer(from, to, tokenId);
 210 |     |         require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");
 211 |     |     }
 212 |     | 
 213 |     |     /**
 214 |     |      * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist
 215 |     |      */
 216 |     |     function _ownerOf(uint256 tokenId) internal view virtual returns (address) {
 217 |     |         return _owners[tokenId];
 218 |     |     }
 219 |     | 
 220 |     |     /**
 221 |     |      * @dev Returns whether `tokenId` exists.
 222 |     |      *
 223 |     |      * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
 224 |     |      *
 225 |     |      * Tokens start existing when they are minted (`_mint`),
 226 |     |      * and stop existing when they are burned (`_burn`).
 227 |     |      */
 228 |     |     function _exists(uint256 tokenId) internal view virtual returns (bool) {
 229 |     |         return _ownerOf(tokenId) != address(0);
 230 |     |     }
 231 |     | 
 232 |     |     /**
 233 |     |      * @dev Returns whether `spender` is allowed to manage `tokenId`.
 234 |     |      *
 235 |     |      * Requirements:
 236 |     |      *
 237 |     |      * - `tokenId` must exist.
 238 |     |      */
 239 |     |     function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
 240 |     |         address owner = ERC721.ownerOf(tokenId);
 241 |     |         return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);
 242 |     |     }
 243 |     | 
 244 |     |     /**
 245 |     |      * @dev Safely mints `tokenId` and transfers it to `to`.
 246 |     |      *
 247 |     |      * Requirements:
 248 |     |      *
 249 |     |      * - `tokenId` must not exist.
 250 |     |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
 251 |     |      *
 252 |     |      * Emits a {Transfer} event.
 253 |     |      */
 254 |     |     function _safeMint(address to, uint256 tokenId) internal virtual {
 255 |     |         _safeMint(to, tokenId, "");
 256 |     |     }
 257 |     | 
 258 |     |     /**
 259 |     |      * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is
 260 |     |      * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.
 261 |     |      */
 262 |     |     function _safeMint(
 263 |     |         address to,
 264 |     |         uint256 tokenId,
 265 |     |         bytes memory data
 266 |     |     ) internal virtual {
 267 |     |         _mint(to, tokenId);
 268 |     |         require(
 269 |     |             _checkOnERC721Received(address(0), to, tokenId, data),
 270 |     |             "ERC721: transfer to non ERC721Receiver implementer"
 271 |     |         );
 272 |     |     }
 273 |     | 
 274 |     |     /**
 275 |     |      * @dev Mints `tokenId` and transfers it to `to`.
 276 |     |      *
 277 |     |      * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible
 278 |     |      *
 279 |     |      * Requirements:
 280 |     |      *
 281 |     |      * - `tokenId` must not exist.
 282 |     |      * - `to` cannot be the zero address.
 283 |     |      *
 284 |     |      * Emits a {Transfer} event.
 285 |     |      */
 286 |     |     function _mint(address to, uint256 tokenId) internal virtual {
 287 |     |         require(to != address(0), "ERC721: mint to the zero address");
 288 |     |         require(!_exists(tokenId), "ERC721: token already minted");
 289 |     | 
 290 |     |         _beforeTokenTransfer(address(0), to, tokenId, 1);
 291 |     | 
 292 |     |         // Check that tokenId was not minted by `_beforeTokenTransfer` hook
 293 |     |         require(!_exists(tokenId), "ERC721: token already minted");
 294 |     | 
 295 |     |         unchecked {
 296 |     |             // Will not overflow unless all 2**256 token ids are minted to the same owner.
 297 |     |             // Given that tokens are minted one by one, it is impossible in practice that
 298 |     |             // this ever happens. Might change if we allow batch minting.
 299 |     |             // The ERC fails to describe this case.
 300 |     |             _balances[to] += 1;
 301 |     |         }
 302 |     | 
 303 |     |         _owners[tokenId] = to;
 304 |     | 
 305 |     |         emit Transfer(address(0), to, tokenId);
 306 |     | 
 307 |     |         _afterTokenTransfer(address(0), to, tokenId, 1);
 308 |     |     }
 309 |     | 
 310 |     |     /**
 311 |     |      * @dev Destroys `tokenId`.
 312 |     |      * The approval is cleared when the token is burned.
 313 |     |      * This is an internal function that does not check if the sender is authorized to operate on the token.
 314 |     |      *
 315 |     |      * Requirements:
 316 |     |      *
 317 |     |      * - `tokenId` must exist.
 318 |     |      *
 319 |     |      * Emits a {Transfer} event.
 320 |     |      */
 321 |     |     function _burn(uint256 tokenId) internal virtual {
 322 |     |         address owner = ERC721.ownerOf(tokenId);
 323 |     | 
 324 |     |         _beforeTokenTransfer(owner, address(0), tokenId, 1);
 325 |     | 
 326 |     |         // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook
 327 |     |         owner = ERC721.ownerOf(tokenId);
 328 |     | 
 329 |     |         // Clear approvals
 330 |     |         delete _tokenApprovals[tokenId];
 331 |     | 
 332 |     |         unchecked {
 333 |     |             // Cannot overflow, as that would require more tokens to be burned/transferred
 334 |     |             // out than the owner initially received through minting and transferring in.
 335 |     |             _balances[owner] -= 1;
 336 |     |         }
 337 |     |         delete _owners[tokenId];
 338 |     | 
 339 |     |         emit Transfer(owner, address(0), tokenId);
 340 |     | 
 341 |     |         _afterTokenTransfer(owner, address(0), tokenId, 1);
 342 |     |     }
 343 |     | 
 344 |     |     /**
 345 |     |      * @dev Transfers `tokenId` from `from` to `to`.
 346 |     |      *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
 347 |     |      *
 348 |     |      * Requirements:
 349 |     |      *
 350 |     |      * - `to` cannot be the zero address.
 351 |     |      * - `tokenId` token must be owned by `from`.
 352 |     |      *
 353 |     |      * Emits a {Transfer} event.
 354 |     |      */
 355 |     |     function _transfer(
 356 |     |         address from,
 357 |     |         address to,
 358 |     |         uint256 tokenId
 359 |     |     ) internal virtual {
 360 |     |         require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");
 361 |     |         require(to != address(0), "ERC721: transfer to the zero address");
 362 |     | 
 363 |     |         _beforeTokenTransfer(from, to, tokenId, 1);
 364 |     | 
 365 |     |         // Check that tokenId was not transferred by `_beforeTokenTransfer` hook
 366 |     |         require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");
 367 |     | 
 368 |     |         // Clear approvals from the previous owner
 369 |     |         delete _tokenApprovals[tokenId];
 370 |     | 
 371 |     |         unchecked {
 372 |     |             // `_balances[from]` cannot overflow for the same reason as described in `_burn`:
 373 |     |             // `from`'s balance is the number of token held, which is at least one before the current
 374 |     |             // transfer.
 375 |     |             // `_balances[to]` could overflow in the conditions described in `_mint`. That would require
 376 |     |             // all 2**256 token ids to be minted, which in practice is impossible.
 377 |     |             _balances[from] -= 1;
 378 |     |             _balances[to] += 1;
 379 |     |         }
 380 |     |         _owners[tokenId] = to;
 381 |     | 
 382 |     |         emit Transfer(from, to, tokenId);
 383 |     | 
 384 |     |         _afterTokenTransfer(from, to, tokenId, 1);
 385 |     |     }
 386 |     | 
 387 |     |     /**
 388 |     |      * @dev Approve `to` to operate on `tokenId`
 389 |     |      *
 390 |     |      * Emits an {Approval} event.
 391 |     |      */
 392 |     |     function _approve(address to, uint256 tokenId) internal virtual {
 393 |     |         _tokenApprovals[tokenId] = to;
 394 |     |         emit Approval(ERC721.ownerOf(tokenId), to, tokenId);
 395 |     |     }
 396 |     | 
 397 |     |     /**
 398 |     |      * @dev Approve `operator` to operate on all of `owner` tokens
 399 |     |      *
 400 |     |      * Emits an {ApprovalForAll} event.
 401 |     |      */
 402 |     |     function _setApprovalForAll(
 403 |     |         address owner,
 404 |     |         address operator,
 405 |     |         bool approved
 406 |     |     ) internal virtual {
 407 |     |         require(owner != operator, "ERC721: approve to caller");
 408 |     |         _operatorApprovals[owner][operator] = approved;
 409 |     |         emit ApprovalForAll(owner, operator, approved);
 410 |     |     }
 411 |     | 
 412 |     |     /**
 413 |     |      * @dev Reverts if the `tokenId` has not been minted yet.
 414 |     |      */
 415 |     |     function _requireMinted(uint256 tokenId) internal view virtual {
 416 |     |         require(_exists(tokenId), "ERC721: invalid token ID");
 417 |     |     }
 418 |     | 
 419 |     |     /**
 420 |     |      * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
 421 |     |      * The call is not executed if the target address is not a contract.
 422 |     |      *
 423 |     |      * @param from address representing the previous owner of the given token ID
 424 |     |      * @param to target address that will receive the tokens
 425 |     |      * @param tokenId uint256 ID of the token to be transferred
 426 |     |      * @param data bytes optional data to send along with the call
 427 |     |      * @return bool whether the call correctly returned the expected magic value
 428 |     |      */
 429 |     |     function _checkOnERC721Received(
 430 |     |         address from,
 431 |     |         address to,
 432 |     |         uint256 tokenId,
 433 |     |         bytes memory data
 434 |     |     ) private returns (bool) {
 435 |     |         if (to.isContract()) {
 436 |     |             try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {
 437 |     |                 return retval == IERC721Receiver.onERC721Received.selector;
 438 |     |             } catch (bytes memory reason) {
 439 |     |                 if (reason.length == 0) {
 440 |     |                     revert("ERC721: transfer to non ERC721Receiver implementer");
 441 |     |                 } else {
 442 |     |                     /// @solidity memory-safe-assembly
 443 |     |                     assembly {
 444 |     |                         revert(add(32, reason), mload(reason))
 445 |     |                     }
 446 |     |                 }
 447 |     |             }
 448 |     |         } else {
 449 |     |             return true;
 450 |     |         }
 451 |     |     }
 452 |     | 
 453 |     |     /**
 454 |     |      * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is
 455 |     |      * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.
 456 |     |      *
 457 |     |      * Calling conditions:
 458 |     |      *
 459 |     |      * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.
 460 |     |      * - When `from` is zero, the tokens will be minted for `to`.
 461 |     |      * - When `to` is zero, ``from``'s tokens will be burned.
 462 |     |      * - `from` and `to` are never both zero.
 463 |     |      * - `batchSize` is non-zero.
 464 |     |      *
 465 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 466 |     |      */
 467 |     |     function _beforeTokenTransfer(
 468 |     |         address from,
 469 |     |         address to,
 470 |     |         uint256, /* firstTokenId */
 471 |     |         uint256 batchSize
 472 |     |     ) internal virtual {
 473 |     |         if (batchSize > 1) {
 474 |     |             if (from != address(0)) {
 475 |     |                 _balances[from] -= batchSize;
 476 |     |             }
 477 |     |             if (to != address(0)) {
 478 |     |                 _balances[to] += batchSize;
 479 |     |             }
 480 |     |         }
 481 |     |     }
 482 |     | 
 483 |     |     /**
 484 |     |      * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is
 485 |     |      * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.
 486 |     |      *
 487 |     |      * Calling conditions:
 488 |     |      *
 489 |     |      * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.
 490 |     |      * - When `from` is zero, the tokens were minted for `to`.
 491 |     |      * - When `to` is zero, ``from``'s tokens were burned.
 492 |     |      * - `from` and `to` are never both zero.
 493 |     |      * - `batchSize` is non-zero.
 494 |     |      *
 495 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 496 |     |      */
 497 |     |     function _afterTokenTransfer(
 498 |     |         address from,
 499 |     |         address to,
 500 |     |         uint256 firstTokenId,
 501 |     |         uint256 batchSize
 502 |     |     ) internal virtual {}
 503 |     | }
 504 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "../../utils/introspection/IERC165.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev Required interface of an ERC721 compliant contract.
  10 |     |  */
  11 |     | interface IERC721 is IERC165 {
  12 |     |     /**
  13 |     |      * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
  14 |     |      */
  15 |     |     event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
  16 |     | 
  17 |     |     /**
  18 |     |      * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
  19 |     |      */
  20 |     |     event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
  24 |     |      */
  25 |     |     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
  26 |     | 
  27 |     |     /**
  28 |     |      * @dev Returns the number of tokens in ``owner``'s account.
  29 |     |      */
  30 |     |     function balanceOf(address owner) external view returns (uint256 balance);
  31 |     | 
  32 |     |     /**
  33 |     |      * @dev Returns the owner of the `tokenId` token.
  34 |     |      *
  35 |     |      * Requirements:
  36 |     |      *
  37 |     |      * - `tokenId` must exist.
  38 |     |      */
  39 |     |     function ownerOf(uint256 tokenId) external view returns (address owner);
  40 |     | 
  41 |     |     /**
  42 |     |      * @dev Safely transfers `tokenId` token from `from` to `to`.
  43 |     |      *
  44 |     |      * Requirements:
  45 |     |      *
  46 |     |      * - `from` cannot be the zero address.
  47 |     |      * - `to` cannot be the zero address.
  48 |     |      * - `tokenId` token must exist and be owned by `from`.
  49 |     |      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
  50 |     |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
  51 |     |      *
  52 |     |      * Emits a {Transfer} event.
  53 |     |      */
  54 |     |     function safeTransferFrom(
  55 |     |         address from,
  56 |     |         address to,
  57 |     |         uint256 tokenId,
  58 |     |         bytes calldata data
  59 |     |     ) external;
  60 |     | 
  61 |     |     /**
  62 |     |      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
  63 |     |      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
  64 |     |      *
  65 |     |      * Requirements:
  66 |     |      *
  67 |     |      * - `from` cannot be the zero address.
  68 |     |      * - `to` cannot be the zero address.
  69 |     |      * - `tokenId` token must exist and be owned by `from`.
  70 |     |      * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.
  71 |     |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
  72 |     |      *
  73 |     |      * Emits a {Transfer} event.
  74 |     |      */
  75 |     |     function safeTransferFrom(
  76 |     |         address from,
  77 |     |         address to,
  78 |     |         uint256 tokenId
  79 |     |     ) external;
  80 |     | 
  81 |     |     /**
  82 |     |      * @dev Transfers `tokenId` token from `from` to `to`.
  83 |     |      *
  84 |     |      * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721
  85 |     |      * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must
  86 |     |      * understand this adds an external call which potentially creates a reentrancy vulnerability.
  87 |     |      *
  88 |     |      * Requirements:
  89 |     |      *
  90 |     |      * - `from` cannot be the zero address.
  91 |     |      * - `to` cannot be the zero address.
  92 |     |      * - `tokenId` token must be owned by `from`.
  93 |     |      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
  94 |     |      *
  95 |     |      * Emits a {Transfer} event.
  96 |     |      */
  97 |     |     function transferFrom(
  98 |     |         address from,
  99 |     |         address to,
 100 |     |         uint256 tokenId
 101 |     |     ) external;
 102 |     | 
 103 |     |     /**
 104 |     |      * @dev Gives permission to `to` to transfer `tokenId` token to another account.
 105 |     |      * The approval is cleared when the token is transferred.
 106 |     |      *
 107 |     |      * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
 108 |     |      *
 109 |     |      * Requirements:
 110 |     |      *
 111 |     |      * - The caller must own the token or be an approved operator.
 112 |     |      * - `tokenId` must exist.
 113 |     |      *
 114 |     |      * Emits an {Approval} event.
 115 |     |      */
 116 |     |     function approve(address to, uint256 tokenId) external;
 117 |     | 
 118 |     |     /**
 119 |     |      * @dev Approve or remove `operator` as an operator for the caller.
 120 |     |      * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
 121 |     |      *
 122 |     |      * Requirements:
 123 |     |      *
 124 |     |      * - The `operator` cannot be the caller.
 125 |     |      *
 126 |     |      * Emits an {ApprovalForAll} event.
 127 |     |      */
 128 |     |     function setApprovalForAll(address operator, bool _approved) external;
 129 |     | 
 130 |     |     /**
 131 |     |      * @dev Returns the account approved for `tokenId` token.
 132 |     |      *
 133 |     |      * Requirements:
 134 |     |      *
 135 |     |      * - `tokenId` must exist.
 136 |     |      */
 137 |     |     function getApproved(uint256 tokenId) external view returns (address operator);
 138 |     | 
 139 |     |     /**
 140 |     |      * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
 141 |     |      *
 142 |     |      * See {setApprovalForAll}
 143 |     |      */
 144 |     |     function isApprovedForAll(address owner, address operator) external view returns (bool);
 145 |     | }
 146 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @title ERC721 token receiver interface
  8 |     |  * @dev Interface for any contract that wants to support safeTransfers
  9 |     |  * from ERC721 asset contracts.
 10 |     |  */
 11 |     | interface IERC721Receiver {
 12 |     |     /**
 13 |     |      * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
 14 |     |      * by `operator` from `from`, this function is called.
 15 |     |      *
 16 |     |      * It must return its Solidity selector to confirm the token transfer.
 17 |     |      * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
 18 |     |      *
 19 |     |      * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.
 20 |     |      */
 21 |     |     function onERC721Received(
 22 |     |         address operator,
 23 |     |         address from,
 24 |     |         uint256 tokenId,
 25 |     |         bytes calldata data
 26 |     |     ) external returns (bytes4);
 27 |     | }
 28 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../IERC721.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
 10 |     |  * @dev See https://eips.ethereum.org/EIPS/eip-721
 11 |     |  */
 12 |     | interface IERC721Metadata is IERC721 {
 13 |     |     /**
 14 |     |      * @dev Returns the token collection name.
 15 |     |      */
 16 |     |     function name() external view returns (string memory);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Returns the token collection symbol.
 20 |     |      */
 21 |     |     function symbol() external view returns (string memory);
 22 |     | 
 23 |     |     /**
 24 |     |      * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
 25 |     |      */
 26 |     |     function tokenURI(uint256 tokenId) external view returns (string memory);
 27 |     | }
 28 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/utils/Address.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.1;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Collection of functions related to the address type
   8 |     |  */
   9 |     | library Address {
  10 |     |     /**
  11 |     |      * @dev Returns true if `account` is a contract.
  12 |     |      *
  13 |     |      * [IMPORTANT]
  14 |     |      * ====
  15 |     |      * It is unsafe to assume that an address for which this function returns
  16 |     |      * false is an externally-owned account (EOA) and not a contract.
  17 |     |      *
  18 |     |      * Among others, `isContract` will return false for the following
  19 |     |      * types of addresses:
  20 |     |      *
  21 |     |      *  - an externally-owned account
  22 |     |      *  - a contract in construction
  23 |     |      *  - an address where a contract will be created
  24 |     |      *  - an address where a contract lived, but was destroyed
  25 |     |      * ====
  26 |     |      *
  27 |     |      * [IMPORTANT]
  28 |     |      * ====
  29 |     |      * You shouldn't rely on `isContract` to protect against flash loan attacks!
  30 |     |      *
  31 |     |      * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
  32 |     |      * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
  33 |     |      * constructor.
  34 |     |      * ====
  35 |     |      */
  36 |     |     function isContract(address account) internal view returns (bool) {
  37 |     |         // This method relies on extcodesize/address.code.length, which returns 0
  38 |     |         // for contracts in construction, since the code is only stored at the end
  39 |     |         // of the constructor execution.
  40 |     | 
  41 |     |         return account.code.length > 0;
  42 |     |     }
  43 |     | 
  44 |     |     /**
  45 |     |      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
  46 |     |      * `recipient`, forwarding all available gas and reverting on errors.
  47 |     |      *
  48 |     |      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
  49 |     |      * of certain opcodes, possibly making contracts go over the 2300 gas limit
  50 |     |      * imposed by `transfer`, making them unable to receive funds via
  51 |     |      * `transfer`. {sendValue} removes this limitation.
  52 |     |      *
  53 |     |      * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
  54 |     |      *
  55 |     |      * IMPORTANT: because control is transferred to `recipient`, care must be
  56 |     |      * taken to not create reentrancy vulnerabilities. Consider using
  57 |     |      * {ReentrancyGuard} or the
  58 |     |      * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
  59 |     |      */
  60 |     |     function sendValue(address payable recipient, uint256 amount) internal {
  61 |     |         require(address(this).balance >= amount, "Address: insufficient balance");
  62 |     | 
  63 |     |         (bool success, ) = recipient.call{value: amount}("");
  64 |     |         require(success, "Address: unable to send value, recipient may have reverted");
  65 |     |     }
  66 |     | 
  67 |     |     /**
  68 |     |      * @dev Performs a Solidity function call using a low level `call`. A
  69 |     |      * plain `call` is an unsafe replacement for a function call: use this
  70 |     |      * function instead.
  71 |     |      *
  72 |     |      * If `target` reverts with a revert reason, it is bubbled up by this
  73 |     |      * function (like regular Solidity function calls).
  74 |     |      *
  75 |     |      * Returns the raw returned data. To convert to the expected return value,
  76 |     |      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
  77 |     |      *
  78 |     |      * Requirements:
  79 |     |      *
  80 |     |      * - `target` must be a contract.
  81 |     |      * - calling `target` with `data` must not revert.
  82 |     |      *
  83 |     |      * _Available since v3.1._
  84 |     |      */
  85 |     |     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
  86 |     |         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
  87 |     |     }
  88 |     | 
  89 |     |     /**
  90 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
  91 |     |      * `errorMessage` as a fallback revert reason when `target` reverts.
  92 |     |      *
  93 |     |      * _Available since v3.1._
  94 |     |      */
  95 |     |     function functionCall(
  96 |     |         address target,
  97 |     |         bytes memory data,
  98 |     |         string memory errorMessage
  99 |     |     ) internal returns (bytes memory) {
 100 |     |         return functionCallWithValue(target, data, 0, errorMessage);
 101 |     |     }
 102 |     | 
 103 |     |     /**
 104 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 105 |     |      * but also transferring `value` wei to `target`.
 106 |     |      *
 107 |     |      * Requirements:
 108 |     |      *
 109 |     |      * - the calling contract must have an ETH balance of at least `value`.
 110 |     |      * - the called Solidity function must be `payable`.
 111 |     |      *
 112 |     |      * _Available since v3.1._
 113 |     |      */
 114 |     |     function functionCallWithValue(
 115 |     |         address target,
 116 |     |         bytes memory data,
 117 |     |         uint256 value
 118 |     |     ) internal returns (bytes memory) {
 119 |     |         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
 120 |     |     }
 121 |     | 
 122 |     |     /**
 123 |     |      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
 124 |     |      * with `errorMessage` as a fallback revert reason when `target` reverts.
 125 |     |      *
 126 |     |      * _Available since v3.1._
 127 |     |      */
 128 |     |     function functionCallWithValue(
 129 |     |         address target,
 130 |     |         bytes memory data,
 131 |     |         uint256 value,
 132 |     |         string memory errorMessage
 133 |     |     ) internal returns (bytes memory) {
 134 |     |         require(address(this).balance >= value, "Address: insufficient balance for call");
 135 |     |         (bool success, bytes memory returndata) = target.call{value: value}(data);
 136 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 137 |     |     }
 138 |     | 
 139 |     |     /**
 140 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 141 |     |      * but performing a static call.
 142 |     |      *
 143 |     |      * _Available since v3.3._
 144 |     |      */
 145 |     |     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
 146 |     |         return functionStaticCall(target, data, "Address: low-level static call failed");
 147 |     |     }
 148 |     | 
 149 |     |     /**
 150 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
 151 |     |      * but performing a static call.
 152 |     |      *
 153 |     |      * _Available since v3.3._
 154 |     |      */
 155 |     |     function functionStaticCall(
 156 |     |         address target,
 157 |     |         bytes memory data,
 158 |     |         string memory errorMessage
 159 |     |     ) internal view returns (bytes memory) {
 160 |     |         (bool success, bytes memory returndata) = target.staticcall(data);
 161 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 162 |     |     }
 163 |     | 
 164 |     |     /**
 165 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 166 |     |      * but performing a delegate call.
 167 |     |      *
 168 |     |      * _Available since v3.4._
 169 |     |      */
 170 |     |     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
 171 |     |         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
 172 |     |     }
 173 |     | 
 174 |     |     /**
 175 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
 176 |     |      * but performing a delegate call.
 177 |     |      *
 178 |     |      * _Available since v3.4._
 179 |     |      */
 180 |     |     function functionDelegateCall(
 181 |     |         address target,
 182 |     |         bytes memory data,
 183 |     |         string memory errorMessage
 184 |     |     ) internal returns (bytes memory) {
 185 |     |         (bool success, bytes memory returndata) = target.delegatecall(data);
 186 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 187 |     |     }
 188 |     | 
 189 |     |     /**
 190 |     |      * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
 191 |     |      * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
 192 |     |      *
 193 |     |      * _Available since v4.8._
 194 |     |      */
 195 |     |     function verifyCallResultFromTarget(
 196 |     |         address target,
 197 |     |         bool success,
 198 |     |         bytes memory returndata,
 199 |     |         string memory errorMessage
 200 |     |     ) internal view returns (bytes memory) {
 201 |     |         if (success) {
 202 |     |             if (returndata.length == 0) {
 203 |     |                 // only check isContract if the call was successful and the return data is empty
 204 |     |                 // otherwise we already know that it was a contract
 205 |     |                 require(isContract(target), "Address: call to non-contract");
 206 |     |             }
 207 |     |             return returndata;
 208 |     |         } else {
 209 |     |             _revert(returndata, errorMessage);
 210 |     |         }
 211 |     |     }
 212 |     | 
 213 |     |     /**
 214 |     |      * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
 215 |     |      * revert reason or using the provided one.
 216 |     |      *
 217 |     |      * _Available since v4.3._
 218 |     |      */
 219 |     |     function verifyCallResult(
 220 |     |         bool success,
 221 |     |         bytes memory returndata,
 222 |     |         string memory errorMessage
 223 |     |     ) internal pure returns (bytes memory) {
 224 |     |         if (success) {
 225 |     |             return returndata;
 226 |     |         } else {
 227 |     |             _revert(returndata, errorMessage);
 228 |     |         }
 229 |     |     }
 230 |     | 
 231 |     |     function _revert(bytes memory returndata, string memory errorMessage) private pure {
 232 |     |         // Look for revert reason and bubble it up if present
 233 |     |         if (returndata.length > 0) {
 234 |     |             // The easiest way to bubble the revert reason is using memory via assembly
 235 |     |             /// @solidity memory-safe-assembly
 236 |     |             assembly {
 237 |     |                 let returndata_size := mload(returndata)
 238 |     |                 revert(add(32, returndata), returndata_size)
 239 |     |             }
 240 |     |         } else {
 241 |     |             revert(errorMessage);
 242 |     |         }
 243 |     |     }
 244 |     | }
 245 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/utils/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides information about the current execution context, including the
  8 |     |  * sender of the transaction and its data. While these are generally available
  9 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 10 |     |  * manner, since when dealing with meta-transactions the account sending and
 11 |     |  * paying for execution may not be the actual sender (as far as an application
 12 |     |  * is concerned).
 13 |     |  *
 14 |     |  * This contract is only required for intermediate, library-like contracts.
 15 |     |  */
 16 |     | abstract contract Context {
 17 |     |     function _msgSender() internal view virtual returns (address) {
 18 |     |         return msg.sender;
 19 |     |     }
 20 |     | 
 21 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 22 |     |         return msg.data;
 23 |     |     }
 24 |     | }
 25 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/utils/Counters.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @title Counters
  8 |     |  * @author Matt Condon (@shrugs)
  9 |     |  * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number
 10 |     |  * of elements in a mapping, issuing ERC721 ids, or counting request ids.
 11 |     |  *
 12 |     |  * Include with `using Counters for Counters.Counter;`
 13 |     |  */
 14 |     | library Counters {
 15 |     |     struct Counter {
 16 |     |         // This variable should never be directly accessed by users of the library: interactions must be restricted to
 17 |     |         // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add
 18 |     |         // this feature: see https://github.com/ethereum/solidity/issues/4637
 19 |     |         uint256 _value; // default: 0
 20 |     |     }
 21 |     | 
 22 |     |     function current(Counter storage counter) internal view returns (uint256) {
 23 |     |         return counter._value;
 24 |     |     }
 25 |     | 
 26 |     |     function increment(Counter storage counter) internal {
 27 |     |         unchecked {
 28 |     |             counter._value += 1;
 29 |     |         }
 30 |     |     }
 31 |     | 
 32 |     |     function decrement(Counter storage counter) internal {
 33 |     |         uint256 value = counter._value;
 34 |     |         require(value > 0, "Counter: decrement overflow");
 35 |     |         unchecked {
 36 |     |             counter._value = value - 1;
 37 |     |         }
 38 |     |     }
 39 |     | 
 40 |     |     function reset(Counter storage counter) internal {
 41 |     |         counter._value = 0;
 42 |     |     }
 43 |     | }
 44 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/utils/Strings.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "./math/Math.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev String operations.
 10 |     |  */
 11 |     | library Strings {
 12 |     |     bytes16 private constant _SYMBOLS = "0123456789abcdef";
 13 |     |     uint8 private constant _ADDRESS_LENGTH = 20;
 14 |     | 
 15 |     |     /**
 16 |     |      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
 17 |     |      */
 18 |     |     function toString(uint256 value) internal pure returns (string memory) {
 19 |     |         unchecked {
 20 |     |             uint256 length = Math.log10(value) + 1;
 21 |     |             string memory buffer = new string(length);
 22 |     |             uint256 ptr;
 23 |     |             /// @solidity memory-safe-assembly
 24 |     |             assembly {
 25 |     |                 ptr := add(buffer, add(32, length))
 26 |     |             }
 27 |     |             while (true) {
 28 |     |                 ptr--;
 29 |     |                 /// @solidity memory-safe-assembly
 30 |     |                 assembly {
 31 |     |                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
 32 |     |                 }
 33 |     |                 value /= 10;
 34 |     |                 if (value == 0) break;
 35 |     |             }
 36 |     |             return buffer;
 37 |     |         }
 38 |     |     }
 39 |     | 
 40 |     |     /**
 41 |     |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
 42 |     |      */
 43 |     |     function toHexString(uint256 value) internal pure returns (string memory) {
 44 |     |         unchecked {
 45 |     |             return toHexString(value, Math.log256(value) + 1);
 46 |     |         }
 47 |     |     }
 48 |     | 
 49 |     |     /**
 50 |     |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
 51 |     |      */
 52 |     |     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
 53 |     |         bytes memory buffer = new bytes(2 * length + 2);
 54 |     |         buffer[0] = "0";
 55 |     |         buffer[1] = "x";
 56 |     |         for (uint256 i = 2 * length + 1; i > 1; --i) {
 57 |     |             buffer[i] = _SYMBOLS[value & 0xf];
 58 |     |             value >>= 4;
 59 |     |         }
 60 |     |         require(value == 0, "Strings: hex length insufficient");
 61 |     |         return string(buffer);
 62 |     |     }
 63 |     | 
 64 |     |     /**
 65 |     |      * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.
 66 |     |      */
 67 |     |     function toHexString(address addr) internal pure returns (string memory) {
 68 |     |         return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);
 69 |     |     }
 70 |     | }
 71 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "../Strings.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.
  10 |     |  *
  11 |     |  * These functions can be used to verify that a message was signed by the holder
  12 |     |  * of the private keys of a given address.
  13 |     |  */
  14 |     | library ECDSA {
  15 |     |     enum RecoverError {
  16 |     |         NoError,
  17 |     |         InvalidSignature,
  18 |     |         InvalidSignatureLength,
  19 |     |         InvalidSignatureS,
  20 |     |         InvalidSignatureV // Deprecated in v4.8
  21 |     |     }
  22 |     | 
  23 |     |     function _throwError(RecoverError error) private pure {
  24 |     |         if (error == RecoverError.NoError) {
  25 |     |             return; // no error: do nothing
  26 |     |         } else if (error == RecoverError.InvalidSignature) {
  27 |     |             revert("ECDSA: invalid signature");
  28 |     |         } else if (error == RecoverError.InvalidSignatureLength) {
  29 |     |             revert("ECDSA: invalid signature length");
  30 |     |         } else if (error == RecoverError.InvalidSignatureS) {
  31 |     |             revert("ECDSA: invalid signature 's' value");
  32 |     |         }
  33 |     |     }
  34 |     | 
  35 |     |     /**
  36 |     |      * @dev Returns the address that signed a hashed message (`hash`) with
  37 |     |      * `signature` or error string. This address can then be used for verification purposes.
  38 |     |      *
  39 |     |      * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:
  40 |     |      * this function rejects them by requiring the `s` value to be in the lower
  41 |     |      * half order, and the `v` value to be either 27 or 28.
  42 |     |      *
  43 |     |      * IMPORTANT: `hash` _must_ be the result of a hash operation for the
  44 |     |      * verification to be secure: it is possible to craft signatures that
  45 |     |      * recover to arbitrary addresses for non-hashed data. A safe way to ensure
  46 |     |      * this is by receiving a hash of the original message (which may otherwise
  47 |     |      * be too long), and then calling {toEthSignedMessageHash} on it.
  48 |     |      *
  49 |     |      * Documentation for signature generation:
  50 |     |      * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]
  51 |     |      * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]
  52 |     |      *
  53 |     |      * _Available since v4.3._
  54 |     |      */
  55 |     |     function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {
  56 |     |         if (signature.length == 65) {
  57 |     |             bytes32 r;
  58 |     |             bytes32 s;
  59 |     |             uint8 v;
  60 |     |             // ecrecover takes the signature parameters, and the only way to get them
  61 |     |             // currently is to use assembly.
  62 |     |             /// @solidity memory-safe-assembly
  63 |     |             assembly {
  64 |     |                 r := mload(add(signature, 0x20))
  65 |     |                 s := mload(add(signature, 0x40))
  66 |     |                 v := byte(0, mload(add(signature, 0x60)))
  67 |     |             }
  68 |     |             return tryRecover(hash, v, r, s);
  69 |     |         } else {
  70 |     |             return (address(0), RecoverError.InvalidSignatureLength);
  71 |     |         }
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @dev Returns the address that signed a hashed message (`hash`) with
  76 |     |      * `signature`. This address can then be used for verification purposes.
  77 |     |      *
  78 |     |      * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:
  79 |     |      * this function rejects them by requiring the `s` value to be in the lower
  80 |     |      * half order, and the `v` value to be either 27 or 28.
  81 |     |      *
  82 |     |      * IMPORTANT: `hash` _must_ be the result of a hash operation for the
  83 |     |      * verification to be secure: it is possible to craft signatures that
  84 |     |      * recover to arbitrary addresses for non-hashed data. A safe way to ensure
  85 |     |      * this is by receiving a hash of the original message (which may otherwise
  86 |     |      * be too long), and then calling {toEthSignedMessageHash} on it.
  87 |     |      */
  88 |     |     function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
  89 |     |         (address recovered, RecoverError error) = tryRecover(hash, signature);
  90 |     |         _throwError(error);
  91 |     |         return recovered;
  92 |     |     }
  93 |     | 
  94 |     |     /**
  95 |     |      * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.
  96 |     |      *
  97 |     |      * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]
  98 |     |      *
  99 |     |      * _Available since v4.3._
 100 |     |      */
 101 |     |     function tryRecover(
 102 |     |         bytes32 hash,
 103 |     |         bytes32 r,
 104 |     |         bytes32 vs
 105 |     |     ) internal pure returns (address, RecoverError) {
 106 |     |         bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
 107 |     |         uint8 v = uint8((uint256(vs) >> 255) + 27);
 108 |     |         return tryRecover(hash, v, r, s);
 109 |     |     }
 110 |     | 
 111 |     |     /**
 112 |     |      * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.
 113 |     |      *
 114 |     |      * _Available since v4.2._
 115 |     |      */
 116 |     |     function recover(
 117 |     |         bytes32 hash,
 118 |     |         bytes32 r,
 119 |     |         bytes32 vs
 120 |     |     ) internal pure returns (address) {
 121 |     |         (address recovered, RecoverError error) = tryRecover(hash, r, vs);
 122 |     |         _throwError(error);
 123 |     |         return recovered;
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev Overload of {ECDSA-tryRecover} that receives the `v`,
 128 |     |      * `r` and `s` signature fields separately.
 129 |     |      *
 130 |     |      * _Available since v4.3._
 131 |     |      */
 132 |     |     function tryRecover(
 133 |     |         bytes32 hash,
 134 |     |         uint8 v,
 135 |     |         bytes32 r,
 136 |     |         bytes32 s
 137 |     |     ) internal pure returns (address, RecoverError) {
 138 |     |         // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature
 139 |     |         // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines
 140 |     |         // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most
 141 |     |         // signatures from current libraries generate a unique signature with an s-value in the lower half order.
 142 |     |         //
 143 |     |         // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value
 144 |     |         // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or
 145 |     |         // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept
 146 |     |         // these malleable signatures as well.
 147 |     |         if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {
 148 |     |             return (address(0), RecoverError.InvalidSignatureS);
 149 |     |         }
 150 |     | 
 151 |     |         // If the signature is valid (and not malleable), return the signer address
 152 |     |         address signer = ecrecover(hash, v, r, s);
 153 |     |         if (signer == address(0)) {
 154 |     |             return (address(0), RecoverError.InvalidSignature);
 155 |     |         }
 156 |     | 
 157 |     |         return (signer, RecoverError.NoError);
 158 |     |     }
 159 |     | 
 160 |     |     /**
 161 |     |      * @dev Overload of {ECDSA-recover} that receives the `v`,
 162 |     |      * `r` and `s` signature fields separately.
 163 |     |      */
 164 |     |     function recover(
 165 |     |         bytes32 hash,
 166 |     |         uint8 v,
 167 |     |         bytes32 r,
 168 |     |         bytes32 s
 169 |     |     ) internal pure returns (address) {
 170 |     |         (address recovered, RecoverError error) = tryRecover(hash, v, r, s);
 171 |     |         _throwError(error);
 172 |     |         return recovered;
 173 |     |     }
 174 |     | 
 175 |     |     /**
 176 |     |      * @dev Returns an Ethereum Signed Message, created from a `hash`. This
 177 |     |      * produces hash corresponding to the one signed with the
 178 |     |      * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]
 179 |     |      * JSON-RPC method as part of EIP-191.
 180 |     |      *
 181 |     |      * See {recover}.
 182 |     |      */
 183 |     |     function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
 184 |     |         // 32 is the length in bytes of hash,
 185 |     |         // enforced by the type signature above
 186 |     |         return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
 187 |     |     }
 188 |     | 
 189 |     |     /**
 190 |     |      * @dev Returns an Ethereum Signed Message, created from `s`. This
 191 |     |      * produces hash corresponding to the one signed with the
 192 |     |      * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]
 193 |     |      * JSON-RPC method as part of EIP-191.
 194 |     |      *
 195 |     |      * See {recover}.
 196 |     |      */
 197 |     |     function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {
 198 |     |         return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n", Strings.toString(s.length), s));
 199 |     |     }
 200 |     | 
 201 |     |     /**
 202 |     |      * @dev Returns an Ethereum Signed Typed Data, created from a
 203 |     |      * `domainSeparator` and a `structHash`. This produces hash corresponding
 204 |     |      * to the one signed with the
 205 |     |      * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]
 206 |     |      * JSON-RPC method as part of EIP-712.
 207 |     |      *
 208 |     |      * See {recover}.
 209 |     |      */
 210 |     |     function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {
 211 |     |         return keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));
 212 |     |     }
 213 |     | }
 214 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/utils/cryptography/EIP712.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/EIP712.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "./ECDSA.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.
  10 |     |  *
  11 |     |  * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,
  12 |     |  * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding
  13 |     |  * they need in their contracts using a combination of `abi.encode` and `keccak256`.
  14 |     |  *
  15 |     |  * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding
  16 |     |  * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA
  17 |     |  * ({_hashTypedDataV4}).
  18 |     |  *
  19 |     |  * The implementation of the domain separator was designed to be as efficient as possible while still properly updating
  20 |     |  * the chain id to protect against replay attacks on an eventual fork of the chain.
  21 |     |  *
  22 |     |  * NOTE: This contract implements the version of the encoding known as "v4", as implemented by the JSON RPC method
  23 |     |  * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].
  24 |     |  *
  25 |     |  * _Available since v3.4._
  26 |     |  */
  27 |     | abstract contract EIP712 {
  28 |     |     /* solhint-disable var-name-mixedcase */
  29 |     |     // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to
  30 |     |     // invalidate the cached domain separator if the chain id changes.
  31 |     |     bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;
  32 |     |     uint256 private immutable _CACHED_CHAIN_ID;
  33 |     |     address private immutable _CACHED_THIS;
  34 |     | 
  35 |     |     bytes32 private immutable _HASHED_NAME;
  36 |     |     bytes32 private immutable _HASHED_VERSION;
  37 |     |     bytes32 private immutable _TYPE_HASH;
  38 |     | 
  39 |     |     /* solhint-enable var-name-mixedcase */
  40 |     | 
  41 |     |     /**
  42 |     |      * @dev Initializes the domain separator and parameter caches.
  43 |     |      *
  44 |     |      * The meaning of `name` and `version` is specified in
  45 |     |      * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:
  46 |     |      *
  47 |     |      * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.
  48 |     |      * - `version`: the current major version of the signing domain.
  49 |     |      *
  50 |     |      * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart
  51 |     |      * contract upgrade].
  52 |     |      */
  53 |     |     constructor(string memory name, string memory version) {
  54 |     |         bytes32 hashedName = keccak256(bytes(name));
  55 |     |         bytes32 hashedVersion = keccak256(bytes(version));
  56 |     |         bytes32 typeHash = keccak256(
  57 |     |             "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
  58 |     |         );
  59 |     |         _HASHED_NAME = hashedName;
  60 |     |         _HASHED_VERSION = hashedVersion;
  61 |     |         _CACHED_CHAIN_ID = block.chainid;
  62 |     |         _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);
  63 |     |         _CACHED_THIS = address(this);
  64 |     |         _TYPE_HASH = typeHash;
  65 |     |     }
  66 |     | 
  67 |     |     /**
  68 |     |      * @dev Returns the domain separator for the current chain.
  69 |     |      */
  70 |     |     function _domainSeparatorV4() internal view returns (bytes32) {
  71 |     |         if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {
  72 |     |             return _CACHED_DOMAIN_SEPARATOR;
  73 |     |         } else {
  74 |     |             return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);
  75 |     |         }
  76 |     |     }
  77 |     | 
  78 |     |     function _buildDomainSeparator(
  79 |     |         bytes32 typeHash,
  80 |     |         bytes32 nameHash,
  81 |     |         bytes32 versionHash
  82 |     |     ) private view returns (bytes32) {
  83 |     |         return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));
  84 |     |     }
  85 |     | 
  86 |     |     /**
  87 |     |      * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this
  88 |     |      * function returns the hash of the fully encoded EIP712 message for this domain.
  89 |     |      *
  90 |     |      * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:
  91 |     |      *
  92 |     |      * ```solidity
  93 |     |      * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(
  94 |     |      *     keccak256("Mail(address to,string contents)"),
  95 |     |      *     mailTo,
  96 |     |      *     keccak256(bytes(mailContents))
  97 |     |      * )));
  98 |     |      * address signer = ECDSA.recover(digest, signature);
  99 |     |      * ```
 100 |     |      */
 101 |     |     function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {
 102 |     |         return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);
 103 |     |     }
 104 |     | }
 105 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/SignatureChecker.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "./ECDSA.sol";
  7 |     | import "../Address.sol";
  8 |     | import "../../interfaces/IERC1271.sol";
  9 |     | 
 10 |     | /**
 11 |     |  * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA
 12 |     |  * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like
 13 |     |  * Argent and Gnosis Safe.
 14 |     |  *
 15 |     |  * _Available since v4.1._
 16 |     |  */
 17 |     | library SignatureChecker {
 18 |     |     /**
 19 |     |      * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the
 20 |     |      * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.
 21 |     |      *
 22 |     |      * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus
 23 |     |      * change through time. It could return true at block N and false at block N+1 (or the opposite).
 24 |     |      */
 25 |     |     function isValidSignatureNow(
 26 |     |         address signer,
 27 |     |         bytes32 hash,
 28 |     |         bytes memory signature
 29 |     |     ) internal view returns (bool) {
 30 |     |         (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);
 31 |     |         if (error == ECDSA.RecoverError.NoError && recovered == signer) {
 32 |     |             return true;
 33 |     |         }
 34 |     | 
 35 |     |         (bool success, bytes memory result) = signer.staticcall(
 36 |     |             abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)
 37 |     |         );
 38 |     |         return (success &&
 39 |     |             result.length == 32 &&
 40 |     |             abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));
 41 |     |     }
 42 |     | }
 43 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "./IERC165.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Implementation of the {IERC165} interface.
 10 |     |  *
 11 |     |  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 12 |     |  * for the additional interface id that will be supported. For example:
 13 |     |  *
 14 |     |  * ```solidity
 15 |     |  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 16 |     |  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 17 |     |  * }
 18 |     |  * ```
 19 |     |  *
 20 |     |  * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
 21 |     |  */
 22 |     | abstract contract ERC165 is IERC165 {
 23 |     |     /**
 24 |     |      * @dev See {IERC165-supportsInterface}.
 25 |     |      */
 26 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 27 |     |         return interfaceId == type(IERC165).interfaceId;
 28 |     |     }
 29 |     | }
 30 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC165 standard, as defined in the
  8 |     |  * https://eips.ethereum.org/EIPS/eip-165[EIP].
  9 |     |  *
 10 |     |  * Implementers can declare support of contract interfaces, which can then be
 11 |     |  * queried by others ({ERC165Checker}).
 12 |     |  *
 13 |     |  * For an implementation, see {ERC165}.
 14 |     |  */
 15 |     | interface IERC165 {
 16 |     |     /**
 17 |     |      * @dev Returns true if this contract implements the interface defined by
 18 |     |      * `interfaceId`. See the corresponding
 19 |     |      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
 20 |     |      * to learn more about how these ids are created.
 21 |     |      *
 22 |     |      * This function call must use less than 30 000 gas.
 23 |     |      */
 24 |     |     function supportsInterface(bytes4 interfaceId) external view returns (bool);
 25 |     | }
 26 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/utils/math/Math.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Standard math utilities missing in the Solidity language.
   8 |     |  */
   9 |     | library Math {
  10 |     |     enum Rounding {
  11 |     |         Down, // Toward negative infinity
  12 |     |         Up, // Toward infinity
  13 |     |         Zero // Toward zero
  14 |     |     }
  15 |     | 
  16 |     |     /**
  17 |     |      * @dev Returns the largest of two numbers.
  18 |     |      */
  19 |     |     function max(uint256 a, uint256 b) internal pure returns (uint256) {
  20 |     |         return a > b ? a : b;
  21 |     |     }
  22 |     | 
  23 |     |     /**
  24 |     |      * @dev Returns the smallest of two numbers.
  25 |     |      */
  26 |     |     function min(uint256 a, uint256 b) internal pure returns (uint256) {
  27 |     |         return a < b ? a : b;
  28 |     |     }
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Returns the average of two numbers. The result is rounded towards
  32 |     |      * zero.
  33 |     |      */
  34 |     |     function average(uint256 a, uint256 b) internal pure returns (uint256) {
  35 |     |         // (a + b) / 2 can overflow.
  36 |     |         return (a & b) + (a ^ b) / 2;
  37 |     |     }
  38 |     | 
  39 |     |     /**
  40 |     |      * @dev Returns the ceiling of the division of two numbers.
  41 |     |      *
  42 |     |      * This differs from standard division with `/` in that it rounds up instead
  43 |     |      * of rounding down.
  44 |     |      */
  45 |     |     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
  46 |     |         // (a + b - 1) / b can overflow on addition, so we distribute.
  47 |     |         return a == 0 ? 0 : (a - 1) / b + 1;
  48 |     |     }
  49 |     | 
  50 |     |     /**
  51 |     |      * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
  52 |     |      * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)
  53 |     |      * with further edits by Uniswap Labs also under MIT license.
  54 |     |      */
  55 |     |     function mulDiv(
  56 |     |         uint256 x,
  57 |     |         uint256 y,
  58 |     |         uint256 denominator
  59 |     |     ) internal pure returns (uint256 result) {
  60 |     |         unchecked {
  61 |     |             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
  62 |     |             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
  63 |     |             // variables such that product = prod1 * 2^256 + prod0.
  64 |     |             uint256 prod0; // Least significant 256 bits of the product
  65 |     |             uint256 prod1; // Most significant 256 bits of the product
  66 |     |             assembly {
  67 |     |                 let mm := mulmod(x, y, not(0))
  68 |     |                 prod0 := mul(x, y)
  69 |     |                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
  70 |     |             }
  71 |     | 
  72 |     |             // Handle non-overflow cases, 256 by 256 division.
  73 |     |             if (prod1 == 0) {
  74 |     |                 return prod0 / denominator;
  75 |     |             }
  76 |     | 
  77 |     |             // Make sure the result is less than 2^256. Also prevents denominator == 0.
  78 |     |             require(denominator > prod1);
  79 |     | 
  80 |     |             ///////////////////////////////////////////////
  81 |     |             // 512 by 256 division.
  82 |     |             ///////////////////////////////////////////////
  83 |     | 
  84 |     |             // Make division exact by subtracting the remainder from [prod1 prod0].
  85 |     |             uint256 remainder;
  86 |     |             assembly {
  87 |     |                 // Compute remainder using mulmod.
  88 |     |                 remainder := mulmod(x, y, denominator)
  89 |     | 
  90 |     |                 // Subtract 256 bit number from 512 bit number.
  91 |     |                 prod1 := sub(prod1, gt(remainder, prod0))
  92 |     |                 prod0 := sub(prod0, remainder)
  93 |     |             }
  94 |     | 
  95 |     |             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
  96 |     |             // See https://cs.stackexchange.com/q/138556/92363.
  97 |     | 
  98 |     |             // Does not overflow because the denominator cannot be zero at this stage in the function.
  99 |     |             uint256 twos = denominator & (~denominator + 1);
 100 |     |             assembly {
 101 |     |                 // Divide denominator by twos.
 102 |     |                 denominator := div(denominator, twos)
 103 |     | 
 104 |     |                 // Divide [prod1 prod0] by twos.
 105 |     |                 prod0 := div(prod0, twos)
 106 |     | 
 107 |     |                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
 108 |     |                 twos := add(div(sub(0, twos), twos), 1)
 109 |     |             }
 110 |     | 
 111 |     |             // Shift in bits from prod1 into prod0.
 112 |     |             prod0 |= prod1 * twos;
 113 |     | 
 114 |     |             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
 115 |     |             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
 116 |     |             // four bits. That is, denominator * inv = 1 mod 2^4.
 117 |     |             uint256 inverse = (3 * denominator) ^ 2;
 118 |     | 
 119 |     |             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
 120 |     |             // in modular arithmetic, doubling the correct bits in each step.
 121 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^8
 122 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^16
 123 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^32
 124 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^64
 125 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^128
 126 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^256
 127 |     | 
 128 |     |             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
 129 |     |             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
 130 |     |             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
 131 |     |             // is no longer required.
 132 |     |             result = prod0 * inverse;
 133 |     |             return result;
 134 |     |         }
 135 |     |     }
 136 |     | 
 137 |     |     /**
 138 |     |      * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.
 139 |     |      */
 140 |     |     function mulDiv(
 141 |     |         uint256 x,
 142 |     |         uint256 y,
 143 |     |         uint256 denominator,
 144 |     |         Rounding rounding
 145 |     |     ) internal pure returns (uint256) {
 146 |     |         uint256 result = mulDiv(x, y, denominator);
 147 |     |         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
 148 |     |             result += 1;
 149 |     |         }
 150 |     |         return result;
 151 |     |     }
 152 |     | 
 153 |     |     /**
 154 |     |      * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.
 155 |     |      *
 156 |     |      * Inspired by Henry S. Warren, Jr.'s "Hacker's Delight" (Chapter 11).
 157 |     |      */
 158 |     |     function sqrt(uint256 a) internal pure returns (uint256) {
 159 |     |         if (a == 0) {
 160 |     |             return 0;
 161 |     |         }
 162 |     | 
 163 |     |         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
 164 |     |         //
 165 |     |         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
 166 |     |         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
 167 |     |         //
 168 |     |         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
 169 |     |         //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
 170 |     |         //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
 171 |     |         //
 172 |     |         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
 173 |     |         uint256 result = 1 << (log2(a) >> 1);
 174 |     | 
 175 |     |         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
 176 |     |         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
 177 |     |         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
 178 |     |         // into the expected uint128 result.
 179 |     |         unchecked {
 180 |     |             result = (result + a / result) >> 1;
 181 |     |             result = (result + a / result) >> 1;
 182 |     |             result = (result + a / result) >> 1;
 183 |     |             result = (result + a / result) >> 1;
 184 |     |             result = (result + a / result) >> 1;
 185 |     |             result = (result + a / result) >> 1;
 186 |     |             result = (result + a / result) >> 1;
 187 |     |             return min(result, a / result);
 188 |     |         }
 189 |     |     }
 190 |     | 
 191 |     |     /**
 192 |     |      * @notice Calculates sqrt(a), following the selected rounding direction.
 193 |     |      */
 194 |     |     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
 195 |     |         unchecked {
 196 |     |             uint256 result = sqrt(a);
 197 |     |             return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
 198 |     |         }
 199 |     |     }
 200 |     | 
 201 |     |     /**
 202 |     |      * @dev Return the log in base 2, rounded down, of a positive value.
 203 |     |      * Returns 0 if given 0.
 204 |     |      */
 205 |     |     function log2(uint256 value) internal pure returns (uint256) {
 206 |     |         uint256 result = 0;
 207 |     |         unchecked {
 208 |     |             if (value >> 128 > 0) {
 209 |     |                 value >>= 128;
 210 |     |                 result += 128;
 211 |     |             }
 212 |     |             if (value >> 64 > 0) {
 213 |     |                 value >>= 64;
 214 |     |                 result += 64;
 215 |     |             }
 216 |     |             if (value >> 32 > 0) {
 217 |     |                 value >>= 32;
 218 |     |                 result += 32;
 219 |     |             }
 220 |     |             if (value >> 16 > 0) {
 221 |     |                 value >>= 16;
 222 |     |                 result += 16;
 223 |     |             }
 224 |     |             if (value >> 8 > 0) {
 225 |     |                 value >>= 8;
 226 |     |                 result += 8;
 227 |     |             }
 228 |     |             if (value >> 4 > 0) {
 229 |     |                 value >>= 4;
 230 |     |                 result += 4;
 231 |     |             }
 232 |     |             if (value >> 2 > 0) {
 233 |     |                 value >>= 2;
 234 |     |                 result += 2;
 235 |     |             }
 236 |     |             if (value >> 1 > 0) {
 237 |     |                 result += 1;
 238 |     |             }
 239 |     |         }
 240 |     |         return result;
 241 |     |     }
 242 |     | 
 243 |     |     /**
 244 |     |      * @dev Return the log in base 2, following the selected rounding direction, of a positive value.
 245 |     |      * Returns 0 if given 0.
 246 |     |      */
 247 |     |     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
 248 |     |         unchecked {
 249 |     |             uint256 result = log2(value);
 250 |     |             return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
 251 |     |         }
 252 |     |     }
 253 |     | 
 254 |     |     /**
 255 |     |      * @dev Return the log in base 10, rounded down, of a positive value.
 256 |     |      * Returns 0 if given 0.
 257 |     |      */
 258 |     |     function log10(uint256 value) internal pure returns (uint256) {
 259 |     |         uint256 result = 0;
 260 |     |         unchecked {
 261 |     |             if (value >= 10**64) {
 262 |     |                 value /= 10**64;
 263 |     |                 result += 64;
 264 |     |             }
 265 |     |             if (value >= 10**32) {
 266 |     |                 value /= 10**32;
 267 |     |                 result += 32;
 268 |     |             }
 269 |     |             if (value >= 10**16) {
 270 |     |                 value /= 10**16;
 271 |     |                 result += 16;
 272 |     |             }
 273 |     |             if (value >= 10**8) {
 274 |     |                 value /= 10**8;
 275 |     |                 result += 8;
 276 |     |             }
 277 |     |             if (value >= 10**4) {
 278 |     |                 value /= 10**4;
 279 |     |                 result += 4;
 280 |     |             }
 281 |     |             if (value >= 10**2) {
 282 |     |                 value /= 10**2;
 283 |     |                 result += 2;
 284 |     |             }
 285 |     |             if (value >= 10**1) {
 286 |     |                 result += 1;
 287 |     |             }
 288 |     |         }
 289 |     |         return result;
 290 |     |     }
 291 |     | 
 292 |     |     /**
 293 |     |      * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
 294 |     |      * Returns 0 if given 0.
 295 |     |      */
 296 |     |     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
 297 |     |         unchecked {
 298 |     |             uint256 result = log10(value);
 299 |     |             return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);
 300 |     |         }
 301 |     |     }
 302 |     | 
 303 |     |     /**
 304 |     |      * @dev Return the log in base 256, rounded down, of a positive value.
 305 |     |      * Returns 0 if given 0.
 306 |     |      *
 307 |     |      * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.
 308 |     |      */
 309 |     |     function log256(uint256 value) internal pure returns (uint256) {
 310 |     |         uint256 result = 0;
 311 |     |         unchecked {
 312 |     |             if (value >> 128 > 0) {
 313 |     |                 value >>= 128;
 314 |     |                 result += 16;
 315 |     |             }
 316 |     |             if (value >> 64 > 0) {
 317 |     |                 value >>= 64;
 318 |     |                 result += 8;
 319 |     |             }
 320 |     |             if (value >> 32 > 0) {
 321 |     |                 value >>= 32;
 322 |     |                 result += 4;
 323 |     |             }
 324 |     |             if (value >> 16 > 0) {
 325 |     |                 value >>= 16;
 326 |     |                 result += 2;
 327 |     |             }
 328 |     |             if (value >> 8 > 0) {
 329 |     |                 result += 1;
 330 |     |             }
 331 |     |         }
 332 |     |         return result;
 333 |     |     }
 334 |     | 
 335 |     |     /**
 336 |     |      * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
 337 |     |      * Returns 0 if given 0.
 338 |     |      */
 339 |     |     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
 340 |     |         unchecked {
 341 |     |             uint256 result = log256(value);
 342 |     |             return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);
 343 |     |         }
 344 |     |     }
 345 |     | }
 346 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/utils/structs/BitMaps.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/BitMaps.sol)
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | /**
  6 |     |  * @dev Library for managing uint256 to bool mapping in a compact and efficient way, providing the keys are sequential.
  7 |     |  * Largely inspired by Uniswap's https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol[merkle-distributor].
  8 |     |  */
  9 |     | library BitMaps {
 10 |     |     struct BitMap {
 11 |     |         mapping(uint256 => uint256) _data;
 12 |     |     }
 13 |     | 
 14 |     |     /**
 15 |     |      * @dev Returns whether the bit at `index` is set.
 16 |     |      */
 17 |     |     function get(BitMap storage bitmap, uint256 index) internal view returns (bool) {
 18 |     |         uint256 bucket = index >> 8;
 19 |     |         uint256 mask = 1 << (index & 0xff);
 20 |     |         return bitmap._data[bucket] & mask != 0;
 21 |     |     }
 22 |     | 
 23 |     |     /**
 24 |     |      * @dev Sets the bit at `index` to the boolean `value`.
 25 |     |      */
 26 |     |     function setTo(
 27 |     |         BitMap storage bitmap,
 28 |     |         uint256 index,
 29 |     |         bool value
 30 |     |     ) internal {
 31 |     |         if (value) {
 32 |     |             set(bitmap, index);
 33 |     |         } else {
 34 |     |             unset(bitmap, index);
 35 |     |         }
 36 |     |     }
 37 |     | 
 38 |     |     /**
 39 |     |      * @dev Sets the bit at `index`.
 40 |     |      */
 41 |     |     function set(BitMap storage bitmap, uint256 index) internal {
 42 |     |         uint256 bucket = index >> 8;
 43 |     |         uint256 mask = 1 << (index & 0xff);
 44 |     |         bitmap._data[bucket] |= mask;
 45 |     |     }
 46 |     | 
 47 |     |     /**
 48 |     |      * @dev Unsets the bit at `index`.
 49 |     |      */
 50 |     |     function unset(BitMap storage bitmap, uint256 index) internal {
 51 |     |         uint256 bucket = index >> 8;
 52 |     |         uint256 mask = 1 << (index & 0xff);
 53 |     |         bitmap._data[bucket] &= ~mask;
 54 |     |     }
 55 |     | }
 56 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@uniswap/lib/contracts/libraries/TransferHelper.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | 
  3 |     | pragma solidity >=0.6.0;
  4 |     | 
  5 |     | // helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false
  6 |     | library TransferHelper {
  7 |     |     function safeApprove(
  8 |     |         address token,
  9 |     |         address to,
 10 |     |         uint256 value
 11 |     |     ) internal {
 12 |     |         // bytes4(keccak256(bytes('approve(address,uint256)')));
 13 |     |         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));
 14 |     |         require(
 15 |     |             success && (data.length == 0 || abi.decode(data, (bool))),
 16 |     |             'TransferHelper::safeApprove: approve failed'
 17 |     |         );
 18 |     |     }
 19 |     | 
 20 |     |     function safeTransfer(
 21 |     |         address token,
 22 |     |         address to,
 23 |     |         uint256 value
 24 |     |     ) internal {
 25 |     |         // bytes4(keccak256(bytes('transfer(address,uint256)')));
 26 |     |         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
 27 |     |         require(
 28 |     |             success && (data.length == 0 || abi.decode(data, (bool))),
 29 |     |             'TransferHelper::safeTransfer: transfer failed'
 30 |     |         );
 31 |     |     }
 32 |     | 
 33 |     |     function safeTransferFrom(
 34 |     |         address token,
 35 |     |         address from,
 36 |     |         address to,
 37 |     |         uint256 value
 38 |     |     ) internal {
 39 |     |         // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));
 40 |     |         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));
 41 |     |         require(
 42 |     |             success && (data.length == 0 || abi.decode(data, (bool))),
 43 |     |             'TransferHelper::transferFrom: transferFrom failed'
 44 |     |         );
 45 |     |     }
 46 |     | 
 47 |     |     function safeTransferETH(address to, uint256 value) internal {
 48 |     |         (bool success, ) = to.call{value: value}(new bytes(0));
 49 |     |         require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');
 50 |     |     }
 51 |     | }
 52 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@uniswap/v2-core/contracts/interfaces/IUniswapV2Callee.sol
 1 |     | pragma solidity >=0.5.0;
 2 |     | 
 3 |     | interface IUniswapV2Callee {
 4 |     |     function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;
 5 |     | }
 6 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@uniswap/v2-core/contracts/interfaces/IUniswapV2ERC20.sol
  1 |     | pragma solidity >=0.5.0;
  2 |     | 
  3 |     | interface IUniswapV2ERC20 {
  4 |     |     event Approval(address indexed owner, address indexed spender, uint value);
  5 |     |     event Transfer(address indexed from, address indexed to, uint value);
  6 |     | 
  7 |     |     function name() external pure returns (string memory);
  8 |     |     function symbol() external pure returns (string memory);
  9 |     |     function decimals() external pure returns (uint8);
 10 |     |     function totalSupply() external view returns (uint);
 11 |     |     function balanceOf(address owner) external view returns (uint);
 12 |     |     function allowance(address owner, address spender) external view returns (uint);
 13 |     | 
 14 |     |     function approve(address spender, uint value) external returns (bool);
 15 |     |     function transfer(address to, uint value) external returns (bool);
 16 |     |     function transferFrom(address from, address to, uint value) external returns (bool);
 17 |     | 
 18 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32);
 19 |     |     function PERMIT_TYPEHASH() external pure returns (bytes32);
 20 |     |     function nonces(address owner) external view returns (uint);
 21 |     | 
 22 |     |     function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
 23 |     | }
 24 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol
  1 |     | pragma solidity >=0.5.0;
  2 |     | 
  3 |     | interface IUniswapV2Factory {
  4 |     |     event PairCreated(address indexed token0, address indexed token1, address pair, uint);
  5 |     | 
  6 |     |     function feeTo() external view returns (address);
  7 |     |     function feeToSetter() external view returns (address);
  8 |     | 
  9 |     |     function getPair(address tokenA, address tokenB) external view returns (address pair);
 10 |     |     function allPairs(uint) external view returns (address pair);
 11 |     |     function allPairsLength() external view returns (uint);
 12 |     | 
 13 |     |     function createPair(address tokenA, address tokenB) external returns (address pair);
 14 |     | 
 15 |     |     function setFeeTo(address) external;
 16 |     |     function setFeeToSetter(address) external;
 17 |     | }
 18 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title The interface for the Uniswap V3 Factory
  5 |     | /// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees
  6 |     | interface IUniswapV3Factory {
  7 |     |     /// @notice Emitted when the owner of the factory is changed
  8 |     |     /// @param oldOwner The owner before the owner was changed
  9 |     |     /// @param newOwner The owner after the owner was changed
 10 |     |     event OwnerChanged(address indexed oldOwner, address indexed newOwner);
 11 |     | 
 12 |     |     /// @notice Emitted when a pool is created
 13 |     |     /// @param token0 The first token of the pool by address sort order
 14 |     |     /// @param token1 The second token of the pool by address sort order
 15 |     |     /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
 16 |     |     /// @param tickSpacing The minimum number of ticks between initialized ticks
 17 |     |     /// @param pool The address of the created pool
 18 |     |     event PoolCreated(
 19 |     |         address indexed token0,
 20 |     |         address indexed token1,
 21 |     |         uint24 indexed fee,
 22 |     |         int24 tickSpacing,
 23 |     |         address pool
 24 |     |     );
 25 |     | 
 26 |     |     /// @notice Emitted when a new fee amount is enabled for pool creation via the factory
 27 |     |     /// @param fee The enabled fee, denominated in hundredths of a bip
 28 |     |     /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee
 29 |     |     event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);
 30 |     | 
 31 |     |     /// @notice Returns the current owner of the factory
 32 |     |     /// @dev Can be changed by the current owner via setOwner
 33 |     |     /// @return The address of the factory owner
 34 |     |     function owner() external view returns (address);
 35 |     | 
 36 |     |     /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled
 37 |     |     /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context
 38 |     |     /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee
 39 |     |     /// @return The tick spacing
 40 |     |     function feeAmountTickSpacing(uint24 fee) external view returns (int24);
 41 |     | 
 42 |     |     /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist
 43 |     |     /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order
 44 |     |     /// @param tokenA The contract address of either token0 or token1
 45 |     |     /// @param tokenB The contract address of the other token
 46 |     |     /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
 47 |     |     /// @return pool The pool address
 48 |     |     function getPool(
 49 |     |         address tokenA,
 50 |     |         address tokenB,
 51 |     |         uint24 fee
 52 |     |     ) external view returns (address pool);
 53 |     | 
 54 |     |     /// @notice Creates a pool for the given two tokens and fee
 55 |     |     /// @param tokenA One of the two tokens in the desired pool
 56 |     |     /// @param tokenB The other of the two tokens in the desired pool
 57 |     |     /// @param fee The desired fee for the pool
 58 |     |     /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved
 59 |     |     /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments
 60 |     |     /// are invalid.
 61 |     |     /// @return pool The address of the newly created pool
 62 |     |     function createPool(
 63 |     |         address tokenA,
 64 |     |         address tokenB,
 65 |     |         uint24 fee
 66 |     |     ) external returns (address pool);
 67 |     | 
 68 |     |     /// @notice Updates the owner of the factory
 69 |     |     /// @dev Must be called by the current owner
 70 |     |     /// @param _owner The new owner of the factory
 71 |     |     function setOwner(address _owner) external;
 72 |     | 
 73 |     |     /// @notice Enables a fee amount with the given tickSpacing
 74 |     |     /// @dev Fee amounts may never be removed once enabled
 75 |     |     /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)
 76 |     |     /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount
 77 |     |     function enableFeeAmount(uint24 fee, int24 tickSpacing) external;
 78 |     | }
 79 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | import './pool/IUniswapV3PoolImmutables.sol';
  5 |     | import './pool/IUniswapV3PoolState.sol';
  6 |     | import './pool/IUniswapV3PoolDerivedState.sol';
  7 |     | import './pool/IUniswapV3PoolActions.sol';
  8 |     | import './pool/IUniswapV3PoolOwnerActions.sol';
  9 |     | import './pool/IUniswapV3PoolEvents.sol';
 10 |     | 
 11 |     | /// @title The interface for a Uniswap V3 Pool
 12 |     | /// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform
 13 |     | /// to the ERC20 specification
 14 |     | /// @dev The pool interface is broken up into many smaller pieces
 15 |     | interface IUniswapV3Pool is
 16 |     |     IUniswapV3PoolImmutables,
 17 |     |     IUniswapV3PoolState,
 18 |     |     IUniswapV3PoolDerivedState,
 19 |     |     IUniswapV3PoolActions,
 20 |     |     IUniswapV3PoolOwnerActions,
 21 |     |     IUniswapV3PoolEvents
 22 |     | {
 23 |     | 
 24 |     | }
 25 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Callback for IUniswapV3PoolActions#swap
  5 |     | /// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface
  6 |     | interface IUniswapV3SwapCallback {
  7 |     |     /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.
  8 |     |     /// @dev In the implementation you must pay the pool tokens owed for the swap.
  9 |     |     /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.
 10 |     |     /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.
 11 |     |     /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by
 12 |     |     /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.
 13 |     |     /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by
 14 |     |     /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.
 15 |     |     /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call
 16 |     |     function uniswapV3SwapCallback(
 17 |     |         int256 amount0Delta,
 18 |     |         int256 amount1Delta,
 19 |     |         bytes calldata data
 20 |     |     ) external;
 21 |     | }
 22 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.5.0;
   3 |     | 
   4 |     | /// @title Permissionless pool actions
   5 |     | /// @notice Contains pool methods that can be called by anyone
   6 |     | interface IUniswapV3PoolActions {
   7 |     |     /// @notice Sets the initial price for the pool
   8 |     |     /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value
   9 |     |     /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96
  10 |     |     function initialize(uint160 sqrtPriceX96) external;
  11 |     | 
  12 |     |     /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position
  13 |     |     /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback
  14 |     |     /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends
  15 |     |     /// on tickLower, tickUpper, the amount of liquidity, and the current price.
  16 |     |     /// @param recipient The address for which the liquidity will be created
  17 |     |     /// @param tickLower The lower tick of the position in which to add liquidity
  18 |     |     /// @param tickUpper The upper tick of the position in which to add liquidity
  19 |     |     /// @param amount The amount of liquidity to mint
  20 |     |     /// @param data Any data that should be passed through to the callback
  21 |     |     /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback
  22 |     |     /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback
  23 |     |     function mint(
  24 |     |         address recipient,
  25 |     |         int24 tickLower,
  26 |     |         int24 tickUpper,
  27 |     |         uint128 amount,
  28 |     |         bytes calldata data
  29 |     |     ) external returns (uint256 amount0, uint256 amount1);
  30 |     | 
  31 |     |     /// @notice Collects tokens owed to a position
  32 |     |     /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.
  33 |     |     /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or
  34 |     |     /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the
  35 |     |     /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.
  36 |     |     /// @param recipient The address which should receive the fees collected
  37 |     |     /// @param tickLower The lower tick of the position for which to collect fees
  38 |     |     /// @param tickUpper The upper tick of the position for which to collect fees
  39 |     |     /// @param amount0Requested How much token0 should be withdrawn from the fees owed
  40 |     |     /// @param amount1Requested How much token1 should be withdrawn from the fees owed
  41 |     |     /// @return amount0 The amount of fees collected in token0
  42 |     |     /// @return amount1 The amount of fees collected in token1
  43 |     |     function collect(
  44 |     |         address recipient,
  45 |     |         int24 tickLower,
  46 |     |         int24 tickUpper,
  47 |     |         uint128 amount0Requested,
  48 |     |         uint128 amount1Requested
  49 |     |     ) external returns (uint128 amount0, uint128 amount1);
  50 |     | 
  51 |     |     /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position
  52 |     |     /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0
  53 |     |     /// @dev Fees must be collected separately via a call to #collect
  54 |     |     /// @param tickLower The lower tick of the position for which to burn liquidity
  55 |     |     /// @param tickUpper The upper tick of the position for which to burn liquidity
  56 |     |     /// @param amount How much liquidity to burn
  57 |     |     /// @return amount0 The amount of token0 sent to the recipient
  58 |     |     /// @return amount1 The amount of token1 sent to the recipient
  59 |     |     function burn(
  60 |     |         int24 tickLower,
  61 |     |         int24 tickUpper,
  62 |     |         uint128 amount
  63 |     |     ) external returns (uint256 amount0, uint256 amount1);
  64 |     | 
  65 |     |     /// @notice Swap token0 for token1, or token1 for token0
  66 |     |     /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback
  67 |     |     /// @param recipient The address to receive the output of the swap
  68 |     |     /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0
  69 |     |     /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)
  70 |     |     /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this
  71 |     |     /// value after the swap. If one for zero, the price cannot be greater than this value after the swap
  72 |     |     /// @param data Any data to be passed through to the callback
  73 |     |     /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive
  74 |     |     /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive
  75 |     |     function swap(
  76 |     |         address recipient,
  77 |     |         bool zeroForOne,
  78 |     |         int256 amountSpecified,
  79 |     |         uint160 sqrtPriceLimitX96,
  80 |     |         bytes calldata data
  81 |     |     ) external returns (int256 amount0, int256 amount1);
  82 |     | 
  83 |     |     /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback
  84 |     |     /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback
  85 |     |     /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling
  86 |     |     /// with 0 amount{0,1} and sending the donation amount(s) from the callback
  87 |     |     /// @param recipient The address which will receive the token0 and token1 amounts
  88 |     |     /// @param amount0 The amount of token0 to send
  89 |     |     /// @param amount1 The amount of token1 to send
  90 |     |     /// @param data Any data to be passed through to the callback
  91 |     |     function flash(
  92 |     |         address recipient,
  93 |     |         uint256 amount0,
  94 |     |         uint256 amount1,
  95 |     |         bytes calldata data
  96 |     |     ) external;
  97 |     | 
  98 |     |     /// @notice Increase the maximum number of price and liquidity observations that this pool will store
  99 |     |     /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to
 100 |     |     /// the input observationCardinalityNext.
 101 |     |     /// @param observationCardinalityNext The desired minimum number of observations for the pool to store
 102 |     |     function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;
 103 |     | }
 104 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Pool state that is not stored
  5 |     | /// @notice Contains view functions to provide information about the pool that is computed rather than stored on the
  6 |     | /// blockchain. The functions here may have variable gas costs.
  7 |     | interface IUniswapV3PoolDerivedState {
  8 |     |     /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp
  9 |     |     /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing
 10 |     |     /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,
 11 |     |     /// you must call it with secondsAgos = [3600, 0].
 12 |     |     /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in
 13 |     |     /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.
 14 |     |     /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned
 15 |     |     /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp
 16 |     |     /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block
 17 |     |     /// timestamp
 18 |     |     function observe(uint32[] calldata secondsAgos)
 19 |     |         external
 20 |     |         view
 21 |     |         returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);
 22 |     | 
 23 |     |     /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range
 24 |     |     /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.
 25 |     |     /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first
 26 |     |     /// snapshot is taken and the second snapshot is taken.
 27 |     |     /// @param tickLower The lower tick of the range
 28 |     |     /// @param tickUpper The upper tick of the range
 29 |     |     /// @return tickCumulativeInside The snapshot of the tick accumulator for the range
 30 |     |     /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range
 31 |     |     /// @return secondsInside The snapshot of seconds per liquidity for the range
 32 |     |     function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)
 33 |     |         external
 34 |     |         view
 35 |     |         returns (
 36 |     |             int56 tickCumulativeInside,
 37 |     |             uint160 secondsPerLiquidityInsideX128,
 38 |     |             uint32 secondsInside
 39 |     |         );
 40 |     | }
 41 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.5.0;
   3 |     | 
   4 |     | /// @title Events emitted by a pool
   5 |     | /// @notice Contains all events emitted by the pool
   6 |     | interface IUniswapV3PoolEvents {
   7 |     |     /// @notice Emitted exactly once by a pool when #initialize is first called on the pool
   8 |     |     /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize
   9 |     |     /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96
  10 |     |     /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool
  11 |     |     event Initialize(uint160 sqrtPriceX96, int24 tick);
  12 |     | 
  13 |     |     /// @notice Emitted when liquidity is minted for a given position
  14 |     |     /// @param sender The address that minted the liquidity
  15 |     |     /// @param owner The owner of the position and recipient of any minted liquidity
  16 |     |     /// @param tickLower The lower tick of the position
  17 |     |     /// @param tickUpper The upper tick of the position
  18 |     |     /// @param amount The amount of liquidity minted to the position range
  19 |     |     /// @param amount0 How much token0 was required for the minted liquidity
  20 |     |     /// @param amount1 How much token1 was required for the minted liquidity
  21 |     |     event Mint(
  22 |     |         address sender,
  23 |     |         address indexed owner,
  24 |     |         int24 indexed tickLower,
  25 |     |         int24 indexed tickUpper,
  26 |     |         uint128 amount,
  27 |     |         uint256 amount0,
  28 |     |         uint256 amount1
  29 |     |     );
  30 |     | 
  31 |     |     /// @notice Emitted when fees are collected by the owner of a position
  32 |     |     /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees
  33 |     |     /// @param owner The owner of the position for which fees are collected
  34 |     |     /// @param tickLower The lower tick of the position
  35 |     |     /// @param tickUpper The upper tick of the position
  36 |     |     /// @param amount0 The amount of token0 fees collected
  37 |     |     /// @param amount1 The amount of token1 fees collected
  38 |     |     event Collect(
  39 |     |         address indexed owner,
  40 |     |         address recipient,
  41 |     |         int24 indexed tickLower,
  42 |     |         int24 indexed tickUpper,
  43 |     |         uint128 amount0,
  44 |     |         uint128 amount1
  45 |     |     );
  46 |     | 
  47 |     |     /// @notice Emitted when a position's liquidity is removed
  48 |     |     /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect
  49 |     |     /// @param owner The owner of the position for which liquidity is removed
  50 |     |     /// @param tickLower The lower tick of the position
  51 |     |     /// @param tickUpper The upper tick of the position
  52 |     |     /// @param amount The amount of liquidity to remove
  53 |     |     /// @param amount0 The amount of token0 withdrawn
  54 |     |     /// @param amount1 The amount of token1 withdrawn
  55 |     |     event Burn(
  56 |     |         address indexed owner,
  57 |     |         int24 indexed tickLower,
  58 |     |         int24 indexed tickUpper,
  59 |     |         uint128 amount,
  60 |     |         uint256 amount0,
  61 |     |         uint256 amount1
  62 |     |     );
  63 |     | 
  64 |     |     /// @notice Emitted by the pool for any swaps between token0 and token1
  65 |     |     /// @param sender The address that initiated the swap call, and that received the callback
  66 |     |     /// @param recipient The address that received the output of the swap
  67 |     |     /// @param amount0 The delta of the token0 balance of the pool
  68 |     |     /// @param amount1 The delta of the token1 balance of the pool
  69 |     |     /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96
  70 |     |     /// @param liquidity The liquidity of the pool after the swap
  71 |     |     /// @param tick The log base 1.0001 of price of the pool after the swap
  72 |     |     event Swap(
  73 |     |         address indexed sender,
  74 |     |         address indexed recipient,
  75 |     |         int256 amount0,
  76 |     |         int256 amount1,
  77 |     |         uint160 sqrtPriceX96,
  78 |     |         uint128 liquidity,
  79 |     |         int24 tick
  80 |     |     );
  81 |     | 
  82 |     |     /// @notice Emitted by the pool for any flashes of token0/token1
  83 |     |     /// @param sender The address that initiated the swap call, and that received the callback
  84 |     |     /// @param recipient The address that received the tokens from flash
  85 |     |     /// @param amount0 The amount of token0 that was flashed
  86 |     |     /// @param amount1 The amount of token1 that was flashed
  87 |     |     /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee
  88 |     |     /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee
  89 |     |     event Flash(
  90 |     |         address indexed sender,
  91 |     |         address indexed recipient,
  92 |     |         uint256 amount0,
  93 |     |         uint256 amount1,
  94 |     |         uint256 paid0,
  95 |     |         uint256 paid1
  96 |     |     );
  97 |     | 
  98 |     |     /// @notice Emitted by the pool for increases to the number of observations that can be stored
  99 |     |     /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index
 100 |     |     /// just before a mint/swap/burn.
 101 |     |     /// @param observationCardinalityNextOld The previous value of the next observation cardinality
 102 |     |     /// @param observationCardinalityNextNew The updated value of the next observation cardinality
 103 |     |     event IncreaseObservationCardinalityNext(
 104 |     |         uint16 observationCardinalityNextOld,
 105 |     |         uint16 observationCardinalityNextNew
 106 |     |     );
 107 |     | 
 108 |     |     /// @notice Emitted when the protocol fee is changed by the pool
 109 |     |     /// @param feeProtocol0Old The previous value of the token0 protocol fee
 110 |     |     /// @param feeProtocol1Old The previous value of the token1 protocol fee
 111 |     |     /// @param feeProtocol0New The updated value of the token0 protocol fee
 112 |     |     /// @param feeProtocol1New The updated value of the token1 protocol fee
 113 |     |     event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);
 114 |     | 
 115 |     |     /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner
 116 |     |     /// @param sender The address that collects the protocol fees
 117 |     |     /// @param recipient The address that receives the collected protocol fees
 118 |     |     /// @param amount0 The amount of token0 protocol fees that is withdrawn
 119 |     |     /// @param amount0 The amount of token1 protocol fees that is withdrawn
 120 |     |     event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);
 121 |     | }
 122 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Pool state that never changes
  5 |     | /// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values
  6 |     | interface IUniswapV3PoolImmutables {
  7 |     |     /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface
  8 |     |     /// @return The contract address
  9 |     |     function factory() external view returns (address);
 10 |     | 
 11 |     |     /// @notice The first of the two tokens of the pool, sorted by address
 12 |     |     /// @return The token contract address
 13 |     |     function token0() external view returns (address);
 14 |     | 
 15 |     |     /// @notice The second of the two tokens of the pool, sorted by address
 16 |     |     /// @return The token contract address
 17 |     |     function token1() external view returns (address);
 18 |     | 
 19 |     |     /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6
 20 |     |     /// @return The fee
 21 |     |     function fee() external view returns (uint24);
 22 |     | 
 23 |     |     /// @notice The pool tick spacing
 24 |     |     /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive
 25 |     |     /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...
 26 |     |     /// This value is an int24 to avoid casting even though it is always positive.
 27 |     |     /// @return The tick spacing
 28 |     |     function tickSpacing() external view returns (int24);
 29 |     | 
 30 |     |     /// @notice The maximum amount of position liquidity that can use any tick in the range
 31 |     |     /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and
 32 |     |     /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool
 33 |     |     /// @return The max amount of liquidity per tick
 34 |     |     function maxLiquidityPerTick() external view returns (uint128);
 35 |     | }
 36 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Permissioned pool actions
  5 |     | /// @notice Contains pool methods that may only be called by the factory owner
  6 |     | interface IUniswapV3PoolOwnerActions {
  7 |     |     /// @notice Set the denominator of the protocol's % share of the fees
  8 |     |     /// @param feeProtocol0 new protocol fee for token0 of the pool
  9 |     |     /// @param feeProtocol1 new protocol fee for token1 of the pool
 10 |     |     function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;
 11 |     | 
 12 |     |     /// @notice Collect the protocol fee accrued to the pool
 13 |     |     /// @param recipient The address to which collected protocol fees should be sent
 14 |     |     /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1
 15 |     |     /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0
 16 |     |     /// @return amount0 The protocol fee collected in token0
 17 |     |     /// @return amount1 The protocol fee collected in token1
 18 |     |     function collectProtocol(
 19 |     |         address recipient,
 20 |     |         uint128 amount0Requested,
 21 |     |         uint128 amount1Requested
 22 |     |     ) external returns (uint128 amount0, uint128 amount1);
 23 |     | }
 24 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.5.0;
   3 |     | 
   4 |     | /// @title Pool state that can change
   5 |     | /// @notice These methods compose the pool's state, and can change with any frequency including multiple times
   6 |     | /// per transaction
   7 |     | interface IUniswapV3PoolState {
   8 |     |     /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas
   9 |     |     /// when accessed externally.
  10 |     |     /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value
  11 |     |     /// tick The current tick of the pool, i.e. according to the last tick transition that was run.
  12 |     |     /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick
  13 |     |     /// boundary.
  14 |     |     /// observationIndex The index of the last oracle observation that was written,
  15 |     |     /// observationCardinality The current maximum number of observations stored in the pool,
  16 |     |     /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.
  17 |     |     /// feeProtocol The protocol fee for both tokens of the pool.
  18 |     |     /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0
  19 |     |     /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.
  20 |     |     /// unlocked Whether the pool is currently locked to reentrancy
  21 |     |     function slot0()
  22 |     |         external
  23 |     |         view
  24 |     |         returns (
  25 |     |             uint160 sqrtPriceX96,
  26 |     |             int24 tick,
  27 |     |             uint16 observationIndex,
  28 |     |             uint16 observationCardinality,
  29 |     |             uint16 observationCardinalityNext,
  30 |     |             uint8 feeProtocol,
  31 |     |             bool unlocked
  32 |     |         );
  33 |     | 
  34 |     |     /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool
  35 |     |     /// @dev This value can overflow the uint256
  36 |     |     function feeGrowthGlobal0X128() external view returns (uint256);
  37 |     | 
  38 |     |     /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool
  39 |     |     /// @dev This value can overflow the uint256
  40 |     |     function feeGrowthGlobal1X128() external view returns (uint256);
  41 |     | 
  42 |     |     /// @notice The amounts of token0 and token1 that are owed to the protocol
  43 |     |     /// @dev Protocol fees will never exceed uint128 max in either token
  44 |     |     function protocolFees() external view returns (uint128 token0, uint128 token1);
  45 |     | 
  46 |     |     /// @notice The currently in range liquidity available to the pool
  47 |     |     /// @dev This value has no relationship to the total liquidity across all ticks
  48 |     |     function liquidity() external view returns (uint128);
  49 |     | 
  50 |     |     /// @notice Look up information about a specific tick in the pool
  51 |     |     /// @param tick The tick to look up
  52 |     |     /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or
  53 |     |     /// tick upper,
  54 |     |     /// liquidityNet how much liquidity changes when the pool price crosses the tick,
  55 |     |     /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,
  56 |     |     /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,
  57 |     |     /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick
  58 |     |     /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,
  59 |     |     /// secondsOutside the seconds spent on the other side of the tick from the current tick,
  60 |     |     /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.
  61 |     |     /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.
  62 |     |     /// In addition, these values are only relative and must be used only in comparison to previous snapshots for
  63 |     |     /// a specific position.
  64 |     |     function ticks(int24 tick)
  65 |     |         external
  66 |     |         view
  67 |     |         returns (
  68 |     |             uint128 liquidityGross,
  69 |     |             int128 liquidityNet,
  70 |     |             uint256 feeGrowthOutside0X128,
  71 |     |             uint256 feeGrowthOutside1X128,
  72 |     |             int56 tickCumulativeOutside,
  73 |     |             uint160 secondsPerLiquidityOutsideX128,
  74 |     |             uint32 secondsOutside,
  75 |     |             bool initialized
  76 |     |         );
  77 |     | 
  78 |     |     /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information
  79 |     |     function tickBitmap(int16 wordPosition) external view returns (uint256);
  80 |     | 
  81 |     |     /// @notice Returns the information about a position by the position's key
  82 |     |     /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
  83 |     |     /// @return _liquidity The amount of liquidity in the position,
  84 |     |     /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,
  85 |     |     /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,
  86 |     |     /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,
  87 |     |     /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke
  88 |     |     function positions(bytes32 key)
  89 |     |         external
  90 |     |         view
  91 |     |         returns (
  92 |     |             uint128 _liquidity,
  93 |     |             uint256 feeGrowthInside0LastX128,
  94 |     |             uint256 feeGrowthInside1LastX128,
  95 |     |             uint128 tokensOwed0,
  96 |     |             uint128 tokensOwed1
  97 |     |         );
  98 |     | 
  99 |     |     /// @notice Returns data about a specific observation index
 100 |     |     /// @param index The element of the observations array to fetch
 101 |     |     /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time
 102 |     |     /// ago, rather than at a specific index in the array.
 103 |     |     /// @return blockTimestamp The timestamp of the observation,
 104 |     |     /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,
 105 |     |     /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,
 106 |     |     /// Returns initialized whether the observation has been initialized and the values are safe to use
 107 |     |     function observations(uint256 index)
 108 |     |         external
 109 |     |         view
 110 |     |         returns (
 111 |     |             uint32 blockTimestamp,
 112 |     |             int56 tickCumulative,
 113 |     |             uint160 secondsPerLiquidityCumulativeX128,
 114 |     |             bool initialized
 115 |     |         );
 116 |     | }
 117 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@uniswap/v3-core/contracts/libraries/FixedPoint96.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.4.0;
  3 |     | 
  4 |     | /// @title FixedPoint96
  5 |     | /// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)
  6 |     | /// @dev Used in SqrtPriceMath.sol
  7 |     | library FixedPoint96 {
  8 |     |     uint8 internal constant RESOLUTION = 96;
  9 |     |     uint256 internal constant Q96 = 0x1000000000000000000000000;
 10 |     | }
 11 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.7.5;
  3 |     | pragma abicoder v2;
  4 |     | 
  5 |     | import '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';
  6 |     | 
  7 |     | /// @title Router token swapping functionality
  8 |     | /// @notice Functions for swapping tokens via Uniswap V3
  9 |     | interface ISwapRouter is IUniswapV3SwapCallback {
 10 |     |     struct ExactInputSingleParams {
 11 |     |         address tokenIn;
 12 |     |         address tokenOut;
 13 |     |         uint24 fee;
 14 |     |         address recipient;
 15 |     |         uint256 deadline;
 16 |     |         uint256 amountIn;
 17 |     |         uint256 amountOutMinimum;
 18 |     |         uint160 sqrtPriceLimitX96;
 19 |     |     }
 20 |     | 
 21 |     |     /// @notice Swaps `amountIn` of one token for as much as possible of another token
 22 |     |     /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata
 23 |     |     /// @return amountOut The amount of the received token
 24 |     |     function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);
 25 |     | 
 26 |     |     struct ExactInputParams {
 27 |     |         bytes path;
 28 |     |         address recipient;
 29 |     |         uint256 deadline;
 30 |     |         uint256 amountIn;
 31 |     |         uint256 amountOutMinimum;
 32 |     |     }
 33 |     | 
 34 |     |     /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path
 35 |     |     /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata
 36 |     |     /// @return amountOut The amount of the received token
 37 |     |     function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);
 38 |     | 
 39 |     |     struct ExactOutputSingleParams {
 40 |     |         address tokenIn;
 41 |     |         address tokenOut;
 42 |     |         uint24 fee;
 43 |     |         address recipient;
 44 |     |         uint256 deadline;
 45 |     |         uint256 amountOut;
 46 |     |         uint256 amountInMaximum;
 47 |     |         uint160 sqrtPriceLimitX96;
 48 |     |     }
 49 |     | 
 50 |     |     /// @notice Swaps as little as possible of one token for `amountOut` of another token
 51 |     |     /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata
 52 |     |     /// @return amountIn The amount of the input token
 53 |     |     function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);
 54 |     | 
 55 |     |     struct ExactOutputParams {
 56 |     |         bytes path;
 57 |     |         address recipient;
 58 |     |         uint256 deadline;
 59 |     |         uint256 amountOut;
 60 |     |         uint256 amountInMaximum;
 61 |     |     }
 62 |     | 
 63 |     |     /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)
 64 |     |     /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata
 65 |     |     /// @return amountIn The amount of the input token
 66 |     |     function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);
 67 |     | }
 68 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/dos/DOS.sol
    1 |     | // SPDX-License-Identifier: BUSL-1.1
    2 |     | pragma solidity ^0.8.17;
    3 |     | 
    4 |     | import "@openzeppelin/contracts/proxy/Proxy.sol";
    5 |     | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
    6 |     | import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
    7 |     | import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
    8 |     | import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
    9 |     | import "@openzeppelin/contracts/utils/Address.sol";
   10 |     | import "@openzeppelin/contracts/security/Pausable.sol";
   11 |     | import "../lib/FsUtils.sol";
   12 |     | import "../lib/FsMath.sol";
   13 |     | import "../interfaces/IDOS.sol";
   14 |     | import "../interfaces/IERC20ValueOracle.sol";
   15 |     | import "../interfaces/INFTValueOracle.sol";
   16 |     | import {PERMIT2, IPermit2} from "../external/interfaces/IPermit2.sol";
   17 |     | import {DSafeProxy} from "./DSafeProxy.sol";
   18 |     | import {IVersionManager} from "../interfaces/IVersionManager.sol";
   19 |     | import "../lib/Call.sol";
   20 |     | import "../lib/ImmutableGovernance.sol";
   21 |     | import {IERC1363SpenderExtended, IERC1363ReceiverExtended} from "../interfaces/IERC1363-extended.sol";
   22 |     | 
   23 |     | /// @notice Sender is not approved to spend dSafe erc20
   24 |     | error NotApprovedOrOwner();
   25 |     | /// @notice Sender is not the owner of the dSafe;
   26 |     | /// @param sender The address of the sender
   27 |     | /// @param owner The address of the owner
   28 |     | error NotOwner(address sender, address owner);
   29 |     | /// @notice Transfer amount exceeds allowance
   30 |     | error InsufficientAllowance();
   31 |     | /// @notice Cannot approve self as spender
   32 |     | error SelfApproval();
   33 |     | /// @notice The receiving address is not a contract
   34 |     | error ReceiverNotContract();
   35 |     | /// @notice The receiver does not implement the required interface
   36 |     | error ReceiverNoImplementation();
   37 |     | /// @notice The receiver did not return the correct value - transaction failed
   38 |     | error WrongDataReturned();
   39 |     | /// @notice Asset is not an NFT
   40 |     | error NotNFT();
   41 |     | /// @notice NFT must be in the user's dSafe
   42 |     | error NFTNotInDSafe();
   43 |     | /// @notice NFT must be owned the the user or user's dSafe
   44 |     | error NotNFTOwner();
   45 |     | /// @notice Asset is not registered
   46 |     | /// @param token The unregistered asset
   47 |     | error NotRegistered(address token);
   48 |     | /// @notice Only dSafe can call this function
   49 |     | error OnlyDSafe();
   50 |     | /// @notice Recipient is not a valid dSafe
   51 |     | error DSafeNonExistent();
   52 |     | /// @notice Operation leaves dSafe insolvent
   53 |     | error Insolvent();
   54 |     | /// @notice The address is not a registered ERC20
   55 |     | error NotERC20();
   56 |     | 
   57 |     | // ERC20 standard token
   58 |     | // ERC721 single non-fungible token support
   59 |     | // ERC677 transferAndCall (transferAndCall2 extension)
   60 |     | // ERC165 interface support (solidity IDOS.interfaceId)
   61 |     | // ERC777 token send
   62 |     | // ERC1155 multi-token support
   63 |     | // ERC1363 payable token (approveAndCall/transferAndCall)
   64 |     | // ERC1820 interface registry support
   65 |     | // EIP2612 permit support (uniswap permit2)
   66 |     | /*
   67 |     |  * NFTs are stored in an array of nfts owned by some dSafe. To prevent looping over arrays we need to
   68 |     |  * know the following information for each NFT in the system (erc721, tokenId, dSafe, array index).
   69 |     |  * Given the expensive nature of storage on the EVM we want to store all information as small as possible.
   70 |     |  * The pair (erc721, tokenId) is describes a particular NFT but would take two storage slots (as a token id)
   71 |     |  * is 256 bits. The erc721 address is 160 bits however we only allow pre-approved erc721 contracts, so in
   72 |     |  * practice 16 bits would be enough to store an index into the allowed erc721 contracts. We can hash (erc721 + tokenId)
   73 |     |  * to get a unique number but that requires storing both tokenId, erc721 and array index. Instead we hash into
   74 |     |  * 224 (256 - 32) bits which is still sufficiently large to avoid collisions. This leaves 32 bits for additional
   75 |     |  * information. The 16 LSB are used to store the index in the dSafe array. The 16 RSB are used to store
   76 |     |  * the 16 RSB of the tokenId. This allows us to store the tokenId + array index in a single storage slot as a map
   77 |     |  * from NFTId to NFTData. Note that the index in the dSafe array might change and thus cannot be part of
   78 |     |  * NFTId and thus has to be stored as part of NFTData, requiring the splitting of tokenId.
   79 |     |  */
   80 |     | 
   81 |     | struct NFTTokenData {
   82 |     |     uint240 tokenId; // 240 LSB of the tokenId of the NFT
   83 |     |     uint16 dSafeIdx; // index in dSafe NFT array
   84 |     |     address approvedSpender; // approved spender for ERC721
   85 |     | }
   86 |     | 
   87 |     | struct ERC20Pool {
   88 |     |     int256 tokens;
   89 |     |     int256 shares;
   90 |     | }
   91 |     | 
   92 |     | struct ERC20Info {
   93 |     |     address erc20Contract;
   94 |     |     IERC20ValueOracle valueOracle;
   95 |     |     ERC20Pool collateral;
   96 |     |     ERC20Pool debt;
   97 |     |     uint256 baseRate;
   98 |     |     uint256 slope1;
   99 |     |     uint256 slope2;
  100 |     |     uint256 targetUtilization;
  101 |     |     uint256 timestamp;
  102 |     | }
  103 |     | 
  104 |     | struct ERC721Info {
  105 |     |     address erc721Contract;
  106 |     |     INFTValueOracle valueOracle;
  107 |     | }
  108 |     | 
  109 |     | struct ContractData {
  110 |     |     uint16 idx;
  111 |     |     ContractKind kind; // 0 invalid, 1 ERC20, 2 ERC721
  112 |     | }
  113 |     | 
  114 |     | enum ContractKind {
  115 |     |     Invalid,
  116 |     |     ERC20,
  117 |     |     ERC721
  118 |     | }
  119 |     | 
  120 |     | // We will initialize the system so that 0 is the base currency
  121 |     | // in which the system calculates value.
  122 |     | uint16 constant K_NUMERAIRE_IDX = 0;
  123 |     | 
  124 |     | library DSafeLib {
  125 |     |     type NFTId is uint256; // 16 bits (tokenId) + 224 bits (hash) + 16 bits (erc721 index)
  126 |     | 
  127 |     |     struct DSafe {
  128 |     |         address owner;
  129 |     |         mapping(uint16 => ERC20Share) erc20Share;
  130 |     |         NFTId[] nfts;
  131 |     |         // bitmask of DOS indexes of ERC20 present in a dSafe. `1` can be increased on updates
  132 |     |         uint256[1] dAccountErc20Idxs;
  133 |     |     }
  134 |     | 
  135 |     |     function removeERC20IdxFromDAccount(DSafe storage dSafe, uint16 erc20Idx) internal {
  136 |     |         dSafe.dAccountErc20Idxs[erc20Idx >> 8] &= ~(1 << (erc20Idx & 255));
  137 |     |     }
  138 |     | 
  139 |     |     function accERC20IdxToDAccount(DSafe storage dSafe, uint16 erc20Idx) internal {
  140 |     |         dSafe.dAccountErc20Idxs[erc20Idx >> 8] |= (1 << (erc20Idx & 255));
  141 |     |     }
  142 |     | 
  143 |     |     function extractPosition(
  144 |     |         ERC20Pool storage pool,
  145 |     |         ERC20Share shares
  146 |     |     ) internal returns (int256 tokens) {
  147 |     |         tokens = computeERC20(pool, shares);
  148 |     |         pool.tokens -= tokens;
  149 |     |         pool.shares -= ERC20Share.unwrap(shares);
  150 |     |     }
  151 |     | 
  152 |     |     function insertPosition(ERC20Pool storage pool, int256 tokens) internal returns (ERC20Share) {
  153 |     |         int256 shares;
  154 |     |         if (pool.shares == 0) {
  155 |     |             FsUtils.Assert(pool.tokens == 0);
  156 |     |             shares = tokens;
  157 |     |         } else {
  158 |     |             shares = (pool.shares * tokens) / pool.tokens;
  159 |     |         }
  160 |     |         pool.tokens += tokens;
  161 |     |         pool.shares += shares;
  162 |     |         return ERC20Share.wrap(shares);
  163 |     |     }
  164 |     | 
  165 |     |     function extractNFT(
  166 |     |         DSafe storage dSafe,
  167 |     |         NFTId nftId,
  168 |     |         mapping(NFTId => NFTTokenData) storage map
  169 |     |     ) internal {
  170 |     |         uint16 idx = map[nftId].dSafeIdx;
  171 |     |         map[nftId].approvedSpender = address(0); // remove approval
  172 |     |         bool userOwnsNFT = dSafe.nfts.length > 0 &&
  173 |     |             NFTId.unwrap(dSafe.nfts[idx]) == NFTId.unwrap(nftId);
  174 |     |         if (!userOwnsNFT) {
  175 |     |             revert NFTNotInDSafe();
  176 |     |         }
  177 |     |         if (idx == dSafe.nfts.length - 1) {
  178 |     |             dSafe.nfts.pop();
  179 |     |         } else {
  180 |     |             NFTId lastNFTId = dSafe.nfts[dSafe.nfts.length - 1];
  181 |     |             map[lastNFTId].dSafeIdx = idx;
  182 |     |             dSafe.nfts.pop();
  183 |     |         }
  184 |     |     }
  185 |     | 
  186 |     |     function insertNFT(
  187 |     |         DSafe storage dSafe,
  188 |     |         NFTId nftId,
  189 |     |         mapping(NFTId => NFTTokenData) storage map
  190 |     |     ) internal {
  191 |     |         uint16 idx = uint16(dSafe.nfts.length);
  192 |     |         dSafe.nfts.push(nftId);
  193 |     |         map[nftId].dSafeIdx = idx;
  194 |     |     }
  195 |     | 
  196 |     |     function getERC20s(DSafe storage dSafe) internal view returns (uint16[] memory erc20s) {
  197 |     |         uint256 numberOfERC20 = 0;
  198 |     |         for (uint256 i = 0; i < dSafe.dAccountErc20Idxs.length; i++) {
  199 |     |             numberOfERC20 += FsMath.bitCount(dSafe.dAccountErc20Idxs[i]);
  200 |     |         }
  201 |     |         erc20s = new uint16[](numberOfERC20);
  202 |     |         uint256 idx = 0;
  203 |     |         for (uint256 i = 0; i < dSafe.dAccountErc20Idxs.length; i++) {
  204 |     |             uint256 mask = dSafe.dAccountErc20Idxs[i];
  205 |     |             for (uint256 j = 0; j < 256; j++) {
  206 |     |                 uint256 x = mask >> j;
  207 |     |                 if (x == 0) break;
  208 |     |                 if ((x & 1) != 0) {
  209 |     |                     erc20s[idx++] = uint16(i * 256 + j);
  210 |     |                 }
  211 |     |             }
  212 |     |         }
  213 |     |     }
  214 |     | 
  215 |     |     function computeERC20(
  216 |     |         ERC20Pool storage pool,
  217 |     |         ERC20Share sharesWrapped
  218 |     |     ) internal view returns (int256 tokens) {
  219 |     |         int256 shares = ERC20Share.unwrap(sharesWrapped);
  220 |     |         if (shares == 0) return 0;
  221 |     |         FsUtils.Assert(pool.shares != 0);
  222 |     |         return (pool.tokens * shares) / pool.shares;
  223 |     |     }
  224 |     | }
  225 |     | 
  226 |     | /// @title DOS State
  227 |     | /// @notice Contract holds the configuration state for DOS
  228 |     | contract DOSState is Pausable {
  229 |     |     using DSafeLib for ERC20Pool;
  230 |     | 
  231 |     |     IVersionManager public versionManager;
  232 |     |     /// @notice mapping between dSafe address and DOS-specific dSafe data
  233 |     |     mapping(address => DSafeLib.DSafe) public dSafes;
  234 |     | 
  235 |     |     /// @notice mapping between dSafe address and an instance of deployed dSafeLogic contract.
  236 |     |     /// It means that this specific dSafeLogic version is setup to operate the dSafe.
  237 |     |     // @dev this could be a mapping to a version index instead of the implementation address
  238 |     |     mapping(address => address) public dSafeLogic;
  239 |     | 
  240 |     |     /// @notice mapping from
  241 |     |     /// dSafe owner address => ERC20 address => dSafe spender address => allowed amount of ERC20.
  242 |     |     /// It represent the allowance of `spender` to transfer up to `amount` of `erc20` balance of
  243 |     |     /// owner's dAccount to some other dAccount. E.g. 123 => abc => 456 => 1000, means that
  244 |     |     /// dSafe 456 can transfer up to 1000 of abc tokens from dAccount of dSafe 123 to some other dAccount.
  245 |     |     /// Note, that no ERC20 are actually getting transferred - dAccount is a DOS concept, and
  246 |     |     /// corresponding tokens are owned by DOS
  247 |     |     mapping(address => mapping(address => mapping(address => uint256))) public allowances;
  248 |     | 
  249 |     |     /// @notice Whether a spender is approved to operate a dSafe's NFTs for a specific collection
  250 |     |     /// @dev Mapping from dSafe owner address => NFT address => spender address => bool
  251 |     |     /// @dev erc721 & erc1155 operator approvals
  252 |     |     mapping(address => mapping(address => mapping(address => bool))) public operatorApprovals;
  253 |     | 
  254 |     |     mapping(DSafeLib.NFTId => NFTTokenData) public tokenDataByNFTId;
  255 |     | 
  256 |     |     ERC20Info[] public erc20Infos;
  257 |     |     ERC721Info[] public erc721Infos;
  258 |     | 
  259 |     |     /// @notice mapping of ERC20 or ERC721 address => DOS asset idx and contract kind.
  260 |     |     /// idx is the index of the ERC20 in `erc20Infos` or ERC721 in `erc721Infos`
  261 |     |     /// kind is ContractKind enum, that here can be ERC20 or ERC721
  262 |     |     mapping(address => ContractData) public infoIdx;
  263 |     | 
  264 |     |     IDOSConfig.Config public config;
  265 |     | 
  266 |     |     modifier onlyDSafe() {
  267 |     |         if (dSafes[msg.sender].owner == address(0)) {
  268 |     |             revert OnlyDSafe();
  269 |     |         }
  270 |     |         _;
  271 |     |     }
  272 |     | 
  273 |     |     modifier dSafeExists(address dSafe) {
  274 |     |         if (dSafes[dSafe].owner == address(0)) {
  275 |     |             revert DSafeNonExistent();
  276 |     |         }
  277 |     |         _;
  278 |     |     }
  279 |     | 
  280 |     |     function getBalance(
  281 |     |         ERC20Share shares,
  282 |     |         ERC20Info storage erc20Info
  283 |     |     ) internal view returns (int256) {
  284 |     |         ERC20Pool storage pool = ERC20Share.unwrap(shares) > 0
  285 |     |             ? erc20Info.collateral
  286 |     |             : erc20Info.debt;
  287 |     |         return pool.computeERC20(shares);
  288 |     |     }
  289 |     | 
  290 |     |     function getNFTData(
  291 |     |         DSafeLib.NFTId nftId
  292 |     |     ) internal view returns (uint16 erc721Idx, uint256 tokenId) {
  293 |     |         uint256 unwrappedId = DSafeLib.NFTId.unwrap(nftId);
  294 |     |         erc721Idx = uint16(unwrappedId);
  295 |     |         tokenId = tokenDataByNFTId[nftId].tokenId | ((unwrappedId >> 240) << 240);
  296 |     |     }
  297 |     | 
  298 |     |     function getERC20Info(IERC20 erc20) internal view returns (ERC20Info storage, uint16) {
  299 |     |         if (infoIdx[address(erc20)].kind != ContractKind.ERC20) {
  300 |     |             revert NotRegistered(address(erc20));
  301 |     |         }
  302 |     |         uint16 idx = infoIdx[address(erc20)].idx;
  303 |     |         return (erc20Infos[idx], idx);
  304 |     |     }
  305 |     | 
  306 |     |     function getERC721Info(IERC721 erc721) internal view returns (ERC721Info storage, uint16) {
  307 |     |         if (infoIdx[address(erc721)].kind != ContractKind.ERC721) {
  308 |     |             revert NotRegistered(address(erc721));
  309 |     |         }
  310 |     |         uint16 idx = infoIdx[address(erc721)].idx;
  311 |     |         return (erc721Infos[idx], idx);
  312 |     |     }
  313 |     | }
  314 |     | 
  315 |     | /// @title DeFi OS (DOS)
  316 |     | contract DOS is DOSState, IDOSCore, IERC721Receiver, Proxy {
  317 |     |     using DSafeLib for DSafeLib.DSafe;
  318 |     |     using DSafeLib for ERC20Pool;
  319 |     |     using SafeERC20 for IERC20;
  320 |     |     using Address for address;
  321 |     | 
  322 |     |     address immutable dosConfigAddress;
  323 |     | 
  324 |     |     modifier onlyRegisteredNFT(address nftContract, uint256 tokenId) {
  325 |     |         // how can we be sure that Oracle would have a price for any possible tokenId?
  326 |     |         // maybe we should check first if Oracle can return a value for this specific NFT?
  327 |     |         if (infoIdx[nftContract].kind == ContractKind.Invalid) {
  328 |     |             revert NotRegistered(nftContract);
  329 |     |         }
  330 |     |         _;
  331 |     |     }
  332 |     | 
  333 |     |     modifier onlyNFTOwner(address nftContract, uint256 tokenId) {
  334 |     |         address _owner = ERC721(nftContract).ownerOf(tokenId);
  335 |     |         bool isOwner = _owner == msg.sender || _owner == dSafes[msg.sender].owner;
  336 |     |         if (!isOwner) {
  337 |     |             revert NotNFTOwner();
  338 |     |         }
  339 |     |         _;
  340 |     |     }
  341 |     | 
  342 |     |     constructor(address _dosConfig, address _versionManager) {
  343 |     |         versionManager = IVersionManager(FsUtils.nonNull(_versionManager));
  344 |     |         dosConfigAddress = FsUtils.nonNull(_dosConfig);
  345 |     |     }
  346 |     | 
  347 |     |     /// @notice top up the dAccount owned by dSafe `to` with `amount` of `erc20`
  348 |     |     /// @param erc20 Address of the ERC20 token to be transferred
  349 |     |     /// @param to Address of the dSafe that dAccount should be top up
  350 |     |     /// @param amount The amount of `erc20` to be sent
  351 |     |     function depositERC20ForSafe(
  352 |     |         address erc20,
  353 |     |         address to,
  354 |     |         uint256 amount
  355 |     |     ) external override dSafeExists(to) whenNotPaused {
  356 |     |         if (amount == 0) return;
  357 |     |         (, uint16 erc20Idx) = getERC20Info(IERC20(erc20));
  358 |     |         int256 signedAmount = FsMath.safeCastToSigned(amount);
  359 |     |         _dAccountERC20ChangeBy(to, erc20Idx, signedAmount);
  360 |     |         emit IDOSCore.ERC20BalanceChanged(erc20, to, signedAmount);
  361 |     |         IERC20(erc20).safeTransferFrom(msg.sender, address(this), amount);
  362 |     |     }
  363 |     | 
  364 |     |     /// @notice deposit `amount` of `erc20` to dAccount from dSafe
  365 |     |     /// @param erc20 Address of the ERC20 token to be transferred
  366 |     |     /// @param amount The amount of `erc20` to be transferred
  367 |     |     function depositERC20(IERC20 erc20, uint256 amount) external override onlyDSafe whenNotPaused {
  368 |     |         if (amount == 0) return;
  369 |     |         (, uint16 erc20Idx) = getERC20Info(erc20);
  370 |     |         int256 signedAmount = FsMath.safeCastToSigned(amount);
  371 |     |         _dAccountERC20ChangeBy(msg.sender, erc20Idx, signedAmount);
  372 |     |         emit IDOSCore.ERC20BalanceChanged(address(erc20), msg.sender, signedAmount);
  373 |     |         erc20.safeTransferFrom(msg.sender, address(this), amount);
  374 |     |     }
  375 |     | 
  376 |     |     /// @notice deposit `amount` of `erc20` from dAccount tp dSafe
  377 |     |     /// @param erc20 Address of the ERC20 token to be transferred
  378 |     |     /// @param amount The amount of `erc20` to be transferred
  379 |     |     function withdrawERC20(IERC20 erc20, uint256 amount) external override onlyDSafe whenNotPaused {
  380 |     |         (, uint16 erc20Idx) = getERC20Info(erc20);
  381 |     |         int256 signedAmount = FsMath.safeCastToSigned(amount);
  382 |     |         _dAccountERC20ChangeBy(msg.sender, erc20Idx, -signedAmount);
  383 |     |         emit IDOSCore.ERC20BalanceChanged(address(erc20), msg.sender, -signedAmount);
  384 |     |         erc20.safeTransfer(msg.sender, amount);
  385 |     |     }
  386 |     | 
  387 |     |     /// @notice deposit all `erc20s` from dSafe to dAccount
  388 |     |     /// @param erc20s Array of addresses of ERC20 to be transferred
  389 |     |     function depositFull(IERC20[] calldata erc20s) external override onlyDSafe whenNotPaused {
  390 |     |         for (uint256 i = 0; i < erc20s.length; i++) {
  391 |     |             (ERC20Info storage erc20Info, uint16 erc20Idx) = getERC20Info(erc20s[i]);
  392 |     |             IERC20 erc20 = IERC20(erc20Info.erc20Contract);
  393 |     |             uint256 amount = erc20.balanceOf(msg.sender);
  394 |     |             int256 signedAmount = FsMath.safeCastToSigned(amount);
  395 |     |             _dAccountERC20ChangeBy(msg.sender, erc20Idx, signedAmount);
  396 |     |             emit IDOSCore.ERC20BalanceChanged(address(erc20), msg.sender, signedAmount);
  397 |     |             erc20.safeTransferFrom(msg.sender, address(this), amount);
  398 |     |         }
  399 |     |     }
  400 |     | 
  401 |     |     /// @notice withdraw all `erc20s` from dAccount to dSafe
  402 |     |     /// @param erc20s Array of addresses of ERC20 to be transferred
  403 |     |     function withdrawFull(IERC20[] calldata erc20s) external onlyDSafe whenNotPaused {
  404 |     |         for (uint256 i = 0; i < erc20s.length; i++) {
  405 |     |             (ERC20Info storage erc20Info, uint16 erc20Idx) = getERC20Info(erc20s[i]);
  406 |     |             IERC20 erc20 = IERC20(erc20Info.erc20Contract);
  407 |     |             int256 amount = _dAccountERC20Clear(msg.sender, erc20Idx);
  408 |     |             require(amount >= 0, "Can't withdraw debt");
  409 |     |             emit IDOSCore.ERC20BalanceChanged(address(erc20), msg.sender, amount);
  410 |     |             erc20.safeTransfer(msg.sender, uint256(amount));
  411 |     |         }
  412 |     |     }
  413 |     | 
  414 |     |     /// @notice deposit ERC721 `erc721Contract` token `tokenId` from dSafe to dAccount
  415 |     |     /// @dev the part when we track the ownership of deposit NFT to a specific dAccount is in
  416 |     |     /// `onERC721Received` function of this contract
  417 |     |     /// @param erc721Contract The address of the ERC721 contract that the token belongs to
  418 |     |     /// @param tokenId The id of the token to be transferred
  419 |     |     function depositERC721(
  420 |     |         address erc721Contract,
  421 |     |         uint256 tokenId
  422 |     |     )
  423 |     |         external
  424 |     |         override
  425 |     |         onlyDSafe
  426 |     |         whenNotPaused
  427 |     |         onlyRegisteredNFT(erc721Contract, tokenId)
  428 |     |         onlyNFTOwner(erc721Contract, tokenId)
  429 |     |     {
  430 |     |         address _owner = ERC721(erc721Contract).ownerOf(tokenId);
  431 |     |         emit IDOSCore.ERC721Deposited(erc721Contract, msg.sender, tokenId);
  432 |     |         ERC721(erc721Contract).safeTransferFrom(
  433 |     |             _owner,
  434 |     |             address(this),
  435 |     |             tokenId,
  436 |     |             abi.encode(msg.sender)
  437 |     |         );
  438 |     |     }
  439 |     | 
  440 |     |     /// @notice withdraw ERC721 `nftContract` token `tokenId` from dAccount to dSafe
  441 |     |     /// @param erc721 The address of the ERC721 contract that the token belongs to
  442 |     |     /// @param tokenId The id of the token to be transferred
  443 |     |     function withdrawERC721(
  444 |     |         address erc721,
  445 |     |         uint256 tokenId
  446 |     |     ) external override onlyDSafe whenNotPaused {
  447 |     |         DSafeLib.NFTId nftId = _getNFTId(erc721, tokenId);
  448 |     | 
  449 |     |         dSafes[msg.sender].extractNFT(nftId, tokenDataByNFTId);
  450 |     |         delete tokenDataByNFTId[nftId];
  451 |     |         emit IDOSCore.ERC721Withdrawn(erc721, msg.sender, tokenId);
  452 |     | 
  453 |     |         ERC721(erc721).safeTransferFrom(address(this), msg.sender, tokenId);
  454 |     |     }
  455 |     | 
  456 |     |     /// @notice transfer `amount` of `erc20` from dAccount of caller dSafe to dAccount of `to` dSafe
  457 |     |     /// @param erc20 Address of the ERC20 token to be transferred
  458 |     |     /// @param to dSafe address, whose dAccount is the transfer target
  459 |     |     /// @param amount The amount of `erc20` to be transferred
  460 |     |     function transferERC20(
  461 |     |         IERC20 erc20,
  462 |     |         address to,
  463 |     |         uint256 amount
  464 |     |     ) external override onlyDSafe whenNotPaused dSafeExists(to) {
  465 |     |         if (amount == 0) return;
  466 |     |         _transferERC20(erc20, msg.sender, to, FsMath.safeCastToSigned(amount));
  467 |     |     }
  468 |     | 
  469 |     |     /// @notice transfer NFT `erc721` token `tokenId` from dAccount of caller dSafe to dAccount of
  470 |     |     /// `to` dSafe
  471 |     |     /// @param erc721 The address of the ERC721 contract that the token belongs to
  472 |     |     /// @param tokenId The id of the token to be transferred
  473 |     |     /// @param to dSafe address, whose dAccount is the transfer target
  474 |     |     function transferERC721(
  475 |     |         address erc721,
  476 |     |         uint256 tokenId,
  477 |     |         address to
  478 |     |     ) external override onlyDSafe whenNotPaused dSafeExists(to) {
  479 |     |         DSafeLib.NFTId nftId = _getNFTId(erc721, tokenId);
  480 |     |         _transferNFT(nftId, msg.sender, to);
  481 |     |     }
  482 |     | 
  483 |     |     /// @notice Transfer ERC20 tokens from dAccount to another dAccount
  484 |     |     /// @dev Note: Allowance must be set with approveERC20
  485 |     |     /// @param erc20 The index of the ERC20 token in erc20Infos array
  486 |     |     /// @param from The address of the dSafe to transfer from
  487 |     |     /// @param to The address of the dSafe to transfer to
  488 |     |     /// @param amount The amount of tokens to transfer
  489 |     |     /// @return true, when the transfer has been successfully finished without been reverted
  490 |     |     function transferFromERC20(
  491 |     |         address erc20,
  492 |     |         address from,
  493 |     |         address to,
  494 |     |         uint256 amount
  495 |     |     ) external override whenNotPaused dSafeExists(from) dSafeExists(to) returns (bool) {
  496 |     |         address spender = msg.sender;
  497 |     |         _spendAllowance(erc20, from, spender, amount);
  498 |     |         _transferERC20(IERC20(erc20), from, to, FsMath.safeCastToSigned(amount));
  499 |     |         return true;
  500 |     |     }
  501 |     | 
  502 |     |     /// @notice Transfer ERC721 tokens from dAccount to another dAccount
  503 |     |     /// @param collection The address of the ERC721 token
  504 |     |     /// @param from The address of the dSafe to transfer from
  505 |     |     /// @param to The address of the dSafe to transfer to
  506 |     |     /// @param tokenId The id of the token to transfer
  507 |     |     function transferFromERC721(
  508 |     |         address collection,
  509 |     |         address from,
  510 |     |         address to,
  511 |     |         uint256 tokenId
  512 |     |     ) external override onlyDSafe whenNotPaused dSafeExists(to) {
  513 |     |         DSafeLib.NFTId nftId = _getNFTId(collection, tokenId);
  514 |     |         if (!_isApprovedOrOwner(msg.sender, from, nftId)) {
  515 |     |             revert NotApprovedOrOwner();
  516 |     |         }
  517 |     |         _transferNFT(nftId, from, to);
  518 |     |     }
  519 |     | 
  520 |     |     /// @notice Liquidate an undercollateralized position
  521 |     |     /// @dev if dAccount of `dSafe` has more debt then collateral then this function will
  522 |     |     /// transfer all debt and collateral ERC20s and ERC721 from dAccount of `dSafe` to dAccount of
  523 |     |     /// caller. Considering that market price of collateral is higher then market price of debt,
  524 |     |     /// a friction of that difference would be sent back to liquidated dAccount in DOS base currency.
  525 |     |     ///   More specific - "some fraction" is `liqFraction` parameter of DOS.
  526 |     |     ///   Considering that call to this function would create debt on caller (debt is less then
  527 |     |     /// gains, yet still), consider using `liquify` instead, that would liquidate and use
  528 |     |     /// obtained assets to cover all created debt
  529 |     |     ///   If dAccount of `dSafe` has less debt then collateral then the transaction will be reverted
  530 |     |     /// @param dSafe The address of dSafe whose dAccount to be liquidate
  531 |     |     function liquidate(address dSafe) external override onlyDSafe whenNotPaused dSafeExists(dSafe) {
  532 |     |         (int256 totalValue, int256 collateral, int256 debt) = getRiskAdjustedPositionValues(dSafe);
  533 |     |         require(collateral < debt, "DSafe is not liquidatable");
  534 |     |         uint16[] memory dSafeERC20s = dSafes[dSafe].getERC20s();
  535 |     |         for (uint256 i = 0; i < dSafeERC20s.length; i++) {
  536 |     |             uint16 erc20Idx = dSafeERC20s[i];
  537 |     |             _transferAllERC20(erc20Idx, dSafe, msg.sender);
  538 |     |         }
  539 |     |         while (dSafes[dSafe].nfts.length > 0) {
  540 |     |             _transferNFT(dSafes[dSafe].nfts[dSafes[dSafe].nfts.length - 1], dSafe, msg.sender);
  541 |     |         }
  542 |     |         if (totalValue > 0) {
  543 |     |             // totalValue of the liquidated dSafe is split between liquidatable and liquidator:
  544 |     |             // totalValue * (1 - liqFraction) - reward of the liquidator, and
  545 |     |             // totalValue * liqFraction - change, liquidator is sending back to liquidatable
  546 |     |             int256 percentUnderwater = (collateral * 1 ether) / debt;
  547 |     |             int256 leftover = ((totalValue * config.liqFraction * percentUnderwater) / 1 ether) /
  548 |     |                 1 ether;
  549 |     |             _transferERC20(
  550 |     |                 IERC20(erc20Infos[K_NUMERAIRE_IDX].erc20Contract),
  551 |     |                 msg.sender,
  552 |     |                 dSafe,
  553 |     |                 leftover
  554 |     |             );
  555 |     |         }
  556 |     |         emit IDOSCore.SafeLiquidated(dSafe, msg.sender);
  557 |     |     }
  558 |     | 
  559 |     |     /// @notice Execute a batch of calls
  560 |     |     /// @dev execute a batch of commands on DOS from the name of dSafe owner. Eventual state of
  561 |     |     /// dAccount and DOS must be solvent, i.e. debt on dAccount cannot exceed collateral
  562 |     |     /// and DOS reserve/debt must be sufficient
  563 |     |     /// @param calls An array of transaction calls
  564 |     |     function executeBatch(Call[] memory calls) external override onlyDSafe whenNotPaused {
  565 |     |         DSafeProxy(payable(msg.sender)).executeBatch(calls);
  566 |     |         if (!isSolvent(msg.sender)) {
  567 |     |             revert Insolvent();
  568 |     |         }
  569 |     |     }
  570 |     | 
  571 |     |     /// @notice ERC721 transfer callback
  572 |     |     /// @dev it's a callback, required to be implemented by IERC721Receiver interface for the
  573 |     |     /// contract to be able to receive ERC721 NFTs.
  574 |     |     /// We are using it to track what dAccount owns what NFT.
  575 |     |     /// `return this.onERC721Received.selector;` is mandatory part for the NFT transfer to work -
  576 |     |     /// not a part of our business logic
  577 |     |     /// @param - operator The address which called `safeTransferFrom` function
  578 |     |     /// @param from The address which previously owned the token
  579 |     |     /// @param tokenId The NFT identifier which is being transferred
  580 |     |     /// @param data Additional data with no specified format
  581 |     |     /// @return `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`
  582 |     |     function onERC721Received(
  583 |     |         address /* operator */,
  584 |     |         address from,
  585 |     |         uint256 tokenId,
  586 |     |         bytes calldata data
  587 |     |     ) external override whenNotPaused returns (bytes4) {
  588 |     |         DSafeLib.NFTId nftId = _getNFTId(msg.sender, tokenId);
  589 |     |         if (data.length != 0) {
  590 |     |             from = abi.decode(data, (address));
  591 |     |         }
  592 |     |         require(dSafes[from].owner != address(0), "DSafe does not exist");
  593 |     |         tokenDataByNFTId[nftId].tokenId = uint240(tokenId);
  594 |     |         dSafes[from].insertNFT(nftId, tokenDataByNFTId);
  595 |     |         return this.onERC721Received.selector;
  596 |     |     }
  597 |     | 
  598 |     |     /// @notice Approve an array of tokens and then call `onApprovalReceived` on spender
  599 |     |     /// @param approvals An array of ERC20 tokens with amounts, or ERC721 contracts with tokenIds
  600 |     |     /// @param spender The address of the spender dSafe
  601 |     |     /// @param data Additional data with no specified format, sent in call to `spender`
  602 |     |     function approveAndCall(
  603 |     |         Approval[] calldata approvals,
  604 |     |         address spender,
  605 |     |         bytes calldata data
  606 |     |     ) external override onlyDSafe whenNotPaused {
  607 |     |         uint256[] memory prev = new uint256[](approvals.length);
  608 |     |         for (uint256 i = 0; i < approvals.length; i++) {
  609 |     |             prev[i] = _approve(
  610 |     |                 msg.sender,
  611 |     |                 spender,
  612 |     |                 approvals[i].ercContract,
  613 |     |                 approvals[i].amountOrTokenId,
  614 |     |                 spender
  615 |     |             );
  616 |     |         }
  617 |     |         if (!_checkOnApprovalReceived(msg.sender, 0, spender, data)) {
  618 |     |             revert WrongDataReturned();
  619 |     |         }
  620 |     |         for (uint256 i = 0; i < approvals.length; i++) {
  621 |     |             _approve(msg.sender, spender, approvals[i].ercContract, prev[i], address(0)); // reset allowance
  622 |     |         }
  623 |     |     }
  624 |     | 
  625 |     |     /// @notice provides the specific version of dSafeLogic contract that is associated with `dSafe`
  626 |     |     /// @param dSafe Address of dSafe whose dSafeLogic contract should be returned
  627 |     |     /// @return the address of the dSafeLogic contract that is associated with the `dSafe`
  628 |     |     function getImplementation(address dSafe) external view override returns (address) {
  629 |     |         // not using msg.sender since this is an external view function
  630 |     |         return dSafeLogic[dSafe];
  631 |     |     }
  632 |     | 
  633 |     |     /// @notice provides the owner of `dSafe`. Owner of the dSafe is the address who created the dSafe
  634 |     |     /// @param dSafe The address of dSafe whose owner should be returned
  635 |     |     /// @return the owner address of the `dSafe`. Owner is the one who created the `dSafe`
  636 |     |     function getDSafeOwner(address dSafe) external view override returns (address) {
  637 |     |         return dSafes[dSafe].owner;
  638 |     |     }
  639 |     | 
  640 |     |     /// @notice returns the collateral, debt and total value of `dSafeAddress`.
  641 |     |     /// @dev Notice that both collateral and debt has some coefficients on the actual amount of deposit
  642 |     |     /// and loan assets! E.g.
  643 |     |     /// for a deposit of 1 ETH the collateral would be equivalent to like 0.8 ETH, and
  644 |     |     /// for a loan of 1 ETH the debt would be equivalent to like 1.2 ETH.
  645 |     |     /// At the same time, totalValue is the unmodified difference between deposits and loans.
  646 |     |     /// @param dSafeAddress The address of dSafe whose collateral, debt and total value would be returned
  647 |     |     /// @return totalValue The difference between equivalents of deposit and loan assets
  648 |     |     /// @return collateral The sum of deposited assets multiplied by their collateral factors
  649 |     |     /// @return debt The sum of borrowed assets multiplied by their borrow factors
  650 |     |     function getRiskAdjustedPositionValues(
  651 |     |         address dSafeAddress
  652 |     |     )
  653 |     |         public
  654 |     |         view
  655 |     |         override
  656 |     |         dSafeExists(dSafeAddress)
  657 |     |         returns (int256 totalValue, int256 collateral, int256 debt)
  658 |     |     {
  659 |     |         DSafeLib.DSafe storage dSafe = dSafes[dSafeAddress];
  660 |     |         uint16[] memory erc20Idxs = dSafe.getERC20s();
  661 |     |         totalValue = 0;
  662 |     |         collateral = 0;
  663 |     |         debt = 0;
  664 |     |         for (uint256 i = 0; i < erc20Idxs.length; i++) {
  665 |     |             uint16 erc20Idx = erc20Idxs[i];
  666 |     |             ERC20Info storage erc20Info = erc20Infos[erc20Idx];
  667 |     |             int256 balance = getBalance(dSafe.erc20Share[erc20Idx], erc20Info);
  668 |     |             (int256 value, int256 riskAdjustedValue) = erc20Info.valueOracle.calcValue(balance);
  669 |     |             totalValue += value;
  670 |     |             if (balance >= 0) {
  671 |     |                 collateral += riskAdjustedValue;
  672 |     |             } else {
  673 |     |                 debt -= riskAdjustedValue;
  674 |     |             }
  675 |     |         }
  676 |     |         for (uint256 i = 0; i < dSafe.nfts.length; i++) {
  677 |     |             DSafeLib.NFTId nftId = dSafe.nfts[i];
  678 |     |             (uint16 erc721Idx, uint256 tokenId) = getNFTData(nftId);
  679 |     |             ERC721Info storage nftInfo = erc721Infos[erc721Idx];
  680 |     |             (int256 nftValue, int256 nftRiskAdjustedValue) = nftInfo.valueOracle.calcValue(tokenId);
  681 |     |             totalValue += nftValue;
  682 |     |             collateral += nftRiskAdjustedValue;
  683 |     |         }
  684 |     |     }
  685 |     | 
  686 |     |     /// @notice Returns the approved address for a token, or zero if no address set
  687 |     |     /// @param collection The address of the ERC721 token
  688 |     |     /// @param tokenId The id of the token to query
  689 |     |     /// @return The dSafe address that is allowed to transfer the ERC721 token
  690 |     |     function getApproved(
  691 |     |         address collection,
  692 |     |         uint256 tokenId
  693 |     |     ) public view override returns (address) {
  694 |     |         DSafeLib.NFTId nftId = _getNFTId(collection, tokenId);
  695 |     |         return tokenDataByNFTId[nftId].approvedSpender;
  696 |     |     }
  697 |     | 
  698 |     |     /// @notice Returns if the `operator` is allowed to manage all of the erc721s of `owner` on the `collection` contract
  699 |     |     /// @param collection The address of the collection contract
  700 |     |     /// @param _owner The address of the dSafe owner
  701 |     |     /// @param spender The address of the dSafe spender
  702 |     |     /// @return if the `spender` is allowed to operate the assets of `collection` of `_owner`
  703 |     |     function isApprovedForAll(
  704 |     |         address collection,
  705 |     |         address _owner,
  706 |     |         address spender
  707 |     |     ) public view override returns (bool) {
  708 |     |         return operatorApprovals[collection][_owner][spender];
  709 |     |     }
  710 |     | 
  711 |     |     /// @notice Returns the remaining amount of tokens that `spender` will be allowed to spend on
  712 |     |     /// behalf of `owner` through {transferFrom}
  713 |     |     /// @dev This value changes when {approve} or {transferFrom} are called
  714 |     |     /// @param erc20 The address of the ERC20 to be checked
  715 |     |     /// @param _owner The dSafe address whose `erc20` are allowed to be transferred by `spender`
  716 |     |     /// @param spender The dSafe address who is allowed to spend `erc20` of `_owner`
  717 |     |     /// @return the remaining amount of tokens that `spender` will be allowed to spend on
  718 |     |     /// behalf of `owner` through {transferFrom}
  719 |     |     function allowance(
  720 |     |         address erc20,
  721 |     |         address _owner,
  722 |     |         address spender
  723 |     |     ) public view override returns (uint256) {
  724 |     |         if (_owner == spender) return type(uint256).max;
  725 |     |         return allowances[_owner][erc20][spender];
  726 |     |     }
  727 |     | 
  728 |     |     /// @notice Compute the interest rate of `underlying`
  729 |     |     /// @param erc20Idx The underlying asset
  730 |     |     /// @return The interest rate of `erc20Idx`
  731 |     |     function computeInterestRate(uint16 erc20Idx) public view override returns (int96) {
  732 |     |         ERC20Info memory erc20Info = erc20Infos[erc20Idx];
  733 |     |         uint256 debt = FsMath.safeCastToUnsigned(-erc20Info.debt.tokens); // question: is debt ever positive?
  734 |     |         uint256 collateral = FsMath.safeCastToUnsigned(erc20Info.collateral.tokens); // question: is collateral ever negative?
  735 |     |         uint256 leverage = FsMath.safeCastToUnsigned(config.fractionalReserveLeverage);
  736 |     |         uint256 poolAssets = debt + collateral;
  737 |     | 
  738 |     |         uint256 ir = erc20Info.baseRate;
  739 |     |         uint256 utilization; // utilization of the pool
  740 |     |         if (poolAssets == 0)
  741 |     |             utilization = 0; // if there are no assets, utilization is 0
  742 |     |         else utilization = uint256((debt * 1e18) / ((collateral - debt) / leverage));
  743 |     | 
  744 |     |         if (utilization <= erc20Info.targetUtilization) {
  745 |     |             ir += (utilization * erc20Info.slope1) / 1e15;
  746 |     |         } else {
  747 |     |             ir += (erc20Info.targetUtilization * erc20Info.slope1) / 1e15;
  748 |     |             ir += ((erc20Info.slope2 * (utilization - erc20Info.targetUtilization)) / 1e15);
  749 |     |         }
  750 |     | 
  751 |     |         return int96(int256(ir));
  752 |     |     }
  753 |     | 
  754 |     |     function _approve(
  755 |     |         address _owner,
  756 |     |         address spender,
  757 |     |         address ercContract,
  758 |     |         uint256 amountOrTokenId,
  759 |     |         address erc721Spender
  760 |     |     ) internal returns (uint256 prev) {
  761 |     |         FsUtils.Assert(spender != address(0));
  762 |     |         ContractData memory data = infoIdx[ercContract];
  763 |     |         if (data.kind == ContractKind.ERC20) {
  764 |     |             prev = allowance(ercContract, _owner, spender);
  765 |     |             allowances[_owner][ercContract][spender] = amountOrTokenId;
  766 |     |         } else if (data.kind == ContractKind.ERC721) {
  767 |     |             prev = amountOrTokenId;
  768 |     |             tokenDataByNFTId[_getNFTId(ercContract, amountOrTokenId)]
  769 |     |                 .approvedSpender = erc721Spender;
  770 |     |         } else {
  771 |     |             FsUtils.Assert(false);
  772 |     |         }
  773 |     |     }
  774 |     | 
  775 |     |     /// @dev changes the quantity of `erc20` by `amount` that are allowed to transfer from dAccount
  776 |     |     /// of dSafe `_owner` by dSafe `spender`
  777 |     |     function _spendAllowance(
  778 |     |         address erc20,
  779 |     |         address _owner,
  780 |     |         address spender,
  781 |     |         uint256 amount
  782 |     |     ) internal {
  783 |     |         uint256 currentAllowance = allowance(erc20, _owner, spender);
  784 |     |         if (currentAllowance != type(uint256).max) {
  785 |     |             if (currentAllowance < amount) {
  786 |     |                 revert InsufficientAllowance();
  787 |     |             }
  788 |     |             unchecked {
  789 |     |                 allowances[_owner][erc20][spender] = currentAllowance - amount;
  790 |     |             }
  791 |     |         }
  792 |     |     }
  793 |     | 
  794 |     |     /**
  795 |     |      * @dev Internal function to invoke {IERC1363Receiver-onApprovalReceived} on a target address
  796 |     |      *  The call is not executed if the target address is not a contract
  797 |     |      * @param spender address The address which will spend the funds
  798 |     |      * @param amount uint256 The amount of tokens to be spent
  799 |     |      * @param data bytes Optional data to send along with the call
  800 |     |      * @return whether the call correctly returned the expected magic value
  801 |     |      */
  802 |     |     function _checkOnApprovalReceived(
  803 |     |         address spender, // safe
  804 |     |         uint256 amount,
  805 |     |         address target, // router
  806 |     |         bytes memory data
  807 |     |     ) internal returns (bool) {
  808 |     |         if (!spender.isContract()) {
  809 |     |             revert ReceiverNotContract();
  810 |     |         }
  811 |     | 
  812 |     |         Call memory call = Call({to: target, callData: data, value: msg.value});
  813 |     | 
  814 |     |         try IERC1363SpenderExtended(spender).onApprovalReceived(msg.sender, amount, call) returns (
  815 |     |             bytes4 retval
  816 |     |         ) {
  817 |     |             return retval == IERC1363SpenderExtended.onApprovalReceived.selector;
  818 |     |         } catch (bytes memory reason) {
  819 |     |             if (reason.length == 0) {
  820 |     |                 revert ReceiverNoImplementation();
  821 |     |             } else {
  822 |     |                 FsUtils.revertBytes(reason);
  823 |     |             }
  824 |     |         }
  825 |     |     }
  826 |     | 
  827 |     |     /// @dev transfer ERC20 balances between dAccounts.
  828 |     |     /// Because all ERC20 tokens on dAccounts are owned by DOS, no tokens are getting transferred -
  829 |     |     /// all changes are inside DOS contract state
  830 |     |     /// @param erc20 The address of ERC20 token balance to transfer
  831 |     |     /// @param from The address of dSafe whose dAccount balance should be decreased by `amount`
  832 |     |     /// @param to The address of dSafe whose dAccount balance should be increased by `amount`
  833 |     |     /// @param amount The amount of `erc20` by witch the balance of
  834 |     |     /// dAccount of dSafe `from` should be decreased and
  835 |     |     /// dAccount of dSafe `to` should be increased.
  836 |     |     /// Note that amount it can be negative
  837 |     |     function _transferERC20(IERC20 erc20, address from, address to, int256 amount) internal {
  838 |     |         (, uint16 erc20Idx) = getERC20Info(erc20);
  839 |     |         _dAccountERC20ChangeBy(from, erc20Idx, -amount);
  840 |     |         _dAccountERC20ChangeBy(to, erc20Idx, amount);
  841 |     |         emit IDOSCore.ERC20Transfer(address(erc20), from, to, amount);
  842 |     |     }
  843 |     | 
  844 |     |     /// @dev transfer ERC721 NFT ownership between dAccounts.
  845 |     |     /// Because all ERC721 NFTs on dAccounts are owned by DOS, no NFT is getting transferred - all
  846 |     |     /// changes are inside DOS contract state
  847 |     |     function _transferNFT(DSafeLib.NFTId nftId, address from, address to) internal {
  848 |     |         dSafes[from].extractNFT(nftId, tokenDataByNFTId);
  849 |     |         dSafes[to].insertNFT(nftId, tokenDataByNFTId);
  850 |     |         emit ERC721Transferred(DSafeLib.NFTId.unwrap(nftId), from, to);
  851 |     |     }
  852 |     | 
  853 |     |     /// @dev transfer all `erc20Idx` from `from` to `to`
  854 |     |     function _transferAllERC20(uint16 erc20Idx, address from, address to) internal {
  855 |     |         int256 amount = _dAccountERC20Clear(from, erc20Idx);
  856 |     |         _dAccountERC20ChangeBy(to, erc20Idx, amount);
  857 |     |         address erc20 = erc20Infos[erc20Idx].erc20Contract;
  858 |     |         emit IDOSCore.ERC20Transfer(erc20, from, to, amount);
  859 |     |     }
  860 |     | 
  861 |     |     function _dAccountERC20ChangeBy(address dSafeAddress, uint16 erc20Idx, int256 amount) internal {
  862 |     |         _updateInterest(erc20Idx);
  863 |     |         DSafeLib.DSafe storage dSafe = dSafes[dSafeAddress];
  864 |     |         ERC20Share shares = dSafe.erc20Share[erc20Idx];
  865 |     |         ERC20Info storage erc20Info = erc20Infos[erc20Idx];
  866 |     |         int256 currentAmount = _extractPosition(shares, erc20Info);
  867 |     |         int256 newAmount = currentAmount + amount;
  868 |     |         dSafe.erc20Share[erc20Idx] = _insertPosition(newAmount, dSafe, erc20Idx);
  869 |     |     }
  870 |     | 
  871 |     |     function _dAccountERC20Clear(address dSafeAddress, uint16 erc20Idx) internal returns (int256) {
  872 |     |         _updateInterest(erc20Idx);
  873 |     |         DSafeLib.DSafe storage dSafe = dSafes[dSafeAddress];
  874 |     |         ERC20Share shares = dSafe.erc20Share[erc20Idx];
  875 |     |         int256 erc20Amount = _extractPosition(shares, erc20Infos[erc20Idx]);
  876 |     |         dSafe.erc20Share[erc20Idx] = ERC20Share.wrap(0);
  877 |     |         dSafe.removeERC20IdxFromDAccount(erc20Idx);
  878 |     |         return erc20Amount;
  879 |     |     }
  880 |     | 
  881 |     |     function _extractPosition(
  882 |     |         ERC20Share sharesWrapped,
  883 |     |         ERC20Info storage erc20Info
  884 |     |     ) internal returns (int256) {
  885 |     |         int256 shares = ERC20Share.unwrap(sharesWrapped);
  886 |     |         ERC20Pool storage pool = shares > 0 ? erc20Info.collateral : erc20Info.debt;
  887 |     |         return pool.extractPosition(sharesWrapped);
  888 |     |     }
  889 |     | 
  890 |     |     function _insertPosition(
  891 |     |         int256 amount,
  892 |     |         DSafeLib.DSafe storage dSafe,
  893 |     |         uint16 erc20Idx
  894 |     |     ) internal returns (ERC20Share) {
  895 |     |         if (amount == 0) {
  896 |     |             dSafe.removeERC20IdxFromDAccount(erc20Idx);
  897 |     |         } else {
  898 |     |             dSafe.accERC20IdxToDAccount(erc20Idx);
  899 |     |         }
  900 |     |         ERC20Info storage erc20Info = erc20Infos[erc20Idx];
  901 |     |         ERC20Pool storage pool = amount > 0 ? erc20Info.collateral : erc20Info.debt;
  902 |     |         return pool.insertPosition(amount);
  903 |     |     }
  904 |     | 
  905 |     |     function _updateInterest(uint16 erc20Idx) internal {
  906 |     |         ERC20Info storage erc20Info = erc20Infos[erc20Idx]; // retrieve ERC20Info and store in memory
  907 |     |         if (erc20Info.timestamp == block.timestamp) return; // already updated this block
  908 |     |         int256 delta = FsMath.safeCastToSigned(block.timestamp - erc20Info.timestamp); // time passed since last update
  909 |     |         erc20Info.timestamp = block.timestamp; // update timestamp to current timestamp
  910 |     |         int256 debt = -erc20Info.debt.tokens; // get the debt
  911 |     |         int256 interestRate = computeInterestRate(erc20Idx);
  912 |     |         int256 interest = (debt * (FsMath.exp(interestRate * delta) - FsMath.FIXED_POINT_SCALE)) /
  913 |     |             FsMath.FIXED_POINT_SCALE; // Get the interest
  914 |     |         int256 treasuryInterest = (interest *
  915 |     |             FsMath.safeCastToSigned(config.treasuryInterestFraction)) / 1 ether; // Get the treasury interest
  916 |     |         erc20Info.debt.tokens -= interest; // subtract interest from debt (increase)
  917 |     |         erc20Info.collateral.tokens += interest - treasuryInterest; // add interest to collateral (increase)
  918 |     | 
  919 |     |         _dAccountERC20ChangeBy(config.treasurySafe, erc20Idx, treasuryInterest); // add treasury interest to treasury
  920 |     |     }
  921 |     | 
  922 |     |     /// @notice Checks if the account's positions are overcollateralized
  923 |     |     /// @dev checks the eventual state of `executeBatch` function execution:
  924 |     |     /// * `dSafe` must have collateral >= debt
  925 |     |     /// * DOS must have sufficient balance of deposits and loans for each ERC20 token
  926 |     |     /// @dev when called by the end of `executeBatch`, isSolvent checks the potential target state
  927 |     |     /// of DOS. Calling this function separately would check current state of DOS, that is always
  928 |     |     /// solvable, and so the return value would always be `true`, unless the `dSafe` is liquidatable
  929 |     |     /// @param dSafe The address of a dSafe who performed the `executeBatch`
  930 |     |     /// @return Whether the position is solvent.
  931 |     |     function isSolvent(address dSafe) internal view returns (bool) {
  932 |     |         uint gasBefore = gasleft();
  933 |     |         int256 leverage = config.fractionalReserveLeverage;
  934 |     |         for (uint256 i = 0; i < erc20Infos.length; i++) {
  935 |     |             int256 totalDebt = erc20Infos[i].debt.tokens;
  936 |     |             int256 reserve = erc20Infos[i].collateral.tokens + totalDebt;
  937 |     |             FsUtils.Assert(
  938 |     |                 IERC20(erc20Infos[i].erc20Contract).balanceOf(address(this)) >= uint256(reserve)
  939 |     |             );
  940 |     |             require(reserve >= -totalDebt / leverage, "Not enough reserve for debt");
  941 |     |         }
  942 |     |         (, int256 collateral, int256 debt) = getRiskAdjustedPositionValues(dSafe);
  943 |     |         if (gasBefore - gasleft() > config.maxSolvencyCheckGasCost)
  944 |     |             revert SolvencyCheckTooExpensive();
  945 |     |         return collateral >= debt;
  946 |     |     }
  947 |     | 
  948 |     |     function _getNFTId(address erc721, uint256 tokenId) internal view returns (DSafeLib.NFTId) {
  949 |     |         if (infoIdx[erc721].kind != ContractKind.ERC721) {
  950 |     |             revert NotNFT();
  951 |     |         }
  952 |     |         uint16 erc721Idx = infoIdx[erc721].idx;
  953 |     |         uint256 tokenHash = uint256(keccak256(abi.encodePacked(tokenId))) >> 32;
  954 |     |         return DSafeLib.NFTId.wrap(erc721Idx | (tokenHash << 16) | ((tokenId >> 240) << 240));
  955 |     |     }
  956 |     | 
  957 |     |     function _isApprovedOrOwner(
  958 |     |         address spender,
  959 |     |         address _owner,
  960 |     |         DSafeLib.NFTId nftId
  961 |     |     ) internal view returns (bool) {
  962 |     |         DSafeLib.DSafe storage p = dSafes[msg.sender];
  963 |     |         (uint16 infoIndex, uint256 tokenId) = getNFTData(nftId);
  964 |     |         address collection = erc721Infos[infoIndex].erc721Contract;
  965 |     |         uint16 idx = tokenDataByNFTId[nftId].dSafeIdx;
  966 |     |         bool isdepositERC721Owner = idx < p.nfts.length &&
  967 |     |             DSafeLib.NFTId.unwrap(p.nfts[idx]) == DSafeLib.NFTId.unwrap(nftId);
  968 |     |         return (isdepositERC721Owner ||
  969 |     |             getApproved(collection, tokenId) == spender ||
  970 |     |             isApprovedForAll(collection, _owner, spender));
  971 |     |     }
  972 |     | 
  973 |     |     // Config functions are handled by DOSConfig
  974 |     |     function _implementation() internal view override returns (address) {
  975 |     |         return dosConfigAddress;
  976 |     |     }
  977 |     | }
  978 |     | 
  979 |     | /// @title DOS Config
  980 |     | contract DOSConfig is DOSState, ImmutableGovernance, IDOSConfig {
  981 |     |     using DSafeLib for DSafeLib.DSafe;
  982 |     |     using DSafeLib for ERC20Pool;
  983 |     |     using SafeERC20 for IERC20;
  984 |     |     using Address for address;
  985 |     | 
  986 |     |     constructor(address _owner) ImmutableGovernance(_owner) {}
  987 |     | 
  988 |     |     /// @notice upgrades the version of dSafeLogic contract for the `dSafe`
  989 |     |     /// @param version The new target version of dSafeLogic contract
  990 |     |     function upgradeDSafeImplementation(
  991 |     |         string calldata version
  992 |     |     ) external override onlyDSafe whenNotPaused {
  993 |     |         (
  994 |     |             ,
  995 |     |             IVersionManager.Status status,
  996 |     |             IVersionManager.BugLevel bugLevel,
  997 |     |             address implementation,
  998 |     | 
  999 |     |         ) = versionManager.getVersionDetails(version);
 1000 |     |         require(status != IVersionManager.Status.DEPRECATED, "Version is deprecated");
 1001 |     |         require(bugLevel == IVersionManager.BugLevel.NONE, "Version has bugs");
 1002 |     |         dSafeLogic[msg.sender] = implementation;
 1003 |     |         emit IDOSConfig.DSafeImplementationUpgraded(msg.sender, version, implementation);
 1004 |     |     }
 1005 |     | 
 1006 |     |     /// @notice transfers the ownership of the `dSafe` to the `newOwner`
 1007 |     |     /// @param newOwner The new owner of the `dSafe`
 1008 |     |     function transferDSafeOwnership(address newOwner) external override onlyDSafe whenNotPaused {
 1009 |     |         dSafes[msg.sender].owner = newOwner;
 1010 |     |         emit IDOSConfig.DSafeOwnershipTransferred(msg.sender, newOwner);
 1011 |     |     }
 1012 |     | 
 1013 |     |     /// @notice Pause the contract
 1014 |     |     function pause() external override onlyGovernance {
 1015 |     |         _pause();
 1016 |     |     }
 1017 |     | 
 1018 |     |     /// @notice Unpause the contract
 1019 |     |     function unpause() external override onlyGovernance {
 1020 |     |         _unpause();
 1021 |     |     }
 1022 |     | 
 1023 |     |     /// @notice add a new ERC20 to be used inside DOS
 1024 |     |     /// @dev For governance only.
 1025 |     |     /// @param erc20Contract The address of ERC20 to add
 1026 |     |     /// @param name The name of the ERC20. E.g. "Wrapped ETH"
 1027 |     |     /// @param symbol The symbol of the ERC20. E.g. "WETH"
 1028 |     |     /// @param decimals Decimals of the ERC20. E.g. 18 for WETH and 6 for USDC
 1029 |     |     /// @param valueOracle The address of the Value Oracle. Probably Uniswap one
 1030 |     |     /// @param baseRate The interest rate when utilization is 0
 1031 |     |     /// @param slope1 The interest rate slope when utilization is less than the targetUtilization
 1032 |     |     /// @param slope2 The interest rate slope when utilization is more than the targetUtilization
 1033 |     |     /// @param targetUtilization The target utilization for the asset
 1034 |     |     /// @return the index of the added ERC20 in the erc20Infos array
 1035 |     |     function addERC20Info(
 1036 |     |         address erc20Contract,
 1037 |     |         string calldata name,
 1038 |     |         string calldata symbol,
 1039 |     |         uint8 decimals,
 1040 |     |         address valueOracle,
 1041 |     |         uint256 baseRate,
 1042 |     |         uint256 slope1,
 1043 |     |         uint256 slope2,
 1044 |     |         uint256 targetUtilization
 1045 |     |     ) external override onlyGovernance returns (uint16) {
 1046 |     |         uint16 erc20Idx = uint16(erc20Infos.length);
 1047 |     |         erc20Infos.push(
 1048 |     |             ERC20Info(
 1049 |     |                 erc20Contract,
 1050 |     |                 IERC20ValueOracle(valueOracle),
 1051 |     |                 ERC20Pool(0, 0),
 1052 |     |                 ERC20Pool(0, 0),
 1053 |     |                 baseRate,
 1054 |     |                 slope1,
 1055 |     |                 slope2,
 1056 |     |                 targetUtilization,
 1057 |     |                 block.timestamp
 1058 |     |             )
 1059 |     |         );
 1060 |     |         infoIdx[erc20Contract] = ContractData(erc20Idx, ContractKind.ERC20);
 1061 |     |         emit IDOSConfig.ERC20Added(
 1062 |     |             erc20Idx,
 1063 |     |             erc20Contract,
 1064 |     |             name,
 1065 |     |             symbol,
 1066 |     |             decimals,
 1067 |     |             valueOracle,
 1068 |     |             baseRate,
 1069 |     |             slope1,
 1070 |     |             slope2,
 1071 |     |             targetUtilization
 1072 |     |         );
 1073 |     |         return erc20Idx;
 1074 |     |     }
 1075 |     | 
 1076 |     |     /// @notice Add a new ERC721 to be used inside DOS.
 1077 |     |     /// @dev For governance only.
 1078 |     |     /// @param erc721Contract The address of the ERC721 to be added
 1079 |     |     /// @param valueOracleAddress The address of the Uniswap Oracle to get the price of a token
 1080 |     |     function addERC721Info(
 1081 |     |         address erc721Contract,
 1082 |     |         address valueOracleAddress
 1083 |     |     ) external override onlyGovernance {
 1084 |     |         if (IERC165(erc721Contract).supportsInterface(type(IERC721).interfaceId) == false) {
 1085 |     |             revert NotNFT();
 1086 |     |         }
 1087 |     |         INFTValueOracle valueOracle = INFTValueOracle(valueOracleAddress);
 1088 |     |         uint256 erc721Idx = erc721Infos.length;
 1089 |     |         erc721Infos.push(ERC721Info(erc721Contract, valueOracle));
 1090 |     |         infoIdx[erc721Contract] = ContractData(uint16(erc721Idx), ContractKind.ERC721);
 1091 |     |         emit IDOSConfig.ERC721Added(erc721Idx, erc721Contract, valueOracleAddress);
 1092 |     |     }
 1093 |     | 
 1094 |     |     /// @notice Updates the config of DOS
 1095 |     |     /// @dev for governance only.
 1096 |     |     /// @param _config the Config of IDOSConfig. A struct with DOS parameters
 1097 |     |     function setConfig(Config calldata _config) external override onlyGovernance {
 1098 |     |         config = _config;
 1099 |     |         emit IDOSConfig.ConfigSet(_config);
 1100 |     |     }
 1101 |     | 
 1102 |     |     /// @notice Set the address of Version Manager contract
 1103 |     |     /// @dev for governance only.
 1104 |     |     /// @param _versionManager The address of the Version Manager contract to be set
 1105 |     |     function setVersionManager(address _versionManager) external override onlyGovernance {
 1106 |     |         versionManager = IVersionManager(_versionManager);
 1107 |     |         emit IDOSConfig.VersionManagerSet(_versionManager);
 1108 |     |     }
 1109 |     | 
 1110 |     |     /// @notice Updates some of ERC20 config parameters
 1111 |     |     /// @dev for governance only.
 1112 |     |     /// @param erc20 The address of ERC20 contract for which DOS config parameters should be updated
 1113 |     |     /// @param baseRate The interest rate when utilization is 0
 1114 |     |     /// @param slope1 The interest rate slope when utilization is less than the targetUtilization
 1115 |     |     /// @param slope2 The interest rate slope when utilization is more than the targetUtilization
 1116 |     |     /// @param targetUtilization The target utilization for the asset
 1117 |     |     function setERC20Data(
 1118 |     |         address erc20,
 1119 |     |         uint256 baseRate,
 1120 |     |         uint256 slope1,
 1121 |     |         uint256 slope2,
 1122 |     |         uint256 targetUtilization
 1123 |     |     ) external override onlyGovernance {
 1124 |     |         uint16 erc20Idx = infoIdx[erc20].idx;
 1125 |     |         if (infoIdx[erc20].kind != ContractKind.ERC20) {
 1126 |     |             revert NotERC20();
 1127 |     |         }
 1128 |     |         erc20Infos[erc20Idx].baseRate = baseRate;
 1129 |     |         erc20Infos[erc20Idx].slope1 = slope1;
 1130 |     |         erc20Infos[erc20Idx].slope2 = slope2;
 1131 |     |         erc20Infos[erc20Idx].targetUtilization = targetUtilization;
 1132 |     |         emit IDOSConfig.ERC20DataSet(erc20, baseRate, slope1, slope2, targetUtilization);
 1133 |     |     }
 1134 |     | 
 1135 |     |     /// @notice creates a new dSafe with sender as the owner and returns the dSafe address
 1136 |     |     /// @return dSafe The address of the created dSafe
 1137 |     |     function createDSafe() external override whenNotPaused returns (address dSafe) {
 1138 |     |         _createDSafe(msg.sender);
 1139 |     |    }
 1140 |     | 
 1141 |     |     function _createDSafe(address sender) public returns (address dSafe) {
 1142 |     |         address[] memory erc20s = new address[](erc20Infos.length);
 1143 |     |         for (uint256 i = 0; i < erc20Infos.length; i++) {
 1144 |     |             erc20s[i] = erc20Infos[i].erc20Contract;
 1145 |     |         }
 1146 |     |         address[] memory erc721s = new address[](erc721Infos.length);
 1147 |     |         for (uint256 i = 0; i < erc721Infos.length; i++) {
 1148 |     |             erc721s[i] = erc721Infos[i].erc721Contract;
 1149 |     |         }
 1150 |     | 
 1151 |     |         dSafe = address(new DSafeProxy(address(this), erc20s, erc721s));
 1152 |     |         dSafes[dSafe].owner = sender;
 1153 |     | 
 1154 |     |         // add a version parameter if users should pick a specific version
 1155 |     |         (, , , address implementation, ) = versionManager.getRecommendedVersion();
 1156 |     |         dSafeLogic[dSafe] = implementation;
 1157 |     |         emit IDOSConfig.DSafeCreated(dSafe, sender);
 1158 |     |     }
 1159 |     | 
 1160 |     |     /// @notice Returns the amount of `erc20` tokens on dAccount of dSafe
 1161 |     |     /// @param dSafeAddr The address of the dSafe for which dAccount the amount of `erc20` should
 1162 |     |     /// be calculated
 1163 |     |     /// @param erc20 The address of ERC20 which balance on dAccount of `dSafe` should be calculated
 1164 |     |     /// @return the amount of `erc20` on the dAccount of `dSafe`
 1165 |     |     function getDAccountERC20(
 1166 |     |         address dSafeAddr,
 1167 |     |         IERC20 erc20
 1168 |     |     ) external view override returns (int256) {
 1169 |     |         DSafeLib.DSafe storage dSafe = dSafes[dSafeAddr];
 1170 |     |         (ERC20Info storage erc20Info, uint16 erc20Idx) = getERC20Info(erc20);
 1171 |     |         ERC20Share erc20Share = dSafe.erc20Share[erc20Idx];
 1172 |     |         return getBalance(erc20Share, erc20Info);
 1173 |     |     }
 1174 |     | 
 1175 |     |     /// @notice returns the NFTs on dAccount of `dSafe`
 1176 |     |     /// @param dSafe The address of dSafe which dAccount NFTs should be returned
 1177 |     |     /// @return The array of NFT deposited on the dAccount of `dSafe`
 1178 |     |     function getDAccountERC721(address dSafe) external view override returns (NFTData[] memory) {
 1179 |     |         NFTData[] memory nftData = new NFTData[](dSafes[dSafe].nfts.length);
 1180 |     |         for (uint i = 0; i < nftData.length; i++) {
 1181 |     |             (uint16 erc721Idx, uint256 tokenId) = getNFTData(dSafes[dSafe].nfts[i]);
 1182 |     |             nftData[i] = NFTData(erc721Infos[erc721Idx].erc721Contract, tokenId);
 1183 |     |         }
 1184 |     |         return nftData;
 1185 |     |     }
 1186 |     | }
 1187 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/dos/DSafeProxy.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity ^0.8.17;
   3 |     | 
   4 |     | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   5 |     | import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
   6 |     | import "@openzeppelin/contracts/utils/cryptography/EIP712.sol";
   7 |     | import "@openzeppelin/contracts/proxy/Proxy.sol";
   8 |     | import "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol";
   9 |     | import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
  10 |     | import "@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol";
  11 |     | import "@openzeppelin/contracts/interfaces/IERC1271.sol";
  12 |     | import "../lib/FsUtils.sol";
  13 |     | import "../lib/Call.sol";
  14 |     | import "../lib/ImmutableVersion.sol";
  15 |     | import "../interfaces/IDOS.sol";
  16 |     | import "../interfaces/IVersionManager.sol";
  17 |     | import "../interfaces/ITransferReceiver2.sol";
  18 |     | import "../external/interfaces/IPermit2.sol";
  19 |     | import {ISafe} from "../interfaces/ISafe.sol";
  20 |     | import "./DSafeState.sol";
  21 |     | import "./Liquifier.sol";
  22 |     | import "../interfaces/IERC1363-extended.sol";
  23 |     | import "../lib/NonceMap.sol";
  24 |     | 
  25 |     | /// @title DSafe Proxy
  26 |     | /// @notice Proxy contract for DOS Safes
  27 |     | // Inspired by TransparentUpdatableProxy
  28 |     | contract DSafeProxy is DSafeState, Proxy {
  29 |     |     modifier ifDos() {
  30 |     |         if (msg.sender == address(dos)) {
  31 |     |             _;
  32 |     |         } else {
  33 |     |             _fallback();
  34 |     |         }
  35 |     |     }
  36 |     | 
  37 |     |     constructor(address _dos, address[] memory erc20s, address[] memory erc721s) DSafeState(_dos) {
  38 |     |         // Approve DOS and PERMIT2 to spend all ERC20s
  39 |     |         for (uint256 i = 0; i < erc20s.length; i++) {
  40 |     |             // slither-disable-next-line missing-zero-check
  41 |     |             IERC20 erc20 = IERC20(FsUtils.nonNull(erc20s[i]));
  42 |     |             erc20.approve(_dos, type(uint256).max);
  43 |     |             erc20.approve(address(PERMIT2), type(uint256).max);
  44 |     |             erc20.approve(address(TRANSFER_AND_CALL2), type(uint256).max);
  45 |     |         }
  46 |     |         // Approve DOS to spend all ERC721s
  47 |     |         for (uint256 i = 0; i < erc721s.length; i++) {
  48 |     |             // slither-disable-next-line missing-zero-check
  49 |     |             IERC721 erc721 = IERC721(FsUtils.nonNull(erc721s[i]));
  50 |     |             erc721.setApprovalForAll(_dos, true);
  51 |     |             // Add future uniswap permit for ERC721 support
  52 |     |         }
  53 |     |     }
  54 |     | 
  55 |     |     // Allow ETH transfers
  56 |     |     receive() external payable override {}
  57 |     | 
  58 |     |     // Allow DOS to make arbitrary calls in lieu of this dSafe
  59 |     |     function executeBatch(Call[] calldata calls) external payable ifDos {
  60 |     |         // Function is payable to allow for ETH transfers to the logic
  61 |     |         // contract, but dos should never send eth (dos contract should
  62 |     |         // never contain eth / other than what's self-destructed into it)
  63 |     |         assert(false);
  64 |     |         FsUtils.Assert(msg.value == 0);
  65 |     |         CallLib.executeBatch(calls);
  66 |     |     }
  67 |     | 
  68 |     |     // The implementation of the delegate is controlled by DOS
  69 |     |     function _implementation() internal view override returns (address) {
  70 |     |         return dos.getImplementation(address(this));
  71 |     |     }
  72 |     | }
  73 |     | 
  74 |     | // Calls to the contract not coming from DOS itself are routed to this logic
  75 |     | // contract. This allows for flexible extra addition to your dSafe.
  76 |     | contract DSafeLogic is
  77 |     |     DSafeState,
  78 |     |     ImmutableVersion,
  79 |     |     IERC721Receiver,
  80 |     |     IERC1271,
  81 |     |     ITransferReceiver2,
  82 |     |     EIP712,
  83 |     |     ISafe,
  84 |     |     Liquifier,
  85 |     |     IERC1363SpenderExtended
  86 |     | {
  87 |     |     using NonceMapLib for NonceMap;
  88 |     | 
  89 |     |     bytes private constant EXECUTEBATCH_TYPESTRING =
  90 |     |         "ExecuteBatch(Call[] calls,uint256 nonce,uint256 deadline)";
  91 |     |     bytes private constant TRANSFER_TYPESTRING = "Transfer(address token,uint256 amount)";
  92 |     |     bytes private constant ONTRANSFERRECEIVED2CALL_TYPESTRING =
  93 |     |         "OnTransferReceived2Call(address operator,address from,Transfer[] transfers,Call[] calls,uint256 nonce,uint256 deadline)";
  94 |     | 
  95 |     |     bytes32 private constant EXECUTEBATCH_TYPEHASH =
  96 |     |         keccak256(abi.encodePacked(EXECUTEBATCH_TYPESTRING, CallLib.CALL_TYPESTRING));
  97 |     |     bytes32 private constant TRANSFER_TYPEHASH = keccak256(TRANSFER_TYPESTRING);
  98 |     |     bytes32 private constant ONTRANSFERRECEIVED2CALL_TYPEHASH =
  99 |     |         keccak256(
 100 |     |             abi.encodePacked(
 101 |     |                 ONTRANSFERRECEIVED2CALL_TYPESTRING,
 102 |     |                 CallLib.CALL_TYPESTRING,
 103 |     |                 TRANSFER_TYPESTRING
 104 |     |             )
 105 |     |         );
 106 |     | 
 107 |     |     string private constant VERSION = "1.0.0";
 108 |     | 
 109 |     |     bool internal forwardNFT;
 110 |     |     NonceMap private nonceMap;
 111 |     | 
 112 |     |     error InvalidData();
 113 |     |     error InvalidSignature();
 114 |     |     error NonceAlreadyUsed();
 115 |     |     error DeadlineExpired();
 116 |     | 
 117 |     |     modifier onlyOwner() {
 118 |     |         require(dos.getDSafeOwner(address(this)) == msg.sender, "");
 119 |     |         _;
 120 |     |     }
 121 |     | 
 122 |     |     // Note EIP712 is implemented with immutable variables and is not using
 123 |     |     // storage and thus can be used in a proxy contract constructor.
 124 |     |     // Version number should be in sync with VersionManager version.
 125 |     |     constructor(
 126 |     |         address _dos
 127 |     |     ) EIP712("DOS dSafe", VERSION) ImmutableVersion(VERSION) DSafeState(_dos) {}
 128 |     | 
 129 |     |     /// @notice makes a batch of different calls from the name of dSafe owner. Eventual state of
 130 |     |     /// dAccount and DOS must be solvent, i.e. debt on dAccount cannot exceed collateral on
 131 |     |     /// dAccount and dSafe and DOS reserve/debt must be sufficient
 132 |     |     /// @dev - this goes to dos.executeBatch that would immediately call DSafeProxy.executeBatch
 133 |     |     /// from above of this file
 134 |     |     /// @param calls {address to, bytes callData, uint256 value}[], where
 135 |     |     ///   * to - is the address of the contract whose function should be called
 136 |     |     ///   * callData - encoded function name and it's arguments
 137 |     |     ///   * value - the amount of ETH to sent with the call
 138 |     |     function executeBatch(Call[] memory calls) external payable onlyOwner {
 139 |     |         assert(false);
 140 |     |         bool saveForwardNFT = forwardNFT;
 141 |     |         forwardNFT = false;
 142 |     |         dos.executeBatch(calls);
 143 |     |         forwardNFT = saveForwardNFT;
 144 |     |     }
 145 |     | 
 146 |     |     function executeSignedBatch(
 147 |     |         Call[] memory calls,
 148 |     |         uint256 nonce,
 149 |     |         uint256 deadline,
 150 |     |         bytes calldata signature
 151 |     |     ) external payable {
 152 |     |         if (deadline < block.timestamp) revert DeadlineExpired();
 153 |     |         nonceMap.validateAndUseNonce(nonce);
 154 |     |         bytes32 digest = _hashTypedDataV4(
 155 |     |             keccak256(
 156 |     |                 abi.encode(EXECUTEBATCH_TYPEHASH, CallLib.hashCallArray(calls), nonce, deadline)
 157 |     |             )
 158 |     |         );
 159 |     |         if (
 160 |     |             !SignatureChecker.isValidSignatureNow(
 161 |     |                 dos.getDSafeOwner(address(this)),
 162 |     |                 digest,
 163 |     |                 signature
 164 |     |             )
 165 |     |         ) revert InvalidSignature();
 166 |     | 
 167 |     |         dos.executeBatch(calls);
 168 |     |     }
 169 |     | 
 170 |     |     function forwardNFTs(bool _forwardNFT) external {
 171 |     |         require(msg.sender == address(this), "only this");
 172 |     |         forwardNFT = _forwardNFT;
 173 |     |     }
 174 |     | 
 175 |     |     /// @notice ERC721 transfer callback
 176 |     |     /// @dev it's a callback, required to be implemented by IERC721Receiver interface for the
 177 |     |     /// contract to be able to receive ERC721 NFTs.
 178 |     |     /// we are already using it to support "forwardNFT" of dSafe.
 179 |     |     /// `return this.onERC721Received.selector;` is mandatory part for the NFT transfer to work -
 180 |     |     /// not a part of owr business logic
 181 |     |     /// @param - operator The address which called `safeTransferFrom` function
 182 |     |     /// @param - from The address which previously owned the token
 183 |     |     /// @param tokenId The NFT identifier which is being transferred
 184 |     |     /// @param data Additional data with no specified format
 185 |     |     /// @return `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`
 186 |     |     function onERC721Received(
 187 |     |         address /* operator */,
 188 |     |         address /* from */,
 189 |     |         uint256 tokenId,
 190 |     |         bytes memory data
 191 |     |     ) public virtual override returns (bytes4) {
 192 |     |         if (forwardNFT) {
 193 |     |             IERC721(msg.sender).safeTransferFrom(address(this), address(dos), tokenId, data);
 194 |     |         }
 195 |     |         return this.onERC721Received.selector;
 196 |     |     }
 197 |     | 
 198 |     |     function setNonce(uint256 nonce) external onlyOwner {
 199 |     |         nonceMap.validateAndUseNonce(nonce);
 200 |     |     }
 201 |     | 
 202 |     |     /// @inheritdoc ITransferReceiver2
 203 |     |     function onTransferReceived2(
 204 |     |         address operator,
 205 |     |         address from,
 206 |     |         ITransferReceiver2.Transfer[] calldata transfers,
 207 |     |         bytes calldata data
 208 |     |     ) external override onlyTransferAndCall2 returns (bytes4) {
 209 |     |         // options:
 210 |     |         // 1) just deposit into proxy, nothing to do
 211 |     |         // 2) execute a batch of calls (msg.sender is owner)
 212 |     |         // 3) directly deposit into dos contract
 213 |     |         // 3) execute a signed batch of tx's
 214 |     |         if (data.length == 0) {
 215 |     |             /* just deposit in the proxy, nothing to do */
 216 |     |         } else if (data[0] == 0x00) {
 217 |     |             // execute batch
 218 |     |             require(msg.sender == dos.getDSafeOwner(address(this)), "Not owner");
 219 |     |             Call[] memory calls = abi.decode(data[1:], (Call[]));
 220 |     |             dos.executeBatch(calls);
 221 |     |         } else if (data[0] == 0x01) {
 222 |     |             require(data.length == 1, "Invalid data - allowed are [], [0...], [1] and [2]");
 223 |     |             // deposit in the dos dSafe
 224 |     |             for (uint256 i = 0; i < transfers.length; i++) {
 225 |     |                 ITransferReceiver2.Transfer memory transfer = transfers[i];
 226 |     |                 dos.depositERC20(IERC20(transfer.token), transfer.amount);
 227 |     |             }
 228 |     |         } else if (data[0] == 0x02) {
 229 |     |             // execute signed batch
 230 |     | 
 231 |     |             // Verify signature matches
 232 |     |             (Call[] memory calls, uint256 nonce, uint256 deadline, bytes memory signature) = abi
 233 |     |                 .decode(data[1:], (Call[], uint256, uint256, bytes));
 234 |     | 
 235 |     |             if (deadline < block.timestamp) revert DeadlineExpired();
 236 |     |             nonceMap.validateAndUseNonce(nonce);
 237 |     | 
 238 |     |             bytes32[] memory transferDigests = new bytes32[](transfers.length);
 239 |     |             for (uint256 i = 0; i < transfers.length; i++) {
 240 |     |                 transferDigests[i] = keccak256(
 241 |     |                     abi.encode(TRANSFER_TYPEHASH, transfers[i].token, transfers[i].amount)
 242 |     |                 );
 243 |     |             }
 244 |     |             bytes32 digest = _hashTypedDataV4(
 245 |     |                 keccak256(
 246 |     |                     abi.encode(
 247 |     |                         ONTRANSFERRECEIVED2CALL_TYPEHASH,
 248 |     |                         operator,
 249 |     |                         from,
 250 |     |                         keccak256(abi.encodePacked(transferDigests)),
 251 |     |                         CallLib.hashCallArray(calls),
 252 |     |                         nonce,
 253 |     |                         deadline
 254 |     |                     )
 255 |     |                 )
 256 |     |             );
 257 |     |             if (
 258 |     |                 !SignatureChecker.isValidSignatureNow(
 259 |     |                     dos.getDSafeOwner(address(this)),
 260 |     |                     digest,
 261 |     |                     signature
 262 |     |                 )
 263 |     |             ) revert InvalidSignature();
 264 |     | 
 265 |     |             dos.executeBatch(calls);
 266 |     |         } else {
 267 |     |             revert("Invalid data - allowed are '', '0x00...', '0x01' and '0x02...'");
 268 |     |         }
 269 |     |         return ITransferReceiver2.onTransferReceived2.selector;
 270 |     |     }
 271 |     | 
 272 |     |     function onApprovalReceived(
 273 |     |         address sender,
 274 |     |         uint256 amount,
 275 |     |         Call memory call
 276 |     |     ) external returns (bytes4) {
 277 |     |         if (call.callData.length == 0) {
 278 |     |             revert("PL: INVALID_DATA");
 279 |     |         }
 280 |     |         emit TokensApproved(sender, amount, call.callData);
 281 |     | 
 282 |     |         Call[] memory calls = new Call[](1);
 283 |     |         calls[0] = call;
 284 |     | 
 285 |     |         dos.executeBatch(calls);
 286 |     | 
 287 |     |         return this.onApprovalReceived.selector;
 288 |     |     }
 289 |     | 
 290 |     |     function owner() external view returns (address) {
 291 |     |         return dos.getDSafeOwner(address(this));
 292 |     |     }
 293 |     | 
 294 |     |     /// @inheritdoc IERC1271
 295 |     |     function isValidSignature(
 296 |     |         bytes32 hash,
 297 |     |         bytes memory signature
 298 |     |     ) public view override returns (bytes4 magicValue) {
 299 |     |         magicValue = SignatureChecker.isValidSignatureNow(
 300 |     |             dos.getDSafeOwner(address(this)),
 301 |     |             hash,
 302 |     |             signature
 303 |     |         )
 304 |     |             ? this.isValidSignature.selector
 305 |     |             : bytes4(0);
 306 |     |     }
 307 |     | 
 308 |     |     function valueNonce(uint256 nonce) external view returns (bool) {
 309 |     |         return nonceMap.getNonce(nonce);
 310 |     |     }
 311 |     | }
 312 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/dos/DSafeState.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.17;
  3 |     | 
  4 |     | import "../interfaces/IDOS.sol";
  5 |     | import "../lib/FsUtils.sol";
  6 |     | 
  7 |     | /// @title the state part of the DSafeLogic. A parent to all contracts that form dSafe
  8 |     | /// @dev the contract is abstract because it is not expected to be used separately from dSafe
  9 |     | abstract contract DSafeState {
 10 |     |     /// @dev DOS instance to be used by all other dSafe contracts
 11 |     |     IDOS public immutable dos;
 12 |     | 
 13 |     |     /// @param _dos - address of a deployed DOS contract
 14 |     |     constructor(address _dos) {
 15 |     |         // slither-disable-next-line missing-zero-check
 16 |     |         dos = IDOS(FsUtils.nonNull(_dos));
 17 |     |     }
 18 |     | }
 19 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/dos/Liquifier.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity ^0.8.17;
   3 |     | 
   4 |     | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   5 |     | import "@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol";
   6 |     | import "../external/interfaces/INonfungiblePositionManager.sol";
   7 |     | import "../interfaces/IDOS.sol";
   8 |     | import "./DSafeState.sol";
   9 |     | 
  10 |     | struct SqrtPricePriceRangeX96 {
  11 |     |     uint160 minSell;
  12 |     |     uint160 maxBuy;
  13 |     | }
  14 |     | 
  15 |     | /// @title Logic for liquify functionality of dSafe
  16 |     | /// @dev It is designed to be an extension for dSafeLogic contract.
  17 |     | /// Functionally, it's a part of the dSafeLogic contract, but has been extracted into a separate
  18 |     | /// contract for better code structuring. This is why the contract is declared as abstract
  19 |     | ///   The only function it exports is `liquify`. The rest are private function that are parts of
  20 |     | /// `liquify`
  21 |     | abstract contract Liquifier is DSafeState {
  22 |     |     modifier selfOrDSafeOwner() {
  23 |     |         require(
  24 |     |             msg.sender == address(this) || msg.sender == dos.getDSafeOwner(address(this)),
  25 |     |             "only self or owner"
  26 |     |         );
  27 |     |         _;
  28 |     |     }
  29 |     | 
  30 |     |     /// @notice Advanced version of liquidate function. Potentially unwanted side-affect of
  31 |     |     /// liquidation is a debt on the liquidator. So liquify would liquidate and then re-balance
  32 |     |     /// obtained assets to have no debt. This is the algorithm:
  33 |     |     ///   * liquidate dAccount of target `dSafe`
  34 |     |     ///   * terminate all obtained ERC721s (NFTs)
  35 |     |     ///   * buy/sell `erc20s` for `numeraire` so the balance of `dSafe` on that ERC20s matches the
  36 |     |     ///     debt of `dSafe` on it's dAccount. E.g.:
  37 |     |     ///     - for 1 WETH of debt on dAccount and 3 WETH on the balance of dSafe - sell 2 WETH
  38 |     |     ///     - for 3 WETH of debt on dAccount and 1 WETH on the balance of dSafe - buy 2 WETH
  39 |     |     ///     - for no debt on dAccount and 1 WETH on the balance of dSafe - sell 2 WETH
  40 |     |     ///     - for 1 WETH of debt on dAccount and no WETH on the balance of dSave - buy 1 WETH
  41 |     |     ///   * deposit `erc20s` and `numeraire` to cover debts
  42 |     |     ///
  43 |     |     /// !! IMPORTANT: because this function executes quite a lot of logic on top of DOS.liquidate(),
  44 |     |     /// there is a risk that for liquidatable position with a long list of NFTs it will run out
  45 |     |     /// of gas. As for now, it's up to liquidator to estimate if specific position is liquifiable,
  46 |     |     /// or DOS.liquidate() need to be used (with further assets re-balancing in other transactions)
  47 |     |     /// @dev notes on erc20s: the reason for erc20s been a call parameter, and not been calculated
  48 |     |     /// inside of liquify, is reducing gas costs
  49 |     |     ///   erc20s should NOT include numeraire. Otherwise, the transaction would be reverted with an
  50 |     |     /// error from uniswap router
  51 |     |     ///   It's the responsibility of caller to provide the correct list of erc20s. Assets
  52 |     |     /// re-balancing would be performed only by this list of tokens and numeraire.
  53 |     |     ///   * if erc20s misses a token that liquidatable have debt on - the debt on this erc20 would
  54 |     |     ///     persist on liquidator's dAccount as-is
  55 |     |     ///   * if erc20s misses a token that liquidatable have collateral on - the token would persist
  56 |     |     ///     on liquidator's dAccount. It may result in generating debt in numeraire on liquidator
  57 |     |     ///     dAccount by the end of liquify (because the token would not be soled for numeraire,
  58 |     |     ///     there may not be enough numeraire to buy tokens to cover debts, and so they will be
  59 |     |     ///     bought in debt)
  60 |     |     ///   * if erc20s misses a token that would be obtained as the result of NFT termination - same
  61 |     |     ///     as previous, except of the token to be persisted on dSafe instead of dAccount of
  62 |     |     ///     liquidator
  63 |     |     ///   Because no buy/sell would be done for prices from outside of the erc20sAllowedPriceRanges,
  64 |     |     /// too narrow range may result in not having enough of some ERC20 to cover the debt. So the
  65 |     |     /// eventual state would still include some debt
  66 |     |     /// @param dSafe - the address of a dSafe to liquidate
  67 |     |     /// @param swapRouter - the address of a Uniswap swap router to be used to buy/sell erc20s
  68 |     |     /// @param nftManager - the address of a Uniswap NonFungibleTokenManager to be used to terminate
  69 |     |     /// ERC721 (NFTs)
  70 |     |     /// @param numeraire - the address of an ERC20 to be used to convert to and from erc20s. The
  71 |     |     /// liquidation reward would be in this token
  72 |     |     /// @param erc20s - the list of ERC20 that liquidated has debt, collateral or that would be
  73 |     |     /// obtained from termination of any ERC721 that he owns. Except of numeraire, that should
  74 |     |     /// never be included in erc20s array
  75 |     |     /// @param erc20sAllowedPriceRanges - the list of root squares of allowed prices in Q96 for
  76 |     |     /// `erc20s` swaps on Uniswap in `numeraire`. This is the protection against sandwich-attack -
  77 |     |     /// if the price would be lower/higher for sell/buy
  78 |     |     ///   It's up to liquidator to decide what range is acceptable. +/- 1% of price before liquify
  79 |     |     /// call seems to be reasonable
  80 |     |     ///   Zero minSell/maxBuy value for a specific ERC20 would disable the corresponding check
  81 |     |     /// Uniswap docs - https://docs.uniswap.org/contracts/v3/guides/swaps/single-swaps
  82 |     |     /// It doesn't explained in Uniswap docs, but this is how it actually works:
  83 |     |     /// * if the price for each token would be below the specified limit
  84 |     |     /// then full amount would be converted and no error would be thrown
  85 |     |     /// * if at least some amount of tokens can be bought by the price that is below the limit
  86 |     |     /// then only that amount of tokens would be bought and no error would be thrown
  87 |     |     /// * if no tokens can be bought by the price below the limit
  88 |     |     /// then error would be thrown with message "SPL"
  89 |     |     function liquify(
  90 |     |         address dSafe,
  91 |     |         address swapRouter,
  92 |     |         address nftManager,
  93 |     |         address numeraire,
  94 |     |         IERC20[] calldata erc20s,
  95 |     |         SqrtPricePriceRangeX96[] calldata erc20sAllowedPriceRanges
  96 |     |     ) external selfOrDSafeOwner {
  97 |     |         if (msg.sender != address(this)) {
  98 |     |             /* prettier-ignore */ // list of liquify arguments as-is
  99 |     |             return callOverBatchExecute(dSafe, swapRouter, nftManager, numeraire, erc20s, erc20sAllowedPriceRanges);
 100 |     |         }
 101 |     | 
 102 |     |         dos.liquidate(dSafe);
 103 |     | 
 104 |     |         (
 105 |     |             IERC20[] memory erc20sCollateral,
 106 |     |             uint256[] memory erc20sDebtAmounts
 107 |     |         ) = analyseDAccountStructure(erc20s, numeraire);
 108 |     | 
 109 |     |         dos.withdrawFull(erc20sCollateral);
 110 |     |         terminateERC721s(nftManager);
 111 |     | 
 112 |     |         (
 113 |     |             uint256[] memory erc20sToSellAmounts,
 114 |     |             uint256[] memory erc20sToBuyAmounts
 115 |     |         ) = calcSellAndBuyERC20Amounts(erc20s, erc20sDebtAmounts);
 116 |     |         sellERC20s(swapRouter, erc20s, erc20sToSellAmounts, numeraire, erc20sAllowedPriceRanges);
 117 |     |         buyERC20s(swapRouter, erc20s, erc20sToBuyAmounts, numeraire, erc20sAllowedPriceRanges);
 118 |     | 
 119 |     |         deposit(erc20s, numeraire);
 120 |     |     }
 121 |     | 
 122 |     |     function callOverBatchExecute(
 123 |     |         address dSafe,
 124 |     |         address swapRouter,
 125 |     |         address nftManager,
 126 |     |         address numeraire,
 127 |     |         IERC20[] calldata erc20s,
 128 |     |         SqrtPricePriceRangeX96[] calldata erc20sAllowedPriceRanges
 129 |     |     ) private {
 130 |     |         Call[] memory calls = new Call[](1);
 131 |     |         calls[0] = Call({
 132 |     |             to: address(this),
 133 |     |             callData: abi.encodeWithSelector(
 134 |     |                 this.liquify.selector,
 135 |     |                 dSafe,
 136 |     |                 swapRouter,
 137 |     |                 nftManager,
 138 |     |                 numeraire,
 139 |     |                 erc20s,
 140 |     |                 erc20sAllowedPriceRanges
 141 |     |             ),
 142 |     |             value: 0
 143 |     |         });
 144 |     |         dos.executeBatch(calls);
 145 |     |     }
 146 |     | 
 147 |     |     /// @param nftManager - passed as-is from liquify function. The address of a Uniswap
 148 |     |     ///   NonFungibleTokenManager to be used to terminate ERC721 (NFTs)
 149 |     |     function terminateERC721s(address nftManager) private {
 150 |     |         INonfungiblePositionManager manager = INonfungiblePositionManager(nftManager);
 151 |     |         IDOS.NFTData[] memory nfts = dos.getDAccountERC721(address(this));
 152 |     |         for (uint256 i = 0; i < nfts.length; i++) {
 153 |     |             IDOS.NFTData memory nft = nfts[i];
 154 |     |             dos.withdrawERC721(nft.erc721, nft.tokenId);
 155 |     |             (, , , , , , , uint128 nftLiquidity, , , , ) = manager.positions(nft.tokenId);
 156 |     |             manager.decreaseLiquidity(
 157 |     |                 INonfungiblePositionManager.DecreaseLiquidityParams({
 158 |     |                     tokenId: nft.tokenId,
 159 |     |                     liquidity: nftLiquidity,
 160 |     |                     amount0Min: 0,
 161 |     |                     amount1Min: 0,
 162 |     |                     deadline: type(uint256).max
 163 |     |                 })
 164 |     |             );
 165 |     |             manager.collect(
 166 |     |                 INonfungiblePositionManager.CollectParams({
 167 |     |                     tokenId: nft.tokenId,
 168 |     |                     recipient: address(this),
 169 |     |                     amount0Max: type(uint128).max,
 170 |     |                     amount1Max: type(uint128).max
 171 |     |                 })
 172 |     |             );
 173 |     | 
 174 |     |             manager.burn(nft.tokenId);
 175 |     |         }
 176 |     |     }
 177 |     | 
 178 |     |     function analyseDAccountStructure(
 179 |     |         IERC20[] calldata erc20s,
 180 |     |         address numeraire
 181 |     |     ) private view returns (IERC20[] memory erc20sCollateral, uint256[] memory erc20sDebtAmounts) {
 182 |     |         uint256 numOfERC20sCollateral = 0;
 183 |     |         int256[] memory balances = new int256[](erc20s.length);
 184 |     | 
 185 |     |         for (uint256 i = 0; i < erc20s.length; i++) {
 186 |     |             int256 balance = dos.getDAccountERC20(address(this), erc20s[i]);
 187 |     |             if (balance > 0) {
 188 |     |                 numOfERC20sCollateral++;
 189 |     |                 balances[i] = balance;
 190 |     |             } else if (balance < 0) {
 191 |     |                 balances[i] = balance;
 192 |     |             }
 193 |     |         }
 194 |     | 
 195 |     |         int256 dAccountNumeraireBalance = dos.getDAccountERC20(address(this), IERC20(numeraire));
 196 |     |         if (dAccountNumeraireBalance > 0) {
 197 |     |             numOfERC20sCollateral++;
 198 |     |         }
 199 |     | 
 200 |     |         erc20sCollateral = new IERC20[](numOfERC20sCollateral);
 201 |     |         erc20sDebtAmounts = new uint256[](erc20s.length);
 202 |     | 
 203 |     |         if (dAccountNumeraireBalance > 0) {
 204 |     |             erc20sCollateral[0] = IERC20(numeraire);
 205 |     |         }
 206 |     | 
 207 |     |         for (uint256 i = 0; i < erc20s.length; i++) {
 208 |     |             if (balances[i] > 0) {
 209 |     |                 erc20sCollateral[--numOfERC20sCollateral] = erc20s[i];
 210 |     |             } else if (balances[i] < 0) {
 211 |     |                 erc20sDebtAmounts[i] = uint256(-balances[i]);
 212 |     |             }
 213 |     |         }
 214 |     |     }
 215 |     | 
 216 |     |     function calcSellAndBuyERC20Amounts(
 217 |     |         IERC20[] calldata erc20s,
 218 |     |         uint256[] memory erc20sDebtAmounts
 219 |     |     )
 220 |     |         private
 221 |     |         view
 222 |     |         returns (uint256[] memory erc20ToSellAmounts, uint256[] memory erc20ToBuyAmounts)
 223 |     |     {
 224 |     |         erc20ToBuyAmounts = new uint256[](erc20s.length);
 225 |     |         erc20ToSellAmounts = new uint256[](erc20s.length);
 226 |     | 
 227 |     |         for (uint256 i = 0; i < erc20s.length; i++) {
 228 |     |             uint256 balance = erc20s[i].balanceOf(address(this));
 229 |     |             if (balance > erc20sDebtAmounts[i]) {
 230 |     |                 erc20ToSellAmounts[i] = balance - erc20sDebtAmounts[i];
 231 |     |             } else if (balance < erc20sDebtAmounts[i]) {
 232 |     |                 erc20ToBuyAmounts[i] = erc20sDebtAmounts[i] - balance;
 233 |     |             }
 234 |     |         }
 235 |     |     }
 236 |     | 
 237 |     |     function sellERC20s(
 238 |     |         address swapRouter,
 239 |     |         IERC20[] memory erc20sToSell,
 240 |     |         uint256[] memory amountsToSell,
 241 |     |         address erc20ToSellFor,
 242 |     |         SqrtPricePriceRangeX96[] calldata erc20sAllowedPriceRanges
 243 |     |     ) private {
 244 |     |         for (uint256 i = 0; i < erc20sToSell.length; i++) {
 245 |     |             if (amountsToSell[i] == 0) continue;
 246 |     | 
 247 |     |             ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({
 248 |     |                 tokenIn: address(erc20sToSell[i]),
 249 |     |                 tokenOut: erc20ToSellFor,
 250 |     |                 fee: 500,
 251 |     |                 recipient: address(this),
 252 |     |                 deadline: type(uint256).max, // ignore - total transaction type should be limited at DOS level
 253 |     |                 amountIn: amountsToSell[i],
 254 |     |                 amountOutMinimum: 0,
 255 |     |                 // see comments on `erc20sAllowedPriceRanges` parameter of `liquify`
 256 |     |                 sqrtPriceLimitX96: erc20sAllowedPriceRanges[i].minSell
 257 |     |             });
 258 |     | 
 259 |     |             try ISwapRouter(swapRouter).exactInputSingle(params) {} catch Error(
 260 |     |                 string memory reason
 261 |     |             ) {
 262 |     |                 // "SPL" means that proposed sell price is too low. If so - silently skip conversion.
 263 |     |                 // For any other error - revert
 264 |     |                 // Consider emitting or logging
 265 |     |                 // Consider ignoring some other errors if it's appropriate
 266 |     |                 // Consider replacing with `Strings.equal` on OpenZeppelin next release
 267 |     |                 if (keccak256(abi.encodePacked(reason)) != keccak256(abi.encodePacked("SPL"))) {
 268 |     |                     revert(reason);
 269 |     |                 }
 270 |     |             }
 271 |     |         }
 272 |     |     }
 273 |     | 
 274 |     |     function buyERC20s(
 275 |     |         address swapRouter,
 276 |     |         IERC20[] memory erc20sToBuy,
 277 |     |         uint256[] memory amountsToBuy,
 278 |     |         address erc20ToBuyFor,
 279 |     |         SqrtPricePriceRangeX96[] calldata erc20sAllowedPriceRanges
 280 |     |     ) private {
 281 |     |         for (uint256 i = 0; i < erc20sToBuy.length; i++) {
 282 |     |             if (amountsToBuy[i] == 0) continue;
 283 |     | 
 284 |     |             ISwapRouter.ExactOutputSingleParams memory params = ISwapRouter
 285 |     |                 .ExactOutputSingleParams({
 286 |     |                     tokenIn: erc20ToBuyFor,
 287 |     |                     tokenOut: address(erc20sToBuy[i]),
 288 |     |                     fee: 500,
 289 |     |                     recipient: address(this),
 290 |     |                     deadline: type(uint256).max, // ignore - total transaction type should be limited at DOS level
 291 |     |                     amountOut: amountsToBuy[i],
 292 |     |                     amountInMaximum: type(uint256).max,
 293 |     |                     // see comments on `erc20sAllowedPriceRanges` parameter of `liquify`
 294 |     |                     sqrtPriceLimitX96: erc20sAllowedPriceRanges[i].maxBuy
 295 |     |                 });
 296 |     | 
 297 |     |             try ISwapRouter(swapRouter).exactOutputSingle(params) {} catch Error(
 298 |     |                 string memory reason
 299 |     |             ) {
 300 |     |                 // "SPL" means that proposed buy price is too high. If so - silently skip conversion.
 301 |     |                 // For any other error - revert
 302 |     |                 // Consider emitting or logging
 303 |     |                 // Consider ignoring some other errors if it's appropriate
 304 |     |                 // Consider replacing with `Strings.equal` on OpenZeppelin next release
 305 |     |                 if (keccak256(abi.encodePacked(reason)) != keccak256(abi.encodePacked("SPL"))) {
 306 |     |                     revert(reason);
 307 |     |                 }
 308 |     |             }
 309 |     |         }
 310 |     |     }
 311 |     | 
 312 |     |     function deposit(IERC20[] memory erc20s, address numeraire) private {
 313 |     |         dos.depositFull(erc20s);
 314 |     |         IERC20[] memory numeraireArray = new IERC20[](1);
 315 |     |         numeraireArray[0] = IERC20(numeraire);
 316 |     |         dos.depositFull(numeraireArray);
 317 |     |     }
 318 |     | }
 319 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/dos/TransferAndCall2.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity ^0.8.17;
   3 |     | 
   4 |     | import "@openzeppelin/contracts/utils/cryptography/EIP712.sol";
   5 |     | import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
   6 |     | import "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol";
   7 |     | import "@openzeppelin/contracts/utils/Address.sol";
   8 |     | import "@openzeppelin/contracts/interfaces/IERC1363Receiver.sol";
   9 |     | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  10 |     | import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
  11 |     | import "../external/interfaces/IWETH9.sol";
  12 |     | import "../interfaces/ITransferReceiver2.sol";
  13 |     | import "../lib/NonceMap.sol";
  14 |     | 
  15 |     | // Bringing ERC1363 to all tokens, it's to ERC1363 what Permit2 is to ERC2612.
  16 |     | // This should be proposed as an EIP and should be deployed cross chain on
  17 |     | // fixed address using AnyswapCreate2Deployer.
  18 |     | contract TransferAndCall2 is IERC1363Receiver, EIP712 {
  19 |     |     using Address for address;
  20 |     |     using SafeERC20 for IERC20;
  21 |     |     using NonceMapLib for NonceMap;
  22 |     | 
  23 |     |     bytes private constant TRANSFER_TYPESTRING = "Transfer(address token,uint256 amount)";
  24 |     |     bytes private constant PERMIT_TYPESTRING =
  25 |     |         "Permit(address receiver,Transfer[] transfers,bytes data,uint256 nonce,uint256 deadline)";
  26 |     |     bytes32 private constant TRANSFER_TYPEHASH = keccak256(TRANSFER_TYPESTRING);
  27 |     |     bytes32 private constant PERMIT_TYPEHASH =
  28 |     |         keccak256(abi.encodePacked(PERMIT_TYPESTRING, TRANSFER_TYPESTRING));
  29 |     | 
  30 |     |     mapping(address => mapping(address => bool)) public approvalByOwnerByOperator;
  31 |     |     mapping(address => NonceMap) private nonceMap;
  32 |     | 
  33 |     |     error onTransferReceivedFailed(
  34 |     |         address to,
  35 |     |         address operator,
  36 |     |         address from,
  37 |     |         ITransferReceiver2.Transfer[] transfers,
  38 |     |         bytes data
  39 |     |     );
  40 |     | 
  41 |     |     error TransfersUnsorted();
  42 |     | 
  43 |     |     error EthDoesntMatchWethTransfer();
  44 |     | 
  45 |     |     error UnauthorizedOperator(address operator, address from);
  46 |     | 
  47 |     |     constructor() EIP712("TransferAndCall2", "1") {}
  48 |     | 
  49 |     |     /// @dev Set approval for all token transfers from msg.sender to a particular operator
  50 |     |     function setApprovalForAll(address operator, bool approved) external {
  51 |     |         approvalByOwnerByOperator[msg.sender][operator] = approved;
  52 |     |     }
  53 |     | 
  54 |     |     /// @dev Called by a token to indicate a transfer into the callee
  55 |     |     /// @param receiver The account to sent the tokens
  56 |     |     /// @param transfers Transfers that have been made
  57 |     |     /// @param data The extra data being passed to the receiving contract
  58 |     |     function transferAndCall2(
  59 |     |         address receiver,
  60 |     |         ITransferReceiver2.Transfer[] calldata transfers,
  61 |     |         bytes calldata data
  62 |     |     ) external {
  63 |     |         return transferFromAndCall2Impl(msg.sender, receiver, address(0), transfers, data);
  64 |     |     }
  65 |     | 
  66 |     |     /// @dev Called by a token to indicate a transfer into the callee, converting ETH to WETH
  67 |     |     /// @param receiver The account to sent the tokens
  68 |     |     /// @param weth The WETH9 contract address
  69 |     |     /// @param transfers Transfers that have been made
  70 |     |     /// @param data The extra data being passed to the receiving contract
  71 |     |     function transferAndCall2WithValue(
  72 |     |         address receiver,
  73 |     |         address weth,
  74 |     |         ITransferReceiver2.Transfer[] calldata transfers,
  75 |     |         bytes calldata data
  76 |     |     ) external payable {
  77 |     |         return transferFromAndCall2Impl(msg.sender, receiver, weth, transfers, data);
  78 |     |     }
  79 |     | 
  80 |     |     /// @dev Called by a token to indicate a transfer into the callee
  81 |     |     /// @param from The account that has sent the tokens
  82 |     |     /// @param receiver The account to sent the tokens
  83 |     |     /// @param transfers Transfers that have been made
  84 |     |     /// @param data The extra data being passed to the receiving contract
  85 |     |     function transferFromAndCall2(
  86 |     |         address from,
  87 |     |         address receiver,
  88 |     |         ITransferReceiver2.Transfer[] calldata transfers,
  89 |     |         bytes calldata data
  90 |     |     ) external {
  91 |     |         if (!approvalByOwnerByOperator[from][msg.sender]) {
  92 |     |             revert UnauthorizedOperator(msg.sender, from);
  93 |     |         }
  94 |     |         return transferFromAndCall2Impl(from, receiver, address(0), transfers, data);
  95 |     |     }
  96 |     | 
  97 |     |     function transferAndCall2WithPermit(
  98 |     |         address from,
  99 |     |         address receiver,
 100 |     |         ITransferReceiver2.Transfer[] calldata transfers,
 101 |     |         bytes calldata data,
 102 |     |         uint256 nonce,
 103 |     |         uint256 deadline,
 104 |     |         bytes calldata signature
 105 |     |     ) external {
 106 |     |         nonceMap[from].validateAndUseNonce(nonce);
 107 |     |         require(block.timestamp <= deadline, "Expired permit");
 108 |     |         bytes32[] memory transferHashes = new bytes32[](transfers.length);
 109 |     |         for (uint256 i = 0; i < transfers.length; i++) {
 110 |     |             transferHashes[i] = keccak256(
 111 |     |                 abi.encodePacked(TRANSFER_TYPEHASH, transfers[i].token, transfers[i].amount)
 112 |     |             );
 113 |     |         }
 114 |     |         bytes32 digest = _hashTypedDataV4(
 115 |     |             keccak256(
 116 |     |                 abi.encode(
 117 |     |                     PERMIT_TYPEHASH,
 118 |     |                     receiver,
 119 |     |                     keccak256(abi.encodePacked(transferHashes)),
 120 |     |                     data,
 121 |     |                     nonce,
 122 |     |                     deadline
 123 |     |                 )
 124 |     |             )
 125 |     |         );
 126 |     |         require(SignatureChecker.isValidSignatureNow(from, digest, signature), "Invalid signature");
 127 |     |         return transferFromAndCall2Impl(from, receiver, address(0), transfers, data);
 128 |     |     }
 129 |     | 
 130 |     |     /// @notice Callback for ERC1363 transferAndCall
 131 |     |     /// @param _operator The address which called `transferAndCall` function
 132 |     |     /// @param _from The address which previously owned the token
 133 |     |     /// @param _amount The amount of tokens being transferred
 134 |     |     /// @param _data Additional data containing the receiver address and the extra data
 135 |     |     function onTransferReceived(
 136 |     |         address _operator,
 137 |     |         address _from,
 138 |     |         uint256 _amount,
 139 |     |         bytes calldata _data
 140 |     |     ) external override returns (bytes4) {
 141 |     |         (address to, bytes memory decodedData) = abi.decode(_data, (address, bytes));
 142 |     |         ITransferReceiver2.Transfer[] memory transfers = new ITransferReceiver2.Transfer[](1);
 143 |     |         transfers[0] = ITransferReceiver2.Transfer(msg.sender, _amount);
 144 |     |         callOnTransferReceived2(to, _operator, _from, transfers, decodedData);
 145 |     |         return IERC1363Receiver.onTransferReceived.selector;
 146 |     |     }
 147 |     | 
 148 |     |     function transferFromAndCall2Impl(
 149 |     |         address from,
 150 |     |         address receiver,
 151 |     |         address weth,
 152 |     |         ITransferReceiver2.Transfer[] calldata transfers,
 153 |     |         bytes memory data
 154 |     |     ) internal {
 155 |     |         uint256 ethAmount = msg.value;
 156 |     |         if (ethAmount != 0) {
 157 |     |             IWETH9(payable(weth)).deposit{value: msg.value}();
 158 |     |             IERC20(weth).safeTransfer(receiver, msg.value);
 159 |     |         }
 160 |     |         address prev = address(0);
 161 |     |         for (uint256 i = 0; i < transfers.length; i++) {
 162 |     |             address tokenAddress = transfers[i].token;
 163 |     |             if (prev >= tokenAddress) revert TransfersUnsorted();
 164 |     |             prev = tokenAddress;
 165 |     |             uint256 amount = transfers[i].amount;
 166 |     |             if (tokenAddress == weth) {
 167 |     |                 // Already send WETH
 168 |     |                 amount -= ethAmount; // reverts if msg.value > amount
 169 |     |                 ethAmount = 0;
 170 |     |             }
 171 |     |             IERC20 token = IERC20(tokenAddress);
 172 |     |             if (amount > 0) token.safeTransferFrom(from, receiver, amount);
 173 |     |         }
 174 |     |         if (ethAmount != 0) revert EthDoesntMatchWethTransfer();
 175 |     |         if (receiver.isContract()) {
 176 |     |             callOnTransferReceived2(receiver, msg.sender, from, transfers, data);
 177 |     |         }
 178 |     |     }
 179 |     | 
 180 |     |     function callOnTransferReceived2(
 181 |     |         address to,
 182 |     |         address operator,
 183 |     |         address from,
 184 |     |         ITransferReceiver2.Transfer[] memory transfers,
 185 |     |         bytes memory data
 186 |     |     ) internal {
 187 |     |         if (
 188 |     |             ITransferReceiver2(to).onTransferReceived2(operator, from, transfers, data) !=
 189 |     |             ITransferReceiver2.onTransferReceived2.selector
 190 |     |         ) {
 191 |     |             revert onTransferReceivedFailed(to, operator, from, transfers, data);
 192 |     |         }
 193 |     |     }
 194 |     | }
 195 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/dos/VersionManager.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity ^0.8.17;
   3 |     | 
   4 |     | // Inspired by the following contract: https://github.com/OpenBazaar/smart-contracts/blob/22d3f190163102f9ceee95ac705001c82ca55624/contracts/registry/ContractManager.sol
   5 |     | 
   6 |     | import "@openzeppelin/contracts/utils/Address.sol";
   7 |     | import {FsUtils} from "../lib/FsUtils.sol";
   8 |     | import {ImmutableGovernance} from "../lib/ImmutableGovernance.sol";
   9 |     | import {ImmutableVersion} from "../lib/ImmutableVersion.sol";
  10 |     | import "../interfaces/IVersionManager.sol";
  11 |     | 
  12 |     | /// @title DOS Version Manager
  13 |     | contract VersionManager is IVersionManager, ImmutableGovernance {
  14 |     |     /// @notice Array of all version names
  15 |     |     string[] internal _versionString;
  16 |     | 
  17 |     |     /// @notice Mapping from version names to version structs
  18 |     |     mapping(string => Version) internal _versions;
  19 |     | 
  20 |     |     /// @dev The recommended version
  21 |     |     string internal _recommendedVersion;
  22 |     | 
  23 |     |     modifier versionExists(string memory versionName) {
  24 |     |         if (_versions[versionName].implementation == address(0)) {
  25 |     |             revert VersionNotRegistered();
  26 |     |         }
  27 |     |         _;
  28 |     |     }
  29 |     | 
  30 |     |     modifier validStatus(Status status) {
  31 |     |         require(uint8(status) <= uint8(Status.DEPRECATED), "Invalid status");
  32 |     |         _;
  33 |     |     }
  34 |     | 
  35 |     |     modifier validBugLevel(BugLevel bugLevel) {
  36 |     |         require(uint8(bugLevel) <= uint8(BugLevel.CRITICAL), "Invalid bug level");
  37 |     |         _;
  38 |     |     }
  39 |     | 
  40 |     |     constructor(address _owner) ImmutableGovernance(_owner) {}
  41 |     | 
  42 |     |     /// @notice Registers a new version of the store contract
  43 |     |     /// @param status Status of the version to be added
  44 |     |     /// @param _implementation The address of the implementation of the version
  45 |     |     function addVersion(
  46 |     |         Status status,
  47 |     |         address _implementation
  48 |     |     ) external onlyGovernance validStatus(status) {
  49 |     |         address implementation = FsUtils.nonNull(_implementation);
  50 |     |         // implementation must be a contract
  51 |     |         if (!Address.isContract(implementation)) {
  52 |     |             revert InvalidImplementation();
  53 |     |         }
  54 |     | 
  55 |     |         string memory versionName = "";
  56 |     |         try ImmutableVersion(implementation).immutableVersion() returns (bytes32 immutableVersion) {
  57 |     |             versionName = string(FsUtils.decodeFromBytes32(immutableVersion));
  58 |     |         } catch {
  59 |     |             revert InvalidImplementation();
  60 |     |         }
  61 |     | 
  62 |     |         // version name must not be the empty string
  63 |     |         if (bytes(versionName).length == 0) {
  64 |     |             revert InvalidVersionName();
  65 |     |         }
  66 |     | 
  67 |     |         // the version name should not already be registered
  68 |     |         if (_versions[versionName].implementation != address(0)) {
  69 |     |             revert VersionAlreadyRegistered();
  70 |     |         }
  71 |     |         _versionString.push(versionName);
  72 |     | 
  73 |     |         _versions[versionName] = Version({
  74 |     |             versionName: versionName,
  75 |     |             status: status,
  76 |     |             bugLevel: BugLevel.NONE,
  77 |     |             implementation: implementation,
  78 |     |             dateAdded: block.timestamp
  79 |     |         });
  80 |     | 
  81 |     |         emit VersionAdded(versionName, implementation);
  82 |     |     }
  83 |     | 
  84 |     |     /// @notice Update a contract version
  85 |     |     /// @param versionName Version of the contract
  86 |     |     /// @param status Status of the contract
  87 |     |     /// @param bugLevel New bug level for the contract
  88 |     |     function updateVersion(
  89 |     |         string calldata versionName,
  90 |     |         Status status,
  91 |     |         BugLevel bugLevel
  92 |     |     )
  93 |     |         external
  94 |     |         onlyGovernance
  95 |     |         versionExists(versionName)
  96 |     |         validStatus(status)
  97 |     |         validBugLevel(bugLevel)
  98 |     |     {
  99 |     |         _versions[versionName].status = status;
 100 |     |         _versions[versionName].bugLevel = bugLevel;
 101 |     | 
 102 |     |         emit VersionUpdated(versionName, status, bugLevel);
 103 |     |     }
 104 |     | 
 105 |     |     /// @notice Set the recommended version
 106 |     |     /// @param versionName Version of the contract
 107 |     |     function markRecommendedVersion(
 108 |     |         string calldata versionName
 109 |     |     ) external onlyGovernance versionExists(versionName) {
 110 |     |         require(
 111 |     |             _versions[versionName].status != IVersionManager.Status.DEPRECATED &&
 112 |     |                 _versions[versionName].bugLevel == IVersionManager.BugLevel.NONE,
 113 |     |             "Version not valid"
 114 |     |         );
 115 |     |         // set the version name as the recommended version
 116 |     |         _recommendedVersion = versionName;
 117 |     | 
 118 |     |         emit VersionRecommended(versionName);
 119 |     |     }
 120 |     | 
 121 |     |     /// @notice Remove the recommended version
 122 |     |     function removeRecommendedVersion() external onlyGovernance {
 123 |     |         // delete the recommended version name
 124 |     |         delete _recommendedVersion;
 125 |     | 
 126 |     |         emit RecommendedVersionRemoved();
 127 |     |     }
 128 |     | 
 129 |     |     /// @notice Get recommended version for the contract.
 130 |     |     /// @return versionName The name of the recommended version
 131 |     |     /// @return status The status of the recommended version
 132 |     |     /// @return bugLevel The bug level of the recommended version
 133 |     |     /// @return implementation The address of the implementation of the recommended version
 134 |     |     /// @return dateAdded The date the recommended version was added
 135 |     |     function getRecommendedVersion()
 136 |     |         external
 137 |     |         view
 138 |     |         returns (
 139 |     |             string memory versionName,
 140 |     |             Status status,
 141 |     |             BugLevel bugLevel,
 142 |     |             address implementation,
 143 |     |             uint256 dateAdded
 144 |     |         )
 145 |     |     {
 146 |     |         require(bytes(_recommendedVersion).length != 0, "Recommended version is not specified");
 147 |     |         versionName = _recommendedVersion;
 148 |     | 
 149 |     |         Version storage recommendedVersion = _versions[versionName];
 150 |     | 
 151 |     |         status = recommendedVersion.status;
 152 |     |         bugLevel = recommendedVersion.bugLevel;
 153 |     |         implementation = recommendedVersion.implementation;
 154 |     |         dateAdded = recommendedVersion.dateAdded;
 155 |     | 
 156 |     |         return (versionName, status, bugLevel, implementation, dateAdded);
 157 |     |     }
 158 |     | 
 159 |     |     /// @notice Get total count of versions
 160 |     |     function getVersionCount() external view returns (uint256 count) {
 161 |     |         count = _versionString.length;
 162 |     |     }
 163 |     | 
 164 |     |     /// @dev Returns the version name at specific index in the versionString[] array
 165 |     |     /// @param index The index to be searched for
 166 |     |     function getVersionAtIndex(uint256 index) external view returns (string memory versionName) {
 167 |     |         versionName = _versionString[index];
 168 |     |     }
 169 |     | 
 170 |     |     /// @notice Get the implementation address for a version
 171 |     |     /// @param index The index of the version
 172 |     |     function getVersionAddress(uint256 index) external view returns (address) {
 173 |     |         string memory versionName = _versionString[index];
 174 |     |         Version memory v = _versions[versionName];
 175 |     |         return v.implementation;
 176 |     |     }
 177 |     | 
 178 |     |     /// @notice Returns the version details for the given version name
 179 |     |     /// @param versionName Version string
 180 |     |     function getVersionDetails(
 181 |     |         string calldata versionName
 182 |     |     )
 183 |     |         external
 184 |     |         view
 185 |     |         returns (
 186 |     |             string memory versionString,
 187 |     |             Status status,
 188 |     |             BugLevel bugLevel,
 189 |     |             address implementation,
 190 |     |             uint256 dateAdded
 191 |     |         )
 192 |     |     {
 193 |     |         Version storage v = _versions[versionName];
 194 |     | 
 195 |     |         versionString = v.versionName;
 196 |     |         status = v.status;
 197 |     |         bugLevel = v.bugLevel;
 198 |     |         implementation = v.implementation;
 199 |     |         dateAdded = v.dateAdded;
 200 |     | 
 201 |     |         return (versionString, status, bugLevel, implementation, dateAdded);
 202 |     |     }
 203 |     | }
 204 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/duoswapV2/DuoswapV2ERC20.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
   2 |     | pragma solidity ^0.8.7;
   3 |     | 
   4 |     | import "@uniswap/v2-core/contracts/interfaces/IUniswapV2ERC20.sol";
   5 |     | 
   6 |     | //solhint-disable var-name-mixedcase
   7 |     | //solhint-disable reason-string
   8 |     | //solhint-disable const-name-snakecase
   9 |     | 
  10 |     | contract DuoswapV2ERC20 is IUniswapV2ERC20 {
  11 |     |     string public constant override name = "Uniswap V2";
  12 |     |     string public constant override symbol = "UNI-V2";
  13 |     |     uint8 public constant override decimals = 18;
  14 |     |     uint256 public override totalSupply;
  15 |     |     mapping(address => uint256) public override balanceOf;
  16 |     |     mapping(address => mapping(address => uint256)) public override allowance;
  17 |     | 
  18 |     |     bytes32 public override DOMAIN_SEPARATOR;
  19 |     |     // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
  20 |     |     bytes32 public constant override PERMIT_TYPEHASH =
  21 |     |         0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
  22 |     |     mapping(address => uint256) public override nonces;
  23 |     | 
  24 |     |     constructor() {
  25 |     |         DOMAIN_SEPARATOR = keccak256(
  26 |     |             abi.encode(
  27 |     |                 keccak256(
  28 |     |                     "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
  29 |     |                 ),
  30 |     |                 keccak256(bytes(name)),
  31 |     |                 keccak256(bytes("1")),
  32 |     |                 block.chainid,
  33 |     |                 address(this)
  34 |     |             )
  35 |     |         );
  36 |     |     }
  37 |     | 
  38 |     |     function approve(address spender, uint256 value) external override returns (bool) {
  39 |     |         _approve(msg.sender, spender, value);
  40 |     |         return true;
  41 |     |     }
  42 |     | 
  43 |     |     function transfer(address to, uint256 value) external override returns (bool) {
  44 |     |         _transfer(msg.sender, to, value);
  45 |     |         return true;
  46 |     |     }
  47 |     | 
  48 |     |     function transferFrom(
  49 |     |         address from,
  50 |     |         address to,
  51 |     |         uint256 value
  52 |     |     ) external override returns (bool) {
  53 |     |         if (allowance[from][msg.sender] != type(uint256).max) {
  54 |     |             allowance[from][msg.sender] -= value;
  55 |     |         }
  56 |     |         _transfer(from, to, value);
  57 |     |         return true;
  58 |     |     }
  59 |     | 
  60 |     |     function permit(
  61 |     |         address owner,
  62 |     |         address spender,
  63 |     |         uint256 value,
  64 |     |         uint256 deadline,
  65 |     |         uint8 v,
  66 |     |         bytes32 r,
  67 |     |         bytes32 s
  68 |     |     ) external override {
  69 |     |         //solhint-disable-next-line not-rely-on-time
  70 |     |         require(deadline >= block.timestamp, "UniswapV2: EXPIRED");
  71 |     |         bytes32 digest = keccak256(
  72 |     |             abi.encodePacked(
  73 |     |                 "\x19\x01",
  74 |     |                 DOMAIN_SEPARATOR,
  75 |     |                 keccak256(
  76 |     |                     abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline)
  77 |     |                 )
  78 |     |             )
  79 |     |         );
  80 |     |         address recoveredAddress = ecrecover(digest, v, r, s);
  81 |     |         require(
  82 |     |             recoveredAddress != address(0) && recoveredAddress == owner,
  83 |     |             "UniswapV2: INVALID_SIGNATURE"
  84 |     |         );
  85 |     |         _approve(owner, spender, value);
  86 |     |     }
  87 |     | 
  88 |     |     function _mint(address to, uint256 value) internal {
  89 |     |         totalSupply += value;
  90 |     |         balanceOf[to] += value;
  91 |     |         emit Transfer(address(0), to, value);
  92 |     |     }
  93 |     | 
  94 |     |     function _burn(address from, uint256 value) internal {
  95 |     |         balanceOf[from] -= value;
  96 |     |         totalSupply -= value;
  97 |     |         emit Transfer(from, address(0), value);
  98 |     |     }
  99 |     | 
 100 |     |     function _approve(address owner, address spender, uint256 value) internal {
 101 |     |         allowance[owner][spender] = value;
 102 |     |         emit Approval(owner, spender, value);
 103 |     |     }
 104 |     | 
 105 |     |     function _transfer(address from, address to, uint256 value) private {
 106 |     |         balanceOf[from] -= value;
 107 |     |         balanceOf[to] += value;
 108 |     |         emit Transfer(from, to, value);
 109 |     |     }
 110 |     | }
 111 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/duoswapV2/DuoswapV2Factory.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity ^0.8.7;
  3 |     | 
  4 |     | import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol";
  5 |     | import {IDuoswapV2Pair, DuoswapV2Pair} from "./DuoswapV2Pair.sol";
  6 |     | 
  7 |     | contract DuoswapV2Factory is IUniswapV2Factory {
  8 |     |     bytes32 public constant PAIR_HASH = keccak256(type(DuoswapV2Pair).creationCode);
  9 |     | 
 10 |     |     address public dos;
 11 |     |     address public override feeTo;
 12 |     |     address public override feeToSetter;
 13 |     | 
 14 |     |     mapping(address => mapping(address => address)) public override getPair;
 15 |     |     address[] public override allPairs;
 16 |     | 
 17 |     |     constructor(address _dos, address _feeToSetter) {
 18 |     |         dos = _dos;
 19 |     |         feeToSetter = _feeToSetter;
 20 |     |     }
 21 |     | 
 22 |     |     function createPair(address tokenA, address tokenB) external override returns (address pair) {
 23 |     |         require(tokenA != tokenB, "UniswapV2: IDENTICAL_ADDRESSES");
 24 |     |         (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
 25 |     |         require(token0 != address(0), "UniswapV2: ZERO_ADDRESS");
 26 |     |         require(getPair[token0][token1] == address(0), "UniswapV2: PAIR_EXISTS"); // single check is sufficient
 27 |     | 
 28 |     |         pair = address(new DuoswapV2Pair{salt: keccak256(abi.encodePacked(token0, token1))}());
 29 |     |         IDuoswapV2Pair(pair).initialize(dos, token0, token1);
 30 |     |         getPair[token0][token1] = pair;
 31 |     |         getPair[token1][token0] = pair; // populate mapping in the reverse direction
 32 |     |         allPairs.push(pair);
 33 |     |         emit PairCreated(token0, token1, pair, allPairs.length);
 34 |     |     }
 35 |     | 
 36 |     |     function setFeeTo(address _feeTo) external override {
 37 |     |         require(msg.sender == feeToSetter, "UniswapV2: FORBIDDEN");
 38 |     |         feeTo = _feeTo;
 39 |     |     }
 40 |     | 
 41 |     |     function setFeeToSetter(address _feeToSetter) external override {
 42 |     |         require(msg.sender == feeToSetter, "UniswapV2: FORBIDDEN");
 43 |     |         feeToSetter = _feeToSetter;
 44 |     |     }
 45 |     | 
 46 |     |     function allPairsLength() external view override returns (uint256) {
 47 |     |         return allPairs.length;
 48 |     |     }
 49 |     | }
 50 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/duoswapV2/DuoswapV2Pair.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
   2 |     | pragma solidity ^0.8.7;
   3 |     | 
   4 |     | //solhint-disable ordering
   5 |     | 
   6 |     | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   7 |     | import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol";
   8 |     | import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Callee.sol";
   9 |     | 
  10 |     | import "./libraries/Math.sol";
  11 |     | import "./libraries/UQ112x112.sol";
  12 |     | 
  13 |     | import {IDuoswapV2Pair} from "./interfaces/IDuoswapV2Pair.sol";
  14 |     | import {DuoswapV2ERC20} from "./DuoswapV2ERC20.sol";
  15 |     | 
  16 |     | import {IDOS} from "../interfaces/IDOS.sol";
  17 |     | import {Call} from "../lib/Call.sol";
  18 |     | import {ISafe} from "../interfaces/ISafe.sol";
  19 |     | 
  20 |     | //solhint-disable func-name-mixedcase
  21 |     | //solhint-disable avoid-low-level-calls
  22 |     | //solhint-disable reason-string
  23 |     | //solhint-disable not-rely-on-time
  24 |     | 
  25 |     | contract DuoswapV2Pair is IDuoswapV2Pair, DuoswapV2ERC20 {
  26 |     |     using UQ112x112 for uint224;
  27 |     | 
  28 |     |     uint256 public constant override MINIMUM_LIQUIDITY = 10 ** 3;
  29 |     | 
  30 |     |     address public override factory;
  31 |     |     address public override token0;
  32 |     |     address public override token1;
  33 |     | 
  34 |     |     address public dos;
  35 |     |     address public dSafe;
  36 |     | 
  37 |     |     uint112 private reserve0; // uses single storage slot, accessible via getReserves
  38 |     |     uint112 private reserve1; // uses single storage slot, accessible via getReserves
  39 |     |     uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves
  40 |     | 
  41 |     |     uint256 public override price0CumulativeLast;
  42 |     |     uint256 public override price1CumulativeLast;
  43 |     |     uint256 public override kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event
  44 |     | 
  45 |     |     uint256 private unlocked = 1;
  46 |     |     modifier lock() {
  47 |     |         require(unlocked == 1, "UniswapV2: LOCKED");
  48 |     |         unlocked = 0;
  49 |     |         _;
  50 |     |         unlocked = 1;
  51 |     |     }
  52 |     | 
  53 |     |     function getReserves()
  54 |     |         public
  55 |     |         view
  56 |     |         override
  57 |     |         returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast)
  58 |     |     {
  59 |     |         _reserve0 = reserve0;
  60 |     |         _reserve1 = reserve1;
  61 |     |         _blockTimestampLast = blockTimestampLast;
  62 |     |     }
  63 |     | 
  64 |     |     function _safeTransfer(address token, address to, uint256 amount) private {
  65 |     |         Call[] memory call = new Call[](1);
  66 |     |         call[0] = (
  67 |     |             Call({
  68 |     |                 to: address(dos),
  69 |     |                 callData: abi.encodeWithSignature(
  70 |     |                     "transferERC20(address,address,uint256)",
  71 |     |                     address(token),
  72 |     |                     to,
  73 |     |                     amount
  74 |     |                 ),
  75 |     |                 value: 0
  76 |     |             })
  77 |     |         );
  78 |     | 
  79 |     |         ISafe(dSafe).executeBatch(call);
  80 |     |         // (bool success, bytes memory data) = token.call(
  81 |     |         //     abi.encodeWithSelector(IERC20.transferFrom.selector, dSafe,to, value)
  82 |     |         // );
  83 |     |         // require(
  84 |     |         //     success && (data.length == 0 || abi.decode(data, (bool))),
  85 |     |         //     "UniswapV2: TRANSFER_FAILED"
  86 |     |         // );
  87 |     |     }
  88 |     | 
  89 |     |     constructor() {
  90 |     |         factory = msg.sender;
  91 |     |     }
  92 |     | 
  93 |     |     // called once by the factory at time of deployment
  94 |     |     function initialize(address _dos, address _token0, address _token1) external override {
  95 |     |         require(msg.sender == factory, "UniswapV2: FORBIDDEN"); // sufficient check
  96 |     |         dos = _dos;
  97 |     |         dSafe = IDOS(dos).createDSafe();
  98 |     |         token0 = _token0;
  99 |     |         token1 = _token1;
 100 |     |     }
 101 |     | 
 102 |     |     // update reserves and, on the first call per block, price accumulators
 103 |     |     function _update(
 104 |     |         uint256 balance0,
 105 |     |         uint256 balance1,
 106 |     |         uint112 _reserve0,
 107 |     |         uint112 _reserve1
 108 |     |     ) private {
 109 |     |         require(
 110 |     |             balance0 <= type(uint112).max && balance1 <= type(uint112).max,
 111 |     |             "UniswapV2: OVERFLOW"
 112 |     |         );
 113 |     |         uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);
 114 |     |         unchecked {
 115 |     |             uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired
 116 |     |             if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {
 117 |     |                 // * never overflows, and + overflow is desired
 118 |     |                 price0CumulativeLast +=
 119 |     |                     uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) *
 120 |     |                     timeElapsed;
 121 |     |                 price1CumulativeLast +=
 122 |     |                     uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) *
 123 |     |                     timeElapsed;
 124 |     |             }
 125 |     |         }
 126 |     |         reserve0 = uint112(balance0);
 127 |     |         reserve1 = uint112(balance1);
 128 |     |         blockTimestampLast = blockTimestamp;
 129 |     |         emit Sync(reserve0, reserve1);
 130 |     |     }
 131 |     | 
 132 |     |     // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)
 133 |     |     function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {
 134 |     |         address feeTo = IUniswapV2Factory(factory).feeTo();
 135 |     |         feeOn = feeTo != address(0);
 136 |     |         uint256 _kLast = kLast; // gas savings
 137 |     |         if (feeOn) {
 138 |     |             if (_kLast != 0) {
 139 |     |                 uint256 rootK = Math.sqrt(uint256(_reserve0) * _reserve1);
 140 |     |                 uint256 rootKLast = Math.sqrt(_kLast);
 141 |     |                 if (rootK > rootKLast) {
 142 |     |                     uint256 numerator = totalSupply * (rootK - rootKLast);
 143 |     |                     uint256 denominator = rootK * 5 + rootKLast;
 144 |     |                     uint256 liquidity = numerator / denominator;
 145 |     |                     if (liquidity > 0) _mint(feeTo, liquidity);
 146 |     |                 }
 147 |     |             }
 148 |     |         } else if (_kLast != 0) {
 149 |     |             kLast = 0;
 150 |     |         }
 151 |     |     }
 152 |     | 
 153 |     |     // this low-level function should be called from a contract which performs important safety checks
 154 |     |     function mint(address to) external override lock returns (uint256 liquidity) {
 155 |     |         (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
 156 |     |         uint256 balance0 = uint256(IDOS(dos).getDAccountERC20(dSafe, IERC20(token0)));
 157 |     |         uint256 balance1 = uint256(IDOS(dos).getDAccountERC20(dSafe, IERC20(token1)));
 158 |     |         uint256 amount0 = balance0 - _reserve0;
 159 |     |         uint256 amount1 = balance1 - _reserve1;
 160 |     | 
 161 |     |         bool feeOn = _mintFee(_reserve0, _reserve1);
 162 |     |         uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
 163 |     |         if (_totalSupply == 0) {
 164 |     |             liquidity = Math.sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY;
 165 |     |             _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens
 166 |     |         } else {
 167 |     |             liquidity = Math.min(
 168 |     |                 (amount0 * _totalSupply) / _reserve0,
 169 |     |                 (amount1 * _totalSupply) / _reserve1
 170 |     |             );
 171 |     |         }
 172 |     |         require(liquidity > 0, "UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED");
 173 |     |         _mint(address(this), liquidity); // mint to this address
 174 |     |         _approve(address(this), address(dos), liquidity);
 175 |     |         IDOS(dos).depositERC20ForSafe(address(this), to, liquidity); // deposit LP tokens into DOS
 176 |     | 
 177 |     |         _update(balance0, balance1, _reserve0, _reserve1);
 178 |     |         if (feeOn) kLast = uint256(reserve0) * reserve1; // reserve0 and reserve1 are up-to-date
 179 |     |         emit Mint(msg.sender, amount0, amount1);
 180 |     |     }
 181 |     | 
 182 |     |     // this low-level function should be called from a contract which performs important safety checks
 183 |     |     function burn(address to) external override lock returns (uint256 amount0, uint256 amount1) {
 184 |     |         (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
 185 |     |         address _token0 = token0; // gas savings
 186 |     |         address _token1 = token1; // gas savings
 187 |     |         uint256 balance0 = uint256(IDOS(dos).getDAccountERC20(dSafe, IERC20(_token0)));
 188 |     |         uint256 balance1 = uint256(IDOS(dos).getDAccountERC20(dSafe, IERC20(_token1)));
 189 |     |         uint256 liquidity = balanceOf[address(this)];
 190 |     | 
 191 |     |         bool feeOn = _mintFee(_reserve0, _reserve1);
 192 |     |         uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
 193 |     |         amount0 = (liquidity * balance0) / _totalSupply; // using balances ensures pro-rata distribution
 194 |     |         amount1 = (liquidity * balance1) / _totalSupply; // using balances ensures pro-rata distribution
 195 |     |         require(amount0 > 0 && amount1 > 0, "UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED");
 196 |     |         _burn(address(this), liquidity);
 197 |     |         _safeTransfer(_token0, to, amount0);
 198 |     |         _safeTransfer(_token1, to, amount1);
 199 |     |         balance0 = uint256(IDOS(dos).getDAccountERC20(dSafe, IERC20(_token0)));
 200 |     |         balance1 = uint256(IDOS(dos).getDAccountERC20(dSafe, IERC20(_token1)));
 201 |     | 
 202 |     |         _update(balance0, balance1, _reserve0, _reserve1);
 203 |     |         if (feeOn) kLast = uint256(reserve0) * reserve1; // reserve0 and reserve1 are up-to-date
 204 |     |         emit Burn(msg.sender, amount0, amount1, to);
 205 |     |     }
 206 |     | 
 207 |     |     // this low-level function should be called from a contract which performs important safety checks
 208 |     |     function swap(
 209 |     |         uint256 amount0Out,
 210 |     |         uint256 amount1Out,
 211 |     |         address to,
 212 |     |         bytes calldata data
 213 |     |     ) external override lock {
 214 |     |         require(amount0Out > 0 || amount1Out > 0, "UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT");
 215 |     |         (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
 216 |     |         require(
 217 |     |             amount0Out < _reserve0 && amount1Out < _reserve1,
 218 |     |             "UniswapV2: INSUFFICIENT_LIQUIDITY"
 219 |     |         );
 220 |     | 
 221 |     |         uint256 balance0;
 222 |     |         uint256 balance1;
 223 |     |         {
 224 |     |             // scope for _token{0,1}, avoids stack too deep errors
 225 |     |             address _token0 = token0;
 226 |     |             address _token1 = token1;
 227 |     |             require(to != _token0 && to != _token1, "UniswapV2: INVALID_TO");
 228 |     |             if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens
 229 |     |             if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens
 230 |     |             if (data.length > 0)
 231 |     |                 IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);
 232 |     | 
 233 |     |             balance0 = uint256(IDOS(dos).getDAccountERC20(dSafe, IERC20(_token0)));
 234 |     |             balance1 = uint256(IDOS(dos).getDAccountERC20(dSafe, IERC20(_token1)));
 235 |     |         }
 236 |     |         uint256 amount0In = balance0 > _reserve0 - amount0Out
 237 |     |             ? balance0 - (_reserve0 - amount0Out)
 238 |     |             : 0;
 239 |     |         uint256 amount1In = balance1 > _reserve1 - amount1Out
 240 |     |             ? balance1 - (_reserve1 - amount1Out)
 241 |     |             : 0;
 242 |     |         require(amount0In > 0 || amount1In > 0, "UniswapV2: INSUFFICIENT_INPUT_AMOUNT");
 243 |     |         {
 244 |     |             // scope for reserve{0,1}Adjusted, avoids stack too deep errors
 245 |     |             uint256 balance0Adjusted = balance0 * 1000 - amount0In * 3;
 246 |     |             uint256 balance1Adjusted = balance1 * 1000 - amount1In * 3;
 247 |     |             require(
 248 |     |                 balance0Adjusted * balance1Adjusted >= uint256(_reserve0) * _reserve1 * 1e6,
 249 |     |                 "UniswapV2: K"
 250 |     |             );
 251 |     |         }
 252 |     | 
 253 |     |         _update(balance0, balance1, _reserve0, _reserve1);
 254 |     |         emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
 255 |     |     }
 256 |     | 
 257 |     |     // force balances to match reserves
 258 |     |     function skim(address to) external override lock {
 259 |     |         address _token0 = token0; // gas savings
 260 |     |         address _token1 = token1; // gas savings
 261 |     |         _safeTransfer(
 262 |     |             _token0,
 263 |     |             to,
 264 |     |             uint256(IDOS(dos).getDAccountERC20(dSafe, IERC20(token0))) - reserve0
 265 |     |         );
 266 |     |         _safeTransfer(_token1, to, uint256(IDOS(dos).getDAccountERC20(dSafe, IERC20(token1))));
 267 |     |     }
 268 |     | 
 269 |     |     // force reserves to match balances
 270 |     |     function sync() external override lock {
 271 |     |         _update(
 272 |     |             uint256(IDOS(dos).getDAccountERC20(dSafe, IERC20(token0))),
 273 |     |             uint256(IDOS(dos).getDAccountERC20(dSafe, IERC20(token1))),
 274 |     |             reserve0,
 275 |     |             reserve1
 276 |     |         );
 277 |     |     }
 278 |     | }
 279 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/duoswapV2/DuoswapV2Router.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
   2 |     | pragma solidity ^0.8.7;
   3 |     | 
   4 |     | //solhint-disable not-rely-on-time
   5 |     | //solhint-disable var-name-mixedcase
   6 |     | //solhint-disable func-name-mixedcase
   7 |     | //solhint-disable func-param-name-mixedcase
   8 |     | //solhint-disable reason-string
   9 |     | //solhint-disable ordering
  10 |     | 
  11 |     | import "@uniswap/lib/contracts/libraries/TransferHelper.sol";
  12 |     | import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol";
  13 |     | 
  14 |     | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  15 |     | 
  16 |     | import "./interfaces/IDuoswapV2Router.sol";
  17 |     | import "./libraries/DuoswapV2Library.sol";
  18 |     | import "../external/interfaces/IWETH9.sol";
  19 |     | 
  20 |     | import {IDuoswapV2Pair} from "./interfaces/IDuoswapV2Pair.sol";
  21 |     | import {IDOS} from "../interfaces/IDOS.sol";
  22 |     | 
  23 |     | contract DuoswapV2Router is IDuoswapV2Router {
  24 |     |     address public immutable override factory;
  25 |     |     address public immutable override WETH;
  26 |     |     address public immutable dos;
  27 |     | 
  28 |     |     modifier ensure(uint256 deadline) {
  29 |     |         require(deadline >= block.timestamp, "UniswapV2Router: EXPIRED");
  30 |     |         _;
  31 |     |     }
  32 |     | 
  33 |     |     constructor(address _factory, address _WETH, address _dos) {
  34 |     |         factory = _factory;
  35 |     |         WETH = _WETH;
  36 |     |         dos = _dos;
  37 |     |     }
  38 |     | 
  39 |     |     receive() external payable {
  40 |     |         assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract
  41 |     |     }
  42 |     | 
  43 |     |     // **** ADD LIQUIDITY ****
  44 |     |     function _addLiquidity(
  45 |     |         address tokenA,
  46 |     |         address tokenB,
  47 |     |         uint256 amountADesired,
  48 |     |         uint256 amountBDesired,
  49 |     |         uint256 amountAMin,
  50 |     |         uint256 amountBMin
  51 |     |     ) internal virtual returns (uint256 amountA, uint256 amountB) {
  52 |     |         // create the pair if it doesn't exist yet
  53 |     |         if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {
  54 |     |             IUniswapV2Factory(factory).createPair(tokenA, tokenB);
  55 |     |         }
  56 |     |         (uint256 reserveA, uint256 reserveB) = DuoswapV2Library.getReserves(
  57 |     |             factory,
  58 |     |             tokenA,
  59 |     |             tokenB
  60 |     |         );
  61 |     |         if (reserveA == 0 && reserveB == 0) {
  62 |     |             (amountA, amountB) = (amountADesired, amountBDesired);
  63 |     |         } else {
  64 |     |             uint256 amountBOptimal = DuoswapV2Library.quote(amountADesired, reserveA, reserveB);
  65 |     |             if (amountBOptimal <= amountBDesired) {
  66 |     |                 require(amountBOptimal >= amountBMin, "UniswapV2Router: INSUFFICIENT_B_AMOUNT");
  67 |     |                 (amountA, amountB) = (amountADesired, amountBOptimal);
  68 |     |             } else {
  69 |     |                 uint256 amountAOptimal = DuoswapV2Library.quote(amountBDesired, reserveB, reserveA);
  70 |     |                 assert(amountAOptimal <= amountADesired);
  71 |     |                 require(amountAOptimal >= amountAMin, "UniswapV2Router: INSUFFICIENT_A_AMOUNT");
  72 |     |                 (amountA, amountB) = (amountAOptimal, amountBDesired);
  73 |     |             }
  74 |     |         }
  75 |     |     }
  76 |     | 
  77 |     |     function addLiquidity(
  78 |     |         address tokenA,
  79 |     |         address tokenB,
  80 |     |         uint256 amountADesired,
  81 |     |         uint256 amountBDesired,
  82 |     |         uint256 amountAMin,
  83 |     |         uint256 amountBMin,
  84 |     |         address to,
  85 |     |         uint256 deadline
  86 |     |     )
  87 |     |         external
  88 |     |         virtual
  89 |     |         override
  90 |     |         ensure(deadline)
  91 |     |         returns (uint256 amountA, uint256 amountB, uint256 liquidity)
  92 |     |     {
  93 |     |         // require(msg.sender == address(dos));
  94 |     |         (amountA, amountB) = _addLiquidity(
  95 |     |             tokenA,
  96 |     |             tokenB,
  97 |     |             amountADesired,
  98 |     |             amountBDesired,
  99 |     |             amountAMin,
 100 |     |             amountBMin
 101 |     |         );
 102 |     |         address pair = DuoswapV2Library.pairFor(factory, tokenA, tokenB);
 103 |     |         address pairSafe = IDuoswapV2Pair(pair).dSafe();
 104 |     | 
 105 |     |         IDOS(dos).transferFromERC20(tokenA, msg.sender, pairSafe, amountA);
 106 |     |         IDOS(dos).transferFromERC20(tokenB, msg.sender, pairSafe, amountB);
 107 |     |         liquidity = IDuoswapV2Pair(pair).mint(to);
 108 |     |     }
 109 |     | 
 110 |     |     // **** REMOVE LIQUIDITY ****
 111 |     |     function removeLiquidity(
 112 |     |         address tokenA,
 113 |     |         address tokenB,
 114 |     |         uint256 liquidity,
 115 |     |         uint256 amountAMin,
 116 |     |         uint256 amountBMin,
 117 |     |         address to,
 118 |     |         uint256 deadline
 119 |     |     ) public virtual override ensure(deadline) returns (uint256 amountA, uint256 amountB) {
 120 |     |         address pair = DuoswapV2Library.pairFor(factory, tokenA, tokenB);
 121 |     |         IDuoswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair
 122 |     |         (uint256 amount0, uint256 amount1) = IDuoswapV2Pair(pair).burn(to);
 123 |     |         (address token0, ) = DuoswapV2Library.sortTokens(tokenA, tokenB);
 124 |     |         (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);
 125 |     |         require(amountA >= amountAMin, "UniswapV2Router: INSUFFICIENT_A_AMOUNT");
 126 |     |         require(amountB >= amountBMin, "UniswapV2Router: INSUFFICIENT_B_AMOUNT");
 127 |     |     }
 128 |     | 
 129 |     |     function removeLiquidityWithPermit(
 130 |     |         address tokenA,
 131 |     |         address tokenB,
 132 |     |         uint256 liquidity,
 133 |     |         uint256 amountAMin,
 134 |     |         uint256 amountBMin,
 135 |     |         address to,
 136 |     |         uint256 deadline,
 137 |     |         bool approveMax,
 138 |     |         uint8 v,
 139 |     |         bytes32 r,
 140 |     |         bytes32 s
 141 |     |     ) external virtual override returns (uint256 amountA, uint256 amountB) {
 142 |     |         address pair = DuoswapV2Library.pairFor(factory, tokenA, tokenB);
 143 |     |         uint256 value = approveMax ? type(uint256).max : liquidity;
 144 |     |         IDuoswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);
 145 |     |         (amountA, amountB) = removeLiquidity(
 146 |     |             tokenA,
 147 |     |             tokenB,
 148 |     |             liquidity,
 149 |     |             amountAMin,
 150 |     |             amountBMin,
 151 |     |             to,
 152 |     |             deadline
 153 |     |         );
 154 |     |     }
 155 |     | 
 156 |     |     // **** SWAP ****
 157 |     |     // requires the initial amount to have already been sent to the first pair
 158 |     |     function _swap(uint256[] memory amounts, address[] memory path, address _to) internal virtual {
 159 |     |         for (uint256 i; i < path.length - 1; i++) {
 160 |     |             (address input, address output) = (path[i], path[i + 1]);
 161 |     |             (address token0, ) = DuoswapV2Library.sortTokens(input, output);
 162 |     |             uint256 amountOut = amounts[i + 1];
 163 |     |             (uint256 amount0Out, uint256 amount1Out) = input == token0
 164 |     |                 ? (uint256(0), amountOut)
 165 |     |                 : (amountOut, uint256(0));
 166 |     |             address to = i < path.length - 2
 167 |     |                 ? DuoswapV2Library.pairFor(factory, output, path[i + 2])
 168 |     |                 : _to;
 169 |     |             IDuoswapV2Pair(DuoswapV2Library.pairFor(factory, input, output)).swap(
 170 |     |                 amount0Out,
 171 |     |                 amount1Out,
 172 |     |                 to,
 173 |     |                 new bytes(0)
 174 |     |             );
 175 |     |         }
 176 |     |     }
 177 |     | 
 178 |     |     function swapExactTokensForTokens(
 179 |     |         uint256 amountIn,
 180 |     |         uint256 amountOutMin,
 181 |     |         address[] calldata path,
 182 |     |         address to,
 183 |     |         uint256 deadline
 184 |     |     ) external virtual override ensure(deadline) returns (uint256[] memory amounts) {
 185 |     |         amounts = DuoswapV2Library.getAmountsOut(factory, amountIn, path);
 186 |     |         require(
 187 |     |             amounts[amounts.length - 1] >= amountOutMin,
 188 |     |             "UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT"
 189 |     |         );
 190 |     |         IDOS(dos).transferFromERC20(
 191 |     |             path[0],
 192 |     |             to, // changed to userSafe
 193 |     |             IDuoswapV2Pair(DuoswapV2Library.pairFor(factory, path[0], path[1])).dSafe(), // changed to pairSafe
 194 |     |             amounts[0]
 195 |     |         );
 196 |     |         _swap(amounts, path, to);
 197 |     |     }
 198 |     | 
 199 |     |     function swapTokensForExactTokens(
 200 |     |         uint256 amountOut,
 201 |     |         uint256 amountInMax,
 202 |     |         address[] calldata path,
 203 |     |         address to,
 204 |     |         uint256 deadline
 205 |     |     ) external virtual override ensure(deadline) returns (uint256[] memory amounts) {
 206 |     |         amounts = DuoswapV2Library.getAmountsIn(factory, amountOut, path);
 207 |     |         require(amounts[0] <= amountInMax, "UniswapV2Router: EXCESSIVE_INPUT_AMOUNT");
 208 |     |         IDOS(dos).transferFromERC20(
 209 |     |             path[0],
 210 |     |             to, // changed to userSafe
 211 |     |             IDuoswapV2Pair(DuoswapV2Library.pairFor(factory, path[0], path[1])).dSafe(), // changed to pairSafe
 212 |     |             amounts[0]
 213 |     |         );
 214 |     |         _swap(amounts, path, to);
 215 |     |     }
 216 |     | 
 217 |     |     // **** SWAP (supporting fee-on-transfer tokens) ****
 218 |     |     // requires the initial amount to have already been sent to the first pair
 219 |     |     function _swapSupportingFeeOnTransferTokens(
 220 |     |         address[] memory path,
 221 |     |         address _to
 222 |     |     ) internal virtual {
 223 |     |         for (uint256 i; i < path.length - 1; i++) {
 224 |     |             (address input, address output) = (path[i], path[i + 1]);
 225 |     |             (address token0, ) = DuoswapV2Library.sortTokens(input, output);
 226 |     |             IDuoswapV2Pair pair = IDuoswapV2Pair(DuoswapV2Library.pairFor(factory, input, output));
 227 |     |             uint256 amountInput;
 228 |     |             uint256 amountOutput;
 229 |     |             {
 230 |     |                 // scope to avoid stack too deep errors
 231 |     |                 (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();
 232 |     |                 (uint256 reserveInput, uint256 reserveOutput) = input == token0
 233 |     |                     ? (reserve0, reserve1)
 234 |     |                     : (reserve1, reserve0);
 235 |     |                 amountInput = IERC20(input).balanceOf(address(pair)) - reserveInput;
 236 |     |                 amountOutput = DuoswapV2Library.getAmountOut(
 237 |     |                     amountInput,
 238 |     |                     reserveInput,
 239 |     |                     reserveOutput
 240 |     |                 );
 241 |     |             }
 242 |     |             (uint256 amount0Out, uint256 amount1Out) = input == token0
 243 |     |                 ? (uint256(0), amountOutput)
 244 |     |                 : (amountOutput, uint256(0));
 245 |     |             address to = i < path.length - 2
 246 |     |                 ? DuoswapV2Library.pairFor(factory, output, path[i + 2])
 247 |     |                 : _to;
 248 |     |             pair.swap(amount0Out, amount1Out, to, new bytes(0));
 249 |     |         }
 250 |     |     }
 251 |     | 
 252 |     |     function swapExactTokensForTokensSupportingFeeOnTransferTokens(
 253 |     |         uint256 amountIn,
 254 |     |         uint256 amountOutMin,
 255 |     |         address[] calldata path,
 256 |     |         address to,
 257 |     |         uint256 deadline
 258 |     |     ) external virtual override ensure(deadline) {
 259 |     |         TransferHelper.safeTransferFrom(
 260 |     |             path[0],
 261 |     |             msg.sender,
 262 |     |             DuoswapV2Library.pairFor(factory, path[0], path[1]),
 263 |     |             amountIn
 264 |     |         );
 265 |     |         uint256 balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);
 266 |     |         _swapSupportingFeeOnTransferTokens(path, to);
 267 |     |         require(
 268 |     |             IERC20(path[path.length - 1]).balanceOf(to) - balanceBefore >= amountOutMin,
 269 |     |             "UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT"
 270 |     |         );
 271 |     |     }
 272 |     | 
 273 |     |     // **** LIBRARY FUNCTIONS ****
 274 |     |     function quote(
 275 |     |         uint256 amountA,
 276 |     |         uint256 reserveA,
 277 |     |         uint256 reserveB
 278 |     |     ) public pure virtual override returns (uint256 amountB) {
 279 |     |         return DuoswapV2Library.quote(amountA, reserveA, reserveB);
 280 |     |     }
 281 |     | 
 282 |     |     function getAmountOut(
 283 |     |         uint256 amountIn,
 284 |     |         uint256 reserveIn,
 285 |     |         uint256 reserveOut
 286 |     |     ) public pure virtual override returns (uint256 amountOut) {
 287 |     |         return DuoswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);
 288 |     |     }
 289 |     | 
 290 |     |     function getAmountIn(
 291 |     |         uint256 amountOut,
 292 |     |         uint256 reserveIn,
 293 |     |         uint256 reserveOut
 294 |     |     ) public pure virtual override returns (uint256 amountIn) {
 295 |     |         return DuoswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);
 296 |     |     }
 297 |     | 
 298 |     |     function getAmountsOut(
 299 |     |         uint256 amountIn,
 300 |     |         address[] memory path
 301 |     |     ) public view virtual override returns (uint256[] memory amounts) {
 302 |     |         return DuoswapV2Library.getAmountsOut(factory, amountIn, path);
 303 |     |     }
 304 |     | 
 305 |     |     function getAmountsIn(
 306 |     |         uint256 amountOut,
 307 |     |         address[] memory path
 308 |     |     ) public view virtual override returns (uint256[] memory amounts) {
 309 |     |         return DuoswapV2Library.getAmountsIn(factory, amountOut, path);
 310 |     |     }
 311 |     | }
 312 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/duoswapV2/interfaces/IDuoswapV2Pair.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | 
  3 |     | //solhint-disable-next-line compiler-version
  4 |     | pragma solidity >=0.5.0;
  5 |     | 
  6 |     | //solhint-disable func-name-mixedcase
  7 |     | 
  8 |     | import "@uniswap/v2-core/contracts/interfaces/IUniswapV2ERC20.sol";
  9 |     | 
 10 |     | interface IDuoswapV2Pair is IUniswapV2ERC20 {
 11 |     |     event Mint(address indexed sender, uint256 amount0, uint256 amount1);
 12 |     |     event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);
 13 |     |     event Swap(
 14 |     |         address indexed sender,
 15 |     |         uint256 amount0In,
 16 |     |         uint256 amount1In,
 17 |     |         uint256 amount0Out,
 18 |     |         uint256 amount1Out,
 19 |     |         address indexed to
 20 |     |     );
 21 |     |     event Sync(uint112 reserve0, uint112 reserve1);
 22 |     | 
 23 |     |     function MINIMUM_LIQUIDITY() external pure returns (uint256);
 24 |     | 
 25 |     |     function factory() external view returns (address);
 26 |     | 
 27 |     |     function token0() external view returns (address);
 28 |     | 
 29 |     |     function token1() external view returns (address);
 30 |     | 
 31 |     |     function dSafe() external view returns (address);
 32 |     | 
 33 |     |     function getReserves()
 34 |     |         external
 35 |     |         view
 36 |     |         returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
 37 |     | 
 38 |     |     function price0CumulativeLast() external view returns (uint256);
 39 |     | 
 40 |     |     function price1CumulativeLast() external view returns (uint256);
 41 |     | 
 42 |     |     function kLast() external view returns (uint256);
 43 |     | 
 44 |     |     function mint(address to) external returns (uint256 liquidity);
 45 |     | 
 46 |     |     function burn(address to) external returns (uint256 amount0, uint256 amount1);
 47 |     | 
 48 |     |     function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;
 49 |     | 
 50 |     |     function skim(address to) external;
 51 |     | 
 52 |     |     function sync() external;
 53 |     | 
 54 |     |     function initialize(address, address, address) external;
 55 |     | }
 56 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/duoswapV2/interfaces/IDuoswapV2Router.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | 
  3 |     | pragma solidity ^0.8.7;
  4 |     | 
  5 |     | import "./IDuoswapV2Router01.sol";
  6 |     | 
  7 |     | interface IDuoswapV2Router is IDuoswapV2Router01 {
  8 |     |     event TokensApproved(address sender, uint256 amount, bytes data);
  9 |     |     event TokensReceived(address spender, address sender, uint256 amount, bytes data);
 10 |     | 
 11 |     |     function swapExactTokensForTokensSupportingFeeOnTransferTokens(
 12 |     |         uint256 amountIn,
 13 |     |         uint256 amountOutMin,
 14 |     |         address[] calldata path,
 15 |     |         address to,
 16 |     |         uint256 deadline
 17 |     |     ) external;
 18 |     | }
 19 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/duoswapV2/interfaces/IDuoswapV2Router01.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity ^0.8.7;
  3 |     | 
  4 |     | //solhint-disable func-name-mixedcase
  5 |     | 
  6 |     | interface IDuoswapV2Router01 {
  7 |     |     function factory() external view returns (address);
  8 |     | 
  9 |     |     function WETH() external view returns (address);
 10 |     | 
 11 |     |     function addLiquidity(
 12 |     |         address tokenA,
 13 |     |         address tokenB,
 14 |     |         uint256 amountADesired,
 15 |     |         uint256 amountBDesired,
 16 |     |         uint256 amountAMin,
 17 |     |         uint256 amountBMin,
 18 |     |         address to,
 19 |     |         uint256 deadline
 20 |     |     ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);
 21 |     | 
 22 |     |     function removeLiquidity(
 23 |     |         address tokenA,
 24 |     |         address tokenB,
 25 |     |         uint256 liquidity,
 26 |     |         uint256 amountAMin,
 27 |     |         uint256 amountBMin,
 28 |     |         address to,
 29 |     |         uint256 deadline
 30 |     |     ) external returns (uint256 amountA, uint256 amountB);
 31 |     | 
 32 |     |     function removeLiquidityWithPermit(
 33 |     |         address tokenA,
 34 |     |         address tokenB,
 35 |     |         uint256 liquidity,
 36 |     |         uint256 amountAMin,
 37 |     |         uint256 amountBMin,
 38 |     |         address to,
 39 |     |         uint256 deadline,
 40 |     |         bool approveMax,
 41 |     |         uint8 v,
 42 |     |         bytes32 r,
 43 |     |         bytes32 s
 44 |     |     ) external returns (uint256 amountA, uint256 amountB);
 45 |     | 
 46 |     |     function swapExactTokensForTokens(
 47 |     |         uint256 amountIn,
 48 |     |         uint256 amountOutMin,
 49 |     |         address[] calldata path,
 50 |     |         address to,
 51 |     |         uint256 deadline
 52 |     |     ) external returns (uint256[] memory amounts);
 53 |     | 
 54 |     |     function swapTokensForExactTokens(
 55 |     |         uint256 amountOut,
 56 |     |         uint256 amountInMax,
 57 |     |         address[] calldata path,
 58 |     |         address to,
 59 |     |         uint256 deadline
 60 |     |     ) external returns (uint256[] memory amounts);
 61 |     | 
 62 |     |     function quote(
 63 |     |         uint256 amountA,
 64 |     |         uint256 reserveA,
 65 |     |         uint256 reserveB
 66 |     |     ) external pure returns (uint256 amountB);
 67 |     | 
 68 |     |     function getAmountOut(
 69 |     |         uint256 amountIn,
 70 |     |         uint256 reserveIn,
 71 |     |         uint256 reserveOut
 72 |     |     ) external pure returns (uint256 amountOut);
 73 |     | 
 74 |     |     function getAmountIn(
 75 |     |         uint256 amountOut,
 76 |     |         uint256 reserveIn,
 77 |     |         uint256 reserveOut
 78 |     |     ) external pure returns (uint256 amountIn);
 79 |     | 
 80 |     |     function getAmountsOut(
 81 |     |         uint256 amountIn,
 82 |     |         address[] calldata path
 83 |     |     ) external view returns (uint256[] memory amounts);
 84 |     | 
 85 |     |     function getAmountsIn(
 86 |     |         uint256 amountOut,
 87 |     |         address[] calldata path
 88 |     |     ) external view returns (uint256[] memory amounts);
 89 |     | }
 90 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/duoswapV2/libraries/DuoswapV2Library.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
   2 |     | pragma solidity ^0.8.4;
   3 |     | 
   4 |     | //solhint-disable reason-string
   5 |     | 
   6 |     | import {IDuoswapV2Pair} from "../interfaces/IDuoswapV2Pair.sol";
   7 |     | 
   8 |     | library DuoswapV2Library {
   9 |     |     // returns sorted token addresses, used to handle return values from pairs sorted in this order
  10 |     |     function sortTokens(
  11 |     |         address tokenA,
  12 |     |         address tokenB
  13 |     |     ) internal pure returns (address token0, address token1) {
  14 |     |         require(tokenA != tokenB, "UniswapV2Library: IDENTICAL_ADDRESSES");
  15 |     |         (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
  16 |     |         require(token0 != address(0), "UniswapV2Library: ZERO_ADDRESS");
  17 |     |     }
  18 |     | 
  19 |     |     // calculates the CREATE2 address for a pair without making any external calls
  20 |     |     function pairFor(
  21 |     |         address factory,
  22 |     |         address tokenA,
  23 |     |         address tokenB
  24 |     |     ) internal pure returns (address pair) {
  25 |     |         (address token0, address token1) = sortTokens(tokenA, tokenB);
  26 |     |         pair = address(
  27 |     |             uint160(
  28 |     |                 uint256(
  29 |     |                     keccak256(
  30 |     |                         abi.encodePacked(
  31 |     |                             bytes1(0xff),
  32 |     |                             factory,
  33 |     |                             keccak256(abi.encodePacked(token0, token1)),
  34 |     |                             hex"6606d7ddc46633fe75181c4673be2eb17f1a8360674e23ec54231cec1e5077c6" // NOTE: need to replace with actual init code hash every time the pair code is updated
  35 |     |                         )
  36 |     |                     )
  37 |     |                 )
  38 |     |             )
  39 |     |         );
  40 |     |     }
  41 |     | 
  42 |     |     // fetches and sorts the reserves for a pair
  43 |     |     function getReserves(
  44 |     |         address factory,
  45 |     |         address tokenA,
  46 |     |         address tokenB
  47 |     |     ) internal view returns (uint256 reserveA, uint256 reserveB) {
  48 |     |         (address token0, ) = sortTokens(tokenA, tokenB);
  49 |     |         (uint256 reserve0, uint256 reserve1, ) = IDuoswapV2Pair(pairFor(factory, tokenA, tokenB))
  50 |     |             .getReserves();
  51 |     |         (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
  52 |     |     }
  53 |     | 
  54 |     |     // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset
  55 |     |     function quote(
  56 |     |         uint256 amountA,
  57 |     |         uint256 reserveA,
  58 |     |         uint256 reserveB
  59 |     |     ) internal pure returns (uint256 amountB) {
  60 |     |         require(amountA > 0, "UniswapV2Library: INSUFFICIENT_AMOUNT");
  61 |     |         require(reserveA > 0 && reserveB > 0, "UniswapV2Library: INSUFFICIENT_LIQUIDITY");
  62 |     |         amountB = (amountA * reserveB) / reserveA;
  63 |     |     }
  64 |     | 
  65 |     |     // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset
  66 |     |     function getAmountOut(
  67 |     |         uint256 amountIn,
  68 |     |         uint256 reserveIn,
  69 |     |         uint256 reserveOut
  70 |     |     ) internal pure returns (uint256 amountOut) {
  71 |     |         require(amountIn > 0, "UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT");
  72 |     |         require(reserveIn > 0 && reserveOut > 0, "UniswapV2Library: INSUFFICIENT_LIQUIDITY");
  73 |     |         uint256 amountInWithFee = amountIn * 997;
  74 |     |         uint256 numerator = amountInWithFee * reserveOut;
  75 |     |         uint256 denominator = reserveIn * 1000 + amountInWithFee;
  76 |     |         amountOut = numerator / denominator;
  77 |     |     }
  78 |     | 
  79 |     |     // given an output amount of an asset and pair reserves, returns a required input amount of the other asset
  80 |     |     function getAmountIn(
  81 |     |         uint256 amountOut,
  82 |     |         uint256 reserveIn,
  83 |     |         uint256 reserveOut
  84 |     |     ) internal pure returns (uint256 amountIn) {
  85 |     |         require(amountOut > 0, "UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT");
  86 |     |         require(reserveIn > 0 && reserveOut > 0, "UniswapV2Library: INSUFFICIENT_LIQUIDITY");
  87 |     |         uint256 numerator = reserveIn * amountOut * 1000;
  88 |     |         uint256 denominator = (reserveOut - amountOut) * 997;
  89 |     |         amountIn = numerator / denominator + 1;
  90 |     |     }
  91 |     | 
  92 |     |     // performs chained getAmountOut calculations on any number of pairs
  93 |     |     function getAmountsOut(
  94 |     |         address factory,
  95 |     |         uint256 amountIn,
  96 |     |         address[] memory path
  97 |     |     ) internal view returns (uint256[] memory amounts) {
  98 |     |         require(path.length >= 2, "UniswapV2Library: INVALID_PATH");
  99 |     |         amounts = new uint256[](path.length);
 100 |     |         amounts[0] = amountIn;
 101 |     | 
 102 |     |         for (uint256 i; i < path.length - 1; i++) {
 103 |     |             (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i], path[i + 1]);
 104 |     |             amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);
 105 |     |         }
 106 |     |     }
 107 |     | 
 108 |     |     // performs chained getAmountIn calculations on any number of pairs
 109 |     |     function getAmountsIn(
 110 |     |         address factory,
 111 |     |         uint256 amountOut,
 112 |     |         address[] memory path
 113 |     |     ) internal view returns (uint256[] memory amounts) {
 114 |     |         require(path.length >= 2, "UniswapV2Library: INVALID_PATH");
 115 |     |         amounts = new uint256[](path.length);
 116 |     |         amounts[amounts.length - 1] = amountOut;
 117 |     |         for (uint256 i = path.length - 1; i > 0; i--) {
 118 |     |             (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i]);
 119 |     |             amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);
 120 |     |         }
 121 |     |     }
 122 |     | }
 123 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/duoswapV2/libraries/Math.sol
  1 |     | pragma solidity >=0.5.16;
  2 |     | 
  3 |     | // a library for performing various math operations
  4 |     | 
  5 |     | library Math {
  6 |     |     function min(uint x, uint y) internal pure returns (uint z) {
  7 |     |         z = x < y ? x : y;
  8 |     |     }
  9 |     | 
 10 |     |     // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)
 11 |     |     function sqrt(uint y) internal pure returns (uint z) {
 12 |     |         if (y > 3) {
 13 |     |             z = y;
 14 |     |             uint x = y / 2 + 1;
 15 |     |             while (x < z) {
 16 |     |                 z = x;
 17 |     |                 x = (y / x + x) / 2;
 18 |     |             }
 19 |     |         } else if (y != 0) {
 20 |     |             z = 1;
 21 |     |         }
 22 |     |     }
 23 |     | }
 24 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/duoswapV2/libraries/UQ112x112.sol
  1 |     | pragma solidity >=0.5.16;
  2 |     | 
  3 |     | // a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))
  4 |     | 
  5 |     | // range: [0, 2**112 - 1]
  6 |     | // resolution: 1 / 2**112
  7 |     | 
  8 |     | library UQ112x112 {
  9 |     |     uint224 constant Q112 = 2 ** 112;
 10 |     | 
 11 |     |     // encode a uint112 as a UQ112x112
 12 |     |     function encode(uint112 y) internal pure returns (uint224 z) {
 13 |     |         z = uint224(y) * Q112; // never overflows
 14 |     |     }
 15 |     | 
 16 |     |     // divide a UQ112x112 by a uint112, returning a UQ112x112
 17 |     |     function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {
 18 |     |         z = x / uint224(y);
 19 |     |     }
 20 |     | }
 21 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/external/interfaces/IAnyswapCreate2Deployer.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.17;
  3 |     | 
  4 |     | interface IAnyswapCreate2Deployer {
  5 |     |     event Deployed(address addr, uint256 salt);
  6 |     | 
  7 |     |     function deploy(bytes memory code, uint256 salt) external;
  8 |     | }
  9 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/external/interfaces/INonfungiblePositionManager.sol
   1 |     | // All this file is taken from @uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol
   2 |     | // Commented out the code that is not compatible with owr OpenZeppelin version.
   3 |     | // So the rest may be used to create an interface for a deployed instance of this contract
   4 |     | 
   5 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   6 |     | pragma solidity >=0.7.5;
   7 |     | pragma abicoder v2;
   8 |     | 
   9 |     | //import '@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol';
  10 |     | //import '@openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol';
  11 |     | 
  12 |     | //import './IPoolInitializer.sol';
  13 |     | //import './IERC721Permit.sol';
  14 |     | //import './IPeripheryPayments.sol';
  15 |     | //import './IPeripheryImmutableState.sol';
  16 |     | //import '../libraries/PoolAddress.sol';
  17 |     | 
  18 |     | /// @title Non-fungible token for positions
  19 |     | /// @notice Wraps Uniswap V3 positions in a non-fungible token interface which allows for them to be transferred
  20 |     | /// and authorized.
  21 |     | //is
  22 |     | //IPoolInitializer,
  23 |     | //IPeripheryPayments,
  24 |     | //IPeripheryImmutableState,
  25 |     | //IERC721Metadata,
  26 |     | //IERC721Enumerable,
  27 |     | //IERC721Permit
  28 |     | interface INonfungiblePositionManager {
  29 |     |     /// @notice Emitted when liquidity is increased for a position NFT
  30 |     |     /// @dev Also emitted when a token is minted
  31 |     |     /// @param tokenId The ID of the token for which liquidity was increased
  32 |     |     /// @param liquidity The amount by which liquidity for the NFT position was increased
  33 |     |     /// @param amount0 The amount of token0 that was paid for the increase in liquidity
  34 |     |     /// @param amount1 The amount of token1 that was paid for the increase in liquidity
  35 |     |     event IncreaseLiquidity(
  36 |     |         uint256 indexed tokenId,
  37 |     |         uint128 liquidity,
  38 |     |         uint256 amount0,
  39 |     |         uint256 amount1
  40 |     |     );
  41 |     |     /// @notice Emitted when liquidity is decreased for a position NFT
  42 |     |     /// @param tokenId The ID of the token for which liquidity was decreased
  43 |     |     /// @param liquidity The amount by which liquidity for the NFT position was decreased
  44 |     |     /// @param amount0 The amount of token0 that was accounted for the decrease in liquidity
  45 |     |     /// @param amount1 The amount of token1 that was accounted for the decrease in liquidity
  46 |     |     event DecreaseLiquidity(
  47 |     |         uint256 indexed tokenId,
  48 |     |         uint128 liquidity,
  49 |     |         uint256 amount0,
  50 |     |         uint256 amount1
  51 |     |     );
  52 |     |     /// @notice Emitted when tokens are collected for a position NFT
  53 |     |     /// @dev The amounts reported may not be exactly equivalent to the amounts transferred, due to rounding behavior
  54 |     |     /// @param tokenId The ID of the token for which underlying tokens were collected
  55 |     |     /// @param recipient The address of the account that received the collected tokens
  56 |     |     /// @param amount0 The amount of token0 owed to the position that was collected
  57 |     |     /// @param amount1 The amount of token1 owed to the position that was collected
  58 |     |     event Collect(uint256 indexed tokenId, address recipient, uint256 amount0, uint256 amount1);
  59 |     | 
  60 |     |     /// @notice Returns the position information associated with a given token ID.
  61 |     |     /// @dev Throws if the token ID is not valid.
  62 |     |     /// @param tokenId The ID of the token that represents the position
  63 |     |     /// @return nonce The nonce for permits
  64 |     |     /// @return operator The address that is approved for spending
  65 |     |     /// @return token0 The address of the token0 for a specific pool
  66 |     |     /// @return token1 The address of the token1 for a specific pool
  67 |     |     /// @return fee The fee associated with the pool
  68 |     |     /// @return tickLower The lower end of the tick range for the position
  69 |     |     /// @return tickUpper The higher end of the tick range for the position
  70 |     |     /// @return liquidity The liquidity of the position
  71 |     |     /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position
  72 |     |     /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position
  73 |     |     /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation
  74 |     |     /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation
  75 |     |     function positions(
  76 |     |         uint256 tokenId
  77 |     |     )
  78 |     |         external
  79 |     |         view
  80 |     |         returns (
  81 |     |             uint96 nonce,
  82 |     |             address operator,
  83 |     |             address token0,
  84 |     |             address token1,
  85 |     |             uint24 fee,
  86 |     |             int24 tickLower,
  87 |     |             int24 tickUpper,
  88 |     |             uint128 liquidity,
  89 |     |             uint256 feeGrowthInside0LastX128,
  90 |     |             uint256 feeGrowthInside1LastX128,
  91 |     |             uint128 tokensOwed0,
  92 |     |             uint128 tokensOwed1
  93 |     |         );
  94 |     | 
  95 |     |     struct MintParams {
  96 |     |         address token0;
  97 |     |         address token1;
  98 |     |         uint24 fee;
  99 |     |         int24 tickLower;
 100 |     |         int24 tickUpper;
 101 |     |         uint256 amount0Desired;
 102 |     |         uint256 amount1Desired;
 103 |     |         uint256 amount0Min;
 104 |     |         uint256 amount1Min;
 105 |     |         address recipient;
 106 |     |         uint256 deadline;
 107 |     |     }
 108 |     | 
 109 |     |     /// @notice Creates a new position wrapped in a NFT
 110 |     |     /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized
 111 |     |     /// a method does not exist, i.e. the pool is assumed to be initialized.
 112 |     |     /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata
 113 |     |     /// @return tokenId The ID of the token that represents the minted position
 114 |     |     /// @return liquidity The amount of liquidity for this position
 115 |     |     /// @return amount0 The amount of token0
 116 |     |     /// @return amount1 The amount of token1
 117 |     |     function mint(
 118 |     |         MintParams calldata params
 119 |     |     )
 120 |     |         external
 121 |     |         payable
 122 |     |         returns (uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);
 123 |     | 
 124 |     |     struct IncreaseLiquidityParams {
 125 |     |         uint256 tokenId;
 126 |     |         uint256 amount0Desired;
 127 |     |         uint256 amount1Desired;
 128 |     |         uint256 amount0Min;
 129 |     |         uint256 amount1Min;
 130 |     |         uint256 deadline;
 131 |     |     }
 132 |     | 
 133 |     |     /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`
 134 |     |     /// @param params tokenId The ID of the token for which liquidity is being increased,
 135 |     |     /// amount0Desired The desired amount of token0 to be spent,
 136 |     |     /// amount1Desired The desired amount of token1 to be spent,
 137 |     |     /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,
 138 |     |     /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,
 139 |     |     /// deadline The time by which the transaction must be included to effect the change
 140 |     |     /// @return liquidity The new liquidity amount as a result of the increase
 141 |     |     /// @return amount0 The amount of token0 to acheive resulting liquidity
 142 |     |     /// @return amount1 The amount of token1 to acheive resulting liquidity
 143 |     |     function increaseLiquidity(
 144 |     |         IncreaseLiquidityParams calldata params
 145 |     |     ) external payable returns (uint128 liquidity, uint256 amount0, uint256 amount1);
 146 |     | 
 147 |     |     struct DecreaseLiquidityParams {
 148 |     |         uint256 tokenId;
 149 |     |         uint128 liquidity;
 150 |     |         uint256 amount0Min;
 151 |     |         uint256 amount1Min;
 152 |     |         uint256 deadline;
 153 |     |     }
 154 |     | 
 155 |     |     /// @notice Decreases the amount of liquidity in a position and accounts it to the position
 156 |     |     /// @param params tokenId The ID of the token for which liquidity is being decreased,
 157 |     |     /// amount The amount by which liquidity will be decreased,
 158 |     |     /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,
 159 |     |     /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,
 160 |     |     /// deadline The time by which the transaction must be included to effect the change
 161 |     |     /// @return amount0 The amount of token0 accounted to the position's tokens owed
 162 |     |     /// @return amount1 The amount of token1 accounted to the position's tokens owed
 163 |     |     function decreaseLiquidity(
 164 |     |         DecreaseLiquidityParams calldata params
 165 |     |     ) external payable returns (uint256 amount0, uint256 amount1);
 166 |     | 
 167 |     |     struct CollectParams {
 168 |     |         uint256 tokenId;
 169 |     |         address recipient;
 170 |     |         uint128 amount0Max;
 171 |     |         uint128 amount1Max;
 172 |     |     }
 173 |     | 
 174 |     |     /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient
 175 |     |     /// @param params tokenId The ID of the NFT for which tokens are being collected,
 176 |     |     /// recipient The account that should receive the tokens,
 177 |     |     /// amount0Max The maximum amount of token0 to collect,
 178 |     |     /// amount1Max The maximum amount of token1 to collect
 179 |     |     /// @return amount0 The amount of fees collected in token0
 180 |     |     /// @return amount1 The amount of fees collected in token1
 181 |     |     function collect(
 182 |     |         CollectParams calldata params
 183 |     |     ) external payable returns (uint256 amount0, uint256 amount1);
 184 |     | 
 185 |     |     /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens
 186 |     |     /// must be collected first.
 187 |     |     /// @param tokenId The ID of the token that is being burned
 188 |     |     function burn(uint256 tokenId) external payable;
 189 |     | }
 190 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/external/interfaces/IPermit2.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.17;
  3 |     | 
  4 |     | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  5 |     | 
  6 |     | // Minimal Permit2 interface, derived from
  7 |     | // https://github.com/Uniswap/permit2/blob/main/src/interfaces/ISignatureTransfer.sol
  8 |     | interface IPermit2 {
  9 |     |     // Token and amount in a permit message.
 10 |     |     struct TokenPermissions {
 11 |     |         // Token to transfer.
 12 |     |         IERC20 token;
 13 |     |         // Amount to transfer.
 14 |     |         uint256 amount;
 15 |     |     }
 16 |     | 
 17 |     |     // The permit2 message.
 18 |     |     struct PermitTransferFrom {
 19 |     |         // Permitted token and amount.
 20 |     |         TokenPermissions permitted;
 21 |     |         // Unique identifier for this permit.
 22 |     |         uint256 nonce;
 23 |     |         // Expiration for this permit.
 24 |     |         uint256 deadline;
 25 |     |     }
 26 |     | 
 27 |     |     // Transfer details for permitTransferFrom().
 28 |     |     struct SignatureTransferDetails {
 29 |     |         // Recipient of tokens.
 30 |     |         address to;
 31 |     |         // Amount to transfer.
 32 |     |         uint256 requestedAmount;
 33 |     |     }
 34 |     | 
 35 |     |     // Consume a permit2 message and transfer tokens.
 36 |     |     function permitTransferFrom(
 37 |     |         PermitTransferFrom calldata permit,
 38 |     |         SignatureTransferDetails calldata transferDetails,
 39 |     |         address owner,
 40 |     |         bytes calldata signature
 41 |     |     ) external;
 42 |     | }
 43 |     | 
 44 |     | // https://docs.uniswap.org/contracts/permit2/overview
 45 |     | // https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3#code
 46 |     | IPermit2 constant PERMIT2 = IPermit2(0x000000000022D473030F116dDEE9F6B43aC78BA3);
 47 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/external/interfaces/IWETH9.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.17;
  3 |     | 
  4 |     | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  5 |     | import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
  6 |     | 
  7 |     | interface IERC20WithMetadata is IERC20, IERC20Metadata {}
  8 |     | 
  9 |     | interface IWETH9 is IERC20WithMetadata {
 10 |     |     receive() external payable;
 11 |     | 
 12 |     |     function deposit() external payable;
 13 |     | 
 14 |     |     function withdraw(uint256 wad) external;
 15 |     | }
 16 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/governance/GovernanceProxy.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity ^0.8.17;
   3 |     | 
   4 |     | import "@openzeppelin/contracts/utils/Address.sol";
   5 |     | import "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol";
   6 |     | import "../lib/FsUtils.sol";
   7 |     | import "../lib/ImmutableGovernance.sol";
   8 |     | import "../lib/AccessControl.sol";
   9 |     | import "../tokens/HashNFT.sol";
  10 |     | import "../lib/Call.sol";
  11 |     | 
  12 |     | // This is a proxy contract representing governance. This allows a fixed
  13 |     | // ethereum address to be the indefinite owner of the system. This works
  14 |     | // nicely with ImmutableGovernance allowing owner to be stored in contract
  15 |     | // code instead of storage. Note that a governance account only has to
  16 |     | // interact with the "execute" method. Proposing new governance or accepting
  17 |     | // governance is done through calls to "execute", simplifying voting
  18 |     | // contracts that govern this proxy.
  19 |     | contract GovernanceProxy {
  20 |     |     using Address for address;
  21 |     | 
  22 |     |     // This address controls the proxy and is allowed to execute
  23 |     |     // contract calls from this contracts account.
  24 |     |     address public governance;
  25 |     |     // To avoid losing governance by accidentally transferring governance
  26 |     |     // to a wrong address we use a propose mechanism, where the proposed
  27 |     |     // governance can also execute and by this action finalize the
  28 |     |     // the transfer of governance. This prevents accidentally transferring
  29 |     |     // control to an invalid address.
  30 |     |     address public proposedGovernance;
  31 |     | 
  32 |     |     event NewGovernanceProposed(address newGovernance);
  33 |     |     event GovernanceChanged(address oldGovernance, address newGovernance);
  34 |     |     event BatchExecuted(CallWithoutValue[] calls);
  35 |     | 
  36 |     |     error OnlyGovernance();
  37 |     | 
  38 |     |     constructor(address _governance) {
  39 |     |         governance = FsUtils.nonNull(_governance);
  40 |     |     }
  41 |     | 
  42 |     |     /// @notice Execute a batch of contract calls.
  43 |     |     /// @param calls an array of calls.
  44 |     |     function executeBatch(CallWithoutValue[] calldata calls) external {
  45 |     |         if (msg.sender != governance) {
  46 |     |             // If the caller is not governance we only accept if the previous
  47 |     |             // governance has proposed it as the new governance account.
  48 |     |             if (msg.sender != proposedGovernance) revert OnlyGovernance();
  49 |     |             emit GovernanceChanged(governance, msg.sender);
  50 |     |             governance = msg.sender;
  51 |     |             proposedGovernance = address(0);
  52 |     |         }
  53 |     |         // Instead of monitoring each configuration change we opt for a
  54 |     |         // simpler approach where we just emit an event for each batch of
  55 |     |         // privileged calls.
  56 |     |         emit BatchExecuted(calls);
  57 |     |         CallLib.executeBatchWithoutValue(calls);
  58 |     |     }
  59 |     | 
  60 |     |     /// @notice Propose a new account as governance account. Note that this can
  61 |     |     /// only be called through the execute method above and hence only
  62 |     |     /// by the current governance.
  63 |     |     /// @param newGovernance address of the new governance account (or zero to revoke proposal)
  64 |     |     function proposeGovernance(address newGovernance) external {
  65 |     |         if (msg.sender != address(this)) revert OnlyGovernance();
  66 |     |         emit NewGovernanceProposed(newGovernance);
  67 |     |         proposedGovernance = newGovernance;
  68 |     |     }
  69 |     | }
  70 |     | 
  71 |     | contract Governance is AccessControl, ERC1155Receiver {
  72 |     |     address public voting;
  73 |     |     uint256 public maxSupportedGasCost = 8e6;
  74 |     |     mapping(address => mapping(bytes4 => uint256)) public bitmaskByAddressBySelector;
  75 |     | 
  76 |     |     event ExecutionFailed(uint256 indexed messageId, string reason);
  77 |     |     event ExecutionSucceeded(uint256 indexed messageId);
  78 |     | 
  79 |     |     error AccessDenied(address account, uint8 accessLevel);
  80 |     |     error InvalidCall(address to, bytes callData);
  81 |     |     error CallDenied(address to, bytes callData, uint8 accessLevel);
  82 |     |     error PrivilagedMethod(address to, bytes4 selector);
  83 |     |     error OnlyHashNFT();
  84 |     |     error InsufficientGas();
  85 |     | 
  86 |     |     constructor(
  87 |     |         address _governanceProxy,
  88 |     |         address _hashNFT,
  89 |     |         address _voting
  90 |     |     ) AccessControl(_governanceProxy, _hashNFT) {
  91 |     |         voting = FsUtils.nonNull(_voting);
  92 |     |     }
  93 |     | 
  94 |     |     function executeBatch(CallWithoutValue[] memory calls) external {
  95 |     |         uint256 tokenId = hashNFT.toTokenId(voting, CallLib.hashCallWithoutValueArray(calls));
  96 |     |         hashNFT.burn(address(this), tokenId, 1); // reverts if tokenId isn't owned.
  97 |     | 
  98 |     |         // For governance calls we do not want them to revert and be in limbo. Thus if the batch
  99 |     |         // reverts we should still burn the NFT. The only caveat is that we want to prevent
 100 |     |         // sabotage votes by executing with insufficient gas and provoking a spurious revert.
 101 |     |         bool failed = false;
 102 |     |         string memory reason = "";
 103 |     |         try governanceProxy().executeBatch(calls) {} catch Error(string memory _reason) {
 104 |     |             failed = true;
 105 |     |             reason = _reason;
 106 |     |         } catch {
 107 |     |             failed = true;
 108 |     |         }
 109 |     |         if (failed) {
 110 |     |             // 1/64th of the gas is left in case the execution fails because of OOG. We need to
 111 |     |             // require that this exceeds maxSupportedGasCost / 64 to ensure that in case it
 112 |     |             // reverted because of OOG the execution was given ample gas.
 113 |     |             if (gasleft() < maxSupportedGasCost / 64) revert InsufficientGas();
 114 |     |             emit ExecutionFailed(tokenId, reason);
 115 |     |         } else {
 116 |     |             emit ExecutionSucceeded(tokenId);
 117 |     |         }
 118 |     |     }
 119 |     | 
 120 |     |     function executeBatchWithClearance(
 121 |     |         CallWithoutValue[] memory calls,
 122 |     |         uint8 accessLevel
 123 |     |     ) external {
 124 |     |         if (!hasAccess(msg.sender, accessLevel)) revert AccessDenied(msg.sender, accessLevel);
 125 |     |         for (uint256 i = 0; i < calls.length; i++) {
 126 |     |             if (calls[i].callData.length < 4) revert InvalidCall(calls[i].to, calls[i].callData);
 127 |     |             bytes4 selector = bytes4(calls[i].callData);
 128 |     |             if ((bitmaskByAddressBySelector[calls[i].to][selector] & (1 << accessLevel)) == 0) {
 129 |     |                 revert CallDenied(calls[i].to, calls[i].callData, accessLevel);
 130 |     |             }
 131 |     |         }
 132 |     |         governanceProxy().executeBatch(calls);
 133 |     |     }
 134 |     | 
 135 |     |     function transferVoting(address newVoting) external onlyGovernance {
 136 |     |         voting = FsUtils.nonNull(newVoting);
 137 |     |     }
 138 |     | 
 139 |     |     function setAccessLevel(
 140 |     |         address addr,
 141 |     |         bytes4 selector,
 142 |     |         uint8 accessLevel,
 143 |     |         bool allowed
 144 |     |     ) external onlyGovernance {
 145 |     |         // We cannot allow setting access level for this contract, since that would enable a designated
 146 |     |         // caller to escalate their access level to include all privilaged functions in the system.
 147 |     |         // By disallowing access levels for this contract we ensure that only the voting system can
 148 |     |         // set access levels for other contracts. The same holds for proposeGovernance on the governance
 149 |     |         // proxy.
 150 |     |         if (
 151 |     |             (addr == address(this) && selector != this.revokeAccess.selector) ||
 152 |     |             addr == immutableGovernance
 153 |     |         ) {
 154 |     |             revert PrivilagedMethod(addr, selector);
 155 |     |         }
 156 |     |         if (allowed) {
 157 |     |             bitmaskByAddressBySelector[addr][selector] |= 1 << accessLevel;
 158 |     |         } else {
 159 |     |             bitmaskByAddressBySelector[addr][selector] &= ~(1 << accessLevel);
 160 |     |         }
 161 |     |     }
 162 |     | 
 163 |     |     function setMaxSupportedGasCost(uint256 _maxSupportedGasCost) external onlyGovernance {
 164 |     |         require(_maxSupportedGasCost > 0, "Governance: invalid gas cost");
 165 |     |         maxSupportedGasCost = _maxSupportedGasCost;
 166 |     |     }
 167 |     | 
 168 |     |     function onERC1155Received(
 169 |     |         address /* operator */,
 170 |     |         address /* from */,
 171 |     |         uint256 /* id */,
 172 |     |         uint256 /* value */,
 173 |     |         bytes calldata /* data */
 174 |     |     ) external view returns (bytes4) {
 175 |     |         if (msg.sender != address(hashNFT)) revert OnlyHashNFT();
 176 |     |         return this.onERC1155Received.selector;
 177 |     |     }
 178 |     | 
 179 |     |     function onERC1155BatchReceived(
 180 |     |         address /* operator */,
 181 |     |         address /* from */,
 182 |     |         uint256[] calldata /* ids */,
 183 |     |         uint256[] calldata /* values */,
 184 |     |         bytes calldata /* data */
 185 |     |     ) external view returns (bytes4) {
 186 |     |         if (msg.sender != address(hashNFT)) revert OnlyHashNFT();
 187 |     |         return this.onERC1155BatchReceived.selector;
 188 |     |     }
 189 |     | 
 190 |     |     function governanceProxy() internal view returns (GovernanceProxy) {
 191 |     |         return GovernanceProxy(immutableGovernance);
 192 |     |     }
 193 |     | }
 194 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/governance/OffchainEntityProxy.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.17;
  3 |     | 
  4 |     | import "@openzeppelin/contracts/access/Ownable.sol";
  5 |     | import "@openzeppelin/contracts/utils/cryptography/EIP712.sol";
  6 |     | import "../lib/Call.sol";
  7 |     | import "../lib/FsUtils.sol";
  8 |     | 
  9 |     | // Signers (EOAs) are the only things that cross EVM chains as they have the same address on all chains.
 10 |     | // To represent an entity cross chains therefore requires a dedicated signer. However this is cumbersome
 11 |     | // to manage securely when the offchain entity is distributed (if the signer is hardware who possesses it, or
 12 |     | // the security risk of sharing the privare key). Instead, ideally we want a multisig smart contract
 13 |     | // representing the entity but with a fixed address on all chains. We propose a simple proxy contract
 14 |     | // that can be deployed to a fixed address on all chains, and can be owned by a multisig wallet. This
 15 |     | // reduces the use of the key to infrequent initial setup for a new chain.
 16 |     | 
 17 |     | // Note: we could deploy this contract with a dedicated deployer key. However this means we must guarantee
 18 |     | // that deployment of this contract is always the first action on the chain for this key. Instead we
 19 |     | // opt for a pattern that only needs the dedicated key to sign offchain.
 20 |     | contract OffchainEntityProxy is Ownable, EIP712 {
 21 |     |     bytes32 constant TAKEOWNERSHIP_TYPEHASH =
 22 |     |         keccak256("TakeOwnership(address newOwner,uint256 nonce)");
 23 |     | 
 24 |     |     bytes32 private immutable entityName;
 25 |     | 
 26 |     |     uint256 public nonce;
 27 |     | 
 28 |     |     // Due to offchain signer address being part of the deployment bytecode, the address at which
 29 |     |     // this contract is deployed identifies the offchain signer.
 30 |     |     constructor(
 31 |     |         address offchainSigner,
 32 |     |         string memory _entityName
 33 |     |     ) EIP712("OffchainEntityProxy", "1") {
 34 |     |         _transferOwnership(offchainSigner);
 35 |     |         entityName = FsUtils.encodeToBytes32(bytes(_entityName));
 36 |     |     }
 37 |     | 
 38 |     |     // By using signature based ownership transfer, we can ensure that the signer can be
 39 |     |     // purely offchain.
 40 |     |     function takeOwnership(bytes calldata signature) external {
 41 |     |         bytes32 digest = _hashTypedDataV4(
 42 |     |             keccak256(abi.encode(TAKEOWNERSHIP_TYPEHASH, msg.sender, nonce++))
 43 |     |         );
 44 |     | 
 45 |     |         address signer = ECDSA.recover(digest, signature);
 46 |     |         require(signer == owner(), "Invalid signature");
 47 |     | 
 48 |     |         _transferOwnership(msg.sender);
 49 |     |     }
 50 |     | 
 51 |     |     // Allow the owner to execute arbitrary calls on behalf of the entity through this proxy
 52 |     |     // contract.
 53 |     |     function executeBatch(Call[] memory calls) external payable onlyOwner {
 54 |     |         CallLib.executeBatch(calls);
 55 |     |     }
 56 |     | 
 57 |     |     function name() external view returns (string memory) {
 58 |     |         return string(FsUtils.decodeFromBytes32(entityName));
 59 |     |     }
 60 |     | }
 61 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/governance/TimeLockedCall.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.17;
  3 |     | 
  4 |     | import "@openzeppelin/contracts/access/Ownable2Step.sol";
  5 |     | import "./GovernanceProxy.sol";
  6 |     | import "../lib/ImmutableGovernance.sol";
  7 |     | import "../tokens/HashNFT.sol";
  8 |     | import "../lib/AccessControl.sol";
  9 |     | 
 10 |     | contract TimeLockedCall is ImmutableGovernance, Ownable2Step {
 11 |     |     uint256 constant MIN_TIMELOCK = 1 days;
 12 |     |     uint256 constant MAX_TIMELOCK = 3 days;
 13 |     | 
 14 |     |     HashNFT public immutable hashNFT;
 15 |     |     uint8 public immutable accessLevel;
 16 |     | 
 17 |     |     uint256 public lockTime;
 18 |     | 
 19 |     |     event BatchProposed(CallWithoutValue[] calls, uint256 executionTime);
 20 |     | 
 21 |     |     constructor(
 22 |     |         address governance,
 23 |     |         address hashNFT_,
 24 |     |         uint8 _accessLevel,
 25 |     |         uint256 _lockTime
 26 |     |     ) ImmutableGovernance(governance) {
 27 |     |         require(
 28 |     |             _accessLevel == uint8(AccessControl.AccessLevel.FINANCIAL_RISK),
 29 |     |             "TimeLockedCall: invalid access level"
 30 |     |         );
 31 |     |         accessLevel = _accessLevel;
 32 |     |         hashNFT = HashNFT(FsUtils.nonNull(hashNFT_));
 33 |     |         _setLockTime(_lockTime);
 34 |     |     }
 35 |     | 
 36 |     |     function proposeBatch(CallWithoutValue[] calldata calls) external onlyOwner {
 37 |     |         uint256 executionTime = block.timestamp + lockTime;
 38 |     |         emit BatchProposed(calls, block.timestamp + lockTime);
 39 |     |         hashNFT.mint(address(this), calcDigest(calls, executionTime), "");
 40 |     |     }
 41 |     | 
 42 |     |     function executeBatch(CallWithoutValue[] calldata calls, uint256 executionTime) external {
 43 |     |         require(executionTime <= block.timestamp, "TimeLockedCall: not ready");
 44 |     |         uint256 tokenId = hashNFT.toTokenId(address(this), calcDigest(calls, executionTime));
 45 |     |         hashNFT.burn(address(this), tokenId, 1);
 46 |     |         Governance(GovernanceProxy(immutableGovernance).governance()).executeBatchWithClearance(
 47 |     |             calls,
 48 |     |             accessLevel
 49 |     |         );
 50 |     |     }
 51 |     | 
 52 |     |     function setLockTime(uint256 _lockTime) external onlyGovernance {
 53 |     |         _setLockTime(_lockTime);
 54 |     |     }
 55 |     | 
 56 |     |     function _setLockTime(uint256 _lockTime) internal {
 57 |     |         require(_lockTime >= MIN_TIMELOCK, "TimeLockedCall: too short");
 58 |     |         require(_lockTime <= MAX_TIMELOCK, "TimeLockedCall: too long");
 59 |     |         lockTime = _lockTime;
 60 |     |     }
 61 |     | 
 62 |     |     function calcDigest(
 63 |     |         CallWithoutValue[] calldata calls,
 64 |     |         uint256 executionTime
 65 |     |     ) internal pure returns (bytes32) {
 66 |     |         return keccak256(abi.encode(executionTime, calls));
 67 |     |     }
 68 |     | }
 69 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/governance/Voting.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity ^0.8.17;
   3 |     | 
   4 |     | import "@openzeppelin/contracts/utils/Address.sol";
   5 |     | import "@openzeppelin/contracts/utils/cryptography/EIP712.sol";
   6 |     | import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
   7 |     | import "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol";
   8 |     | import "../tokens/HashNFT.sol";
   9 |     | import "../lib/Proofs.sol";
  10 |     | import "../lib/Call.sol";
  11 |     | import "../lib/FsUtils.sol";
  12 |     | import "../lib/NonceMap.sol";
  13 |     | 
  14 |     | contract Voting is EIP712 {
  15 |     |     using NonceMapLib for NonceMap;
  16 |     |     using Address for address;
  17 |     | 
  18 |     |     struct Proposal {
  19 |     |         bytes32 digest;
  20 |     |         uint256 deadline;
  21 |     |         bytes32 storageHash;
  22 |     |         uint256 totalSupply;
  23 |     |         uint256 yesVotes;
  24 |     |         uint256 noVotes;
  25 |     |     }
  26 |     | 
  27 |     |     struct Vote {
  28 |     |         address voter;
  29 |     |         bool support;
  30 |     |         bytes signature;
  31 |     |         bytes proof;
  32 |     |     }
  33 |     | 
  34 |     |     bytes private constant VOTE_TYPESTRING = "Vote(uint256 proposalId,bool support)";
  35 |     |     bytes32 private constant VOTE_TYPEHASH = keccak256(VOTE_TYPESTRING);
  36 |     | 
  37 |     |     uint256 public constant FRACTION = 10; // 10% must vote for quorum
  38 |     |     uint256 public constant MIN_VOTING_POWER = 100 ether;
  39 |     | 
  40 |     |     HashNFT public immutable hashNFT;
  41 |     |     address public immutable governanceToken;
  42 |     |     address public immutable governance;
  43 |     |     uint256 public immutable mappingSlot;
  44 |     |     uint256 public immutable totalSupplySlot;
  45 |     | 
  46 |     |     Proposal[] public proposals;
  47 |     |     mapping(address => NonceMap) private votesByAddress;
  48 |     |     mapping(address => address) public delegates;
  49 |     | 
  50 |     |     event ProposalCreated(
  51 |     |         uint256 proposalId,
  52 |     |         string title,
  53 |     |         string description,
  54 |     |         CallWithoutValue[] calls,
  55 |     |         uint256 deadline,
  56 |     |         bytes32 digest,
  57 |     |         uint256 blockNumber
  58 |     |     );
  59 |     | 
  60 |     |     event VoteCasted(address voter, uint256 proposalId, bool support, uint256 votes);
  61 |     | 
  62 |     |     modifier requireValidProposal(uint256 proposalId) {
  63 |     |         require(
  64 |     |             proposalId < proposals.length && proposals[proposalId].deadline > 0,
  65 |     |             "proposal not found"
  66 |     |         );
  67 |     |         require(proposals[proposalId].deadline >= block.timestamp, "voting ended");
  68 |     |         _;
  69 |     |     }
  70 |     | 
  71 |     |     constructor(
  72 |     |         address hashNFT_,
  73 |     |         address governanceToken_,
  74 |     |         uint256 mappingSlot_,
  75 |     |         uint256 totalSupplySlot_,
  76 |     |         address governance_
  77 |     |     ) EIP712("Voting", "1") {
  78 |     |         hashNFT = HashNFT(FsUtils.nonNull(hashNFT_));
  79 |     |         governanceToken = FsUtils.nonNull(governanceToken_);
  80 |     |         mappingSlot = mappingSlot_;
  81 |     |         totalSupplySlot = totalSupplySlot_;
  82 |     |         governance = FsUtils.nonNull(governance_);
  83 |     |     }
  84 |     | 
  85 |     |     function proposeVote(
  86 |     |         string calldata title,
  87 |     |         string calldata description,
  88 |     |         CallWithoutValue[] calldata calls,
  89 |     |         uint256 blockNumber,
  90 |     |         bytes calldata blockHeader,
  91 |     |         bytes calldata stateProof,
  92 |     |         bytes calldata totalSupplyProof,
  93 |     |         address voter,
  94 |     |         bytes calldata proof
  95 |     |     ) external {
  96 |     |         require(msg.sender == voter || delegates[voter] == msg.sender, "not authorized");
  97 |     |         require(calls.length > 0, "Empty proposal");
  98 |     |         for (uint256 i = 0; i < calls.length; i++) {
  99 |     |             require(calls[i].to.isContract(), "target not a contract");
 100 |     |             require(calls[i].callData.length >= 4, "Invalid callData");
 101 |     |         }
 102 |     |         bytes32 storageHash;
 103 |     |         {
 104 |     |             bytes32 blockHash = getBlockHash(blockNumber);
 105 |     |             require(block.number <= blockNumber + 256, "block too old");
 106 |     |             require(keccak256(blockHeader) == blockHash, "invalid block header");
 107 |     |             // RLP of block header 1 list tag + 2 length bytes + 33 bytes of parent hash + 33 bytes of ommers + 21 bytes of coinbase + 1 byte tag
 108 |     |             bytes32 stateHash = bytes32(blockHeader[91:]);
 109 |     | 
 110 |     |             (, , storageHash, ) = TrieLib.proofAccount(governanceToken, stateHash, stateProof);
 111 |     |         }
 112 |     | 
 113 |     |         // proof storageHash is correct for blockhash(blockNumber) governanceTokenAddress
 114 |     |         Proposal storage proposal = proposals.push();
 115 |     |         proposal.digest = CallLib.hashCallWithoutValueArray(calls);
 116 |     |         proposal.deadline = block.timestamp + 2 days;
 117 |     |         proposal.storageHash = storageHash;
 118 |     |         proposal.totalSupply = TrieLib.proofStorageAt(
 119 |     |             bytes32(totalSupplySlot),
 120 |     |             storageHash,
 121 |     |             totalSupplyProof
 122 |     |         );
 123 |     | 
 124 |     |         emit ProposalCreated(
 125 |     |             proposals.length - 1,
 126 |     |             title,
 127 |     |             description,
 128 |     |             calls,
 129 |     |             proposal.deadline,
 130 |     |             proposal.digest,
 131 |     |             blockNumber
 132 |     |         );
 133 |     | 
 134 |     |         uint256 amount = _vote(voter, proposals.length - 1, true, proof);
 135 |     |         require(amount >= MIN_VOTING_POWER, "insufficient voting power");
 136 |     |     }
 137 |     | 
 138 |     |     function vote(
 139 |     |         address voter,
 140 |     |         uint256 proposalId,
 141 |     |         bool support,
 142 |     |         bytes calldata proof
 143 |     |     ) external requireValidProposal(proposalId) {
 144 |     |         if (voter == address(0)) {
 145 |     |             voter = msg.sender;
 146 |     |         } else {
 147 |     |             require(voter == msg.sender || msg.sender == delegates[voter], "invalid voter");
 148 |     |         }
 149 |     |         _vote(voter, proposalId, support, proof);
 150 |     |     }
 151 |     | 
 152 |     |     // Allow multiple offchain votes to be verified in a single transaction
 153 |     |     function voteBatch(
 154 |     |         uint256 proposalId,
 155 |     |         Vote[] calldata votes
 156 |     |     ) external requireValidProposal(proposalId) {
 157 |     |         bytes32 yesVoteDigest = _hashTypedDataV4(
 158 |     |             keccak256(abi.encode(VOTE_TYPEHASH, proposalId, true))
 159 |     |         );
 160 |     |         bytes32 noVoteDigest = _hashTypedDataV4(
 161 |     |             keccak256(abi.encode(VOTE_TYPEHASH, proposalId, false))
 162 |     |         );
 163 |     |         for (uint256 i = 0; i < votes.length; i++) {
 164 |     |             address addr = votes[i].voter;
 165 |     |             if (delegates[addr] != address(0)) {
 166 |     |                 addr = delegates[addr];
 167 |     |             }
 168 |     |             require(
 169 |     |                 SignatureChecker.isValidSignatureNow(
 170 |     |                     addr,
 171 |     |                     votes[i].support ? yesVoteDigest : noVoteDigest,
 172 |     |                     votes[i].signature
 173 |     |                 ),
 174 |     |                 "invalid signature"
 175 |     |             );
 176 |     |             _vote(votes[i].voter, proposalId, votes[i].support, votes[i].proof);
 177 |     |         }
 178 |     |     }
 179 |     | 
 180 |     |     function resolve(uint256 proposalId) external {
 181 |     |         Proposal storage proposal = proposals[proposalId];
 182 |     |         require(proposal.deadline > 0, "proposal not found");
 183 |     |         require(proposal.deadline < block.timestamp, "voting not ended");
 184 |     |         if (proposal.yesVotes <= proposal.noVotes) {
 185 |     |             delete proposals[proposalId];
 186 |     |             return;
 187 |     |         }
 188 |     |         if (proposal.yesVotes + proposal.noVotes < proposal.totalSupply / FRACTION) {
 189 |     |             delete proposals[proposalId];
 190 |     |             return;
 191 |     |         }
 192 |     |         bytes32 digest = proposal.digest;
 193 |     |         delete proposals[proposalId];
 194 |     |         // Vote passed;
 195 |     |         hashNFT.mint(governance, digest, "");
 196 |     |     }
 197 |     | 
 198 |     |     function setDelegate(address delegate) external {
 199 |     |         delegates[msg.sender] = delegate;
 200 |     |     }
 201 |     | 
 202 |     |     function hasVoted(address voter, uint256 proposalId) external view returns (bool) {
 203 |     |         return votesByAddress[voter].getNonce(proposalId);
 204 |     |     }
 205 |     | 
 206 |     |     function _vote(
 207 |     |         address addr,
 208 |     |         uint256 proposalId,
 209 |     |         bool support,
 210 |     |         bytes calldata proof
 211 |     |     ) internal returns (uint256 amount) {
 212 |     |         votesByAddress[addr].validateAndUseNonce(proposalId);
 213 |     |         // Solidity mapping convention
 214 |     |         bytes32 addressMappingSlot = keccak256(abi.encode(addr, mappingSlot));
 215 |     |         amount = TrieLib.proofStorageAt(
 216 |     |             addressMappingSlot,
 217 |     |             proposals[proposalId].storageHash,
 218 |     |             proof
 219 |     |         );
 220 |     |         require(amount > 0, "no balance");
 221 |     |         if (support) {
 222 |     |             proposals[proposalId].yesVotes += amount;
 223 |     |         } else {
 224 |     |             proposals[proposalId].noVotes += amount;
 225 |     |         }
 226 |     |         emit VoteCasted(addr, proposalId, support, amount);
 227 |     |     }
 228 |     | 
 229 |     |     /// @dev Override this function for testing to return handcrafted blockhashes
 230 |     |     function getBlockHash(uint256 blockNumber) internal view virtual returns (bytes32 blockHash) {
 231 |     |         return blockhash(blockNumber);
 232 |     |     }
 233 |     | }
 234 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/interfaces/IDOS.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity ^0.8.7;
   3 |     | 
   4 |     | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   5 |     | import {Call} from "../lib/Call.sol";
   6 |     | import {IERC20ValueOracle} from "./IERC20ValueOracle.sol";
   7 |     | 
   8 |     | type ERC20Share is int256;
   9 |     | 
  10 |     | interface IDOSERC20 is IERC20 {
  11 |     |     function mint(address account, uint256 amount) external;
  12 |     | 
  13 |     |     function burn(address account, uint256 amount) external;
  14 |     | }
  15 |     | 
  16 |     | interface IDOSConfig {
  17 |     |     struct Config {
  18 |     |         address treasurySafe; // The address of the treasury safe
  19 |     |         uint256 treasuryInterestFraction; // Fraction of interest to send to treasury
  20 |     |         uint256 maxSolvencyCheckGasCost;
  21 |     |         int256 liqFraction; // Fraction for the user
  22 |     |         int256 fractionalReserveLeverage; // Ratio of debt to reserves
  23 |     |     }
  24 |     | 
  25 |     |     struct NFTData {
  26 |     |         address erc721;
  27 |     |         uint256 tokenId;
  28 |     |     }
  29 |     | 
  30 |     |     /// @notice Emitted when the implementation of a dSafe is upgraded
  31 |     |     /// @param dSafe The address of the dSafe
  32 |     |     /// @param version The new implementation version
  33 |     |     event DSafeImplementationUpgraded(
  34 |     |         address indexed dSafe,
  35 |     |         string indexed version,
  36 |     |         address implementation
  37 |     |     );
  38 |     | 
  39 |     |     event DSafeOwnershipTransferred(address indexed dSafe, address indexed newOwner);
  40 |     | 
  41 |     |     /// @notice Emitted when a new ERC20 is added to the protocol
  42 |     |     /// @param erc20Idx The index of the ERC20 in the protocol
  43 |     |     /// @param erc20 The address of the ERC20 contract
  44 |     |     /// @param name The name of the ERC20
  45 |     |     /// @param symbol The symbol of the ERC20
  46 |     |     /// @param decimals The decimals of the ERC20
  47 |     |     /// @param valueOracle The address of the value oracle for the ERC20
  48 |     |     /// @param baseRate The interest rate at 0% utilization
  49 |     |     /// @param slope1 The interest rate slope at 0% to target utilization
  50 |     |     /// @param slope2 The interest rate slope at target utilization to 100% utilization
  51 |     |     /// @param targetUtilization The target utilization for the ERC20
  52 |     |     event ERC20Added(
  53 |     |         uint16 erc20Idx,
  54 |     |         address erc20,
  55 |     |         string name,
  56 |     |         string symbol,
  57 |     |         uint8 decimals,
  58 |     |         address valueOracle,
  59 |     |         uint256 baseRate,
  60 |     |         uint256 slope1,
  61 |     |         uint256 slope2,
  62 |     |         uint256 targetUtilization
  63 |     |     );
  64 |     | 
  65 |     |     /// @notice Emitted when a new ERC721 is added to the protocol
  66 |     |     /// @param erc721Idx The index of the ERC721 in the protocol
  67 |     |     /// @param erc721Contract The address of the ERC721 contract
  68 |     |     /// @param valueOracleAddress The address of the value oracle for the ERC721
  69 |     |     event ERC721Added(
  70 |     |         uint256 indexed erc721Idx,
  71 |     |         address indexed erc721Contract,
  72 |     |         address valueOracleAddress
  73 |     |     );
  74 |     | 
  75 |     |     /// @notice Emitted when the config is set
  76 |     |     /// @param config The new config
  77 |     |     event ConfigSet(Config indexed config);
  78 |     | 
  79 |     |     /// @notice Emitted when the version manager address is set
  80 |     |     /// @param versionManager The version manager address
  81 |     |     event VersionManagerSet(address indexed versionManager);
  82 |     | 
  83 |     |     /// @notice Emitted when ERC20 Data is set
  84 |     |     /// @param erc20 The address of the erc20 token
  85 |     |     /// @param baseRate The new base interest rate
  86 |     |     /// @param slope1 The new slope1
  87 |     |     /// @param slope2 The new slope2
  88 |     |     /// @param targetUtilization The new target utilization
  89 |     |     event ERC20DataSet(
  90 |     |         address indexed erc20,
  91 |     |         uint256 baseRate,
  92 |     |         uint256 slope1,
  93 |     |         uint256 slope2,
  94 |     |         uint256 targetUtilization
  95 |     |     );
  96 |     | 
  97 |     |     /// @notice Emitted when a dSafe is created
  98 |     |     /// @param dSafe The address of the dSafe
  99 |     |     /// @param owner The address of the owner
 100 |     |     event DSafeCreated(address dSafe, address owner);
 101 |     | 
 102 |     |     function upgradeDSafeImplementation(string calldata version) external;
 103 |     | 
 104 |     |     function transferDSafeOwnership(address newOwner) external;
 105 |     | 
 106 |     |     function addERC20Info(
 107 |     |         address erc20Contract,
 108 |     |         string calldata name,
 109 |     |         string calldata symbol,
 110 |     |         uint8 decimals,
 111 |     |         address valueOracle,
 112 |     |         uint256 baseRate,
 113 |     |         uint256 slope1,
 114 |     |         uint256 slope2,
 115 |     |         uint256 targetUtilization
 116 |     |     ) external returns (uint16);
 117 |     | 
 118 |     |     function addERC721Info(address nftContract, address valueOracleAddress) external;
 119 |     | 
 120 |     |     function setERC20Data(
 121 |     |         address erc20,
 122 |     |         uint256 baseRate,
 123 |     |         uint256 slope1,
 124 |     |         uint256 slope2,
 125 |     |         uint256 targetUtilization
 126 |     |     ) external;
 127 |     | 
 128 |     |     function setConfig(Config calldata _config) external;
 129 |     | 
 130 |     |     function setVersionManager(address _versionManager) external;
 131 |     | 
 132 |     |     function createDSafe() external returns (address dSafe);
 133 |     | 
 134 |     |     function pause() external;
 135 |     | 
 136 |     |     function unpause() external;
 137 |     | 
 138 |     |     function getDAccountERC20(address dSafe, IERC20 erc20) external view returns (int256);
 139 |     | 
 140 |     |     function getDAccountERC721(address dSafe) external view returns (NFTData[] memory);
 141 |     | }
 142 |     | 
 143 |     | interface IDOSCore {
 144 |     |     struct Approval {
 145 |     |         address ercContract; // ERC20/ERC721 contract
 146 |     |         uint256 amountOrTokenId; // amount or tokenId
 147 |     |     }
 148 |     | 
 149 |     |     /// @notice Emitted when ERC20 tokens are transferred between credit accounts
 150 |     |     /// @param erc20 The address of the ERC20 token
 151 |     |     /// @param from The address of the sender
 152 |     |     /// @param to The address of the receiver
 153 |     |     /// @param value The amount of tokens transferred
 154 |     |     event ERC20Transfer(
 155 |     |         address indexed erc20,
 156 |     |         address indexed from,
 157 |     |         address indexed to,
 158 |     |         int256 value
 159 |     |     );
 160 |     | 
 161 |     |     /// @notice Emitted when erc20 tokens are deposited or withdrawn from a credit account
 162 |     |     /// @param erc20 The address of the ERC20 token
 163 |     |     /// @param to The address of the dSafe
 164 |     |     /// @param amount The amount of tokens deposited or withdrawn
 165 |     |     event ERC20BalanceChanged(address indexed erc20, address indexed to, int256 indexed amount);
 166 |     | 
 167 |     |     /// @notice Emitted when a ERC721 is transferred between credit accounts
 168 |     |     /// @param nftId The nftId of the ERC721 token
 169 |     |     /// @param from The address of the sender
 170 |     |     /// @param to The address of the receiver
 171 |     |     event ERC721Transferred(uint256 indexed nftId, address indexed from, address indexed to);
 172 |     | 
 173 |     |     /// @notice Emitted when an ERC721 token is deposited to a credit account
 174 |     |     /// @param erc721 The address of the ERC721 token
 175 |     |     /// @param to The address of the dSafe
 176 |     |     /// @param tokenId The id of the token deposited
 177 |     |     event ERC721Deposited(address indexed erc721, address indexed to, uint256 indexed tokenId);
 178 |     | 
 179 |     |     /// @notice Emitted when an ERC721 token is withdrawn from a credit account
 180 |     |     /// @param erc721 The address of the ERC721 token
 181 |     |     /// @param from The address of the dSafe
 182 |     |     /// @param tokenId The id of the token withdrawn
 183 |     |     event ERC721Withdrawn(address indexed erc721, address indexed from, uint256 indexed tokenId);
 184 |     | 
 185 |     |     /// @dev Emitted when `owner` approves `spender` to spend `value` tokens on their behalf.
 186 |     |     /// @param erc20 The ERC20 token to approve
 187 |     |     /// @param owner The address of the token owner
 188 |     |     /// @param spender The address of the spender
 189 |     |     /// @param value The amount of tokens to approve
 190 |     |     event ERC20Approval(
 191 |     |         address indexed erc20,
 192 |     |         address indexed owner,
 193 |     |         address indexed spender,
 194 |     |         uint256 value
 195 |     |     );
 196 |     | 
 197 |     |     /// @dev Emitted when `owner` enables `approved` to manage the `tokenId` token on collection `collection`.
 198 |     |     /// @param collection The address of the ERC721 collection
 199 |     |     /// @param owner The address of the token owner
 200 |     |     /// @param approved The address of the approved operator
 201 |     |     /// @param tokenId The ID of the approved token
 202 |     |     event ERC721Approval(
 203 |     |         address indexed collection,
 204 |     |         address indexed owner,
 205 |     |         address indexed approved,
 206 |     |         uint256 tokenId
 207 |     |     );
 208 |     | 
 209 |     |     /// @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its erc20s.
 210 |     |     /// @param collection The address of the collection
 211 |     |     /// @param owner The address of the owner
 212 |     |     /// @param operator The address of the operator
 213 |     |     /// @param approved True if the operator is approved, false to revoke approval
 214 |     |     event ApprovalForAll(
 215 |     |         address indexed collection,
 216 |     |         address indexed owner,
 217 |     |         address indexed operator,
 218 |     |         bool approved
 219 |     |     );
 220 |     | 
 221 |     |     /// @notice Emitted when a dSafe is liquidated
 222 |     |     /// @param dSafe The address of the liquidated dSafe
 223 |     |     /// @param liquidator The address of the liquidator
 224 |     |     event SafeLiquidated(address indexed dSafe, address indexed liquidator);
 225 |     | 
 226 |     |     /// @notice Error thrown if a dSafe accumulates too many assets
 227 |     |     error SolvencyCheckTooExpensive();
 228 |     | 
 229 |     |     function liquidate(address dSafe) external;
 230 |     | 
 231 |     |     function depositERC20(IERC20 erc20, uint256 amount) external;
 232 |     | 
 233 |     |     function withdrawERC20(IERC20 erc20, uint256 amount) external;
 234 |     | 
 235 |     |     function depositERC20ForSafe(address erc20, address to, uint256 amount) external;
 236 |     | 
 237 |     |     function depositFull(IERC20[] calldata erc20s) external;
 238 |     | 
 239 |     |     function withdrawFull(IERC20[] calldata erc20s) external;
 240 |     | 
 241 |     |     function executeBatch(Call[] memory calls) external;
 242 |     | 
 243 |     |     function transferERC20(IERC20 erc20, address to, uint256 amount) external;
 244 |     | 
 245 |     |     function depositERC721(address nftContract, uint256 tokenId) external;
 246 |     | 
 247 |     |     function withdrawERC721(address erc721, uint256 tokenId) external;
 248 |     | 
 249 |     |     function transferERC721(address erc721, uint256 tokenId, address to) external;
 250 |     | 
 251 |     |     /// @notice Transfer ERC20 tokens from dSafe to another dSafe
 252 |     |     /// @dev Note: Allowance must be set with approveERC20
 253 |     |     /// @param erc20 The index of the ERC20 token in erc20Infos array
 254 |     |     /// @param from The address of the dSafe to transfer from
 255 |     |     /// @param to The address of the dSafe to transfer to
 256 |     |     /// @param amount The amount of tokens to transfer
 257 |     |     function transferFromERC20(
 258 |     |         address erc20,
 259 |     |         address from,
 260 |     |         address to,
 261 |     |         uint256 amount
 262 |     |     ) external returns (bool);
 263 |     | 
 264 |     |     /// @notice Transfer ERC721 tokens from dSafe to another dSafe
 265 |     |     /// @param collection The address of the ERC721 token
 266 |     |     /// @param from The address of the dSafe to transfer from
 267 |     |     /// @param to The address of the dSafe to transfer to
 268 |     |     /// @param tokenId The id of the token to transfer
 269 |     |     function transferFromERC721(
 270 |     |         address collection,
 271 |     |         address from,
 272 |     |         address to,
 273 |     |         uint256 tokenId
 274 |     |     ) external;
 275 |     | 
 276 |     |     function approveAndCall(
 277 |     |         Approval[] calldata approvals,
 278 |     |         address spender,
 279 |     |         bytes calldata data
 280 |     |     ) external;
 281 |     | 
 282 |     |     /// @notice Returns the approved address for a token, or zero if no address set
 283 |     |     /// @param collection The address of the ERC721 token
 284 |     |     /// @param tokenId The id of the token to query
 285 |     |     function getApproved(address collection, uint256 tokenId) external view returns (address);
 286 |     | 
 287 |     |     function getRiskAdjustedPositionValues(
 288 |     |         address dSafeAddress
 289 |     |     ) external view returns (int256 totalValue, int256 collateral, int256 debt);
 290 |     | 
 291 |     |     /// @notice Returns if the `operator` is allowed to manage all of the erc20s of `owner` on the `collection` contract
 292 |     |     /// @param collection The address of the collection contract
 293 |     |     /// @param _owner The address of the owner
 294 |     |     /// @param spender The address of the spender
 295 |     |     function isApprovedForAll(
 296 |     |         address collection,
 297 |     |         address _owner,
 298 |     |         address spender
 299 |     |     ) external view returns (bool);
 300 |     | 
 301 |     |     /**
 302 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 303 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 304 |     |      * zero by default.
 305 |     |      *
 306 |     |      * This value changes when {approve} or {transferFrom} are called.
 307 |     |      */
 308 |     |     function allowance(
 309 |     |         address erc20,
 310 |     |         address _owner,
 311 |     |         address spender
 312 |     |     ) external view returns (uint256);
 313 |     | 
 314 |     |     function computeInterestRate(uint16 erc20Idx) external view returns (int96);
 315 |     | 
 316 |     |     function getImplementation(address dSafe) external view returns (address);
 317 |     | 
 318 |     |     function getDSafeOwner(address dSafe) external view returns (address);
 319 |     | }
 320 |     | 
 321 |     | interface IDOS is IDOSCore, IDOSConfig {}
 322 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/interfaces/IERC1363-extended.sol
  1 |     | //SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.7;
  3 |     | 
  4 |     | import {Call} from "../lib/Call.sol";
  5 |     | 
  6 |     | interface IERC1363SpenderExtended {
  7 |     |     function onApprovalReceived(
  8 |     |         address owner,
  9 |     |         uint256 value,
 10 |     |         Call calldata call
 11 |     |     ) external returns (bytes4);
 12 |     | }
 13 |     | 
 14 |     | interface IERC1363ReceiverExtended {
 15 |     |     function onTransferReceived(
 16 |     |         address operator,
 17 |     |         address token,
 18 |     |         uint256 value,
 19 |     |         bytes calldata data
 20 |     |     ) external returns (bytes4);
 21 |     | }
 22 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/interfaces/IERC20ValueOracle.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.17;
  3 |     | 
  4 |     | interface IERC20ValueOracle {
  5 |     |     function calcValue(
  6 |     |         int256 balance
  7 |     |     ) external view returns (int256 value, int256 riskAdjustedValue);
  8 |     | }
  9 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/interfaces/INFTValueOracle.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.17;
  3 |     | 
  4 |     | /// @title NFT Value Oracle Interface
  5 |     | interface INFTValueOracle {
  6 |     |     function calcValue(
  7 |     |         uint256 tokenId
  8 |     |     ) external view returns (int256 value, int256 riskAdjustedValue);
  9 |     | }
 10 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/interfaces/ISafe.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity ^0.8.13;
  3 |     | 
  4 |     | import {Call} from "../lib/Call.sol";
  5 |     | 
  6 |     | interface ISafe {
  7 |     |     event TokensApproved(address sender, uint256 amount, bytes data);
  8 |     |     event TokensReceived(address spender, address sender, uint256 amount, bytes data);
  9 |     | 
 10 |     |     function executeBatch(Call[] memory calls) external payable;
 11 |     | }
 12 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/interfaces/ITransferReceiver2.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.17;
  3 |     | 
  4 |     | import "@openzeppelin/contracts/utils/Address.sol";
  5 |     | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  6 |     | import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
  7 |     | 
  8 |     | // This address is in flux as long as the bytecode of this contract is not fixed. For now
  9 |     | // we deploy it on local block chain on fixed address, when we go deploy this needs to change
 10 |     | // to the permanent address.
 11 |     | address constant TRANSFER_AND_CALL2 = address(0x4e765952997a33893AfB4457A6A7f381909f3629);
 12 |     | 
 13 |     | // Contracts that implement can receive multiple ERC20 transfers in a single transaction,
 14 |     | // with backwards compatibility for legacy ERC20's not implementing ERC677.
 15 |     | abstract contract ITransferReceiver2 {
 16 |     |     error InvalidSender(address sender);
 17 |     | 
 18 |     |     struct Transfer {
 19 |     |         address token;
 20 |     |         uint256 amount;
 21 |     |     }
 22 |     | 
 23 |     |     /// @dev Called by a token to indicate a transfer into the callee
 24 |     |     /// @param operator The account that initiated the transfer
 25 |     |     /// @param from The account that has sent the token
 26 |     |     /// @param transfers Transfers that have been made
 27 |     |     /// @param data The extra data being passed to the receiving contract
 28 |     |     function onTransferReceived2(
 29 |     |         address operator,
 30 |     |         address from,
 31 |     |         Transfer[] calldata transfers,
 32 |     |         bytes calldata data
 33 |     |     ) external virtual returns (bytes4);
 34 |     | 
 35 |     |     modifier onlyTransferAndCall2() {
 36 |     |         if (msg.sender != TRANSFER_AND_CALL2) revert InvalidSender(msg.sender);
 37 |     |         _;
 38 |     |     }
 39 |     | }
 40 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/interfaces/IVersionManager.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.17;
  3 |     | 
  4 |     | /// @notice version is not registered
  5 |     | error VersionNotRegistered();
  6 |     | /// @notice version name cannot be the empty string
  7 |     | error InvalidVersionName();
  8 |     | /// @notice implementation must be a contract
  9 |     | error InvalidImplementation();
 10 |     | /// @notice version is already registered
 11 |     | error VersionAlreadyRegistered();
 12 |     | 
 13 |     | interface IVersionManager {
 14 |     |     /// @dev Signifies the status of a version
 15 |     |     enum Status {
 16 |     |         BETA,
 17 |     |         RC,
 18 |     |         PRODUCTION,
 19 |     |         DEPRECATED
 20 |     |     }
 21 |     | 
 22 |     |     /// @dev Indicated the highest level of bug found in the version
 23 |     |     enum BugLevel {
 24 |     |         NONE,
 25 |     |         LOW,
 26 |     |         MEDIUM,
 27 |     |         HIGH,
 28 |     |         CRITICAL
 29 |     |     }
 30 |     | 
 31 |     |     /// @dev A struct to encode version details
 32 |     |     struct Version {
 33 |     |         // the version number string ex. "v1.0"
 34 |     |         string versionName;
 35 |     |         Status status;
 36 |     |         BugLevel bugLevel;
 37 |     |         // the address of the instantiation of the version
 38 |     |         address implementation;
 39 |     |         // the date when this version was registered with the contract
 40 |     |         uint256 dateAdded;
 41 |     |     }
 42 |     | 
 43 |     |     event VersionAdded(string versionName, address indexed implementation);
 44 |     | 
 45 |     |     event VersionUpdated(string versionName, Status status, BugLevel bugLevel);
 46 |     | 
 47 |     |     event VersionRecommended(string versionName);
 48 |     | 
 49 |     |     event RecommendedVersionRemoved();
 50 |     | 
 51 |     |     function addVersion(Status status, address implementation) external;
 52 |     | 
 53 |     |     function updateVersion(string calldata versionName, Status status, BugLevel bugLevel) external;
 54 |     | 
 55 |     |     function markRecommendedVersion(string calldata versionName) external;
 56 |     | 
 57 |     |     function removeRecommendedVersion() external;
 58 |     | 
 59 |     |     function getRecommendedVersion()
 60 |     |         external
 61 |     |         view
 62 |     |         returns (
 63 |     |             string memory versionName,
 64 |     |             Status status,
 65 |     |             BugLevel bugLevel,
 66 |     |             address implementation,
 67 |     |             uint256 dateAdded
 68 |     |         );
 69 |     | 
 70 |     |     function getVersionCount() external view returns (uint256 count);
 71 |     | 
 72 |     |     function getVersionAtIndex(uint256 index) external view returns (string memory versionName);
 73 |     | 
 74 |     |     function getVersionAddress(uint256 index) external view returns (address);
 75 |     | 
 76 |     |     function getVersionDetails(
 77 |     |         string calldata versionName
 78 |     |     )
 79 |     |         external
 80 |     |         view
 81 |     |         returns (
 82 |     |             string memory versionString,
 83 |     |             Status status,
 84 |     |             BugLevel bugLevel,
 85 |     |             address implementation,
 86 |     |             uint256 dateAdded
 87 |     |         );
 88 |     | }
 89 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/lib/AccessControl.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.17;
  3 |     | 
  4 |     | import "../tokens/HashNFT.sol";
  5 |     | import "../lib/FsUtils.sol";
  6 |     | import "./ImmutableGovernance.sol";
  7 |     | 
  8 |     | /// @title AccessControl
  9 |     | /// @notice Access control based on HashNFT ownership.
 10 |     | /// @dev The owner can grant access rights to an address by minting a HashNFT token
 11 |     | /// to the address with the given access level.
 12 |     | contract AccessControl is ImmutableGovernance {
 13 |     |     enum AccessLevel {
 14 |     |         SECURITY, // Can operate immediately on pausing exchange
 15 |     |         FINANCIAL_RISK // Can set fees, risk factors and interest rates
 16 |     |     }
 17 |     | 
 18 |     |     HashNFT internal immutable hashNFT;
 19 |     | 
 20 |     |     constructor(address owner, address hashNFT_) ImmutableGovernance(owner) {
 21 |     |         hashNFT = HashNFT(FsUtils.nonNull(hashNFT_));
 22 |     |         require(
 23 |     |             hashNFT.supportsInterface(type(IERC1155).interfaceId),
 24 |     |             "AccessControl: not HashNFT"
 25 |     |         );
 26 |     |     }
 27 |     | 
 28 |     |     function mintAccess(
 29 |     |         address to,
 30 |     |         uint256 accessLevel,
 31 |     |         bytes calldata data
 32 |     |     ) external onlyGovernance {
 33 |     |         hashNFT.mint(to, bytes32(accessLevel), data);
 34 |     |     }
 35 |     | 
 36 |     |     function revokeAccess(address from, uint256 accessLevel) external onlyGovernance {
 37 |     |         hashNFT.revoke(from, bytes32(accessLevel));
 38 |     |     }
 39 |     | 
 40 |     |     function hasAccess(address account, uint256 accessLevel) public view returns (bool) {
 41 |     |         return
 42 |     |             hashNFT.balanceOf(account, hashNFT.toTokenId(address(this), bytes32(accessLevel))) > 0;
 43 |     |     }
 44 |     | }
 45 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/lib/Call.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity ^0.8.17;
   3 |     | 
   4 |     | import "@openzeppelin/contracts/utils/Address.sol";
   5 |     | 
   6 |     | /**
   7 |     |  * @title A serialized contract method call.
   8 |     |  *
   9 |     |  * @notice A call to a contract with no native value transferred as part of the call.
  10 |     |  *
  11 |     |  * We often need to pass calls around, so this is a common representation to use.
  12 |     |  */
  13 |     | struct CallWithoutValue {
  14 |     |     address to;
  15 |     |     bytes callData;
  16 |     | }
  17 |     | 
  18 |     | /**
  19 |     |  * @title A serialized contract method call, with value.
  20 |     |  *
  21 |     |  * @notice A call to a contract that may also have native value transferred as part of the call.
  22 |     |  *
  23 |     |  * We often need to pass calls around, so this is a common representation to use.
  24 |     |  */
  25 |     | struct Call {
  26 |     |     address to;
  27 |     |     bytes callData;
  28 |     |     uint256 value;
  29 |     | }
  30 |     | 
  31 |     | library CallLib {
  32 |     |     using Address for address;
  33 |     | 
  34 |     |     bytes internal constant CALL_TYPESTRING = "Call(address to,bytes callData,uint256 value)";
  35 |     |     bytes32 constant CALL_TYPEHASH = keccak256(CALL_TYPESTRING);
  36 |     |     bytes internal constant CALLWITHOUTVALUE_TYPESTRING =
  37 |     |         "CallWithoutValue(address to,bytes callData)";
  38 |     |     bytes32 constant CALLWITHOUTVALUE_TYPEHASH = keccak256(CALLWITHOUTVALUE_TYPESTRING);
  39 |     | 
  40 |     |     /**
  41 |     |      * @notice Execute a call.
  42 |     |      *
  43 |     |      * @param call The call to execute.
  44 |     |      */
  45 |     |     function executeWithoutValue(CallWithoutValue memory call) internal {
  46 |     |         call.to.functionCall(call.callData);
  47 |     |     }
  48 |     | 
  49 |     |     /**
  50 |     |      * @notice Execute a call with value.
  51 |     |      *
  52 |     |      * @param call The call to execute.
  53 |     |      */
  54 |     |     function execute(Call memory call) internal {
  55 |     |         call.to.functionCallWithValue(call.callData, call.value);
  56 |     |     }
  57 |     | 
  58 |     |     /**
  59 |     |      * @notice Execute a batch of calls.
  60 |     |      *
  61 |     |      * @param calls The calls to execute.
  62 |     |      */
  63 |     |     function executeBatch(Call[] memory calls) internal {
  64 |     |         for (uint256 i = 0; i < calls.length; i++) {
  65 |     |             execute(calls[i]);
  66 |     |         }
  67 |     |     }
  68 |     | 
  69 |     |     /**
  70 |     |      * @notice Execute a batch of calls with value.
  71 |     |      *
  72 |     |      * @param calls The calls to execute.
  73 |     |      */
  74 |     |     function executeBatchWithoutValue(CallWithoutValue[] memory calls) internal {
  75 |     |         for (uint256 i = 0; i < calls.length; i++) {
  76 |     |             executeWithoutValue(calls[i]);
  77 |     |         }
  78 |     |     }
  79 |     | 
  80 |     |     function hashCall(Call memory call) internal pure returns (bytes32) {
  81 |     |         return keccak256(abi.encode(CALL_TYPEHASH, call.to, keccak256(call.callData), call.value));
  82 |     |     }
  83 |     | 
  84 |     |     function hashCallArray(Call[] memory calls) internal pure returns (bytes32) {
  85 |     |         bytes32[] memory hashes = new bytes32[](calls.length);
  86 |     |         for (uint256 i = 0; i < calls.length; i++) {
  87 |     |             hashes[i] = hashCall(calls[i]);
  88 |     |         }
  89 |     |         return keccak256(abi.encodePacked(hashes));
  90 |     |     }
  91 |     | 
  92 |     |     function hashCallWithoutValue(CallWithoutValue memory call) internal pure returns (bytes32) {
  93 |     |         return keccak256(abi.encode(CALLWITHOUTVALUE_TYPEHASH, call.to, keccak256(call.callData)));
  94 |     |     }
  95 |     | 
  96 |     |     function hashCallWithoutValueArray(
  97 |     |         CallWithoutValue[] memory calls
  98 |     |     ) internal pure returns (bytes32) {
  99 |     |         bytes32[] memory hashes = new bytes32[](calls.length);
 100 |     |         for (uint256 i = 0; i < calls.length; i++) {
 101 |     |             hashes[i] = hashCallWithoutValue(calls[i]);
 102 |     |         }
 103 |     |         return keccak256(abi.encodePacked(hashes));
 104 |     |     }
 105 |     | }
 106 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/lib/FsMath.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity ^0.8.17;
   3 |     | 
   4 |     | import "./FsUtils.sol";
   5 |     | 
   6 |     | /**
   7 |     |  * @title Utility methods basic math operations.
   8 |     |  *
   9 |     |  * NOTE In order for the fuzzing tests to be isolated, all functions in this library need to be
  10 |     |  * `internal`.  Otherwise a contract that uses this library has a dependency on the library.
  11 |     |  *
  12 |     |  * Our current Echidna setup requires contracts to be deployable in isolation, so make sure to keep
  13 |     |  * the functions `internal`, until we update our Echidna tests to support more complex setups.
  14 |     |  */
  15 |     | library FsMath {
  16 |     |     /**
  17 |     |      * @notice Size of `FIXED_POINT_SCALE` in bits.
  18 |     |      */
  19 |     |     int256 constant FIXED_POINT_SCALE_BITS = 64;
  20 |     | 
  21 |     |     /**
  22 |     |      * @notice Scaling factor used by our fixed-point integer representation.
  23 |     |      *
  24 |     |      * We chose `FIXED_POINT_SCALE` to be a power of 2 to make certain optimizations in the
  25 |     |      * calculation of `e^x` more efficient.  See `exp()` implementation for details.
  26 |     |      *
  27 |     |      * See https://en.wikipedia.org/wiki/Fixed-point_arithmetic
  28 |     |      */
  29 |     |     int256 constant FIXED_POINT_SCALE = int256(1) << uint256(FIXED_POINT_SCALE_BITS);
  30 |     | 
  31 |     |     uint256 constant UINT256_MAX = ~uint256(0);
  32 |     | 
  33 |     |     function abs(int256 value) internal pure returns (uint256) {
  34 |     |         if (value >= 0) {
  35 |     |             // slither-disable-next-line safe-cast
  36 |     |             return uint256(value);
  37 |     |         }
  38 |     |         // slither-disable-next-line safe-cast
  39 |     |         return uint256(-value);
  40 |     |     }
  41 |     | 
  42 |     |     function sabs(int256 value) internal pure returns (int256) {
  43 |     |         if (value >= 0) {
  44 |     |             return value;
  45 |     |         }
  46 |     |         return -value;
  47 |     |     }
  48 |     | 
  49 |     |     function sign(int256 value) internal pure returns (int256) {
  50 |     |         if (value < 0) {
  51 |     |             return -1;
  52 |     |         } else if (value > 0) {
  53 |     |             return 1;
  54 |     |         } else {
  55 |     |             return 0;
  56 |     |         }
  57 |     |     }
  58 |     | 
  59 |     |     function min(int256 a, int256 b) internal pure returns (int256) {
  60 |     |         return a < b ? a : b;
  61 |     |     }
  62 |     | 
  63 |     |     function max(int256 a, int256 b) internal pure returns (int256) {
  64 |     |         return a > b ? a : b;
  65 |     |     }
  66 |     | 
  67 |     |     // Clip val into interval [lower, upper]
  68 |     |     function clip(int256 val, int256 lower, int256 upper) internal pure returns (int256) {
  69 |     |         return min(max(val, lower), upper);
  70 |     |     }
  71 |     | 
  72 |     |     function safeCastToSigned(uint256 x) internal pure returns (int256) {
  73 |     |         // slither-disable-next-line safe-cast
  74 |     |         int256 ret = int256(x);
  75 |     |         require(ret >= 0, "Cast overflow");
  76 |     |         return ret;
  77 |     |     }
  78 |     | 
  79 |     |     function safeCastToUnsigned(int256 x) internal pure returns (uint256) {
  80 |     |         require(x >= 0, "Cast underflow");
  81 |     |         // slither-disable-next-line safe-cast
  82 |     |         return uint256(x);
  83 |     |     }
  84 |     | 
  85 |     |     /**
  86 |     |      * @notice Calculate `e^x`.
  87 |     |      *
  88 |     |      * @param x Is a fixed point decimals with the scale of `FIXED_POINT_SCALE`.
  89 |     |      * @return A fixed point decimals with the scale of `FIXED_POINT_SCALE`.
  90 |     |      */
  91 |     |     function exp(int256 x) internal pure returns (int256) {
  92 |     |         /*
  93 |     |          * Making fixed point representation explicit we want to compute
  94 |     |          *
  95 |     |          * result = e^(x / FIXED_POINT_SCALE) * FIXED_POINT_SCALE
  96 |     |          *
  97 |     |          * To efficiently and accurately calculate the above expression we decompose this into 3
  98 |     |          * parts where each part has an efficient and accurate method of calculation.
  99 |     |          *
 100 |     |          * First, we transform the exponentiation into base 2 so we can use shifts:
 101 |     |          *
 102 |     |          *   e^(x / FIXED_POINT_SCALE) * FIXED_POINT_SCALE
 103 |     |          * = 2^(x / FIXED_POINT_SCALE / ln(2)) * FIXED_POINT_SCALE
 104 |     |          * = 2^(x / ln2FixedPoint) * FIXED_POINT_SCALE
 105 |     |          * = 2^integerQuot * 2^(rem / ln2FixedPoint) * FIXED_POINT_SCALE
 106 |     |          */
 107 |     | 
 108 |     |         FsUtils.Assert(FIXED_POINT_SCALE_BITS == 64);
 109 |     |         /*
 110 |     |          * ln(2) * 2^FIXED_POINT_SCALE_BITS = ln(2) * 2^64
 111 |     |          */
 112 |     |         int256 ln2FixedPoint = 12786308645202655659;
 113 |     | 
 114 |     |         int256 shiftLeft = x / ln2FixedPoint;
 115 |     |         int256 remainder = x % ln2FixedPoint;
 116 |     |         if (shiftLeft <= -FIXED_POINT_SCALE_BITS) return 0;
 117 |     |         require(shiftLeft < (256 - FIXED_POINT_SCALE_BITS), "Exponentiation overflows");
 118 |     | 
 119 |     |         /*
 120 |     |          * At this point we have decomposed exp as a simple bitshift and a fractional power of 2. We
 121 |     |          * could express this as an integer power like
 122 |     |          *
 123 |     |          *      (2^(1/ln2FixedPoint))^remainder
 124 |     |          *
 125 |     |          * but `remainder` is very big, in the order of `10^19` resulting in ~60 (2log) iteration in
 126 |     |          * repeated squaring but more problematic also a lot of precision loss. It turns out that
 127 |     |          * `ln2FixedPoint` as an integer has a smallish factor.
 128 |     |          */
 129 |     |         int256 smallFactor = 4373;
 130 |     |         int256 bigFactor = ln2FixedPoint / smallFactor;
 131 |     | 
 132 |     |         /*
 133 |     |          * Split
 134 |     |          *
 135 |     |          *      2^(remainder/ln2FixedPoint)
 136 |     |          *
 137 |     |          * as
 138 |     |          *
 139 |     |          *      (2^(1/smallFactor)) ^ (remainder/bigFactor)
 140 |     |          */
 141 |     |         int256 integerPower = remainder / bigFactor;
 142 |     |         int256 smallRemainder = remainder % bigFactor;
 143 |     | 
 144 |     |         /*
 145 |     |          * So we can further decompose as follows:
 146 |     |          *
 147 |     |          * (2^(1/smallFactor))^(integerPower) * exp(smallRemainder/fixedPoint)
 148 |     |          *
 149 |     |          * where in the last factor base 2 is replaced with an ordinary e-power using ln2.
 150 |     |          *
 151 |     |          * At this point `0 <= integerPower < smallFactor` and `0 <= smallRemainder < bigFactor`.
 152 |     |          * The first range implies that repeated exponentiation of the first factor won't loop too
 153 |     |          * much and has rather good precision.  The second range implies that
 154 |     |          * `smallRemainder/FIXED_POINT_SCALE < 1/4373` so that the Taylor expansion rapidly
 155 |     |          * converges.
 156 |     |          */
 157 |     |         int256 taylorApprox = FIXED_POINT_SCALE +
 158 |     |             smallRemainder +
 159 |     |             (smallRemainder * smallRemainder) /
 160 |     |             (2 * FIXED_POINT_SCALE) +
 161 |     |             (smallRemainder * smallRemainder * smallRemainder) /
 162 |     |             (6 * FIXED_POINT_SCALE * FIXED_POINT_SCALE);
 163 |     | 
 164 |     |         int256 twoPowRecipSmallFactor = 18449668226934502855; // 2^(1/smallFactor) in fixed point
 165 |     |         int256 prod;
 166 |     |         if (integerPower >= 0) {
 167 |     |             /*
 168 |     |              * This implies shiftLeft >= 0 we don't want to lose precision by first dividing and
 169 |     |              * subsequent shifting left.
 170 |     |              */
 171 |     |             prod = pow(twoPowRecipSmallFactor, integerPower) * taylorApprox;
 172 |     |             shiftLeft -= FIXED_POINT_SCALE_BITS;
 173 |     |         } else {
 174 |     |             /*
 175 |     |              * This implies shiftLeft <= 0 so we're losing precision anyway.
 176 |     |              */
 177 |     |             prod = (FIXED_POINT_SCALE * taylorApprox) / pow(twoPowRecipSmallFactor, -integerPower);
 178 |     |         }
 179 |     | 
 180 |     |         return shiftLeft >= 0 ? (prod << uint256(shiftLeft)) : (prod >> uint256(-shiftLeft));
 181 |     |     }
 182 |     | 
 183 |     |     /**
 184 |     |      * @notice Calculates `x^n`
 185 |     |      *
 186 |     |      * Note we cannot use solidity `**` as we have to normalize fixed point after every
 187 |     |      * multiplication.
 188 |     |      *
 189 |     |      * @param x  a `FIXED_POINT_SCALE` fixed point decimal, with a scale of `FIXED_POINT_SCALE`.
 190 |     |      * @param n  an integer.
 191 |     |      */
 192 |     |     function pow(int256 x, int256 n) internal pure returns (int256) {
 193 |     |         if (n >= 0) {
 194 |     |             return powInternal(x, n);
 195 |     |         } else {
 196 |     |             return powInternal((FIXED_POINT_SCALE * FIXED_POINT_SCALE) / x, -n);
 197 |     |         }
 198 |     |     }
 199 |     | 
 200 |     |     /**
 201 |     |      * @notice Calculates square root of `x`, in fixed point decimal with a scale of
 202 |     |      * `FIXED_POINT_SCALE`.
 203 |     |      *
 204 |     |      * @param x  a `FIXED_POINT_SCALE` fixed point decimal, with a scale of `FIXED_POINT_SCALE`.
 205 |     |      */
 206 |     |     function sqrt(int256 x) internal pure returns (int256) {
 207 |     |         require(x >= 0, "Square root of negative number");
 208 |     |         int256 prevRes = 0;
 209 |     |         int256 res = x / 2;
 210 |     |         while (res != prevRes) {
 211 |     |             prevRes = res;
 212 |     |             res = (res + (x << uint256(FIXED_POINT_SCALE_BITS)) / res) / 2;
 213 |     |         }
 214 |     |         return res;
 215 |     |     }
 216 |     | 
 217 |     |     // See https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation
 218 |     |     function bitCount(uint256 x) internal pure returns (uint256) {
 219 |     |         // In this routine we purposefully interpret x as a number in Z mod (2^256) in the
 220 |     |         // multiplication.
 221 |     |         unchecked {
 222 |     |             if (x == UINT256_MAX) return 256;
 223 |     | 
 224 |     |             // Count 1's in 128 2-bit groups
 225 |     |             uint256 mask = UINT256_MAX / 3; // 0x5555...
 226 |     |             // Special case (x & mask) + ((x >> 1) & mask) equals formula below with less
 227 |     |             // instructions.
 228 |     |             x = x - ((x >> 1) & mask);
 229 |     | 
 230 |     |             // Count 1's in 64 4-bit groups
 231 |     |             mask = UINT256_MAX / 5; // 0x3333....
 232 |     |             x = (x & mask) + ((x >> 2) & mask);
 233 |     | 
 234 |     |             // Count 1's in 32 8-bit groups. Note At this point there is no danger of overflowing
 235 |     |             // between count of groups so we can have
 236 |     |             // (x & mask) + ((x >> n) & mask) = (x + (x >> n)) & mask
 237 |     |             // which saves an instruction
 238 |     |             mask = UINT256_MAX / 17; // 0x0F0F...
 239 |     |             x = (x + (x >> 4)) & mask;
 240 |     | 
 241 |     |             // At this point we have the count of each of the 32 bytes. In 8 bits we can store
 242 |     |             // 0 to 255, so only UINT_MAX would overflow when represented in a single byte, which
 243 |     |             // is case we have excluded. So we can calculate the
 244 |     |             mask = UINT256_MAX / 255;
 245 |     |             x = (x * mask) >> (256 - 8);
 246 |     |         }
 247 |     |         return x;
 248 |     |     }
 249 |     | 
 250 |     |     /**
 251 |     |      * @notice A helper used by `pow`, that expects that `n` is positive.
 252 |     |      */
 253 |     |     function powInternal(int256 x, int256 n) private pure returns (int256) {
 254 |     |         int256 res = FIXED_POINT_SCALE;
 255 |     |         while (n > 0) {
 256 |     |             if ((n & 1) == 1) {
 257 |     |                 res = (res * x) / FIXED_POINT_SCALE;
 258 |     |             }
 259 |     |             x = (x * x) / FIXED_POINT_SCALE;
 260 |     |             n /= 2;
 261 |     |         }
 262 |     |         return res;
 263 |     |     }
 264 |     | }
 265 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/lib/FsUtils.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.17;
  3 |     | 
  4 |     | // BEGIN STRIP
  5 |     | // Used in `FsUtils.log` which is a debugging tool.
  6 |     | import "hardhat/console.sol";
  7 |     | 
  8 |     | // END STRIP
  9 |     | 
 10 |     | library FsUtils {
 11 |     |     // BEGIN STRIP
 12 |     |     // This method is only mean to be used in local testing.  See `preprocess` property in
 13 |     |     // `packages/contracts/hardhat.config.ts`.
 14 |     |     // Slither sees this function is not used, but it is convenient to have it around for debugging
 15 |     |     // purposes.
 16 |     |     // slither-disable-next-line dead-code
 17 |     |     function log(string memory s) internal view {
 18 |     |         console.log(s);
 19 |     |     }
 20 |     | 
 21 |     |     // This method is only mean to be used in local testing.  See `preprocess` property in
 22 |     |     // `packages/contracts/hardhat.config.ts`.
 23 |     |     // Slither sees this function is not used, but it is convenient to have it around for debugging
 24 |     |     // purposes.
 25 |     |     // slither-disable-next-line dead-code
 26 |     |     function log(string memory s, int256 x) internal view {
 27 |     |         console.log(s);
 28 |     |         console.logInt(x);
 29 |     |     }
 30 |     | 
 31 |     |     function log(string memory s, address x) internal view {
 32 |     |         console.log(s, x);
 33 |     |     }
 34 |     | 
 35 |     |     // END STRIP
 36 |     | 
 37 |     |     function encodeToBytes32(bytes memory b) internal pure returns (bytes32) {
 38 |     |         require(b.length < 32, "Byte array to long");
 39 |     |         bytes32 out = bytes32(b);
 40 |     |         out = (out & (~(bytes32(type(uint256).max) >> (8 * b.length)))) | bytes32(b.length);
 41 |     |         return out;
 42 |     |     }
 43 |     | 
 44 |     |     function decodeFromBytes32(bytes32 b) internal pure returns (bytes memory) {
 45 |     |         uint256 len = uint256(b) & 0xff;
 46 |     |         bytes memory out = new bytes(len);
 47 |     |         for (uint256 i = 0; i < len; i++) {
 48 |     |             out[i] = b[i];
 49 |     |         }
 50 |     |         return out;
 51 |     |     }
 52 |     | 
 53 |     |     function nonNull(address _address) internal pure returns (address) {
 54 |     |         require(_address != address(0), "Zero address");
 55 |     |         return _address;
 56 |     |     }
 57 |     | 
 58 |     |     function revertBytes(bytes memory b) internal pure {
 59 |     |         assembly ("memory-safe") {
 60 |     |             revert(add(b, 0x20), mload(b))
 61 |     |         }
 62 |     |     }
 63 |     | 
 64 |     |     // assert a condition. Assert should be used to assert an invariant that should be true
 65 |     |     // logically.
 66 |     |     // This is useful for readability and debugability. A failing assert is always a bug.
 67 |     |     //
 68 |     |     // In production builds (non-hardhat, and non-localhost deployments) this method is a noop.
 69 |     |     //
 70 |     |     // Use "require" to enforce requirements on data coming from outside of a contract. Ie.,
 71 |     |     //
 72 |     |     // ```solidity
 73 |     |     // function nonNegativeX(int x) external { require(x >= 0, "non-negative"); }
 74 |     |     // ```
 75 |     |     //
 76 |     |     // But
 77 |     |     // ```solidity
 78 |     |     // function nonNegativeX(int x) private { assert(x >= 0); }
 79 |     |     // ```
 80 |     |     //
 81 |     |     // If a private function has a pre-condition that it should only be called with non-negative
 82 |     |     // values it's a bug in the contract if it's called with a negative value.
 83 |     |     // solhint-disable-next-line func-name-mixedcase
 84 |     |     function Assert(bool cond) internal pure {
 85 |     |         // BEGIN STRIP
 86 |     |         assert(cond);
 87 |     |         // END STRIP
 88 |     |     }
 89 |     | }
 90 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/lib/GitCommitHash.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.17;
  3 |     | 
  4 |     | // Contracts deriving from this contract will have a public pure function
  5 |     | // that returns a gitCommitHash at the moment it was compiled.
  6 |     | contract GitCommitHash {
  7 |     |     // A purely random string that's being replaced in a prod build by
  8 |     |     // the git hash at build time.
  9 |     |     uint256 public immutable gitCommitHash =
 10 |     |         0xDEADBEEFCAFEBABEBEACBABEBA5EBA11B0A710ADB00BBABEDEFACA7EDEADFA11;
 11 |     | }
 12 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/lib/ImmutableGovernance.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.17;
  3 |     | 
  4 |     | import "./FsUtils.sol";
  5 |     | 
  6 |     | /// @title ImmutableGovernance
  7 |     | /// @dev This contract is meant to be inherited by other contracts, to make them ownable.
  8 |     | contract ImmutableGovernance {
  9 |     |     address public immutable immutableGovernance;
 10 |     | 
 11 |     |     modifier onlyGovernance() {
 12 |     |         require(msg.sender == immutableGovernance, "Only owner");
 13 |     |         _;
 14 |     |     }
 15 |     | 
 16 |     |     constructor(address governance) {
 17 |     |         // slither-disable-next-line missing-zero-check
 18 |     |         immutableGovernance = FsUtils.nonNull(governance);
 19 |     |     }
 20 |     | }
 21 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/lib/ImmutableVersion.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.17;
  3 |     | 
  4 |     | import "./FsUtils.sol";
  5 |     | import "./GitCommitHash.sol";
  6 |     | 
  7 |     | /// @title ImmutableVersion
  8 |     | /// @dev This contract is meant to be inherited by other contracts, to version them.
  9 |     | /// @notice Inherits from GitCommitHash to tie the version to the commit hash in the git repo.
 10 |     | contract ImmutableVersion is GitCommitHash {
 11 |     |     bytes32 public immutable immutableVersion;
 12 |     | 
 13 |     |     constructor(string memory _version) {
 14 |     |         require(bytes(_version).length > 0, "Version is empty");
 15 |     |         immutableVersion = FsUtils.encodeToBytes32(bytes(_version));
 16 |     |     }
 17 |     | }
 18 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/lib/NonceMap.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.17;
  3 |     | 
  4 |     | import "@openzeppelin/contracts/utils/structs/BitMaps.sol";
  5 |     | 
  6 |     | struct NonceMap {
  7 |     |     BitMaps.BitMap bitMap;
  8 |     | }
  9 |     | 
 10 |     | library NonceMapLib {
 11 |     |     using BitMaps for BitMaps.BitMap;
 12 |     | 
 13 |     |     function validateAndUseNonce(NonceMap storage self, uint256 nonce) internal {
 14 |     |         require(!self.bitMap.get(nonce), "Nonce already used");
 15 |     |         self.bitMap.set(nonce);
 16 |     |     }
 17 |     | 
 18 |     |     function getNonce(NonceMap storage self, uint256 nonce) internal view returns (bool) {
 19 |     |         return self.bitMap.get(nonce);
 20 |     |     }
 21 |     | }
 22 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/lib/Proofs.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity ^0.8.17;
   3 |     | 
   4 |     | import "./FsUtils.sol";
   5 |     | 
   6 |     | type BytesView is uint256;
   7 |     | 
   8 |     | type RLPItem is uint256;
   9 |     | 
  10 |     | type RLPIterator is uint256;
  11 |     | 
  12 |     | library BytesViewLib {
  13 |     |     uint256 private constant WORD_SIZE = 32;
  14 |     | 
  15 |     |     error OutOfBounds();
  16 |     |     error InvalidScalarEncoding();
  17 |     | 
  18 |     |     function mload(uint256 ptr) internal pure returns (bytes32 res) {
  19 |     |         assembly {
  20 |     |             res := mload(ptr)
  21 |     |         }
  22 |     |     }
  23 |     | 
  24 |     |     function mstore(uint256 ptr, bytes32 value) internal pure {
  25 |     |         assembly {
  26 |     |             mstore(ptr, value)
  27 |     |         }
  28 |     |     }
  29 |     | 
  30 |     |     function memPtr(bytes memory b) internal pure returns (uint256 res) {
  31 |     |         assembly {
  32 |     |             res := add(b, 0x20)
  33 |     |         }
  34 |     |     }
  35 |     | 
  36 |     |     function mCopy(uint256 src, uint256 dest, uint256 len) internal pure {
  37 |     |         unchecked {
  38 |     |             // copy as many word sizes as possible
  39 |     |             for (; len >= WORD_SIZE; len -= WORD_SIZE) {
  40 |     |                 mstore(dest, mload(src));
  41 |     | 
  42 |     |                 src += WORD_SIZE;
  43 |     |                 dest += WORD_SIZE;
  44 |     |             }
  45 |     |             if (len == 0) return;
  46 |     |             // left over bytes. Mask is used to remove unwanted bytes from the word
  47 |     |             FsUtils.Assert(len > 0 && len < WORD_SIZE);
  48 |     |             bytes32 mask = bytes32((1 << ((WORD_SIZE - len) << 3)) - 1);
  49 |     |             bytes32 srcpart = mload(src) & ~mask; // zero out src
  50 |     |             bytes32 destpart = mload(dest) & mask; // retrieve the bytes
  51 |     |             mstore(dest, destpart | srcpart);
  52 |     |         }
  53 |     |     }
  54 |     | 
  55 |     |     function empty() internal pure returns (BytesView) {
  56 |     |         return BytesView.wrap(0);
  57 |     |     }
  58 |     | 
  59 |     |     function wrap(uint256 ptr, uint256 len) internal pure returns (BytesView) {
  60 |     |         return BytesView.wrap((ptr << 128) | len);
  61 |     |     }
  62 |     | 
  63 |     |     function length(BytesView b) internal pure returns (uint256) {
  64 |     |         return BytesView.unwrap(b) & type(uint128).max;
  65 |     |     }
  66 |     | 
  67 |     |     function memPtr(BytesView b) private pure returns (uint256) {
  68 |     |         return BytesView.unwrap(b) >> 128;
  69 |     |     }
  70 |     | 
  71 |     |     function fromBytes(bytes memory b) internal pure returns (BytesView) {
  72 |     |         return BytesViewLib.wrap(memPtr(b), b.length);
  73 |     |     }
  74 |     | 
  75 |     |     function toBytes(BytesView b) internal pure returns (bytes memory res) {
  76 |     |         uint len = length(b);
  77 |     |         res = new bytes(len);
  78 |     |         mCopy(memPtr(b), BytesViewLib.memPtr(res), len);
  79 |     |     }
  80 |     | 
  81 |     |     function unsafeLoadUInt8(BytesView b, uint256 offset) internal pure returns (uint256) {
  82 |     |         unchecked {
  83 |     |             return uint256(mload(memPtr(b) + offset)) >> 248;
  84 |     |         }
  85 |     |     }
  86 |     | 
  87 |     |     function loadUInt8(BytesView b, uint256 offset) internal pure returns (uint256) {
  88 |     |         if (offset >= length(b)) revert OutOfBounds();
  89 |     |         return unsafeLoadUInt8(b, offset);
  90 |     |     }
  91 |     | 
  92 |     |     function unsafeLoadBytes32(BytesView b, uint256 offset) internal pure returns (bytes32) {
  93 |     |         unchecked {
  94 |     |             return mload(memPtr(b) + offset);
  95 |     |         }
  96 |     |     }
  97 |     | 
  98 |     |     function loadBytes32(BytesView b, uint256 offset) internal pure returns (bytes32) {
  99 |     |         if (offset + 32 > length(b)) revert OutOfBounds();
 100 |     |         return unsafeLoadBytes32(b, offset);
 101 |     |     }
 102 |     | 
 103 |     |     // Decode scalar value (non-negative integer) as described in yellow paper
 104 |     |     function decodeScalar(BytesView b) internal pure returns (uint256) {
 105 |     |         uint len = length(b);
 106 |     |         if (len == 0) return 0;
 107 |     |         bytes32 data = unsafeLoadBytes32(b, 0);
 108 |     |         if (data[0] == 0) revert InvalidScalarEncoding();
 109 |     |         return uint256(data >> ((WORD_SIZE - len) << 3)); // reverts if len > 32
 110 |     |     }
 111 |     | 
 112 |     |     function unsafeSlice(
 113 |     |         BytesView b,
 114 |     |         uint256 offset,
 115 |     |         uint256 len
 116 |     |     ) internal pure returns (BytesView) {
 117 |     |         unchecked {
 118 |     |             FsUtils.Assert(offset + len <= length(b));
 119 |     |             return BytesViewLib.wrap(memPtr(b) + offset, len);
 120 |     |         }
 121 |     |     }
 122 |     | 
 123 |     |     function slice(BytesView b, uint256 offset, uint256 len) internal pure returns (BytesView) {
 124 |     |         if (offset + len > length(b)) revert OutOfBounds();
 125 |     |         return unsafeSlice(b, offset, len);
 126 |     |     }
 127 |     | 
 128 |     |     function unsafeSkip(BytesView b, uint256 offset) internal pure returns (BytesView) {
 129 |     |         unchecked {
 130 |     |             FsUtils.Assert(offset <= length(b));
 131 |     |             return BytesViewLib.wrap(memPtr(b) + offset, length(b) - offset);
 132 |     |         }
 133 |     |     }
 134 |     | 
 135 |     |     function skip(BytesView b, uint256 offset) internal pure returns (BytesView) {
 136 |     |         if (offset > length(b)) revert OutOfBounds();
 137 |     |         return unsafeSkip(b, offset);
 138 |     |     }
 139 |     | 
 140 |     |     function keccak(BytesView b) internal pure returns (bytes32 res) {
 141 |     |         uint256 ptr = memPtr(b);
 142 |     |         uint256 len = length(b);
 143 |     |         assembly {
 144 |     |             res := keccak256(ptr, len)
 145 |     |         }
 146 |     |     }
 147 |     | }
 148 |     | 
 149 |     | library RLP {
 150 |     |     using BytesViewLib for BytesView;
 151 |     |     using RLP for RLPItem;
 152 |     |     using RLP for RLPIterator;
 153 |     | 
 154 |     |     error InvalidRLPItem();
 155 |     |     error ItemIsNotList();
 156 |     |     error ItemIsNotBytes();
 157 |     | 
 158 |     |     function isList(RLPItem item) internal pure returns (bool) {
 159 |     |         FsUtils.Assert(buffer(item).length() > 0);
 160 |     |         return buffer(item).unsafeLoadUInt8(0) >= 0xc0;
 161 |     |     }
 162 |     | 
 163 |     |     function isBytes(RLPItem item) internal pure returns (bool) {
 164 |     |         return !isList(item);
 165 |     |     }
 166 |     | 
 167 |     |     function requireRLPItem(BytesView b) internal pure returns (RLPItem) {
 168 |     |         uint256 len = rlpLen(b);
 169 |     |         if (len != b.length()) revert InvalidRLPItem();
 170 |     |         return asRLPItem(b);
 171 |     |     }
 172 |     | 
 173 |     |     function requireBytesView(RLPItem item) internal pure returns (BytesView) {
 174 |     |         if (!isBytes(item)) revert ItemIsNotBytes();
 175 |     |         return toBytesView(item);
 176 |     |     }
 177 |     | 
 178 |     |     function toBytesView(RLPItem item) internal pure returns (BytesView) {
 179 |     |         unchecked {
 180 |     |             FsUtils.Assert(isBytes(item));
 181 |     |             uint256 tag = buffer(item).unsafeLoadUInt8(0);
 182 |     |             if (tag < 0x80) {
 183 |     |                 return buffer(item).unsafeSlice(0, 1);
 184 |     |             } else if (tag < 0xb8) {
 185 |     |                 return buffer(item).unsafeSlice(1, tag - 0x80);
 186 |     |             } else {
 187 |     |                 uint256 lenLen = tag - 0xb7;
 188 |     |                 uint256 len = uint256(buffer(item).unsafeLoadBytes32(1)) >> (8 * (32 - lenLen));
 189 |     |                 return buffer(item).unsafeSlice(1 + lenLen, len);
 190 |     |             }
 191 |     |         }
 192 |     |     }
 193 |     | 
 194 |     |     function requireRLPItemIterator(RLPItem item) internal pure returns (RLPIterator) {
 195 |     |         if (!isList(item)) revert ItemIsNotList();
 196 |     |         return toRLPItemIterator(item);
 197 |     |     }
 198 |     | 
 199 |     |     function toRLPItemIterator(RLPItem item) internal pure returns (RLPIterator) {
 200 |     |         unchecked {
 201 |     |             FsUtils.Assert(isList(item));
 202 |     |             uint256 len = 0;
 203 |     |             uint256 lenLen = 0;
 204 |     |             uint256 initial = buffer(item).unsafeLoadUInt8(0);
 205 |     |             if (initial < 0xf8) {
 206 |     |                 len = initial - 0xc0;
 207 |     |             } else {
 208 |     |                 lenLen = initial - 0xf7;
 209 |     |                 len = uint256(buffer(item).unsafeLoadBytes32(1)) >> (8 * (32 - lenLen));
 210 |     |             }
 211 |     |             FsUtils.Assert(len + lenLen + 1 == buffer(item).length()); // , "RLP: Invalid length it");
 212 |     |             BytesView b = buffer(item).unsafeSlice(1 + lenLen, len);
 213 |     |             return RLPIterator.wrap(BytesView.unwrap(b));
 214 |     |         }
 215 |     |     }
 216 |     | 
 217 |     |     function unsafeNext(RLPIterator it) internal pure returns (RLPItem item, RLPIterator nextIt) {
 218 |     |         FsUtils.Assert(buffer(it).length() > 0); // "RLP: Iterator out of bounds");
 219 |     |         uint256 len = rlpLen(buffer(it));
 220 |     |         item = asRLPItem(buffer(it).unsafeSlice(0, len));
 221 |     |         nextIt = asRLPIterator(buffer(it).unsafeSkip(len));
 222 |     |     }
 223 |     | 
 224 |     |     function next(RLPIterator it) internal pure returns (RLPItem item, RLPIterator nextIt) {
 225 |     |         FsUtils.Assert(buffer(it).length() > 0); // "RLP: Iterator out of bounds");
 226 |     |         uint256 len = rlpLen(buffer(it));
 227 |     |         item = asRLPItem(buffer(it).slice(0, len));
 228 |     |         nextIt = asRLPIterator(buffer(it).unsafeSkip(len));
 229 |     |     }
 230 |     | 
 231 |     |     function unsafeSkipNext(RLPIterator it) internal pure returns (RLPIterator nextIt) {
 232 |     |         FsUtils.Assert(buffer(it).length() > 0); // "RLP: Iterator out of bounds");
 233 |     |         uint256 len = rlpLen(buffer(it));
 234 |     |         nextIt = asRLPIterator(buffer(it).unsafeSkip(len));
 235 |     |     }
 236 |     | 
 237 |     |     function hasNext(RLPIterator it) internal pure returns (bool) {
 238 |     |         return buffer(it).length() > 0;
 239 |     |     }
 240 |     | 
 241 |     |     function length(RLPItem item) internal pure returns (uint256) {
 242 |     |         return buffer(item).length();
 243 |     |     }
 244 |     | 
 245 |     |     function keccak(RLPItem item) internal pure returns (bytes32 res) {
 246 |     |         return buffer(item).keccak();
 247 |     |     }
 248 |     | 
 249 |     |     function buffer(RLPItem item) private pure returns (BytesView) {
 250 |     |         return BytesView.wrap(RLPItem.unwrap(item));
 251 |     |     }
 252 |     | 
 253 |     |     function buffer(RLPIterator it) private pure returns (BytesView) {
 254 |     |         return BytesView.wrap(RLPIterator.unwrap(it));
 255 |     |     }
 256 |     | 
 257 |     |     function rlpLen(BytesView b) private pure returns (uint256) {
 258 |     |         unchecked {
 259 |     |             FsUtils.Assert(b.length() > 0); // "RLP: Empty buffer");
 260 |     |             uint256 len = 0;
 261 |     |             uint256 lenLen = 0;
 262 |     |             uint256 initial = b.unsafeLoadUInt8(0);
 263 |     |             if (initial < 0x80) {
 264 |     |                 return 1;
 265 |     |                 // nothing
 266 |     |             } else if (initial < 0xb8) {
 267 |     |                 return 1 + initial - 0x80;
 268 |     |             } else if (initial < 0xc0) {
 269 |     |                 lenLen = initial - 0xb7;
 270 |     |                 // Continue below
 271 |     |             } else if (initial < 0xf8) {
 272 |     |                 return 1 + initial - 0xc0;
 273 |     |             } else {
 274 |     |                 lenLen = initial - 0xf7;
 275 |     |                 // Continue below
 276 |     |             }
 277 |     |             len = uint256(b.unsafeLoadBytes32(1)) >> (8 * (32 - lenLen));
 278 |     |             return len + lenLen + 1;
 279 |     |         }
 280 |     |     }
 281 |     | 
 282 |     |     function asRLPItem(BytesView b) private pure returns (RLPItem) {
 283 |     |         return RLPItem.wrap(BytesView.unwrap(b));
 284 |     |     }
 285 |     | 
 286 |     |     function asRLPIterator(BytesView b) private pure returns (RLPIterator) {
 287 |     |         return RLPIterator.wrap(BytesView.unwrap(b));
 288 |     |     }
 289 |     | }
 290 |     | 
 291 |     | library TrieLib {
 292 |     |     using BytesViewLib for BytesView;
 293 |     |     using RLP for RLPItem;
 294 |     |     using RLP for RLPIterator;
 295 |     | 
 296 |     |     // RLP("") = "0x80"
 297 |     |     bytes32 private constant EMPTY_TRIE_HASH =
 298 |     |         0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421;
 299 |     | 
 300 |     |     error KeyTooLong();
 301 |     |     error ProofTooLong();
 302 |     |     error IncompleteProof();
 303 |     |     error InvalidProof();
 304 |     | 
 305 |     |     /// @dev Verify a proof of a key in a Merkle Patricia Trie, revert if the proof is invalid.
 306 |     |     /// @param key The key to verify.
 307 |     |     /// @param root The root hash of the trie. This is assumed to be from a trusted source (e.g. a block header)
 308 |     |     ///        and therefore represents a structurally valid tree.
 309 |     |     /// @param proof The proof of the key. Untrusted data.
 310 |     |     /// @return The value of the key if the key exists or empty if key doesn't exist.
 311 |     |     /// @notice The stored value is encoded as RLP and thus never empty, so empty means the key doesn't exist.
 312 |     |     ///         This is reasonably optimized for gas, it's around 25k gas per proof depending on the depth.
 313 |     |     function verify(
 314 |     |         bytes32 key,
 315 |     |         uint256 keyLength,
 316 |     |         bytes32 root,
 317 |     |         bytes memory proof
 318 |     |     ) internal pure returns (BytesView) {
 319 |     |         unchecked {
 320 |     |             if (keyLength > 32) revert KeyTooLong();
 321 |     |             uint256 nibblesLeft = keyLength * 2;
 322 |     |             RLPItem rlpListItem = RLP.requireRLPItem(BytesViewLib.fromBytes(proof));
 323 |     |             RLPIterator listIt = rlpListItem.requireRLPItemIterator();
 324 |     |             RLPItem child0;
 325 |     |             RLPItem child1;
 326 |     |             BytesView res = BytesViewLib.empty();
 327 |     |             while (listIt.hasNext()) {
 328 |     |                 if (root == EMPTY_TRIE_HASH) revert ProofTooLong();
 329 |     |                 RLPItem rlpItem;
 330 |     |                 (rlpItem, listIt) = listIt.next();
 331 |     |                 if (rlpItem.keccak() != root) revert InvalidProof();
 332 |     |                 // Because it passed this cryptographic check, we know that the rlpItem is a well-formed
 333 |     |                 // RLP encoded MPT node.
 334 |     | 
 335 |     |                 RLPIterator childIt = rlpItem.toRLPItemIterator();
 336 |     |                 FsUtils.Assert(childIt.hasNext());
 337 |     |                 (child0, childIt) = childIt.unsafeNext();
 338 |     |                 FsUtils.Assert(childIt.hasNext());
 339 |     |                 (child1, childIt) = childIt.unsafeNext();
 340 |     | 
 341 |     |                 RLPItem nextRoot;
 342 |     |                 root = EMPTY_TRIE_HASH; // sentinel indicating end of proof
 343 |     |                 if (childIt.hasNext()) {
 344 |     |                     // Branch node
 345 |     |                     uint nibble = nibblesLeft == 0 ? 16 : uint256(key) >> 252;
 346 |     | 
 347 |     |                     if (nibble < 2) {
 348 |     |                         nextRoot = nibble == 0 ? child0 : child1;
 349 |     |                     } else {
 350 |     |                         for (uint i = 2; i < nibble; i++) {
 351 |     |                             FsUtils.Assert(childIt.hasNext());
 352 |     |                             childIt = childIt.unsafeSkipNext();
 353 |     |                         }
 354 |     |                         FsUtils.Assert(childIt.hasNext());
 355 |     |                         (nextRoot, childIt) = childIt.unsafeNext();
 356 |     |                     }
 357 |     | 
 358 |     |                     if (nibblesLeft == 0) {
 359 |     |                         res = nextRoot.toBytesView();
 360 |     |                         continue;
 361 |     |                     }
 362 |     |                     key <<= 4;
 363 |     |                     nibblesLeft -= 1;
 364 |     |                 } else {
 365 |     |                     // Extension or leaf nodes
 366 |     |                     BytesView partialKey = child0.toBytesView();
 367 |     |                     FsUtils.Assert(partialKey.length() > 0 && partialKey.length() <= 33);
 368 |     |                     uint256 tag = partialKey.unsafeLoadUInt8(0);
 369 |     |                     bytes32 partialKeyBytes = partialKey.unsafeLoadBytes32(1);
 370 |     |                     uint partialKeyLength = 2 * partialKey.length() - 2;
 371 |     |                     // Two most significant bits must be zero for a valid hex-prefix string
 372 |     |                     FsUtils.Assert(tag < 64);
 373 |     |                     if ((tag & 16) != 0) {
 374 |     |                         // Odd number of nibbles, low order nibble of tag is first nibble of key
 375 |     |                         partialKeyBytes = (partialKeyBytes >> 4) | bytes32(tag << 252);
 376 |     |                         partialKeyLength += 1;
 377 |     |                     } else {
 378 |     |                         // Even number of nibbles, low order nibble of tag is zero
 379 |     |                         FsUtils.Assert(tag & 0xF == 0);
 380 |     |                     }
 381 |     |                     // For a valid MPT, the partial key must be at least one nibble and will
 382 |     |                     // never be more then 32 bytes.
 383 |     |                     FsUtils.Assert(partialKeyLength > 0 && partialKeyLength <= 64);
 384 |     |                     // The partialKey must be a prefix of key
 385 |     |                     if (
 386 |     |                         partialKeyLength > nibblesLeft ||
 387 |     |                         (partialKeyBytes ^ key) >> (256 - 4 * partialKeyLength) != 0
 388 |     |                     ) {
 389 |     |                         // The partial key is not a prefix of the key, so the key doesn't exist
 390 |     |                         continue;
 391 |     |                     }
 392 |     |                     nibblesLeft -= partialKeyLength;
 393 |     |                     key <<= 4 * partialKeyLength;
 394 |     | 
 395 |     |                     if ((tag & 32) != 0) {
 396 |     |                         // Leaf node
 397 |     |                         if (nibblesLeft == 0) {
 398 |     |                             res = child1.toBytesView();
 399 |     |                         }
 400 |     |                         continue;
 401 |     |                     }
 402 |     |                     nextRoot = child1;
 403 |     |                 }
 404 |     |                 // Proof continue with child node
 405 |     |                 if (nextRoot.isBytes()) {
 406 |     |                     BytesView childBytes = nextRoot.toBytesView();
 407 |     |                     if (childBytes.length() == 0) {
 408 |     |                         continue;
 409 |     |                     }
 410 |     |                     FsUtils.Assert(childBytes.length() == 32); // Invalid child hash
 411 |     |                     root = childBytes.unsafeLoadBytes32(0);
 412 |     |                 } else {
 413 |     |                     FsUtils.Assert(nextRoot.isList());
 414 |     |                     // The next node is embedded directly in this node
 415 |     |                     // as it's RLP length is less than 32 bytes.
 416 |     |                     FsUtils.Assert(nextRoot.length() < 32); // "IP: child node too long";
 417 |     |                     root = nextRoot.keccak();
 418 |     |                 }
 419 |     |             }
 420 |     |             if (root != EMPTY_TRIE_HASH) revert IncompleteProof();
 421 |     |             return res;
 422 |     |         }
 423 |     |     }
 424 |     | 
 425 |     |     function proofAccount(
 426 |     |         address account,
 427 |     |         bytes32 stateRoot,
 428 |     |         bytes memory proof
 429 |     |     )
 430 |     |         internal
 431 |     |         pure
 432 |     |         returns (uint256 nonce, uint256 balance, bytes32 storageHash, bytes32 codeHash)
 433 |     |     {
 434 |     |         BytesView accountRLP = verify(keccak256(abi.encodePacked(account)), 32, stateRoot, proof);
 435 |     |         if (accountRLP.length() == 0) {
 436 |     |             return (0, 0, bytes32(0), bytes32(0));
 437 |     |         }
 438 |     |         RLPItem item = RLP.requireRLPItem(accountRLP);
 439 |     |         RLPIterator it = item.requireRLPItemIterator();
 440 |     |         FsUtils.Assert(it.hasNext());
 441 |     |         (item, it) = it.next();
 442 |     |         nonce = item.requireBytesView().decodeScalar();
 443 |     |         FsUtils.Assert(it.hasNext());
 444 |     |         (item, it) = it.next();
 445 |     |         balance = item.requireBytesView().decodeScalar();
 446 |     |         FsUtils.Assert(it.hasNext());
 447 |     |         (item, it) = it.next();
 448 |     |         storageHash = item.requireBytesView().unsafeLoadBytes32(0);
 449 |     |         FsUtils.Assert(it.hasNext());
 450 |     |         (item, it) = it.next();
 451 |     |         codeHash = item.requireBytesView().unsafeLoadBytes32(0);
 452 |     |     }
 453 |     | 
 454 |     |     function proofStorageAt(
 455 |     |         bytes32 slot,
 456 |     |         bytes32 storageHash,
 457 |     |         bytes memory proof
 458 |     |     ) internal pure returns (uint256) {
 459 |     |         BytesView valueRLP = verify(keccak256(abi.encodePacked(slot)), 32, storageHash, proof);
 460 |     |         if (valueRLP.length() == 0) {
 461 |     |             return 0;
 462 |     |         }
 463 |     |         RLPItem item = RLP.requireRLPItem(valueRLP);
 464 |     |         BytesView storedAmount = item.requireBytesView();
 465 |     |         return storedAmount.decodeScalar();
 466 |     |     }
 467 |     | }
 468 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/oracles/ERC20ChainlinkValueOracle.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.17;
  3 |     | 
  4 |     | import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";
  5 |     | import "@openzeppelin/contracts/utils/Strings.sol";
  6 |     | import "../lib/FsUtils.sol";
  7 |     | import "../interfaces/IERC20ValueOracle.sol";
  8 |     | 
  9 |     | import {ImmutableGovernance} from "../lib/ImmutableGovernance.sol";
 10 |     | 
 11 |     | contract ERC20ChainlinkValueOracle is ImmutableGovernance, IERC20ValueOracle {
 12 |     |     AggregatorV3Interface priceOracle;
 13 |     |     int256 immutable base;
 14 |     |     int256 collateralFactor = 1 ether;
 15 |     |     int256 borrowFactor = 1 ether;
 16 |     | 
 17 |     |     modifier checkDecimals(string memory label, uint8 decimals) {
 18 |     |         if (decimals < 3 || 18 < decimals) {
 19 |     |             // prettier-ignore
 20 |     |             revert(string.concat(
 21 |     |                 "Invalid ", label, ": must be within [3, 18] range while provided is ",
 22 |     |                 Strings.toString(decimals)
 23 |     |             ));
 24 |     |         }
 25 |     |         _;
 26 |     |     }
 27 |     | 
 28 |     |     constructor(
 29 |     |         address chainlink,
 30 |     |         uint8 baseDecimals,
 31 |     |         uint8 tokenDecimals,
 32 |     |         int256 _collateralFactor,
 33 |     |         int256 _borrowFactor,
 34 |     |         address _owner
 35 |     |     )
 36 |     |         ImmutableGovernance(_owner)
 37 |     |         checkDecimals("baseDecimals", baseDecimals)
 38 |     |         checkDecimals("tokenDecimals", tokenDecimals)
 39 |     |     {
 40 |     |         priceOracle = AggregatorV3Interface(FsUtils.nonNull(chainlink));
 41 |     |         base = int256(10) ** (tokenDecimals + priceOracle.decimals() - baseDecimals);
 42 |     |         collateralFactor = _collateralFactor;
 43 |     |         borrowFactor = _borrowFactor;
 44 |     |     }
 45 |     | 
 46 |     |     function setRiskFactors(
 47 |     |         int256 _collateralFactor,
 48 |     |         int256 _borrowFactor
 49 |     |     ) external onlyGovernance {
 50 |     |         collateralFactor = _collateralFactor;
 51 |     |         borrowFactor = _borrowFactor;
 52 |     |     }
 53 |     | 
 54 |     |     function calcValue(
 55 |     |         int256 balance
 56 |     |     ) external view override returns (int256 value, int256 riskAdjustedValue) {
 57 |     |         (, int256 price, , , ) = priceOracle.latestRoundData();
 58 |     |         value = (balance * price) / base;
 59 |     |         if (balance >= 0) {
 60 |     |             riskAdjustedValue = (value * collateralFactor) / 1 ether;
 61 |     |         } else {
 62 |     |             riskAdjustedValue = (value * 1 ether) / borrowFactor;
 63 |     |         }
 64 |     |         return (value, riskAdjustedValue);
 65 |     |     }
 66 |     | }
 67 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/oracles/UniV2Oracle.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.17;
  3 |     | 
  4 |     | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  5 |     | 
  6 |     | import {ImmutableGovernance} from "../lib/ImmutableGovernance.sol";
  7 |     | import {IERC20ValueOracle} from "../interfaces/IERC20ValueOracle.sol";
  8 |     | import {FsMath} from "../lib/FsMath.sol";
  9 |     | import {IDOS} from "../interfaces/IDOS.sol";
 10 |     | import {IDuoswapV2Pair} from "../duoswapV2/interfaces/IDuoswapV2Pair.sol";
 11 |     | 
 12 |     | contract UniV2Oracle is ImmutableGovernance, IERC20ValueOracle {
 13 |     |     IDOS public immutable dos;
 14 |     |     IDuoswapV2Pair public immutable pair;
 15 |     |     // address public immutable dSafe;
 16 |     |     // address public immutable token0;
 17 |     |     // address public immutable token1;
 18 |     | 
 19 |     |     mapping(address => IERC20ValueOracle) public erc20ValueOracle;
 20 |     | 
 21 |     |     constructor(address _dos, address _pair, address _owner) ImmutableGovernance(_owner) {
 22 |     |         if (_dos == address(0) || _pair == address(0) || _owner == address(0)) {
 23 |     |             revert("Zero address");
 24 |     |         }
 25 |     |         dos = IDOS(_dos);
 26 |     |         pair = IDuoswapV2Pair(_pair);
 27 |     | 
 28 |     |         // dSafe = IUniswapV2Pair(_pair).dSafe();
 29 |     |         // token0 = IUniswapV2Pair(_pair).token0();
 30 |     |         // token1 = IUniswapV2Pair(_pair).token1();
 31 |     |     }
 32 |     | 
 33 |     |     /// @notice Set the oracle for an underlying token
 34 |     |     /// @param erc20 The underlying token
 35 |     |     /// @param oracle The oracle for the underlying token
 36 |     |     function setERC20ValueOracle(address erc20, address oracle) external onlyGovernance {
 37 |     |         erc20ValueOracle[erc20] = IERC20ValueOracle(oracle);
 38 |     |     }
 39 |     | 
 40 |     |     /// @notice Calculate the value of a uniswap pair token
 41 |     |     /// @param amount The amount of the token
 42 |     |     /// @return value The value of the uniswap pair token
 43 |     |     /// @return riskAdjustedValue The risk adjusted value of the uniswap pair token
 44 |     |     function calcValue(
 45 |     |         int256 amount
 46 |     |     ) external view override returns (int256 value, int256 riskAdjustedValue) {
 47 |     |         uint256 totalSupply = pair.totalSupply();
 48 |     |         if (totalSupply == 0) {
 49 |     |             return (0, 0);
 50 |     |         }
 51 |     |         address dSafe = pair.dSafe();
 52 |     |         address token0 = pair.token0();
 53 |     |         address token1 = pair.token1();
 54 |     | 
 55 |     |         uint256 balance0 = uint256(IDOS(dos).getDAccountERC20(dSafe, IERC20(token0)));
 56 |     |         uint256 balance1 = uint256(IDOS(dos).getDAccountERC20(dSafe, IERC20(token1)));
 57 |     | 
 58 |     |         (int256 price0, int256 adjustedPrice0) = erc20ValueOracle[token0].calcValue(
 59 |     |             FsMath.safeCastToSigned(balance0)
 60 |     |         );
 61 |     |         (int256 price1, int256 adjustedPrice1) = erc20ValueOracle[token1].calcValue(
 62 |     |             FsMath.safeCastToSigned(balance1)
 63 |     |         );
 64 |     | 
 65 |     |         value = ((price0 + price1) * amount) / FsMath.safeCastToSigned(totalSupply);
 66 |     |         riskAdjustedValue =
 67 |     |             ((adjustedPrice0 + adjustedPrice1) * amount) /
 68 |     |             FsMath.safeCastToSigned(totalSupply);
 69 |     |         return (value, riskAdjustedValue);
 70 |     |     }
 71 |     | }
 72 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/oracles/UniV3Oracle.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity ^0.8.17;
   3 |     | 
   4 |     | import "../lib/ImmutableGovernance.sol";
   5 |     | import "../interfaces/IERC20ValueOracle.sol";
   6 |     | import "../interfaces/INFTValueOracle.sol";
   7 |     | import "../lib/FsMath.sol";
   8 |     | import "../lib/FsUtils.sol";
   9 |     | import "../external/interfaces/INonfungiblePositionManager.sol";
  10 |     | import "@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol";
  11 |     | import "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";
  12 |     | import "@uniswap/v3-core/contracts/libraries/FixedPoint96.sol";
  13 |     | 
  14 |     | // TickMath lib is inconsistent with solidity compiler version
  15 |     | library TickMath {
  16 |     |     /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128
  17 |     |     int24 internal constant MIN_TICK = -887272;
  18 |     |     /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128
  19 |     |     int24 internal constant MAX_TICK = -MIN_TICK;
  20 |     | 
  21 |     |     /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)
  22 |     |     uint160 internal constant MIN_SQRT_RATIO = 4295128739;
  23 |     |     /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)
  24 |     |     uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;
  25 |     | 
  26 |     |     /// @notice Calculates sqrt(1.0001^tick) * 2^96
  27 |     |     /// @dev Throws if |tick| > max tick
  28 |     |     /// @param tick The input tick for the above formula
  29 |     |     /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two erc20s (token1/token0)
  30 |     |     /// at the given tick
  31 |     |     function getSqrtRatioAtTick(int24 tick) internal pure returns (int256 sqrtPriceX96) {
  32 |     |         uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
  33 |     |         require(absTick <= uint256(uint24(MAX_TICK)), "T");
  34 |     | 
  35 |     |         uint256 ratio = absTick & 0x1 != 0
  36 |     |             ? 0xfffcb933bd6fad37aa2d162d1a594001
  37 |     |             : 0x100000000000000000000000000000000;
  38 |     |         if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
  39 |     |         if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
  40 |     |         if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
  41 |     |         if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
  42 |     |         if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
  43 |     |         if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
  44 |     |         if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
  45 |     |         if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
  46 |     |         if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
  47 |     |         if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
  48 |     |         if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
  49 |     |         if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
  50 |     |         if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
  51 |     |         if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
  52 |     |         if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
  53 |     |         if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
  54 |     |         if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
  55 |     |         if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
  56 |     |         if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;
  57 |     | 
  58 |     |         if (tick > 0) ratio = type(uint256).max / ratio;
  59 |     | 
  60 |     |         // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.
  61 |     |         // we then downcast because we know the result always fits within 160 bits due to our tick input constraint
  62 |     |         // we round up in the division so getTickAtSqrtRatio of the output price is always consistent
  63 |     |         sqrtPriceX96 = int256((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
  64 |     |     }
  65 |     | }
  66 |     | 
  67 |     | contract UniV3Oracle is ImmutableGovernance, INFTValueOracle {
  68 |     |     INonfungiblePositionManager public immutable manager;
  69 |     |     IUniswapV3Factory public immutable factory;
  70 |     | 
  71 |     |     int256 collateralFactor = 1 ether;
  72 |     | 
  73 |     |     mapping(address => IERC20ValueOracle) public erc20ValueOracle;
  74 |     | 
  75 |     |     int256 constant Q96 = int256(FixedPoint96.Q96);
  76 |     | 
  77 |     |     constructor(address _factory, address _manager, address _owner) ImmutableGovernance(_owner) {
  78 |     |         manager = INonfungiblePositionManager(_manager);
  79 |     |         factory = IUniswapV3Factory(_factory);
  80 |     |     }
  81 |     | 
  82 |     |     function setERC20ValueOracle(address token, address oracle) external onlyGovernance {
  83 |     |         erc20ValueOracle[token] = IERC20ValueOracle(oracle);
  84 |     |     }
  85 |     | 
  86 |     |     function setCollateralFactor(int256 _collateralFactor) external onlyGovernance {
  87 |     |         collateralFactor = _collateralFactor;
  88 |     |     }
  89 |     | 
  90 |     |     function calcValue(uint256 tokenId) external view override returns (int256, int256) {
  91 |     |         address token0;
  92 |     |         address token1;
  93 |     |         int256 liquidity;
  94 |     |         int256 sqrtPrice;
  95 |     |         int256 baseX;
  96 |     |         int256 baseY;
  97 |     |         {
  98 |     |             (
  99 |     |                 ,
 100 |     |                 ,
 101 |     |                 address token0Tmp,
 102 |     |                 address token1Tmp,
 103 |     |                 uint24 fee,
 104 |     |                 int24 tickLower,
 105 |     |                 int24 tickUpper,
 106 |     |                 uint128 liquidityUnsigned,
 107 |     |                 ,
 108 |     |                 ,
 109 |     |                 ,
 110 |     | 
 111 |     |             ) = manager.positions(tokenId);
 112 |     |             liquidity = int256(uint256(liquidityUnsigned));
 113 |     |             IUniswapV3Pool pool = IUniswapV3Pool(factory.getPool(token0Tmp, token1Tmp, fee));
 114 |     |             (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();
 115 |     |             sqrtPrice = int256(uint256(sqrtPriceX96));
 116 |     |             token0 = token0Tmp;
 117 |     |             token1 = token1Tmp;
 118 |     |             int256 lowerSqrtPrice = TickMath.getSqrtRatioAtTick(tickLower);
 119 |     |             int256 upperSqrtPrice = TickMath.getSqrtRatioAtTick(tickUpper);
 120 |     |             // Clamp the price into the range
 121 |     |             sqrtPrice = FsMath.clip(sqrtPrice, lowerSqrtPrice, upperSqrtPrice);
 122 |     |             baseX = (liquidity * Q96) / upperSqrtPrice;
 123 |     |             baseY = (lowerSqrtPrice * liquidity) / Q96;
 124 |     |         }
 125 |     |         // X token0 amount, Y token1 amount
 126 |     |         // L = sqrt(X * Y)  p = Y / X
 127 |     |         // Thus sqrt(p) * L = Y and sqrt(p) / L = X
 128 |     | 
 129 |     |         int256 amountY = (sqrtPrice * liquidity) / Q96 - baseY;
 130 |     |         int256 amountX = (liquidity * Q96) / sqrtPrice - baseX;
 131 |     | 
 132 |     |         int256 value = 0;
 133 |     |         int256 riskAdjustedValue;
 134 |     |         {
 135 |     |             IERC20ValueOracle valueOracle = erc20ValueOracle[token0];
 136 |     |             if (address(valueOracle) != address(0)) {
 137 |     |                 (int256 assetValue, int256 adjustedAssetValue) = valueOracle.calcValue(amountX);
 138 |     |                 value += assetValue;
 139 |     |                 riskAdjustedValue += adjustedAssetValue;
 140 |     |             }
 141 |     |         }
 142 |     |         {
 143 |     |             IERC20ValueOracle valueOracle = erc20ValueOracle[token1];
 144 |     |             if (address(valueOracle) != address(0)) {
 145 |     |                 (int256 assetValue, int256 adjustedAssetValue) = valueOracle.calcValue(amountY);
 146 |     |                 value += assetValue;
 147 |     |                 riskAdjustedValue += adjustedAssetValue;
 148 |     |             }
 149 |     |         }
 150 |     |         riskAdjustedValue = (riskAdjustedValue * collateralFactor) / 1 ether;
 151 |     |         return (value, riskAdjustedValue);
 152 |     |     }
 153 |     | }
 154 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/testing/Echidna.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.17;
  3 |     | 
  4 |     | import "../dos/DOS.sol";
  5 |     | import "../dos/DSafeProxy.sol";
  6 |     | import "../dos/VersionManager.sol";
  7 |     | import "../interfaces/IVersionManager.sol";
  8 |     | import "../lib/FsMath.sol";
  9 |     | import "../lib/FsUtils.sol";
 10 |     | import "../lib/ImmutableVersion.sol";
 11 |     | 
 12 |     | // echidna-test . --config echidna.yaml --contract Echidna
 13 |     | contract Echidna {
 14 |     |   constructor() public {
 15 |     |     initDos();
 16 |     |   }
 17 |     | 
 18 |     |   function testExp(int256 xa, int256 xb) public {
 19 |     |     int256 x = xa*FsMath.FIXED_POINT_SCALE+xb;
 20 |     |     int256 result = FsMath.exp(x);
 21 |     |     int256 epsilon = int256(1)<<uint256(10); // 2^10, far less than FIXED_POINT_SCALE
 22 |     | 
 23 |     |     if (x >= 0)
 24 |     |       assert(result >= FsMath.FIXED_POINT_SCALE);
 25 |     |     if (x >= epsilon)
 26 |     |       assert(result > FsMath.FIXED_POINT_SCALE);
 27 |     |     if (x <= 0)
 28 |     |       assert(result <= FsMath.FIXED_POINT_SCALE);
 29 |     |     if (x <= -epsilon)
 30 |     |       assert(result < FsMath.FIXED_POINT_SCALE);
 31 |     |   }
 32 |     | 
 33 |     |   function testPow(int256 xa, int256 xb, int256 n) public {
 34 |     |     int256 x = xa*FsMath.FIXED_POINT_SCALE+xb;
 35 |     |     int256 result = FsMath.pow(x,n);
 36 |     | 
 37 |     |     int256 signExpected = FsMath.sign(x);
 38 |     |     if (n % 2 == 0 && signExpected == -1) // when n is even, x^n is positive
 39 |     |       signExpected = 1;
 40 |     | 
 41 |     |     if (n == 0) // x^0 = 1
 42 |     |       assert(result == FsMath.FIXED_POINT_SCALE);
 43 |     |     else if (n < 0 || (x > -FsMath.FIXED_POINT_SCALE && x < FsMath.FIXED_POINT_SCALE)) // if n is negative or |x| < 1, x^n can round to 0
 44 |     |       assert(FsMath.sign(result) == signExpected || result == 0);
 45 |     |     else
 46 |     |       assert(FsMath.sign(result) == signExpected);
 47 |     |   }
 48 |     | 
 49 |     |   function testSqrt(int256 xa, int256 xb) public {
 50 |     |     int256 x = xa*FsMath.FIXED_POINT_SCALE+xb;
 51 |     |     require(x >= 0, "Must be positive");
 52 |     |     require(x <= 100*FsMath.FIXED_POINT_SCALE, "Too big");
 53 |     |     int256 result = FsMath.sqrt(x);
 54 |     | 
 55 |     |     assert(result >= 0);
 56 |     |     if (x >= FsMath.FIXED_POINT_SCALE)
 57 |     |       assert(result <= x);
 58 |     |     else
 59 |     |       assert(result >= x);
 60 |     |   }
 61 |     | 
 62 |     |   VersionManager public versionManager;
 63 |     |   DOSConfig public dosConfig;
 64 |     |   DOS public dos;
 65 |     |   DSafeLogic public dSafeLogic;
 66 |     |   DSafeProxy public proxy1_1;
 67 |     |   DSafeProxy public proxy1_2;
 68 |     |   DSafeProxy public proxy2_1;
 69 |     |   DSafeProxy public proxy2_2;
 70 |     |   DSafeProxy public proxy3_1;
 71 |     |   DSafeProxy public proxy3_2;
 72 |     |   function initDos() internal {
 73 |     |     versionManager = new VersionManager(address(this));
 74 |     |     dosConfig = new DOSConfig(address(this));
 75 |     |     dos = new DOS(address(dosConfig), address(versionManager));
 76 |     |     dSafeLogic = new DSafeLogic(address(dos));
 77 |     | 
 78 |     |     dosConfig.setVersionManager(address(versionManager));
 79 |     | 
 80 |     |     versionManager.addVersion(IVersionManager.Status.PRODUCTION, address(dSafeLogic));
 81 |     |     string memory versionName = string(FsUtils.decodeFromBytes32(dSafeLogic.immutableVersion()));
 82 |     |     versionManager.markRecommendedVersion(versionName);
 83 |     | 
 84 |     |     proxy1_1 = DSafeProxy(payable(dosConfig._createDSafe(address(0x10000))));
 85 |     |     proxy1_2 = DSafeProxy(payable(dosConfig._createDSafe(address(0x10000))));
 86 |     |     proxy2_1 = DSafeProxy(payable(dosConfig._createDSafe(address(0x20000))));
 87 |     |     proxy2_2 = DSafeProxy(payable(dosConfig._createDSafe(address(0x20000))));
 88 |     |     proxy3_1 = DSafeProxy(payable(dosConfig._createDSafe(address(0x30000))));
 89 |     |     proxy3_2 = DSafeProxy(payable(dosConfig._createDSafe(address(0x30000))));
 90 |     |   }
 91 |     | }
 92 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/testing/Echidna2.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.17;
  3 |     | 
  4 |     | import "../dos/DOS.sol";
  5 |     | import "../dos/DSafeProxy.sol";
  6 |     | import "../dos/VersionManager.sol";
  7 |     | import "../interfaces/IVersionManager.sol";
  8 |     | import "../lib/FsMath.sol";
  9 |     | import "../lib/FsUtils.sol";
 10 |     | import "../lib/ImmutableVersion.sol";
 11 | *r  | 
 12 |     | contract Echidna2 {
 13 |     |   // SETUP STUFF, I THINK I DID THIS PART RIGHT:
 14 |     |   VersionManager public versionManager;
 15 | *   |   DOSConfig public dosConfig;
 16 | *   |   DOS public dos;
 17 | *   |   DSafeLogic public dSafeLogic;
 18 |     |   address public proxy1;
 19 |     |   constructor() public {
 20 |     |     versionManager = new VersionManager(address(this));
 21 |     |     dosConfig = new DOSConfig(address(this));
 22 |     |     dos = new DOS(address(dosConfig), address(versionManager));
 23 |     |     dSafeLogic = new DSafeLogic(address(dos));
 24 |     | 
 25 |     |     IDOSConfig(address(dos)).setConfig(
 26 |     |             IDOSConfig.Config({
 27 |     |                 treasurySafe: address(0),
 28 |     |                 treasuryInterestFraction: 0,
 29 |     |                 maxSolvencyCheckGasCost: 10_000_000,
 30 |     |                 liqFraction: 8e17,
 31 |     |                 fractionalReserveLeverage: 10
 32 |     |             })
 33 |     |         );
 34 |     | 
 35 |     |     //dosConfig.setVersionManager(address(versionManager));
 36 |     | 
 37 |     |     versionManager.addVersion(IVersionManager.Status.PRODUCTION, address(dSafeLogic));
 38 | *   |     //string memory versionName = string(FsUtils.decodeFromBytes32(dSafeLogic.immutableVersion()));
 39 |     |     versionManager.markRecommendedVersion("1.0.0");
 40 |     | 
 41 | r   |     // pretty sure everything up here is good
 42 |     | 
 43 | r   |     proxy1 = DSafeProxy(payable(IDOSConfig(address(dos)).createDSafe()));
 44 |     |   }
 45 | r   |   function ensureProxyNonzero() public { // fails in assert mode, meaning proxy1 is nonzero
 46 | r   |     if (proxy1 != address(0))
 47 |     |       assert(false);
 48 |     |   }
 49 |     |   // ONE OF THESE TWO SHOULD WORK:
 50 |     |   function tryToCall1() public { // passes in assert mode, meaning the call isn't working
 51 |     |     DSafeProxy(payable(proxy1)).executeBatch(new Call[](0));
 52 |     |   }
 53 |     |   function tryToCall2() public { // passes in assert mode, meaning the call isn't working
 54 |     |     DSafeLogic(proxy1).executeBatch(new Call[](0));
 55 |     |   }
 56 |     | }

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/testing/MockERC20Oracle.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.17;
  3 |     | 
  4 |     | import "../interfaces/IERC20ValueOracle.sol";
  5 |     | import "../lib/ImmutableGovernance.sol";
  6 |     | 
  7 |     | contract MockERC20Oracle is IERC20ValueOracle, ImmutableGovernance {
  8 |     |     int256 public price;
  9 |     |     int256 collateralFactor = 1 ether;
 10 |     | 
 11 |     |     constructor(address owner) ImmutableGovernance(owner) {}
 12 |     | 
 13 |     |     function setPrice(
 14 |     |         int256 _price,
 15 |     |         uint256 baseDecimals,
 16 |     |         uint256 decimals
 17 |     |     ) external onlyGovernance {
 18 |     |         price = (_price * (int256(10) ** (18 + baseDecimals - decimals))) / 1 ether;
 19 |     |     }
 20 |     | 
 21 |     |     function setCollateralFactor(int256 _collateralFactor) external onlyGovernance {
 22 |     |         collateralFactor = _collateralFactor;
 23 |     |     }
 24 |     | 
 25 |     |     function calcValue(
 26 |     |         int256 amount
 27 |     |     ) external view override returns (int256 value, int256 riskAdjustedValue) {
 28 |     |         value = (amount * price) / 1 ether;
 29 |     |         riskAdjustedValue = (value * collateralFactor) / 1 ether;
 30 |     |         return (value, riskAdjustedValue);
 31 |     |     }
 32 |     | }
 33 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/testing/MockNFTOracle.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.17;
  3 |     | 
  4 |     | import "../interfaces/INFTValueOracle.sol";
  5 |     | import "@openzeppelin/contracts/utils/Strings.sol";
  6 |     | 
  7 |     | contract MockNFTOracle is INFTValueOracle {
  8 |     |     mapping(uint256 => int256) prices;
  9 |     |     int256 collateralFactor = 1 ether;
 10 |     | 
 11 |     |     function setPrice(uint256 tokenId, int256 price) external {
 12 |     |         require(
 13 |     |             price != -1,
 14 |     |             "Please, don't use -1 as NFT price - it's a reserved value used for early error detection"
 15 |     |         );
 16 |     |         prices[tokenId] = price + 1;
 17 |     |     }
 18 |     | 
 19 |     |     function setCollateralFactor(int256 _collateralFactor) external {
 20 |     |         collateralFactor = _collateralFactor;
 21 |     |     }
 22 |     | 
 23 |     |     function calcValue(uint256 tokenId) external view override returns (int256, int256) {
 24 |     |         require(
 25 |     |             prices[tokenId] > 0,
 26 |     |             string.concat(
 27 |     |                 "Price for the NFT with tokenId ",
 28 |     |                 Strings.toString(tokenId),
 29 |     |                 " is not set"
 30 |     |             )
 31 |     |         );
 32 |     |         int256 value = prices[tokenId] - 1;
 33 |     |         int256 riskAdjustedValue = (value * collateralFactor) / 1 ether;
 34 |     |         return (value, riskAdjustedValue);
 35 |     |     }
 36 |     | }
 37 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/testing/TestERC20.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.7;
  3 |     | 
  4 |     | import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
  5 |     | 
  6 |     | contract TestERC20 is ERC20 {
  7 |     |     uint8 private immutable _decimals;
  8 |     | 
  9 |     |     constructor(string memory name, string memory symbol, uint8 deci) ERC20(name, symbol) {
 10 |     |         _decimals = deci;
 11 |     |     }
 12 |     | 
 13 |     |     function mint(address to, uint256 amount) external {
 14 |     |         _mint(to, amount);
 15 |     |     }
 16 |     | 
 17 |     |     function decimals() public view virtual override returns (uint8) {
 18 |     |         return _decimals;
 19 |     |     }
 20 |     | }
 21 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/testing/TestFsMath.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.17;
  3 |     | 
  4 |     | import "../lib/FsMath.sol";
  5 |     | 
  6 |     | contract TestFsMath {
  7 |     |     function abs(int256 value) external pure returns (uint256) {
  8 |     |         return FsMath.abs(value);
  9 |     |     }
 10 |     | 
 11 |     |     function sabs(int256 value) external pure returns (int256) {
 12 |     |         return FsMath.sabs(value);
 13 |     |     }
 14 |     | 
 15 |     |     function sign(int256 value) external pure returns (int256) {
 16 |     |         return FsMath.sign(value);
 17 |     |     }
 18 |     | 
 19 |     |     function min(int256 a, int256 b) external pure returns (int256) {
 20 |     |         return FsMath.min(a, b);
 21 |     |     }
 22 |     | 
 23 |     |     function max(int256 a, int256 b) external pure returns (int256) {
 24 |     |         return FsMath.max(a, b);
 25 |     |     }
 26 |     | 
 27 |     |     // Clip val into interval [lower, upper]
 28 |     |     function clip(int256 val, int256 lower, int256 upper) external pure returns (int256) {
 29 |     |         return FsMath.clip(val, lower, upper);
 30 |     |     }
 31 |     | 
 32 |     |     function safeCastToSigned(uint256 x) external pure returns (int256) {
 33 |     |         return FsMath.safeCastToSigned(x);
 34 |     |     }
 35 |     | 
 36 |     |     function safeCastToUnsigned(int256 x) external pure returns (uint256) {
 37 |     |         return FsMath.safeCastToUnsigned(x);
 38 |     |     }
 39 |     | 
 40 |     |     function exp(int256 x) external pure returns (int256) {
 41 |     |         return FsMath.exp(x);
 42 |     |     }
 43 |     | 
 44 |     |     function sqrt(int256 x) external pure returns (int256) {
 45 |     |         return FsMath.sqrt(x);
 46 |     |     }
 47 |     | 
 48 |     |     function bitCount(uint256 x) external pure returns (uint256) {
 49 |     |         return FsMath.bitCount(x);
 50 |     |     }
 51 |     | }
 52 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/testing/TestNFT.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.17;
  3 |     | 
  4 |     | import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
  5 |     | import "@openzeppelin/contracts/utils/Counters.sol";
  6 |     | 
  7 |     | contract TestNFT is ERC721 {
  8 |     |     using Counters for Counters.Counter;
  9 |     |     Counters.Counter private tokenIdCounter;
 10 |     | 
 11 |     |     event Mint(uint256 tokenId);
 12 |     | 
 13 |     |     constructor(
 14 |     |         string memory name,
 15 |     |         string memory symbol,
 16 |     |         uint256 initTokenId
 17 |     |     ) ERC721(name, symbol) {
 18 |     |         tokenIdCounter._value = initTokenId;
 19 |     |     }
 20 |     | 
 21 |     |     function mint(address to) public returns (uint256) {
 22 |     |         uint256 tokenId = tokenIdCounter.current();
 23 |     |         tokenIdCounter.increment();
 24 |     |         _mint(to, tokenId);
 25 |     |         emit Mint(tokenId);
 26 |     |         return tokenId;
 27 |     |     }
 28 |     | }
 29 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/testing/TestTrie.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.17;
  3 |     | 
  4 |     | import "../lib/Proofs.sol";
  5 |     | 
  6 |     | contract TestTrie {
  7 |     |     function verify(
  8 |     |         bytes calldata key,
  9 |     |         bytes32 root,
 10 |     |         bytes calldata proof
 11 |     |     ) external pure returns (bytes memory) {
 12 |     |         return BytesViewLib.toBytes(TrieLib.verify(bytes32(key), key.length, root, proof));
 13 |     |     }
 14 |     | }
 15 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/testing/VotingTest.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.17;
  3 |     | 
  4 |     | import "../governance/Voting.sol";
  5 |     | 
  6 |     | contract VotingTest is Voting {
  7 |     |     bytes32 public mockBlockHash;
  8 |     | 
  9 |     |     constructor(
 10 |     |         address hashNFT_,
 11 |     |         address governanceToken_,
 12 |     |         uint256 mappingSlot_,
 13 |     |         uint256 totalSupplySlot_,
 14 |     |         address governance_
 15 |     |     ) Voting(hashNFT_, governanceToken_, mappingSlot_, totalSupplySlot_, governance_) {}
 16 |     | 
 17 |     |     function setMockBlockHash(bytes32 blockHash) external {
 18 |     |         mockBlockHash = blockHash;
 19 |     |     }
 20 |     | 
 21 |     |     function getBlockHash(uint256) internal view override returns (bytes32) {
 22 |     |         return mockBlockHash;
 23 |     |     }
 24 |     | }
 25 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/testing/external/WETH9.sol
  1 |     | //SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity ^0.8.7;
  3 |     | 
  4 |     | import "@openzeppelin/contracts/utils/Address.sol";
  5 |     | import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
  6 |     | 
  7 |     | contract WETH9 is ERC20 {
  8 |     |     constructor() ERC20("Wrapped ETH", "WETH") {}
  9 |     | 
 10 |     |     function deposit() external payable {
 11 |     |         _mint(msg.sender, msg.value);
 12 |     |     }
 13 |     | 
 14 |     |     function withdraw(uint256 amount) external {
 15 |     |         _burn(msg.sender, amount);
 16 |     | 
 17 |     |         Address.sendValue(payable(msg.sender), amount);
 18 |     |     }
 19 |     | 
 20 |     |     function mint(address to, uint256 amount) external {
 21 |     |         _mint(to, amount);
 22 |     |     }
 23 |     | }
 24 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/tokens/HashNFT.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.17;
  3 |     | 
  4 |     | import "@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Burnable.sol";
  5 |     | 
  6 |     | /// @title HashNFT a NFT for cryptographic proof of ownership.
  7 |     | /// @notice A generic ownerless contract that allows fine grained access control,
  8 |     | /// voting and other use cases build on top of.
  9 |     | /// @dev The 256 bit tokenId of ERC1155 is used to store cryptographic hash of the
 10 |     | /// an arbitrary digest and minter address. The cryptographic security of the hash
 11 |     | /// provides the guarantees of the contract.
 12 |     | /// 1) Each token id is associated with only one minter and digest.
 13 |     | /// 2) Ownership of a token id implies the minter has granted (directly or indirectly)
 14 |     | ///    the ownership to the owner. (The minter can revoke the token at any time.
 15 |     | /// 3) A minter (and only the minter) can revoke tokens it issued itself.
 16 |     | /// 4) Everyone can burn tokens they own.
 17 |     | contract HashNFT is ERC1155Burnable {
 18 |     |     bytes constant HASHNFT_TYPESTRING = "HashNFT(address minter,bytes32 digest)";
 19 |     |     bytes32 constant HASHNFT_TYPEHASH = keccak256(HASHNFT_TYPESTRING);
 20 |     | 
 21 |     |     event Minted(uint256 indexed tokenId, address indexed minter, bytes32 indexed digest);
 22 |     | 
 23 |     |     constructor(string memory uri) ERC1155(uri) {}
 24 |     | 
 25 |     |     function mint(
 26 |     |         address to,
 27 |     |         bytes32 digest,
 28 |     |         bytes calldata data
 29 |     |     ) external returns (uint256 tokenId) {
 30 |     |         tokenId = toTokenId(msg.sender, digest);
 31 |     |         _mint(to, tokenId, 1, data);
 32 |     |         emit Minted(tokenId, msg.sender, digest);
 33 |     |     }
 34 |     | 
 35 |     |     // The minter can revoke tokens it minted.
 36 |     |     function revoke(address from, bytes32 digest) external {
 37 |     |         uint256 tokenId = toTokenId(msg.sender, digest);
 38 |     |         _burn(from, tokenId, 1);
 39 |     |     }
 40 |     | 
 41 |     |     // Crypto secure hash function, to ensure only valid digest are recognized
 42 |     |     function toTokenId(address minter, bytes32 digest) public pure returns (uint256) {
 43 |     |         return uint256(keccak256(abi.encode(HASHNFT_TYPEHASH, minter, digest)));
 44 |     |     }
 45 |     | }
 46 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/utils/TypeChainGeneration.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.17;
  3 |     | 
  4 |     | import "@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol";
  5 |     | import "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";
  6 |     | import "@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol";
  7 |     | // These unfortunately don't compile due to conflict with our version of openzeppelin
  8 |     | // import "@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol";
  9 |     | // import "@uniswap/v3-periphery/contracts/interfaces/INonfungibleTokenPositionDescriptor.sol";
 10 |     | 
 11 |     | // Just here so solidity compiles and typechain generates the types
 12 |     | 

/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/hardhat/console.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | pragma solidity >= 0.4.22 <0.9.0;
    3 |     | 
    4 |     | library console {
    5 |     | 	address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);
    6 |     | 
    7 |     | 	function _sendLogPayload(bytes memory payload) private view {
    8 |     | 		uint256 payloadLength = payload.length;
    9 |     | 		address consoleAddress = CONSOLE_ADDRESS;
   10 |     | 		assembly {
   11 |     | 			let payloadStart := add(payload, 32)
   12 |     | 			let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)
   13 |     | 		}
   14 |     | 	}
   15 |     | 
   16 |     | 	function log() internal view {
   17 |     | 		_sendLogPayload(abi.encodeWithSignature("log()"));
   18 |     | 	}
   19 |     | 
   20 |     | 	function logInt(int256 p0) internal view {
   21 |     | 		_sendLogPayload(abi.encodeWithSignature("log(int256)", p0));
   22 |     | 	}
   23 |     | 
   24 |     | 	function logUint(uint256 p0) internal view {
   25 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
   26 |     | 	}
   27 |     | 
   28 |     | 	function logString(string memory p0) internal view {
   29 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string)", p0));
   30 |     | 	}
   31 |     | 
   32 |     | 	function logBool(bool p0) internal view {
   33 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
   34 |     | 	}
   35 |     | 
   36 |     | 	function logAddress(address p0) internal view {
   37 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address)", p0));
   38 |     | 	}
   39 |     | 
   40 |     | 	function logBytes(bytes memory p0) internal view {
   41 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
   42 |     | 	}
   43 |     | 
   44 |     | 	function logBytes1(bytes1 p0) internal view {
   45 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
   46 |     | 	}
   47 |     | 
   48 |     | 	function logBytes2(bytes2 p0) internal view {
   49 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
   50 |     | 	}
   51 |     | 
   52 |     | 	function logBytes3(bytes3 p0) internal view {
   53 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
   54 |     | 	}
   55 |     | 
   56 |     | 	function logBytes4(bytes4 p0) internal view {
   57 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
   58 |     | 	}
   59 |     | 
   60 |     | 	function logBytes5(bytes5 p0) internal view {
   61 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
   62 |     | 	}
   63 |     | 
   64 |     | 	function logBytes6(bytes6 p0) internal view {
   65 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
   66 |     | 	}
   67 |     | 
   68 |     | 	function logBytes7(bytes7 p0) internal view {
   69 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
   70 |     | 	}
   71 |     | 
   72 |     | 	function logBytes8(bytes8 p0) internal view {
   73 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
   74 |     | 	}
   75 |     | 
   76 |     | 	function logBytes9(bytes9 p0) internal view {
   77 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
   78 |     | 	}
   79 |     | 
   80 |     | 	function logBytes10(bytes10 p0) internal view {
   81 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
   82 |     | 	}
   83 |     | 
   84 |     | 	function logBytes11(bytes11 p0) internal view {
   85 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
   86 |     | 	}
   87 |     | 
   88 |     | 	function logBytes12(bytes12 p0) internal view {
   89 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
   90 |     | 	}
   91 |     | 
   92 |     | 	function logBytes13(bytes13 p0) internal view {
   93 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
   94 |     | 	}
   95 |     | 
   96 |     | 	function logBytes14(bytes14 p0) internal view {
   97 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
   98 |     | 	}
   99 |     | 
  100 |     | 	function logBytes15(bytes15 p0) internal view {
  101 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
  102 |     | 	}
  103 |     | 
  104 |     | 	function logBytes16(bytes16 p0) internal view {
  105 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
  106 |     | 	}
  107 |     | 
  108 |     | 	function logBytes17(bytes17 p0) internal view {
  109 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
  110 |     | 	}
  111 |     | 
  112 |     | 	function logBytes18(bytes18 p0) internal view {
  113 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
  114 |     | 	}
  115 |     | 
  116 |     | 	function logBytes19(bytes19 p0) internal view {
  117 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
  118 |     | 	}
  119 |     | 
  120 |     | 	function logBytes20(bytes20 p0) internal view {
  121 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
  122 |     | 	}
  123 |     | 
  124 |     | 	function logBytes21(bytes21 p0) internal view {
  125 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
  126 |     | 	}
  127 |     | 
  128 |     | 	function logBytes22(bytes22 p0) internal view {
  129 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
  130 |     | 	}
  131 |     | 
  132 |     | 	function logBytes23(bytes23 p0) internal view {
  133 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
  134 |     | 	}
  135 |     | 
  136 |     | 	function logBytes24(bytes24 p0) internal view {
  137 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
  138 |     | 	}
  139 |     | 
  140 |     | 	function logBytes25(bytes25 p0) internal view {
  141 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
  142 |     | 	}
  143 |     | 
  144 |     | 	function logBytes26(bytes26 p0) internal view {
  145 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
  146 |     | 	}
  147 |     | 
  148 |     | 	function logBytes27(bytes27 p0) internal view {
  149 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
  150 |     | 	}
  151 |     | 
  152 |     | 	function logBytes28(bytes28 p0) internal view {
  153 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
  154 |     | 	}
  155 |     | 
  156 |     | 	function logBytes29(bytes29 p0) internal view {
  157 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
  158 |     | 	}
  159 |     | 
  160 |     | 	function logBytes30(bytes30 p0) internal view {
  161 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
  162 |     | 	}
  163 |     | 
  164 |     | 	function logBytes31(bytes31 p0) internal view {
  165 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
  166 |     | 	}
  167 |     | 
  168 |     | 	function logBytes32(bytes32 p0) internal view {
  169 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
  170 |     | 	}
  171 |     | 
  172 |     | 	function log(uint256 p0) internal view {
  173 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
  174 |     | 	}
  175 |     | 
  176 |     | 	function log(string memory p0) internal view {
  177 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string)", p0));
  178 |     | 	}
  179 |     | 
  180 |     | 	function log(bool p0) internal view {
  181 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
  182 |     | 	}
  183 |     | 
  184 |     | 	function log(address p0) internal view {
  185 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address)", p0));
  186 |     | 	}
  187 |     | 
  188 |     | 	function log(uint256 p0, uint256 p1) internal view {
  189 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256)", p0, p1));
  190 |     | 	}
  191 |     | 
  192 |     | 	function log(uint256 p0, string memory p1) internal view {
  193 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,string)", p0, p1));
  194 |     | 	}
  195 |     | 
  196 |     | 	function log(uint256 p0, bool p1) internal view {
  197 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool)", p0, p1));
  198 |     | 	}
  199 |     | 
  200 |     | 	function log(uint256 p0, address p1) internal view {
  201 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,address)", p0, p1));
  202 |     | 	}
  203 |     | 
  204 |     | 	function log(string memory p0, uint256 p1) internal view {
  205 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint256)", p0, p1));
  206 |     | 	}
  207 |     | 
  208 |     | 	function log(string memory p0, string memory p1) internal view {
  209 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
  210 |     | 	}
  211 |     | 
  212 |     | 	function log(string memory p0, bool p1) internal view {
  213 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
  214 |     | 	}
  215 |     | 
  216 |     | 	function log(string memory p0, address p1) internal view {
  217 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
  218 |     | 	}
  219 |     | 
  220 |     | 	function log(bool p0, uint256 p1) internal view {
  221 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256)", p0, p1));
  222 |     | 	}
  223 |     | 
  224 |     | 	function log(bool p0, string memory p1) internal view {
  225 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
  226 |     | 	}
  227 |     | 
  228 |     | 	function log(bool p0, bool p1) internal view {
  229 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
  230 |     | 	}
  231 |     | 
  232 |     | 	function log(bool p0, address p1) internal view {
  233 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
  234 |     | 	}
  235 |     | 
  236 |     | 	function log(address p0, uint256 p1) internal view {
  237 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint256)", p0, p1));
  238 |     | 	}
  239 |     | 
  240 |     | 	function log(address p0, string memory p1) internal view {
  241 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
  242 |     | 	}
  243 |     | 
  244 |     | 	function log(address p0, bool p1) internal view {
  245 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
  246 |     | 	}
  247 |     | 
  248 |     | 	function log(address p0, address p1) internal view {
  249 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
  250 |     | 	}
  251 |     | 
  252 |     | 	function log(uint256 p0, uint256 p1, uint256 p2) internal view {
  253 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256)", p0, p1, p2));
  254 |     | 	}
  255 |     | 
  256 |     | 	function log(uint256 p0, uint256 p1, string memory p2) internal view {
  257 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string)", p0, p1, p2));
  258 |     | 	}
  259 |     | 
  260 |     | 	function log(uint256 p0, uint256 p1, bool p2) internal view {
  261 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool)", p0, p1, p2));
  262 |     | 	}
  263 |     | 
  264 |     | 	function log(uint256 p0, uint256 p1, address p2) internal view {
  265 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address)", p0, p1, p2));
  266 |     | 	}
  267 |     | 
  268 |     | 	function log(uint256 p0, string memory p1, uint256 p2) internal view {
  269 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256)", p0, p1, p2));
  270 |     | 	}
  271 |     | 
  272 |     | 	function log(uint256 p0, string memory p1, string memory p2) internal view {
  273 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,string)", p0, p1, p2));
  274 |     | 	}
  275 |     | 
  276 |     | 	function log(uint256 p0, string memory p1, bool p2) internal view {
  277 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool)", p0, p1, p2));
  278 |     | 	}
  279 |     | 
  280 |     | 	function log(uint256 p0, string memory p1, address p2) internal view {
  281 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,address)", p0, p1, p2));
  282 |     | 	}
  283 |     | 
  284 |     | 	function log(uint256 p0, bool p1, uint256 p2) internal view {
  285 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256)", p0, p1, p2));
  286 |     | 	}
  287 |     | 
  288 |     | 	function log(uint256 p0, bool p1, string memory p2) internal view {
  289 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string)", p0, p1, p2));
  290 |     | 	}
  291 |     | 
  292 |     | 	function log(uint256 p0, bool p1, bool p2) internal view {
  293 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool)", p0, p1, p2));
  294 |     | 	}
  295 |     | 
  296 |     | 	function log(uint256 p0, bool p1, address p2) internal view {
  297 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address)", p0, p1, p2));
  298 |     | 	}
  299 |     | 
  300 |     | 	function log(uint256 p0, address p1, uint256 p2) internal view {
  301 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256)", p0, p1, p2));
  302 |     | 	}
  303 |     | 
  304 |     | 	function log(uint256 p0, address p1, string memory p2) internal view {
  305 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,string)", p0, p1, p2));
  306 |     | 	}
  307 |     | 
  308 |     | 	function log(uint256 p0, address p1, bool p2) internal view {
  309 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool)", p0, p1, p2));
  310 |     | 	}
  311 |     | 
  312 |     | 	function log(uint256 p0, address p1, address p2) internal view {
  313 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,address)", p0, p1, p2));
  314 |     | 	}
  315 |     | 
  316 |     | 	function log(string memory p0, uint256 p1, uint256 p2) internal view {
  317 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256)", p0, p1, p2));
  318 |     | 	}
  319 |     | 
  320 |     | 	function log(string memory p0, uint256 p1, string memory p2) internal view {
  321 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,string)", p0, p1, p2));
  322 |     | 	}
  323 |     | 
  324 |     | 	function log(string memory p0, uint256 p1, bool p2) internal view {
  325 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool)", p0, p1, p2));
  326 |     | 	}
  327 |     | 
  328 |     | 	function log(string memory p0, uint256 p1, address p2) internal view {
  329 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,address)", p0, p1, p2));
  330 |     | 	}
  331 |     | 
  332 |     | 	function log(string memory p0, string memory p1, uint256 p2) internal view {
  333 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint256)", p0, p1, p2));
  334 |     | 	}
  335 |     | 
  336 |     | 	function log(string memory p0, string memory p1, string memory p2) internal view {
  337 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
  338 |     | 	}
  339 |     | 
  340 |     | 	function log(string memory p0, string memory p1, bool p2) internal view {
  341 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
  342 |     | 	}
  343 |     | 
  344 |     | 	function log(string memory p0, string memory p1, address p2) internal view {
  345 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
  346 |     | 	}
  347 |     | 
  348 |     | 	function log(string memory p0, bool p1, uint256 p2) internal view {
  349 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256)", p0, p1, p2));
  350 |     | 	}
  351 |     | 
  352 |     | 	function log(string memory p0, bool p1, string memory p2) internal view {
  353 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
  354 |     | 	}
  355 |     | 
  356 |     | 	function log(string memory p0, bool p1, bool p2) internal view {
  357 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
  358 |     | 	}
  359 |     | 
  360 |     | 	function log(string memory p0, bool p1, address p2) internal view {
  361 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
  362 |     | 	}
  363 |     | 
  364 |     | 	function log(string memory p0, address p1, uint256 p2) internal view {
  365 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint256)", p0, p1, p2));
  366 |     | 	}
  367 |     | 
  368 |     | 	function log(string memory p0, address p1, string memory p2) internal view {
  369 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
  370 |     | 	}
  371 |     | 
  372 |     | 	function log(string memory p0, address p1, bool p2) internal view {
  373 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
  374 |     | 	}
  375 |     | 
  376 |     | 	function log(string memory p0, address p1, address p2) internal view {
  377 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
  378 |     | 	}
  379 |     | 
  380 |     | 	function log(bool p0, uint256 p1, uint256 p2) internal view {
  381 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256)", p0, p1, p2));
  382 |     | 	}
  383 |     | 
  384 |     | 	function log(bool p0, uint256 p1, string memory p2) internal view {
  385 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string)", p0, p1, p2));
  386 |     | 	}
  387 |     | 
  388 |     | 	function log(bool p0, uint256 p1, bool p2) internal view {
  389 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool)", p0, p1, p2));
  390 |     | 	}
  391 |     | 
  392 |     | 	function log(bool p0, uint256 p1, address p2) internal view {
  393 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address)", p0, p1, p2));
  394 |     | 	}
  395 |     | 
  396 |     | 	function log(bool p0, string memory p1, uint256 p2) internal view {
  397 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256)", p0, p1, p2));
  398 |     | 	}
  399 |     | 
  400 |     | 	function log(bool p0, string memory p1, string memory p2) internal view {
  401 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
  402 |     | 	}
  403 |     | 
  404 |     | 	function log(bool p0, string memory p1, bool p2) internal view {
  405 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
  406 |     | 	}
  407 |     | 
  408 |     | 	function log(bool p0, string memory p1, address p2) internal view {
  409 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
  410 |     | 	}
  411 |     | 
  412 |     | 	function log(bool p0, bool p1, uint256 p2) internal view {
  413 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256)", p0, p1, p2));
  414 |     | 	}
  415 |     | 
  416 |     | 	function log(bool p0, bool p1, string memory p2) internal view {
  417 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
  418 |     | 	}
  419 |     | 
  420 |     | 	function log(bool p0, bool p1, bool p2) internal view {
  421 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
  422 |     | 	}
  423 |     | 
  424 |     | 	function log(bool p0, bool p1, address p2) internal view {
  425 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
  426 |     | 	}
  427 |     | 
  428 |     | 	function log(bool p0, address p1, uint256 p2) internal view {
  429 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256)", p0, p1, p2));
  430 |     | 	}
  431 |     | 
  432 |     | 	function log(bool p0, address p1, string memory p2) internal view {
  433 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
  434 |     | 	}
  435 |     | 
  436 |     | 	function log(bool p0, address p1, bool p2) internal view {
  437 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
  438 |     | 	}
  439 |     | 
  440 |     | 	function log(bool p0, address p1, address p2) internal view {
  441 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
  442 |     | 	}
  443 |     | 
  444 |     | 	function log(address p0, uint256 p1, uint256 p2) internal view {
  445 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256)", p0, p1, p2));
  446 |     | 	}
  447 |     | 
  448 |     | 	function log(address p0, uint256 p1, string memory p2) internal view {
  449 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,string)", p0, p1, p2));
  450 |     | 	}
  451 |     | 
  452 |     | 	function log(address p0, uint256 p1, bool p2) internal view {
  453 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool)", p0, p1, p2));
  454 |     | 	}
  455 |     | 
  456 |     | 	function log(address p0, uint256 p1, address p2) internal view {
  457 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,address)", p0, p1, p2));
  458 |     | 	}
  459 |     | 
  460 |     | 	function log(address p0, string memory p1, uint256 p2) internal view {
  461 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint256)", p0, p1, p2));
  462 |     | 	}
  463 |     | 
  464 |     | 	function log(address p0, string memory p1, string memory p2) internal view {
  465 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
  466 |     | 	}
  467 |     | 
  468 |     | 	function log(address p0, string memory p1, bool p2) internal view {
  469 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
  470 |     | 	}
  471 |     | 
  472 |     | 	function log(address p0, string memory p1, address p2) internal view {
  473 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
  474 |     | 	}
  475 |     | 
  476 |     | 	function log(address p0, bool p1, uint256 p2) internal view {
  477 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256)", p0, p1, p2));
  478 |     | 	}
  479 |     | 
  480 |     | 	function log(address p0, bool p1, string memory p2) internal view {
  481 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
  482 |     | 	}
  483 |     | 
  484 |     | 	function log(address p0, bool p1, bool p2) internal view {
  485 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
  486 |     | 	}
  487 |     | 
  488 |     | 	function log(address p0, bool p1, address p2) internal view {
  489 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
  490 |     | 	}
  491 |     | 
  492 |     | 	function log(address p0, address p1, uint256 p2) internal view {
  493 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint256)", p0, p1, p2));
  494 |     | 	}
  495 |     | 
  496 |     | 	function log(address p0, address p1, string memory p2) internal view {
  497 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
  498 |     | 	}
  499 |     | 
  500 |     | 	function log(address p0, address p1, bool p2) internal view {
  501 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
  502 |     | 	}
  503 |     | 
  504 |     | 	function log(address p0, address p1, address p2) internal view {
  505 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
  506 |     | 	}
  507 |     | 
  508 |     | 	function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {
  509 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,uint256)", p0, p1, p2, p3));
  510 |     | 	}
  511 |     | 
  512 |     | 	function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {
  513 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,string)", p0, p1, p2, p3));
  514 |     | 	}
  515 |     | 
  516 |     | 	function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {
  517 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,bool)", p0, p1, p2, p3));
  518 |     | 	}
  519 |     | 
  520 |     | 	function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {
  521 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,address)", p0, p1, p2, p3));
  522 |     | 	}
  523 |     | 
  524 |     | 	function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {
  525 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,uint256)", p0, p1, p2, p3));
  526 |     | 	}
  527 |     | 
  528 |     | 	function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {
  529 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,string)", p0, p1, p2, p3));
  530 |     | 	}
  531 |     | 
  532 |     | 	function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {
  533 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,bool)", p0, p1, p2, p3));
  534 |     | 	}
  535 |     | 
  536 |     | 	function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {
  537 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,address)", p0, p1, p2, p3));
  538 |     | 	}
  539 |     | 
  540 |     | 	function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {
  541 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,uint256)", p0, p1, p2, p3));
  542 |     | 	}
  543 |     | 
  544 |     | 	function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {
  545 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,string)", p0, p1, p2, p3));
  546 |     | 	}
  547 |     | 
  548 |     | 	function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {
  549 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,bool)", p0, p1, p2, p3));
  550 |     | 	}
  551 |     | 
  552 |     | 	function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {
  553 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,address)", p0, p1, p2, p3));
  554 |     | 	}
  555 |     | 
  556 |     | 	function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {
  557 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,uint256)", p0, p1, p2, p3));
  558 |     | 	}
  559 |     | 
  560 |     | 	function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {
  561 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,string)", p0, p1, p2, p3));
  562 |     | 	}
  563 |     | 
  564 |     | 	function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {
  565 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,bool)", p0, p1, p2, p3));
  566 |     | 	}
  567 |     | 
  568 |     | 	function log(uint256 p0, uint256 p1, address p2, address p3) internal view {
  569 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,address)", p0, p1, p2, p3));
  570 |     | 	}
  571 |     | 
  572 |     | 	function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {
  573 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,uint256)", p0, p1, p2, p3));
  574 |     | 	}
  575 |     | 
  576 |     | 	function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {
  577 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,string)", p0, p1, p2, p3));
  578 |     | 	}
  579 |     | 
  580 |     | 	function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {
  581 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,bool)", p0, p1, p2, p3));
  582 |     | 	}
  583 |     | 
  584 |     | 	function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {
  585 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,address)", p0, p1, p2, p3));
  586 |     | 	}
  587 |     | 
  588 |     | 	function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {
  589 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,uint256)", p0, p1, p2, p3));
  590 |     | 	}
  591 |     | 
  592 |     | 	function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {
  593 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,string)", p0, p1, p2, p3));
  594 |     | 	}
  595 |     | 
  596 |     | 	function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {
  597 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,bool)", p0, p1, p2, p3));
  598 |     | 	}
  599 |     | 
  600 |     | 	function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {
  601 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,address)", p0, p1, p2, p3));
  602 |     | 	}
  603 |     | 
  604 |     | 	function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {
  605 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,uint256)", p0, p1, p2, p3));
  606 |     | 	}
  607 |     | 
  608 |     | 	function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {
  609 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,string)", p0, p1, p2, p3));
  610 |     | 	}
  611 |     | 
  612 |     | 	function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {
  613 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,bool)", p0, p1, p2, p3));
  614 |     | 	}
  615 |     | 
  616 |     | 	function log(uint256 p0, string memory p1, bool p2, address p3) internal view {
  617 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,address)", p0, p1, p2, p3));
  618 |     | 	}
  619 |     | 
  620 |     | 	function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {
  621 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,uint256)", p0, p1, p2, p3));
  622 |     | 	}
  623 |     | 
  624 |     | 	function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {
  625 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,string)", p0, p1, p2, p3));
  626 |     | 	}
  627 |     | 
  628 |     | 	function log(uint256 p0, string memory p1, address p2, bool p3) internal view {
  629 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,bool)", p0, p1, p2, p3));
  630 |     | 	}
  631 |     | 
  632 |     | 	function log(uint256 p0, string memory p1, address p2, address p3) internal view {
  633 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,address)", p0, p1, p2, p3));
  634 |     | 	}
  635 |     | 
  636 |     | 	function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {
  637 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,uint256)", p0, p1, p2, p3));
  638 |     | 	}
  639 |     | 
  640 |     | 	function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {
  641 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,string)", p0, p1, p2, p3));
  642 |     | 	}
  643 |     | 
  644 |     | 	function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {
  645 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,bool)", p0, p1, p2, p3));
  646 |     | 	}
  647 |     | 
  648 |     | 	function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {
  649 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,address)", p0, p1, p2, p3));
  650 |     | 	}
  651 |     | 
  652 |     | 	function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {
  653 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,uint256)", p0, p1, p2, p3));
  654 |     | 	}
  655 |     | 
  656 |     | 	function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {
  657 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,string)", p0, p1, p2, p3));
  658 |     | 	}
  659 |     | 
  660 |     | 	function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {
  661 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,bool)", p0, p1, p2, p3));
  662 |     | 	}
  663 |     | 
  664 |     | 	function log(uint256 p0, bool p1, string memory p2, address p3) internal view {
  665 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,address)", p0, p1, p2, p3));
  666 |     | 	}
  667 |     | 
  668 |     | 	function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {
  669 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,uint256)", p0, p1, p2, p3));
  670 |     | 	}
  671 |     | 
  672 |     | 	function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {
  673 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,string)", p0, p1, p2, p3));
  674 |     | 	}
  675 |     | 
  676 |     | 	function log(uint256 p0, bool p1, bool p2, bool p3) internal view {
  677 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,bool)", p0, p1, p2, p3));
  678 |     | 	}
  679 |     | 
  680 |     | 	function log(uint256 p0, bool p1, bool p2, address p3) internal view {
  681 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,address)", p0, p1, p2, p3));
  682 |     | 	}
  683 |     | 
  684 |     | 	function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {
  685 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,uint256)", p0, p1, p2, p3));
  686 |     | 	}
  687 |     | 
  688 |     | 	function log(uint256 p0, bool p1, address p2, string memory p3) internal view {
  689 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,string)", p0, p1, p2, p3));
  690 |     | 	}
  691 |     | 
  692 |     | 	function log(uint256 p0, bool p1, address p2, bool p3) internal view {
  693 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,bool)", p0, p1, p2, p3));
  694 |     | 	}
  695 |     | 
  696 |     | 	function log(uint256 p0, bool p1, address p2, address p3) internal view {
  697 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,address)", p0, p1, p2, p3));
  698 |     | 	}
  699 |     | 
  700 |     | 	function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {
  701 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,uint256)", p0, p1, p2, p3));
  702 |     | 	}
  703 |     | 
  704 |     | 	function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {
  705 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,string)", p0, p1, p2, p3));
  706 |     | 	}
  707 |     | 
  708 |     | 	function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {
  709 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,bool)", p0, p1, p2, p3));
  710 |     | 	}
  711 |     | 
  712 |     | 	function log(uint256 p0, address p1, uint256 p2, address p3) internal view {
  713 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,address)", p0, p1, p2, p3));
  714 |     | 	}
  715 |     | 
  716 |     | 	function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {
  717 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,uint256)", p0, p1, p2, p3));
  718 |     | 	}
  719 |     | 
  720 |     | 	function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {
  721 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,string)", p0, p1, p2, p3));
  722 |     | 	}
  723 |     | 
  724 |     | 	function log(uint256 p0, address p1, string memory p2, bool p3) internal view {
  725 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,bool)", p0, p1, p2, p3));
  726 |     | 	}
  727 |     | 
  728 |     | 	function log(uint256 p0, address p1, string memory p2, address p3) internal view {
  729 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,address)", p0, p1, p2, p3));
  730 |     | 	}
  731 |     | 
  732 |     | 	function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {
  733 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,uint256)", p0, p1, p2, p3));
  734 |     | 	}
  735 |     | 
  736 |     | 	function log(uint256 p0, address p1, bool p2, string memory p3) internal view {
  737 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,string)", p0, p1, p2, p3));
  738 |     | 	}
  739 |     | 
  740 |     | 	function log(uint256 p0, address p1, bool p2, bool p3) internal view {
  741 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,bool)", p0, p1, p2, p3));
  742 |     | 	}
  743 |     | 
  744 |     | 	function log(uint256 p0, address p1, bool p2, address p3) internal view {
  745 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,address)", p0, p1, p2, p3));
  746 |     | 	}
  747 |     | 
  748 |     | 	function log(uint256 p0, address p1, address p2, uint256 p3) internal view {
  749 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,uint256)", p0, p1, p2, p3));
  750 |     | 	}
  751 |     | 
  752 |     | 	function log(uint256 p0, address p1, address p2, string memory p3) internal view {
  753 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,string)", p0, p1, p2, p3));
  754 |     | 	}
  755 |     | 
  756 |     | 	function log(uint256 p0, address p1, address p2, bool p3) internal view {
  757 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,bool)", p0, p1, p2, p3));
  758 |     | 	}
  759 |     | 
  760 |     | 	function log(uint256 p0, address p1, address p2, address p3) internal view {
  761 |     | 		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,address)", p0, p1, p2, p3));
  762 |     | 	}
  763 |     | 
  764 |     | 	function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {
  765 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,uint256)", p0, p1, p2, p3));
  766 |     | 	}
  767 |     | 
  768 |     | 	function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {
  769 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,string)", p0, p1, p2, p3));
  770 |     | 	}
  771 |     | 
  772 |     | 	function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {
  773 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,bool)", p0, p1, p2, p3));
  774 |     | 	}
  775 |     | 
  776 |     | 	function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {
  777 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,address)", p0, p1, p2, p3));
  778 |     | 	}
  779 |     | 
  780 |     | 	function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {
  781 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,uint256)", p0, p1, p2, p3));
  782 |     | 	}
  783 |     | 
  784 |     | 	function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {
  785 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,string)", p0, p1, p2, p3));
  786 |     | 	}
  787 |     | 
  788 |     | 	function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {
  789 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,bool)", p0, p1, p2, p3));
  790 |     | 	}
  791 |     | 
  792 |     | 	function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {
  793 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,address)", p0, p1, p2, p3));
  794 |     | 	}
  795 |     | 
  796 |     | 	function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {
  797 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,uint256)", p0, p1, p2, p3));
  798 |     | 	}
  799 |     | 
  800 |     | 	function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {
  801 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,string)", p0, p1, p2, p3));
  802 |     | 	}
  803 |     | 
  804 |     | 	function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {
  805 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,bool)", p0, p1, p2, p3));
  806 |     | 	}
  807 |     | 
  808 |     | 	function log(string memory p0, uint256 p1, bool p2, address p3) internal view {
  809 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,address)", p0, p1, p2, p3));
  810 |     | 	}
  811 |     | 
  812 |     | 	function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {
  813 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,uint256)", p0, p1, p2, p3));
  814 |     | 	}
  815 |     | 
  816 |     | 	function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {
  817 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,string)", p0, p1, p2, p3));
  818 |     | 	}
  819 |     | 
  820 |     | 	function log(string memory p0, uint256 p1, address p2, bool p3) internal view {
  821 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,bool)", p0, p1, p2, p3));
  822 |     | 	}
  823 |     | 
  824 |     | 	function log(string memory p0, uint256 p1, address p2, address p3) internal view {
  825 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,address)", p0, p1, p2, p3));
  826 |     | 	}
  827 |     | 
  828 |     | 	function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {
  829 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,uint256)", p0, p1, p2, p3));
  830 |     | 	}
  831 |     | 
  832 |     | 	function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {
  833 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,string)", p0, p1, p2, p3));
  834 |     | 	}
  835 |     | 
  836 |     | 	function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {
  837 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,bool)", p0, p1, p2, p3));
  838 |     | 	}
  839 |     | 
  840 |     | 	function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {
  841 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,address)", p0, p1, p2, p3));
  842 |     | 	}
  843 |     | 
  844 |     | 	function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {
  845 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint256)", p0, p1, p2, p3));
  846 |     | 	}
  847 |     | 
  848 |     | 	function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {
  849 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
  850 |     | 	}
  851 |     | 
  852 |     | 	function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {
  853 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
  854 |     | 	}
  855 |     | 
  856 |     | 	function log(string memory p0, string memory p1, string memory p2, address p3) internal view {
  857 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
  858 |     | 	}
  859 |     | 
  860 |     | 	function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {
  861 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint256)", p0, p1, p2, p3));
  862 |     | 	}
  863 |     | 
  864 |     | 	function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {
  865 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
  866 |     | 	}
  867 |     | 
  868 |     | 	function log(string memory p0, string memory p1, bool p2, bool p3) internal view {
  869 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
  870 |     | 	}
  871 |     | 
  872 |     | 	function log(string memory p0, string memory p1, bool p2, address p3) internal view {
  873 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
  874 |     | 	}
  875 |     | 
  876 |     | 	function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {
  877 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint256)", p0, p1, p2, p3));
  878 |     | 	}
  879 |     | 
  880 |     | 	function log(string memory p0, string memory p1, address p2, string memory p3) internal view {
  881 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
  882 |     | 	}
  883 |     | 
  884 |     | 	function log(string memory p0, string memory p1, address p2, bool p3) internal view {
  885 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
  886 |     | 	}
  887 |     | 
  888 |     | 	function log(string memory p0, string memory p1, address p2, address p3) internal view {
  889 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
  890 |     | 	}
  891 |     | 
  892 |     | 	function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {
  893 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,uint256)", p0, p1, p2, p3));
  894 |     | 	}
  895 |     | 
  896 |     | 	function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {
  897 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,string)", p0, p1, p2, p3));
  898 |     | 	}
  899 |     | 
  900 |     | 	function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {
  901 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,bool)", p0, p1, p2, p3));
  902 |     | 	}
  903 |     | 
  904 |     | 	function log(string memory p0, bool p1, uint256 p2, address p3) internal view {
  905 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,address)", p0, p1, p2, p3));
  906 |     | 	}
  907 |     | 
  908 |     | 	function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {
  909 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint256)", p0, p1, p2, p3));
  910 |     | 	}
  911 |     | 
  912 |     | 	function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {
  913 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
  914 |     | 	}
  915 |     | 
  916 |     | 	function log(string memory p0, bool p1, string memory p2, bool p3) internal view {
  917 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
  918 |     | 	}
  919 |     | 
  920 |     | 	function log(string memory p0, bool p1, string memory p2, address p3) internal view {
  921 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
  922 |     | 	}
  923 |     | 
  924 |     | 	function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {
  925 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint256)", p0, p1, p2, p3));
  926 |     | 	}
  927 |     | 
  928 |     | 	function log(string memory p0, bool p1, bool p2, string memory p3) internal view {
  929 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
  930 |     | 	}
  931 |     | 
  932 |     | 	function log(string memory p0, bool p1, bool p2, bool p3) internal view {
  933 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
  934 |     | 	}
  935 |     | 
  936 |     | 	function log(string memory p0, bool p1, bool p2, address p3) internal view {
  937 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
  938 |     | 	}
  939 |     | 
  940 |     | 	function log(string memory p0, bool p1, address p2, uint256 p3) internal view {
  941 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint256)", p0, p1, p2, p3));
  942 |     | 	}
  943 |     | 
  944 |     | 	function log(string memory p0, bool p1, address p2, string memory p3) internal view {
  945 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
  946 |     | 	}
  947 |     | 
  948 |     | 	function log(string memory p0, bool p1, address p2, bool p3) internal view {
  949 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
  950 |     | 	}
  951 |     | 
  952 |     | 	function log(string memory p0, bool p1, address p2, address p3) internal view {
  953 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
  954 |     | 	}
  955 |     | 
  956 |     | 	function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {
  957 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,uint256)", p0, p1, p2, p3));
  958 |     | 	}
  959 |     | 
  960 |     | 	function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {
  961 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,string)", p0, p1, p2, p3));
  962 |     | 	}
  963 |     | 
  964 |     | 	function log(string memory p0, address p1, uint256 p2, bool p3) internal view {
  965 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,bool)", p0, p1, p2, p3));
  966 |     | 	}
  967 |     | 
  968 |     | 	function log(string memory p0, address p1, uint256 p2, address p3) internal view {
  969 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,address)", p0, p1, p2, p3));
  970 |     | 	}
  971 |     | 
  972 |     | 	function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {
  973 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint256)", p0, p1, p2, p3));
  974 |     | 	}
  975 |     | 
  976 |     | 	function log(string memory p0, address p1, string memory p2, string memory p3) internal view {
  977 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
  978 |     | 	}
  979 |     | 
  980 |     | 	function log(string memory p0, address p1, string memory p2, bool p3) internal view {
  981 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
  982 |     | 	}
  983 |     | 
  984 |     | 	function log(string memory p0, address p1, string memory p2, address p3) internal view {
  985 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
  986 |     | 	}
  987 |     | 
  988 |     | 	function log(string memory p0, address p1, bool p2, uint256 p3) internal view {
  989 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint256)", p0, p1, p2, p3));
  990 |     | 	}
  991 |     | 
  992 |     | 	function log(string memory p0, address p1, bool p2, string memory p3) internal view {
  993 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
  994 |     | 	}
  995 |     | 
  996 |     | 	function log(string memory p0, address p1, bool p2, bool p3) internal view {
  997 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
  998 |     | 	}
  999 |     | 
 1000 |     | 	function log(string memory p0, address p1, bool p2, address p3) internal view {
 1001 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
 1002 |     | 	}
 1003 |     | 
 1004 |     | 	function log(string memory p0, address p1, address p2, uint256 p3) internal view {
 1005 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint256)", p0, p1, p2, p3));
 1006 |     | 	}
 1007 |     | 
 1008 |     | 	function log(string memory p0, address p1, address p2, string memory p3) internal view {
 1009 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
 1010 |     | 	}
 1011 |     | 
 1012 |     | 	function log(string memory p0, address p1, address p2, bool p3) internal view {
 1013 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
 1014 |     | 	}
 1015 |     | 
 1016 |     | 	function log(string memory p0, address p1, address p2, address p3) internal view {
 1017 |     | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
 1018 |     | 	}
 1019 |     | 
 1020 |     | 	function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {
 1021 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,uint256)", p0, p1, p2, p3));
 1022 |     | 	}
 1023 |     | 
 1024 |     | 	function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {
 1025 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,string)", p0, p1, p2, p3));
 1026 |     | 	}
 1027 |     | 
 1028 |     | 	function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {
 1029 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,bool)", p0, p1, p2, p3));
 1030 |     | 	}
 1031 |     | 
 1032 |     | 	function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {
 1033 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,address)", p0, p1, p2, p3));
 1034 |     | 	}
 1035 |     | 
 1036 |     | 	function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {
 1037 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,uint256)", p0, p1, p2, p3));
 1038 |     | 	}
 1039 |     | 
 1040 |     | 	function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {
 1041 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,string)", p0, p1, p2, p3));
 1042 |     | 	}
 1043 |     | 
 1044 |     | 	function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {
 1045 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,bool)", p0, p1, p2, p3));
 1046 |     | 	}
 1047 |     | 
 1048 |     | 	function log(bool p0, uint256 p1, string memory p2, address p3) internal view {
 1049 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,address)", p0, p1, p2, p3));
 1050 |     | 	}
 1051 |     | 
 1052 |     | 	function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {
 1053 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,uint256)", p0, p1, p2, p3));
 1054 |     | 	}
 1055 |     | 
 1056 |     | 	function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {
 1057 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,string)", p0, p1, p2, p3));
 1058 |     | 	}
 1059 |     | 
 1060 |     | 	function log(bool p0, uint256 p1, bool p2, bool p3) internal view {
 1061 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,bool)", p0, p1, p2, p3));
 1062 |     | 	}
 1063 |     | 
 1064 |     | 	function log(bool p0, uint256 p1, bool p2, address p3) internal view {
 1065 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,address)", p0, p1, p2, p3));
 1066 |     | 	}
 1067 |     | 
 1068 |     | 	function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {
 1069 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,uint256)", p0, p1, p2, p3));
 1070 |     | 	}
 1071 |     | 
 1072 |     | 	function log(bool p0, uint256 p1, address p2, string memory p3) internal view {
 1073 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,string)", p0, p1, p2, p3));
 1074 |     | 	}
 1075 |     | 
 1076 |     | 	function log(bool p0, uint256 p1, address p2, bool p3) internal view {
 1077 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,bool)", p0, p1, p2, p3));
 1078 |     | 	}
 1079 |     | 
 1080 |     | 	function log(bool p0, uint256 p1, address p2, address p3) internal view {
 1081 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,address)", p0, p1, p2, p3));
 1082 |     | 	}
 1083 |     | 
 1084 |     | 	function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {
 1085 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,uint256)", p0, p1, p2, p3));
 1086 |     | 	}
 1087 |     | 
 1088 |     | 	function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {
 1089 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,string)", p0, p1, p2, p3));
 1090 |     | 	}
 1091 |     | 
 1092 |     | 	function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {
 1093 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,bool)", p0, p1, p2, p3));
 1094 |     | 	}
 1095 |     | 
 1096 |     | 	function log(bool p0, string memory p1, uint256 p2, address p3) internal view {
 1097 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,address)", p0, p1, p2, p3));
 1098 |     | 	}
 1099 |     | 
 1100 |     | 	function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {
 1101 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint256)", p0, p1, p2, p3));
 1102 |     | 	}
 1103 |     | 
 1104 |     | 	function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {
 1105 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
 1106 |     | 	}
 1107 |     | 
 1108 |     | 	function log(bool p0, string memory p1, string memory p2, bool p3) internal view {
 1109 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
 1110 |     | 	}
 1111 |     | 
 1112 |     | 	function log(bool p0, string memory p1, string memory p2, address p3) internal view {
 1113 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
 1114 |     | 	}
 1115 |     | 
 1116 |     | 	function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {
 1117 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint256)", p0, p1, p2, p3));
 1118 |     | 	}
 1119 |     | 
 1120 |     | 	function log(bool p0, string memory p1, bool p2, string memory p3) internal view {
 1121 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
 1122 |     | 	}
 1123 |     | 
 1124 |     | 	function log(bool p0, string memory p1, bool p2, bool p3) internal view {
 1125 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
 1126 |     | 	}
 1127 |     | 
 1128 |     | 	function log(bool p0, string memory p1, bool p2, address p3) internal view {
 1129 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
 1130 |     | 	}
 1131 |     | 
 1132 |     | 	function log(bool p0, string memory p1, address p2, uint256 p3) internal view {
 1133 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint256)", p0, p1, p2, p3));
 1134 |     | 	}
 1135 |     | 
 1136 |     | 	function log(bool p0, string memory p1, address p2, string memory p3) internal view {
 1137 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
 1138 |     | 	}
 1139 |     | 
 1140 |     | 	function log(bool p0, string memory p1, address p2, bool p3) internal view {
 1141 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
 1142 |     | 	}
 1143 |     | 
 1144 |     | 	function log(bool p0, string memory p1, address p2, address p3) internal view {
 1145 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
 1146 |     | 	}
 1147 |     | 
 1148 |     | 	function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {
 1149 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,uint256)", p0, p1, p2, p3));
 1150 |     | 	}
 1151 |     | 
 1152 |     | 	function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {
 1153 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,string)", p0, p1, p2, p3));
 1154 |     | 	}
 1155 |     | 
 1156 |     | 	function log(bool p0, bool p1, uint256 p2, bool p3) internal view {
 1157 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,bool)", p0, p1, p2, p3));
 1158 |     | 	}
 1159 |     | 
 1160 |     | 	function log(bool p0, bool p1, uint256 p2, address p3) internal view {
 1161 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,address)", p0, p1, p2, p3));
 1162 |     | 	}
 1163 |     | 
 1164 |     | 	function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {
 1165 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint256)", p0, p1, p2, p3));
 1166 |     | 	}
 1167 |     | 
 1168 |     | 	function log(bool p0, bool p1, string memory p2, string memory p3) internal view {
 1169 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
 1170 |     | 	}
 1171 |     | 
 1172 |     | 	function log(bool p0, bool p1, string memory p2, bool p3) internal view {
 1173 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
 1174 |     | 	}
 1175 |     | 
 1176 |     | 	function log(bool p0, bool p1, string memory p2, address p3) internal view {
 1177 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
 1178 |     | 	}
 1179 |     | 
 1180 |     | 	function log(bool p0, bool p1, bool p2, uint256 p3) internal view {
 1181 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint256)", p0, p1, p2, p3));
 1182 |     | 	}
 1183 |     | 
 1184 |     | 	function log(bool p0, bool p1, bool p2, string memory p3) internal view {
 1185 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
 1186 |     | 	}
 1187 |     | 
 1188 |     | 	function log(bool p0, bool p1, bool p2, bool p3) internal view {
 1189 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
 1190 |     | 	}
 1191 |     | 
 1192 |     | 	function log(bool p0, bool p1, bool p2, address p3) internal view {
 1193 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
 1194 |     | 	}
 1195 |     | 
 1196 |     | 	function log(bool p0, bool p1, address p2, uint256 p3) internal view {
 1197 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint256)", p0, p1, p2, p3));
 1198 |     | 	}
 1199 |     | 
 1200 |     | 	function log(bool p0, bool p1, address p2, string memory p3) internal view {
 1201 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
 1202 |     | 	}
 1203 |     | 
 1204 |     | 	function log(bool p0, bool p1, address p2, bool p3) internal view {
 1205 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
 1206 |     | 	}
 1207 |     | 
 1208 |     | 	function log(bool p0, bool p1, address p2, address p3) internal view {
 1209 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
 1210 |     | 	}
 1211 |     | 
 1212 |     | 	function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {
 1213 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,uint256)", p0, p1, p2, p3));
 1214 |     | 	}
 1215 |     | 
 1216 |     | 	function log(bool p0, address p1, uint256 p2, string memory p3) internal view {
 1217 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,string)", p0, p1, p2, p3));
 1218 |     | 	}
 1219 |     | 
 1220 |     | 	function log(bool p0, address p1, uint256 p2, bool p3) internal view {
 1221 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,bool)", p0, p1, p2, p3));
 1222 |     | 	}
 1223 |     | 
 1224 |     | 	function log(bool p0, address p1, uint256 p2, address p3) internal view {
 1225 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,address)", p0, p1, p2, p3));
 1226 |     | 	}
 1227 |     | 
 1228 |     | 	function log(bool p0, address p1, string memory p2, uint256 p3) internal view {
 1229 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint256)", p0, p1, p2, p3));
 1230 |     | 	}
 1231 |     | 
 1232 |     | 	function log(bool p0, address p1, string memory p2, string memory p3) internal view {
 1233 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
 1234 |     | 	}
 1235 |     | 
 1236 |     | 	function log(bool p0, address p1, string memory p2, bool p3) internal view {
 1237 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
 1238 |     | 	}
 1239 |     | 
 1240 |     | 	function log(bool p0, address p1, string memory p2, address p3) internal view {
 1241 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
 1242 |     | 	}
 1243 |     | 
 1244 |     | 	function log(bool p0, address p1, bool p2, uint256 p3) internal view {
 1245 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint256)", p0, p1, p2, p3));
 1246 |     | 	}
 1247 |     | 
 1248 |     | 	function log(bool p0, address p1, bool p2, string memory p3) internal view {
 1249 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
 1250 |     | 	}
 1251 |     | 
 1252 |     | 	function log(bool p0, address p1, bool p2, bool p3) internal view {
 1253 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
 1254 |     | 	}
 1255 |     | 
 1256 |     | 	function log(bool p0, address p1, bool p2, address p3) internal view {
 1257 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
 1258 |     | 	}
 1259 |     | 
 1260 |     | 	function log(bool p0, address p1, address p2, uint256 p3) internal view {
 1261 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint256)", p0, p1, p2, p3));
 1262 |     | 	}
 1263 |     | 
 1264 |     | 	function log(bool p0, address p1, address p2, string memory p3) internal view {
 1265 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
 1266 |     | 	}
 1267 |     | 
 1268 |     | 	function log(bool p0, address p1, address p2, bool p3) internal view {
 1269 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
 1270 |     | 	}
 1271 |     | 
 1272 |     | 	function log(bool p0, address p1, address p2, address p3) internal view {
 1273 |     | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
 1274 |     | 	}
 1275 |     | 
 1276 |     | 	function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {
 1277 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,uint256)", p0, p1, p2, p3));
 1278 |     | 	}
 1279 |     | 
 1280 |     | 	function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {
 1281 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,string)", p0, p1, p2, p3));
 1282 |     | 	}
 1283 |     | 
 1284 |     | 	function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {
 1285 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,bool)", p0, p1, p2, p3));
 1286 |     | 	}
 1287 |     | 
 1288 |     | 	function log(address p0, uint256 p1, uint256 p2, address p3) internal view {
 1289 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,address)", p0, p1, p2, p3));
 1290 |     | 	}
 1291 |     | 
 1292 |     | 	function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {
 1293 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,uint256)", p0, p1, p2, p3));
 1294 |     | 	}
 1295 |     | 
 1296 |     | 	function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {
 1297 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,string)", p0, p1, p2, p3));
 1298 |     | 	}
 1299 |     | 
 1300 |     | 	function log(address p0, uint256 p1, string memory p2, bool p3) internal view {
 1301 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,bool)", p0, p1, p2, p3));
 1302 |     | 	}
 1303 |     | 
 1304 |     | 	function log(address p0, uint256 p1, string memory p2, address p3) internal view {
 1305 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,address)", p0, p1, p2, p3));
 1306 |     | 	}
 1307 |     | 
 1308 |     | 	function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {
 1309 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,uint256)", p0, p1, p2, p3));
 1310 |     | 	}
 1311 |     | 
 1312 |     | 	function log(address p0, uint256 p1, bool p2, string memory p3) internal view {
 1313 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,string)", p0, p1, p2, p3));
 1314 |     | 	}
 1315 |     | 
 1316 |     | 	function log(address p0, uint256 p1, bool p2, bool p3) internal view {
 1317 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,bool)", p0, p1, p2, p3));
 1318 |     | 	}
 1319 |     | 
 1320 |     | 	function log(address p0, uint256 p1, bool p2, address p3) internal view {
 1321 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,address)", p0, p1, p2, p3));
 1322 |     | 	}
 1323 |     | 
 1324 |     | 	function log(address p0, uint256 p1, address p2, uint256 p3) internal view {
 1325 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,uint256)", p0, p1, p2, p3));
 1326 |     | 	}
 1327 |     | 
 1328 |     | 	function log(address p0, uint256 p1, address p2, string memory p3) internal view {
 1329 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,string)", p0, p1, p2, p3));
 1330 |     | 	}
 1331 |     | 
 1332 |     | 	function log(address p0, uint256 p1, address p2, bool p3) internal view {
 1333 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,bool)", p0, p1, p2, p3));
 1334 |     | 	}
 1335 |     | 
 1336 |     | 	function log(address p0, uint256 p1, address p2, address p3) internal view {
 1337 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,address)", p0, p1, p2, p3));
 1338 |     | 	}
 1339 |     | 
 1340 |     | 	function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {
 1341 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,uint256)", p0, p1, p2, p3));
 1342 |     | 	}
 1343 |     | 
 1344 |     | 	function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {
 1345 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,string)", p0, p1, p2, p3));
 1346 |     | 	}
 1347 |     | 
 1348 |     | 	function log(address p0, string memory p1, uint256 p2, bool p3) internal view {
 1349 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,bool)", p0, p1, p2, p3));
 1350 |     | 	}
 1351 |     | 
 1352 |     | 	function log(address p0, string memory p1, uint256 p2, address p3) internal view {
 1353 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,address)", p0, p1, p2, p3));
 1354 |     | 	}
 1355 |     | 
 1356 |     | 	function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {
 1357 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint256)", p0, p1, p2, p3));
 1358 |     | 	}
 1359 |     | 
 1360 |     | 	function log(address p0, string memory p1, string memory p2, string memory p3) internal view {
 1361 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
 1362 |     | 	}
 1363 |     | 
 1364 |     | 	function log(address p0, string memory p1, string memory p2, bool p3) internal view {
 1365 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
 1366 |     | 	}
 1367 |     | 
 1368 |     | 	function log(address p0, string memory p1, string memory p2, address p3) internal view {
 1369 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
 1370 |     | 	}
 1371 |     | 
 1372 |     | 	function log(address p0, string memory p1, bool p2, uint256 p3) internal view {
 1373 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint256)", p0, p1, p2, p3));
 1374 |     | 	}
 1375 |     | 
 1376 |     | 	function log(address p0, string memory p1, bool p2, string memory p3) internal view {
 1377 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
 1378 |     | 	}
 1379 |     | 
 1380 |     | 	function log(address p0, string memory p1, bool p2, bool p3) internal view {
 1381 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
 1382 |     | 	}
 1383 |     | 
 1384 |     | 	function log(address p0, string memory p1, bool p2, address p3) internal view {
 1385 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
 1386 |     | 	}
 1387 |     | 
 1388 |     | 	function log(address p0, string memory p1, address p2, uint256 p3) internal view {
 1389 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint256)", p0, p1, p2, p3));
 1390 |     | 	}
 1391 |     | 
 1392 |     | 	function log(address p0, string memory p1, address p2, string memory p3) internal view {
 1393 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
 1394 |     | 	}
 1395 |     | 
 1396 |     | 	function log(address p0, string memory p1, address p2, bool p3) internal view {
 1397 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
 1398 |     | 	}
 1399 |     | 
 1400 |     | 	function log(address p0, string memory p1, address p2, address p3) internal view {
 1401 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
 1402 |     | 	}
 1403 |     | 
 1404 |     | 	function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {
 1405 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,uint256)", p0, p1, p2, p3));
 1406 |     | 	}
 1407 |     | 
 1408 |     | 	function log(address p0, bool p1, uint256 p2, string memory p3) internal view {
 1409 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,string)", p0, p1, p2, p3));
 1410 |     | 	}
 1411 |     | 
 1412 |     | 	function log(address p0, bool p1, uint256 p2, bool p3) internal view {
 1413 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,bool)", p0, p1, p2, p3));
 1414 |     | 	}
 1415 |     | 
 1416 |     | 	function log(address p0, bool p1, uint256 p2, address p3) internal view {
 1417 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,address)", p0, p1, p2, p3));
 1418 |     | 	}
 1419 |     | 
 1420 |     | 	function log(address p0, bool p1, string memory p2, uint256 p3) internal view {
 1421 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint256)", p0, p1, p2, p3));
 1422 |     | 	}
 1423 |     | 
 1424 |     | 	function log(address p0, bool p1, string memory p2, string memory p3) internal view {
 1425 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
 1426 |     | 	}
 1427 |     | 
 1428 |     | 	function log(address p0, bool p1, string memory p2, bool p3) internal view {
 1429 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
 1430 |     | 	}
 1431 |     | 
 1432 |     | 	function log(address p0, bool p1, string memory p2, address p3) internal view {
 1433 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
 1434 |     | 	}
 1435 |     | 
 1436 |     | 	function log(address p0, bool p1, bool p2, uint256 p3) internal view {
 1437 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint256)", p0, p1, p2, p3));
 1438 |     | 	}
 1439 |     | 
 1440 |     | 	function log(address p0, bool p1, bool p2, string memory p3) internal view {
 1441 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
 1442 |     | 	}
 1443 |     | 
 1444 |     | 	function log(address p0, bool p1, bool p2, bool p3) internal view {
 1445 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
 1446 |     | 	}
 1447 |     | 
 1448 |     | 	function log(address p0, bool p1, bool p2, address p3) internal view {
 1449 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
 1450 |     | 	}
 1451 |     | 
 1452 |     | 	function log(address p0, bool p1, address p2, uint256 p3) internal view {
 1453 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint256)", p0, p1, p2, p3));
 1454 |     | 	}
 1455 |     | 
 1456 |     | 	function log(address p0, bool p1, address p2, string memory p3) internal view {
 1457 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
 1458 |     | 	}
 1459 |     | 
 1460 |     | 	function log(address p0, bool p1, address p2, bool p3) internal view {
 1461 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
 1462 |     | 	}
 1463 |     | 
 1464 |     | 	function log(address p0, bool p1, address p2, address p3) internal view {
 1465 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
 1466 |     | 	}
 1467 |     | 
 1468 |     | 	function log(address p0, address p1, uint256 p2, uint256 p3) internal view {
 1469 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,uint256)", p0, p1, p2, p3));
 1470 |     | 	}
 1471 |     | 
 1472 |     | 	function log(address p0, address p1, uint256 p2, string memory p3) internal view {
 1473 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,string)", p0, p1, p2, p3));
 1474 |     | 	}
 1475 |     | 
 1476 |     | 	function log(address p0, address p1, uint256 p2, bool p3) internal view {
 1477 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,bool)", p0, p1, p2, p3));
 1478 |     | 	}
 1479 |     | 
 1480 |     | 	function log(address p0, address p1, uint256 p2, address p3) internal view {
 1481 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,address)", p0, p1, p2, p3));
 1482 |     | 	}
 1483 |     | 
 1484 |     | 	function log(address p0, address p1, string memory p2, uint256 p3) internal view {
 1485 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint256)", p0, p1, p2, p3));
 1486 |     | 	}
 1487 |     | 
 1488 |     | 	function log(address p0, address p1, string memory p2, string memory p3) internal view {
 1489 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
 1490 |     | 	}
 1491 |     | 
 1492 |     | 	function log(address p0, address p1, string memory p2, bool p3) internal view {
 1493 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
 1494 |     | 	}
 1495 |     | 
 1496 |     | 	function log(address p0, address p1, string memory p2, address p3) internal view {
 1497 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
 1498 |     | 	}
 1499 |     | 
 1500 |     | 	function log(address p0, address p1, bool p2, uint256 p3) internal view {
 1501 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint256)", p0, p1, p2, p3));
 1502 |     | 	}
 1503 |     | 
 1504 |     | 	function log(address p0, address p1, bool p2, string memory p3) internal view {
 1505 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
 1506 |     | 	}
 1507 |     | 
 1508 |     | 	function log(address p0, address p1, bool p2, bool p3) internal view {
 1509 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
 1510 |     | 	}
 1511 |     | 
 1512 |     | 	function log(address p0, address p1, bool p2, address p3) internal view {
 1513 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
 1514 |     | 	}
 1515 |     | 
 1516 |     | 	function log(address p0, address p1, address p2, uint256 p3) internal view {
 1517 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint256)", p0, p1, p2, p3));
 1518 |     | 	}
 1519 |     | 
 1520 |     | 	function log(address p0, address p1, address p2, string memory p3) internal view {
 1521 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
 1522 |     | 	}
 1523 |     | 
 1524 |     | 	function log(address p0, address p1, address p2, bool p3) internal view {
 1525 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
 1526 |     | 	}
 1527 |     | 
 1528 |     | 	function log(address p0, address p1, address p2, address p3) internal view {
 1529 |     | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
 1530 |     | 	}
 1531 |     | 
 1532 |     | }
 1533 |     | 

