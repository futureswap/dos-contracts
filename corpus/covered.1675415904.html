<style> code { white-space: pre-wrap; display: block; background-color: #eee; }.executed { background-color: #afa; }.reverted { background-color: #ffa; }.unexecuted { background-color: #faa; }.neutral { background-color: #eee; }</style><b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol</b>
<code>
  1 | r   | <span class='reverted'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface AggregatorV3Interface {</span>
  5 |     | <span class='neutral'>  function decimals() external view returns (uint8);</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>  function description() external view returns (string memory);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>  function version() external view returns (uint256);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>  function getRoundData(uint80 _roundId)</span>
 12 |     | <span class='neutral'>    external</span>
 13 |     | <span class='neutral'>    view</span>
 14 |     | <span class='neutral'>    returns (</span>
 15 |     | <span class='neutral'>      uint80 roundId,</span>
 16 |     | <span class='neutral'>      int256 answer,</span>
 17 |     | <span class='neutral'>      uint256 startedAt,</span>
 18 |     | <span class='neutral'>      uint256 updatedAt,</span>
 19 |     | <span class='neutral'>      uint80 answeredInRound</span>
 20 |     | <span class='neutral'>    );</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>  function latestRoundData()</span>
 23 |     | <span class='neutral'>    external</span>
 24 |     | <span class='neutral'>    view</span>
 25 |     | <span class='neutral'>    returns (</span>
 26 |     | <span class='neutral'>      uint80 roundId,</span>
 27 |     | <span class='neutral'>      int256 answer,</span>
 28 |     | <span class='neutral'>      uint256 startedAt,</span>
 29 |     | <span class='neutral'>      uint256 updatedAt,</span>
 30 |     | <span class='neutral'>      uint80 answeredInRound</span>
 31 |     | <span class='neutral'>    );</span>
 32 |     | <span class='neutral'>}</span>
 33 | *r  | <span class='executed'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/access/Ownable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../utils/Context.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Contract module which provides a basic access control mechanism, where</span>
 10 |     | <span class='neutral'> * there is an account (an owner) that can be granted exclusive access to</span>
 11 |     | <span class='neutral'> * specific functions.</span>
 12 |     | <span class='neutral'> *</span>
 13 |     | <span class='neutral'> * By default, the owner account will be the one that deploys the contract. This</span>
 14 |     | <span class='neutral'> * can later be changed with {transferOwnership}.</span>
 15 |     | <span class='neutral'> *</span>
 16 |     | <span class='neutral'> * This module is used through inheritance. It will make available the modifier</span>
 17 |     | <span class='neutral'> * `onlyOwner`, which can be applied to your functions to restrict their use to</span>
 18 |     | <span class='neutral'> * the owner.</span>
 19 |     | <span class='neutral'> */</span>
 20 |     | <span class='neutral'>abstract contract Ownable is Context {</span>
 21 |     | <span class='neutral'>    address private _owner;</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    /**</span>
 26 |     | <span class='neutral'>     * @dev Initializes the contract setting the deployer as the initial owner.</span>
 27 |     | <span class='neutral'>     */</span>
 28 |     | <span class='neutral'>    constructor() {</span>
 29 |     | <span class='neutral'>        _transferOwnership(_msgSender());</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    /**</span>
 33 |     | <span class='neutral'>     * @dev Throws if called by any account other than the owner.</span>
 34 |     | <span class='neutral'>     */</span>
 35 |     | <span class='neutral'>    modifier onlyOwner() {</span>
 36 | *r  | <span class='executed'>        _checkOwner();</span>
 37 |     | <span class='neutral'>        _;</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    /**</span>
 41 | r   | <span class='reverted'>     * @dev Returns the address of the current owner.</span>
 42 |     | <span class='neutral'>     */</span>
 43 | r   | <span class='reverted'>    function owner() public view virtual returns (address) {</span>
 44 |     | <span class='neutral'>        return _owner;</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    /**</span>
 48 |     | <span class='neutral'>     * @dev Throws if the sender is not the owner.</span>
 49 |     | <span class='neutral'>     */</span>
 50 |     | <span class='neutral'>    function _checkOwner() internal view virtual {</span>
 51 |     | <span class='unexecuted'>        require(owner() == _msgSender(), &quot;Ownable: caller is not the owner&quot;);</span>
 52 |     | <span class='unexecuted'>    }</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    /**</span>
 55 |     | <span class='neutral'>     * @dev Leaves the contract without owner. It will not be possible to call</span>
 56 |     | <span class='unexecuted'>     * `onlyOwner` functions anymore. Can only be called by the current owner.</span>
 57 |     | <span class='neutral'>     *</span>
 58 |     | <span class='unexecuted'>     * NOTE: Renouncing ownership will leave the contract without an owner,</span>
 59 |     | <span class='unexecuted'>     * thereby removing any functionality that is only available to the owner.</span>
 60 |     | <span class='neutral'>     */</span>
 61 |     | <span class='unexecuted'>    function renounceOwnership() public virtual onlyOwner {</span>
 62 |     | <span class='unexecuted'>        _transferOwnership(address(0));</span>
 63 |     | <span class='neutral'>    }</span>
 64 |     | <span class='neutral'></span>
 65 |     | <span class='neutral'>    /**</span>
 66 |     | <span class='unexecuted'>     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span>
 67 |     | <span class='unexecuted'>     * Can only be called by the current owner.</span>
 68 |     | <span class='neutral'>     */</span>
 69 |     | <span class='neutral'>    function transferOwnership(address newOwner) public virtual onlyOwner {</span>
 70 |     | <span class='neutral'>        require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);</span>
 71 |     | <span class='neutral'>        _transferOwnership(newOwner);</span>
 72 |     | <span class='neutral'>    }</span>
 73 |     | <span class='neutral'></span>
 74 |     | <span class='neutral'>    /**</span>
 75 |     | <span class='neutral'>     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span>
 76 |     | <span class='neutral'>     * Internal function without access restriction.</span>
 77 |     | <span class='neutral'>     */</span>
 78 |     | <span class='neutral'>    function _transferOwnership(address newOwner) internal virtual {</span>
 79 |     | <span class='neutral'>        address oldOwner = _owner;</span>
 80 |     | <span class='neutral'>        _owner = newOwner;</span>
 81 |     | <span class='neutral'>        emit OwnershipTransferred(oldOwner, newOwner);</span>
 82 |     | <span class='neutral'>    }</span>
 83 |     | <span class='unexecuted'>}</span>
 84 | *r  | <span class='executed'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/access/Ownable2Step.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (access/Ownable2Step.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;./Ownable.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Contract module which provides access control mechanism, where</span>
 10 |     | <span class='neutral'> * there is an account (an owner) that can be granted exclusive access to</span>
 11 |     | <span class='neutral'> * specific functions.</span>
 12 |     | <span class='neutral'> *</span>
 13 | *   | <span class='executed'> * By default, the owner account will be the one that deploys the contract. This</span>
 14 |     | <span class='neutral'> * can later be changed with {transferOwnership} and {acceptOwnership}.</span>
 15 |     | <span class='neutral'> *</span>
 16 |     | <span class='neutral'> * This module is used through inheritance. It will make available all functions</span>
 17 |     | <span class='unexecuted'> * from parent (Ownable).</span>
 18 |     | <span class='neutral'> */</span>
 19 |     | <span class='unexecuted'>abstract contract Ownable2Step is Ownable {</span>
 20 |     | <span class='neutral'>    address private _pendingOwner;</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the address of the pending owner.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function pendingOwner() public view virtual returns (address) {</span>
 28 |     | <span class='neutral'>        return _pendingOwner;</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    /**</span>
 32 |     | <span class='neutral'>     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.</span>
 33 |     | <span class='neutral'>     * Can only be called by the current owner.</span>
 34 |     | <span class='neutral'>     */</span>
 35 |     | <span class='neutral'>    function transferOwnership(address newOwner) public virtual override onlyOwner {</span>
 36 |     | <span class='neutral'>        _pendingOwner = newOwner;</span>
 37 |     | <span class='neutral'>        emit OwnershipTransferStarted(owner(), newOwner);</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    /**</span>
 41 |     | <span class='neutral'>     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.</span>
 42 |     | <span class='neutral'>     * Internal function without access restriction.</span>
 43 |     | <span class='neutral'>     */</span>
 44 |     | <span class='neutral'>    function _transferOwnership(address newOwner) internal virtual override {</span>
 45 |     | <span class='neutral'>        delete _pendingOwner;</span>
 46 |     | <span class='neutral'>        super._transferOwnership(newOwner);</span>
 47 |     | <span class='neutral'>    }</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='neutral'>    /**</span>
 50 |     | <span class='neutral'>     * @dev The new owner accepts the ownership transfer.</span>
 51 |     | <span class='neutral'>     */</span>
 52 |     | <span class='neutral'>    function acceptOwnership() external {</span>
 53 |     | <span class='neutral'>        address sender = _msgSender();</span>
 54 |     | <span class='neutral'>        require(pendingOwner() == sender, &quot;Ownable2Step: caller is not the new owner&quot;);</span>
 55 |     | <span class='neutral'>        _transferOwnership(sender);</span>
 56 |     | <span class='neutral'>    }</span>
 57 |     | <span class='neutral'>}</span>
 58 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/interfaces/IERC1271.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC1271 standard signature validation method for</span>
  8 |     | <span class='neutral'> * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].</span>
  9 |     | <span class='neutral'> *</span>
 10 |     | <span class='neutral'> * _Available since v4.1._</span>
 11 |     | <span class='neutral'> */</span>
 12 |     | <span class='neutral'>interface IERC1271 {</span>
 13 |     | <span class='neutral'>    /**</span>
 14 |     | <span class='neutral'>     * @dev Should return whether the signature provided is valid for the provided data</span>
 15 |     | <span class='neutral'>     * @param hash      Hash of the data to be signed</span>
 16 |     | <span class='neutral'>     * @param signature Signature byte array associated with _data</span>
 17 |     | <span class='neutral'>     */</span>
 18 |     | <span class='neutral'>    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);</span>
 19 |     | <span class='neutral'>}</span>
 20 | r   | <span class='reverted'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/interfaces/IERC1363Receiver.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1363Receiver.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IERC1363Receiver {</span>
  7 |     | <span class='neutral'>    /*</span>
  8 |     | <span class='neutral'>     * Note: the ERC-165 identifier for this interface is 0x88a7ca5c.</span>
  9 |     | <span class='neutral'>     * 0x88a7ca5c === bytes4(keccak256(&quot;onTransferReceived(address,address,uint256,bytes)&quot;))</span>
 10 |     | <span class='neutral'>     */</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    /**</span>
 13 |     | <span class='neutral'>     * @notice Handle the receipt of ERC1363 tokens</span>
 14 |     | <span class='neutral'>     * @dev Any ERC1363 smart contract calls this function on the recipient</span>
 15 |     | <span class='neutral'>     * after a `transfer` or a `transferFrom`. This function MAY throw to revert and reject the</span>
 16 |     | <span class='neutral'>     * transfer. Return of other than the magic value MUST result in the</span>
 17 |     | <span class='neutral'>     * transaction being reverted.</span>
 18 |     | <span class='neutral'>     * Note: the token contract address is always the message sender.</span>
 19 |     | <span class='unexecuted'>     * @param operator address The address which called `transferAndCall` or `transferFromAndCall` function</span>
 20 |     | <span class='neutral'>     * @param from address The address which are token transferred from</span>
 21 |     | <span class='neutral'>     * @param value uint256 The amount of tokens transferred</span>
 22 |     | <span class='unexecuted'>     * @param data bytes Additional data with no specified format</span>
 23 |     | <span class='unexecuted'>     * @return `bytes4(keccak256(&quot;onTransferReceived(address,address,uint256,bytes)&quot;))`</span>
 24 |     | <span class='neutral'>     *  unless throwing</span>
 25 |     | <span class='neutral'>     */</span>
 26 |     | <span class='neutral'>    function onTransferReceived(</span>
 27 |     | <span class='neutral'>        address operator,</span>
 28 |     | <span class='neutral'>        address from,</span>
 29 |     | <span class='unexecuted'>        uint256 value,</span>
 30 |     | <span class='neutral'>        bytes memory data</span>
 31 |     | <span class='neutral'>    ) external returns (bytes4);</span>
 32 |     | <span class='neutral'>}</span>
 33 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/proxy/Proxy.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM</span>
  8 |     | <span class='neutral'> * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to</span>
  9 |     | <span class='neutral'> * be specified by overriding the virtual {_implementation} function.</span>
 10 |     | <span class='neutral'> *</span>
 11 | *r  | <span class='executed'> * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a</span>
 12 |     | <span class='neutral'> * different contract through the {_delegate} function.</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * The success and return data of the delegated call will be returned back to the caller of the proxy.</span>
 15 |     | <span class='neutral'> */</span>
 16 |     | <span class='neutral'>abstract contract Proxy {</span>
 17 |     | <span class='neutral'>    /**</span>
 18 |     | <span class='neutral'>     * @dev Delegates the current call to `implementation`.</span>
 19 |     | <span class='neutral'>     *</span>
 20 |     | <span class='neutral'>     * This function does not return to its internal call site, it will return directly to the external caller.</span>
 21 |     | <span class='unexecuted'>     */</span>
 22 |     | <span class='unexecuted'>    function _delegate(address implementation) internal virtual {</span>
 23 |     | <span class='unexecuted'>        assembly {</span>
 24 |     | <span class='neutral'>            // Copy msg.data. We take full control of memory in this inline assembly</span>
 25 |     | <span class='unexecuted'>            // block because it will not return to Solidity code. We overwrite the</span>
 26 |     | <span class='neutral'>            // Solidity scratch pad at memory position 0.</span>
 27 |     | <span class='unexecuted'>            calldatacopy(0, 0, calldatasize())</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>            // Call the implementation.</span>
 30 |     | <span class='neutral'>            // out and outsize are 0 because we don&#39;t know the size yet.</span>
 31 |     | <span class='neutral'>            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>            // Copy the returned data.</span>
 34 |     | <span class='neutral'>            returndatacopy(0, 0, returndatasize())</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>            switch result</span>
 37 |     | <span class='neutral'>            // delegatecall returns 0 on error.</span>
 38 |     | <span class='neutral'>            case 0 {</span>
 39 |     | <span class='neutral'>                revert(0, returndatasize())</span>
 40 |     | <span class='neutral'>            }</span>
 41 |     | <span class='neutral'>            default {</span>
 42 |     | <span class='neutral'>                return(0, returndatasize())</span>
 43 |     | <span class='neutral'>            }</span>
 44 |     | <span class='neutral'>        }</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    /**</span>
 48 |     | <span class='unexecuted'>     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function</span>
 49 |     | <span class='neutral'>     * and {_fallback} should delegate.</span>
 50 |     | <span class='unexecuted'>     */</span>
 51 |     | <span class='neutral'>    function _implementation() internal view virtual returns (address);</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='neutral'>    /**</span>
 54 |     | <span class='unexecuted'>     * @dev Delegates the current call to the address returned by `_implementation()`.</span>
 55 |     | <span class='neutral'>     *</span>
 56 |     | <span class='unexecuted'>     * This function does not return to its internal call site, it will return directly to the external caller.</span>
 57 |     | <span class='neutral'>     */</span>
 58 |     | <span class='unexecuted'>    function _fallback() internal virtual {</span>
 59 |     | <span class='unexecuted'>        _beforeFallback();</span>
 60 |     | <span class='neutral'>        _delegate(_implementation());</span>
 61 |     | <span class='neutral'>    }</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='neutral'>    /**</span>
 64 |     | <span class='unexecuted'>     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other</span>
 65 |     | <span class='neutral'>     * function in the contract matches the call data.</span>
 66 |     | <span class='neutral'>     */</span>
 67 |     | <span class='neutral'>    fallback() external payable virtual {</span>
 68 |     | <span class='unexecuted'>        _fallback();</span>
 69 |     | <span class='neutral'>    }</span>
 70 |     | <span class='neutral'></span>
 71 |     | <span class='neutral'>    /**</span>
 72 |     | <span class='neutral'>     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data</span>
 73 |     | <span class='neutral'>     * is empty.</span>
 74 |     | <span class='neutral'>     */</span>
 75 |     | <span class='unexecuted'>    receive() external payable virtual {</span>
 76 |     | <span class='unexecuted'>        _fallback();</span>
 77 |     | <span class='neutral'>    }</span>
 78 |     | <span class='neutral'></span>
 79 |     | <span class='neutral'>    /**</span>
 80 |     | <span class='neutral'>     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`</span>
 81 |     | <span class='neutral'>     * call, or as part of the Solidity `fallback` or `receive` functions.</span>
 82 |     | <span class='neutral'>     *</span>
 83 |     | <span class='neutral'>     * If overridden should call `super._beforeFallback()`.</span>
 84 |     | <span class='neutral'>     */</span>
 85 |     | <span class='neutral'>    function _beforeFallback() internal virtual {}</span>
 86 |     | <span class='neutral'>}</span>
 87 | *r  | <span class='executed'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/security/Pausable.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;../utils/Context.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/**</span>
   9 |     | <span class='neutral'> * @dev Contract module which allows children to implement an emergency stop</span>
  10 |     | <span class='unexecuted'> * mechanism that can be triggered by an authorized account.</span>
  11 |     | <span class='neutral'> *</span>
  12 |     | <span class='unexecuted'> * This module is used through inheritance. It will make available the</span>
  13 |     | <span class='neutral'> * modifiers `whenNotPaused` and `whenPaused`, which can be applied to</span>
  14 |     | <span class='unexecuted'> * the functions of your contract. Note that they will not be pausable by</span>
  15 |     | <span class='unexecuted'> * simply including this module, only once the modifiers are put in place.</span>
  16 |     | <span class='neutral'> */</span>
  17 |     | <span class='neutral'>abstract contract Pausable is Context {</span>
  18 |     | <span class='neutral'>    /**</span>
  19 |     | <span class='neutral'>     * @dev Emitted when the pause is triggered by `account`.</span>
  20 |     | <span class='neutral'>     */</span>
  21 |     | <span class='neutral'>    event Paused(address account);</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    /**</span>
  24 |     | <span class='neutral'>     * @dev Emitted when the pause is lifted by `account`.</span>
  25 |     | <span class='neutral'>     */</span>
  26 |     | <span class='unexecuted'>    event Unpaused(address account);</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    bool private _paused;</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /**</span>
  31 |     | <span class='neutral'>     * @dev Initializes the contract in unpaused state.</span>
  32 |     | <span class='neutral'>     */</span>
  33 |     | <span class='neutral'>    constructor() {</span>
  34 |     | <span class='unexecuted'>        _paused = false;</span>
  35 |     | <span class='neutral'>    }</span>
  36 |     | <span class='unexecuted'></span>
  37 |     | <span class='neutral'>    /**</span>
  38 |     | <span class='unexecuted'>     * @dev Modifier to make a function callable only when the contract is not paused.</span>
  39 |     | <span class='neutral'>     *</span>
  40 |     | <span class='neutral'>     * Requirements:</span>
  41 |     | <span class='neutral'>     *</span>
  42 |     | <span class='neutral'>     * - The contract must not be paused.</span>
  43 |     | <span class='neutral'>     */</span>
  44 |     | <span class='unexecuted'>    modifier whenNotPaused() {</span>
  45 |     | <span class='neutral'>        _requireNotPaused();</span>
  46 |     | <span class='unexecuted'>        _;</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    /**</span>
  50 |     | <span class='unexecuted'>     * @dev Modifier to make a function callable only when the contract is paused.</span>
  51 |     | <span class='neutral'>     *</span>
  52 |     | <span class='neutral'>     * Requirements:</span>
  53 |     | <span class='neutral'>     *</span>
  54 |     | <span class='neutral'>     * - The contract must be paused.</span>
  55 |     | <span class='neutral'>     */</span>
  56 |     | <span class='neutral'>    modifier whenPaused() {</span>
  57 |     | <span class='unexecuted'>        _requirePaused();</span>
  58 |     | <span class='neutral'>        _;</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    /**</span>
  62 |     | <span class='neutral'>     * @dev Returns true if the contract is paused, and false otherwise.</span>
  63 |     | <span class='neutral'>     */</span>
  64 |     | <span class='unexecuted'>    function paused() public view virtual returns (bool) {</span>
  65 |     | <span class='neutral'>        return _paused;</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    /**</span>
  69 |     | <span class='neutral'>     * @dev Throws if the contract is paused.</span>
  70 |     | <span class='neutral'>     */</span>
  71 |     | <span class='neutral'>    function _requireNotPaused() internal view virtual {</span>
  72 |     | <span class='unexecuted'>        require(!paused(), &quot;Pausable: paused&quot;);</span>
  73 |     | <span class='unexecuted'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    /**</span>
  76 |     | <span class='unexecuted'>     * @dev Throws if the contract is not paused.</span>
  77 |     | <span class='neutral'>     */</span>
  78 |     | <span class='unexecuted'>    function _requirePaused() internal view virtual {</span>
  79 |     | <span class='neutral'>        require(paused(), &quot;Pausable: not paused&quot;);</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    /**</span>
  83 |     | <span class='neutral'>     * @dev Triggers stopped state.</span>
  84 |     | <span class='neutral'>     *</span>
  85 |     | <span class='neutral'>     * Requirements:</span>
  86 |     | <span class='neutral'>     *</span>
  87 |     | <span class='neutral'>     * - The contract must not be paused.</span>
  88 |     | <span class='neutral'>     */</span>
  89 |     | <span class='neutral'>    function _pause() internal virtual whenNotPaused {</span>
  90 |     | <span class='neutral'>        _paused = true;</span>
  91 |     | <span class='unexecuted'>        emit Paused(_msgSender());</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    /**</span>
  95 |     | <span class='neutral'>     * @dev Returns to normal state.</span>
  96 |     | <span class='neutral'>     *</span>
  97 |     | <span class='unexecuted'>     * Requirements:</span>
  98 |     | <span class='unexecuted'>     *</span>
  99 |     | <span class='neutral'>     * - The contract must be paused.</span>
 100 |     | <span class='neutral'>     */</span>
 101 |     | <span class='unexecuted'>    function _unpause() internal virtual whenPaused {</span>
 102 |     | <span class='unexecuted'>        _paused = false;</span>
 103 |     | <span class='neutral'>        emit Unpaused(_msgSender());</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'>}</span>
 106 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/token/ERC1155/ERC1155.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC1155/ERC1155.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;./IERC1155.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./IERC1155Receiver.sol&quot;;</span>
   8 |     | <span class='unexecuted'>import &quot;./extensions/IERC1155MetadataURI.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;../../utils/Address.sol&quot;;</span>
  10 |     | <span class='unexecuted'>import &quot;../../utils/Context.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;../../utils/introspection/ERC165.sol&quot;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>/**</span>
  14 |     | <span class='unexecuted'> * @dev Implementation of the basic standard multi-token.</span>
  15 |     | <span class='neutral'> * See https://eips.ethereum.org/EIPS/eip-1155</span>
  16 |     | <span class='unexecuted'> * Originally based on code by Enjin: https://github.com/enjin/erc-1155</span>
  17 |     | <span class='neutral'> *</span>
  18 |     | <span class='neutral'> * _Available since v3.1._</span>
  19 |     | <span class='neutral'> */</span>
  20 |     | <span class='neutral'>contract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {</span>
  21 |     | <span class='unexecuted'>    using Address for address;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    // Mapping from token ID to account balances</span>
  24 |     | <span class='neutral'>    mapping(uint256 =&gt; mapping(address =&gt; uint256)) private _balances;</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='unexecuted'>    // Mapping from account to operator approvals</span>
  27 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(address =&gt; bool)) private _operatorApprovals;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='unexecuted'>    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json</span>
  30 |     | <span class='neutral'>    string private _uri;</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    /**</span>
  33 |     | <span class='neutral'>     * @dev See {_setURI}.</span>
  34 |     | <span class='neutral'>     */</span>
  35 |     | <span class='neutral'>    constructor(string memory uri_) {</span>
  36 |     | <span class='unexecuted'>        _setURI(uri_);</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='unexecuted'></span>
  39 |     | <span class='neutral'>    /**</span>
  40 |     | <span class='unexecuted'>     * @dev See {IERC165-supportsInterface}.</span>
  41 |     | <span class='unexecuted'>     */</span>
  42 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {</span>
  43 |     | <span class='neutral'>        return</span>
  44 |     | <span class='neutral'>            interfaceId == type(IERC1155).interfaceId ||</span>
  45 |     | <span class='unexecuted'>            interfaceId == type(IERC1155MetadataURI).interfaceId ||</span>
  46 |     | <span class='neutral'>            super.supportsInterface(interfaceId);</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    /**</span>
  50 |     | <span class='unexecuted'>     * @dev See {IERC1155MetadataURI-uri}.</span>
  51 |     | <span class='unexecuted'>     *</span>
  52 |     | <span class='neutral'>     * This implementation returns the same URI for *all* token types. It relies</span>
  53 |     | <span class='neutral'>     * on the token type ID substitution mechanism</span>
  54 |     | <span class='unexecuted'>     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].</span>
  55 |     | <span class='neutral'>     *</span>
  56 |     | <span class='neutral'>     * Clients calling this function must replace the `\{id\}` substring with the</span>
  57 |     | <span class='neutral'>     * actual token type ID.</span>
  58 |     | <span class='neutral'>     */</span>
  59 |     | <span class='neutral'>    function uri(uint256) public view virtual override returns (string memory) {</span>
  60 |     | <span class='neutral'>        return _uri;</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    /**</span>
  64 |     | <span class='neutral'>     * @dev See {IERC1155-balanceOf}.</span>
  65 |     | <span class='neutral'>     *</span>
  66 |     | <span class='neutral'>     * Requirements:</span>
  67 |     | <span class='neutral'>     *</span>
  68 |     | <span class='neutral'>     * - `account` cannot be the zero address.</span>
  69 |     | <span class='neutral'>     */</span>
  70 |     | <span class='neutral'>    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {</span>
  71 |     | <span class='neutral'>        require(account != address(0), &quot;ERC1155: address zero is not a valid owner&quot;);</span>
  72 |     | <span class='neutral'>        return _balances[id][account];</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    /**</span>
  76 |     | <span class='neutral'>     * @dev See {IERC1155-balanceOfBatch}.</span>
  77 |     | <span class='neutral'>     *</span>
  78 |     | <span class='neutral'>     * Requirements:</span>
  79 |     | <span class='neutral'>     *</span>
  80 |     | <span class='neutral'>     * - `accounts` and `ids` must have the same length.</span>
  81 |     | <span class='neutral'>     */</span>
  82 |     | <span class='neutral'>    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)</span>
  83 |     | <span class='neutral'>        public</span>
  84 |     | <span class='neutral'>        view</span>
  85 |     | <span class='neutral'>        virtual</span>
  86 |     | <span class='neutral'>        override</span>
  87 |     | <span class='neutral'>        returns (uint256[] memory)</span>
  88 |     | <span class='neutral'>    {</span>
  89 |     | <span class='neutral'>        require(accounts.length == ids.length, &quot;ERC1155: accounts and ids length mismatch&quot;);</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>        uint256[] memory batchBalances = new uint256[](accounts.length);</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; accounts.length; ++i) {</span>
  94 |     | <span class='neutral'>            batchBalances[i] = balanceOf(accounts[i], ids[i]);</span>
  95 |     | <span class='neutral'>        }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>        return batchBalances;</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    /**</span>
 101 |     | <span class='neutral'>     * @dev See {IERC1155-setApprovalForAll}.</span>
 102 |     | <span class='neutral'>     */</span>
 103 |     | <span class='neutral'>    function setApprovalForAll(address operator, bool approved) public virtual override {</span>
 104 |     | <span class='neutral'>        _setApprovalForAll(_msgSender(), operator, approved);</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    /**</span>
 108 |     | <span class='neutral'>     * @dev See {IERC1155-isApprovedForAll}.</span>
 109 |     | <span class='neutral'>     */</span>
 110 |     | <span class='neutral'>    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {</span>
 111 |     | <span class='neutral'>        return _operatorApprovals[account][operator];</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    /**</span>
 115 |     | <span class='neutral'>     * @dev See {IERC1155-safeTransferFrom}.</span>
 116 |     | <span class='neutral'>     */</span>
 117 |     | <span class='neutral'>    function safeTransferFrom(</span>
 118 |     | <span class='neutral'>        address from,</span>
 119 |     | <span class='neutral'>        address to,</span>
 120 |     | <span class='neutral'>        uint256 id,</span>
 121 |     | <span class='neutral'>        uint256 amount,</span>
 122 |     | <span class='neutral'>        bytes memory data</span>
 123 |     | <span class='neutral'>    ) public virtual override {</span>
 124 |     | <span class='neutral'>        require(</span>
 125 |     | <span class='neutral'>            from == _msgSender() || isApprovedForAll(from, _msgSender()),</span>
 126 |     | <span class='neutral'>            &quot;ERC1155: caller is not token owner or approved&quot;</span>
 127 |     | <span class='neutral'>        );</span>
 128 |     | <span class='neutral'>        _safeTransferFrom(from, to, id, amount, data);</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    /**</span>
 132 |     | <span class='neutral'>     * @dev See {IERC1155-safeBatchTransferFrom}.</span>
 133 |     | <span class='neutral'>     */</span>
 134 |     | <span class='neutral'>    function safeBatchTransferFrom(</span>
 135 |     | <span class='neutral'>        address from,</span>
 136 |     | <span class='neutral'>        address to,</span>
 137 |     | <span class='neutral'>        uint256[] memory ids,</span>
 138 |     | <span class='neutral'>        uint256[] memory amounts,</span>
 139 |     | <span class='neutral'>        bytes memory data</span>
 140 |     | <span class='neutral'>    ) public virtual override {</span>
 141 |     | <span class='neutral'>        require(</span>
 142 |     | <span class='neutral'>            from == _msgSender() || isApprovedForAll(from, _msgSender()),</span>
 143 |     | <span class='neutral'>            &quot;ERC1155: caller is not token owner or approved&quot;</span>
 144 |     | <span class='neutral'>        );</span>
 145 |     | <span class='neutral'>        _safeBatchTransferFrom(from, to, ids, amounts, data);</span>
 146 |     | <span class='neutral'>    }</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>    /**</span>
 149 |     | <span class='neutral'>     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.</span>
 150 |     | <span class='neutral'>     *</span>
 151 |     | <span class='neutral'>     * Emits a {TransferSingle} event.</span>
 152 |     | <span class='neutral'>     *</span>
 153 |     | <span class='neutral'>     * Requirements:</span>
 154 |     | <span class='neutral'>     *</span>
 155 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 156 |     | <span class='neutral'>     * - `from` must have a balance of tokens of type `id` of at least `amount`.</span>
 157 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the</span>
 158 |     | <span class='neutral'>     * acceptance magic value.</span>
 159 |     | <span class='neutral'>     */</span>
 160 |     | <span class='neutral'>    function _safeTransferFrom(</span>
 161 |     | <span class='neutral'>        address from,</span>
 162 |     | <span class='neutral'>        address to,</span>
 163 |     | <span class='neutral'>        uint256 id,</span>
 164 |     | <span class='neutral'>        uint256 amount,</span>
 165 |     | <span class='neutral'>        bytes memory data</span>
 166 |     | <span class='neutral'>    ) internal virtual {</span>
 167 |     | <span class='neutral'>        require(to != address(0), &quot;ERC1155: transfer to the zero address&quot;);</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='neutral'>        address operator = _msgSender();</span>
 170 |     | <span class='neutral'>        uint256[] memory ids = _asSingletonArray(id);</span>
 171 |     | <span class='neutral'>        uint256[] memory amounts = _asSingletonArray(amount);</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'>        _beforeTokenTransfer(operator, from, to, ids, amounts, data);</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>        uint256 fromBalance = _balances[id][from];</span>
 176 |     | <span class='neutral'>        require(fromBalance &gt;= amount, &quot;ERC1155: insufficient balance for transfer&quot;);</span>
 177 |     | <span class='neutral'>        unchecked {</span>
 178 |     | <span class='neutral'>            _balances[id][from] = fromBalance - amount;</span>
 179 |     | <span class='neutral'>        }</span>
 180 |     | <span class='neutral'>        _balances[id][to] += amount;</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>        emit TransferSingle(operator, from, to, id, amount);</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>        _afterTokenTransfer(operator, from, to, ids, amounts, data);</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);</span>
 187 |     | <span class='neutral'>    }</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>    /**</span>
 190 |     | <span class='neutral'>     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.</span>
 191 |     | <span class='neutral'>     *</span>
 192 |     | <span class='neutral'>     * Emits a {TransferBatch} event.</span>
 193 |     | <span class='neutral'>     *</span>
 194 |     | <span class='neutral'>     * Requirements:</span>
 195 |     | <span class='neutral'>     *</span>
 196 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the</span>
 197 |     | <span class='neutral'>     * acceptance magic value.</span>
 198 |     | <span class='neutral'>     */</span>
 199 |     | <span class='neutral'>    function _safeBatchTransferFrom(</span>
 200 |     | <span class='neutral'>        address from,</span>
 201 |     | <span class='neutral'>        address to,</span>
 202 |     | <span class='neutral'>        uint256[] memory ids,</span>
 203 |     | <span class='neutral'>        uint256[] memory amounts,</span>
 204 |     | <span class='neutral'>        bytes memory data</span>
 205 |     | <span class='neutral'>    ) internal virtual {</span>
 206 |     | <span class='neutral'>        require(ids.length == amounts.length, &quot;ERC1155: ids and amounts length mismatch&quot;);</span>
 207 |     | <span class='neutral'>        require(to != address(0), &quot;ERC1155: transfer to the zero address&quot;);</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='neutral'>        address operator = _msgSender();</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>        _beforeTokenTransfer(operator, from, to, ids, amounts, data);</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; ids.length; ++i) {</span>
 214 |     | <span class='neutral'>            uint256 id = ids[i];</span>
 215 |     | <span class='neutral'>            uint256 amount = amounts[i];</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='neutral'>            uint256 fromBalance = _balances[id][from];</span>
 218 |     | <span class='neutral'>            require(fromBalance &gt;= amount, &quot;ERC1155: insufficient balance for transfer&quot;);</span>
 219 |     | <span class='neutral'>            unchecked {</span>
 220 |     | <span class='neutral'>                _balances[id][from] = fromBalance - amount;</span>
 221 |     | <span class='neutral'>            }</span>
 222 |     | <span class='neutral'>            _balances[id][to] += amount;</span>
 223 |     | <span class='neutral'>        }</span>
 224 |     | <span class='neutral'></span>
 225 |     | <span class='neutral'>        emit TransferBatch(operator, from, to, ids, amounts);</span>
 226 |     | <span class='neutral'></span>
 227 |     | <span class='neutral'>        _afterTokenTransfer(operator, from, to, ids, amounts, data);</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='neutral'>        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);</span>
 230 |     | <span class='neutral'>    }</span>
 231 |     | <span class='neutral'></span>
 232 |     | <span class='neutral'>    /**</span>
 233 |     | <span class='neutral'>     * @dev Sets a new URI for all token types, by relying on the token type ID</span>
 234 |     | <span class='neutral'>     * substitution mechanism</span>
 235 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].</span>
 236 |     | <span class='neutral'>     *</span>
 237 |     | <span class='neutral'>     * By this mechanism, any occurrence of the `\{id\}` substring in either the</span>
 238 |     | <span class='neutral'>     * URI or any of the amounts in the JSON file at said URI will be replaced by</span>
 239 |     | <span class='neutral'>     * clients with the token type ID.</span>
 240 |     | <span class='neutral'>     *</span>
 241 |     | <span class='neutral'>     * For example, the `https://token-cdn-domain/\{id\}.json` URI would be</span>
 242 |     | <span class='neutral'>     * interpreted by clients as</span>
 243 |     | <span class='neutral'>     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`</span>
 244 |     | <span class='neutral'>     * for token type ID 0x4cce0.</span>
 245 |     | <span class='neutral'>     *</span>
 246 |     | <span class='neutral'>     * See {uri}.</span>
 247 |     | <span class='neutral'>     *</span>
 248 |     | <span class='neutral'>     * Because these URIs cannot be meaningfully represented by the {URI} event,</span>
 249 |     | <span class='neutral'>     * this function emits no events.</span>
 250 |     | <span class='neutral'>     */</span>
 251 |     | <span class='neutral'>    function _setURI(string memory newuri) internal virtual {</span>
 252 |     | <span class='neutral'>        _uri = newuri;</span>
 253 |     | <span class='neutral'>    }</span>
 254 |     | <span class='neutral'></span>
 255 |     | <span class='neutral'>    /**</span>
 256 |     | <span class='neutral'>     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.</span>
 257 |     | <span class='neutral'>     *</span>
 258 |     | <span class='neutral'>     * Emits a {TransferSingle} event.</span>
 259 |     | <span class='neutral'>     *</span>
 260 |     | <span class='neutral'>     * Requirements:</span>
 261 |     | <span class='neutral'>     *</span>
 262 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 263 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the</span>
 264 |     | <span class='neutral'>     * acceptance magic value.</span>
 265 |     | <span class='neutral'>     */</span>
 266 |     | <span class='neutral'>    function _mint(</span>
 267 |     | <span class='neutral'>        address to,</span>
 268 |     | <span class='neutral'>        uint256 id,</span>
 269 |     | <span class='neutral'>        uint256 amount,</span>
 270 |     | <span class='neutral'>        bytes memory data</span>
 271 |     | <span class='neutral'>    ) internal virtual {</span>
 272 |     | <span class='neutral'>        require(to != address(0), &quot;ERC1155: mint to the zero address&quot;);</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='neutral'>        address operator = _msgSender();</span>
 275 |     | <span class='neutral'>        uint256[] memory ids = _asSingletonArray(id);</span>
 276 |     | <span class='neutral'>        uint256[] memory amounts = _asSingletonArray(amount);</span>
 277 |     | <span class='neutral'></span>
 278 |     | <span class='neutral'>        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>        _balances[id][to] += amount;</span>
 281 |     | <span class='neutral'>        emit TransferSingle(operator, address(0), to, id, amount);</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='neutral'>        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='neutral'>        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);</span>
 286 |     | <span class='neutral'>    }</span>
 287 |     | <span class='neutral'></span>
 288 |     | <span class='neutral'>    /**</span>
 289 |     | <span class='neutral'>     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.</span>
 290 |     | <span class='neutral'>     *</span>
 291 |     | <span class='neutral'>     * Emits a {TransferBatch} event.</span>
 292 |     | <span class='neutral'>     *</span>
 293 |     | <span class='neutral'>     * Requirements:</span>
 294 |     | <span class='neutral'>     *</span>
 295 |     | <span class='neutral'>     * - `ids` and `amounts` must have the same length.</span>
 296 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the</span>
 297 |     | <span class='neutral'>     * acceptance magic value.</span>
 298 |     | <span class='neutral'>     */</span>
 299 |     | <span class='neutral'>    function _mintBatch(</span>
 300 |     | <span class='neutral'>        address to,</span>
 301 |     | <span class='neutral'>        uint256[] memory ids,</span>
 302 |     | <span class='neutral'>        uint256[] memory amounts,</span>
 303 |     | <span class='neutral'>        bytes memory data</span>
 304 |     | <span class='neutral'>    ) internal virtual {</span>
 305 |     | <span class='neutral'>        require(to != address(0), &quot;ERC1155: mint to the zero address&quot;);</span>
 306 |     | <span class='neutral'>        require(ids.length == amounts.length, &quot;ERC1155: ids and amounts length mismatch&quot;);</span>
 307 |     | <span class='neutral'></span>
 308 |     | <span class='neutral'>        address operator = _msgSender();</span>
 309 |     | <span class='neutral'></span>
 310 |     | <span class='neutral'>        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);</span>
 311 |     | <span class='neutral'></span>
 312 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; ids.length; i++) {</span>
 313 |     | <span class='neutral'>            _balances[ids[i]][to] += amounts[i];</span>
 314 |     | <span class='neutral'>        }</span>
 315 |     | <span class='neutral'></span>
 316 |     | <span class='neutral'>        emit TransferBatch(operator, address(0), to, ids, amounts);</span>
 317 |     | <span class='neutral'></span>
 318 |     | <span class='neutral'>        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);</span>
 319 |     | <span class='neutral'></span>
 320 |     | <span class='neutral'>        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);</span>
 321 |     | <span class='neutral'>    }</span>
 322 |     | <span class='neutral'></span>
 323 |     | <span class='neutral'>    /**</span>
 324 |     | <span class='neutral'>     * @dev Destroys `amount` tokens of token type `id` from `from`</span>
 325 |     | <span class='neutral'>     *</span>
 326 |     | <span class='neutral'>     * Emits a {TransferSingle} event.</span>
 327 |     | <span class='neutral'>     *</span>
 328 |     | <span class='neutral'>     * Requirements:</span>
 329 |     | <span class='neutral'>     *</span>
 330 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
 331 |     | <span class='neutral'>     * - `from` must have at least `amount` tokens of token type `id`.</span>
 332 |     | <span class='neutral'>     */</span>
 333 |     | <span class='neutral'>    function _burn(</span>
 334 |     | <span class='neutral'>        address from,</span>
 335 |     | <span class='neutral'>        uint256 id,</span>
 336 |     | <span class='neutral'>        uint256 amount</span>
 337 |     | <span class='neutral'>    ) internal virtual {</span>
 338 |     | <span class='neutral'>        require(from != address(0), &quot;ERC1155: burn from the zero address&quot;);</span>
 339 |     | <span class='neutral'></span>
 340 |     | <span class='neutral'>        address operator = _msgSender();</span>
 341 |     | <span class='neutral'>        uint256[] memory ids = _asSingletonArray(id);</span>
 342 |     | <span class='neutral'>        uint256[] memory amounts = _asSingletonArray(amount);</span>
 343 |     | <span class='neutral'></span>
 344 |     | <span class='neutral'>        _beforeTokenTransfer(operator, from, address(0), ids, amounts, &quot;&quot;);</span>
 345 |     | <span class='neutral'></span>
 346 |     | <span class='neutral'>        uint256 fromBalance = _balances[id][from];</span>
 347 |     | <span class='neutral'>        require(fromBalance &gt;= amount, &quot;ERC1155: burn amount exceeds balance&quot;);</span>
 348 |     | <span class='neutral'>        unchecked {</span>
 349 |     | <span class='neutral'>            _balances[id][from] = fromBalance - amount;</span>
 350 |     | <span class='neutral'>        }</span>
 351 |     | <span class='neutral'></span>
 352 |     | <span class='neutral'>        emit TransferSingle(operator, from, address(0), id, amount);</span>
 353 |     | <span class='neutral'></span>
 354 |     | <span class='neutral'>        _afterTokenTransfer(operator, from, address(0), ids, amounts, &quot;&quot;);</span>
 355 |     | <span class='neutral'>    }</span>
 356 |     | <span class='neutral'></span>
 357 |     | <span class='neutral'>    /**</span>
 358 |     | <span class='neutral'>     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.</span>
 359 |     | <span class='neutral'>     *</span>
 360 |     | <span class='neutral'>     * Emits a {TransferBatch} event.</span>
 361 |     | <span class='neutral'>     *</span>
 362 |     | <span class='neutral'>     * Requirements:</span>
 363 |     | <span class='neutral'>     *</span>
 364 |     | <span class='neutral'>     * - `ids` and `amounts` must have the same length.</span>
 365 |     | <span class='neutral'>     */</span>
 366 |     | <span class='neutral'>    function _burnBatch(</span>
 367 |     | <span class='neutral'>        address from,</span>
 368 |     | <span class='neutral'>        uint256[] memory ids,</span>
 369 |     | <span class='neutral'>        uint256[] memory amounts</span>
 370 |     | <span class='neutral'>    ) internal virtual {</span>
 371 |     | <span class='neutral'>        require(from != address(0), &quot;ERC1155: burn from the zero address&quot;);</span>
 372 |     | <span class='neutral'>        require(ids.length == amounts.length, &quot;ERC1155: ids and amounts length mismatch&quot;);</span>
 373 |     | <span class='neutral'></span>
 374 |     | <span class='neutral'>        address operator = _msgSender();</span>
 375 |     | <span class='neutral'></span>
 376 |     | <span class='neutral'>        _beforeTokenTransfer(operator, from, address(0), ids, amounts, &quot;&quot;);</span>
 377 |     | <span class='neutral'></span>
 378 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; ids.length; i++) {</span>
 379 |     | <span class='neutral'>            uint256 id = ids[i];</span>
 380 |     | <span class='neutral'>            uint256 amount = amounts[i];</span>
 381 |     | <span class='neutral'></span>
 382 |     | <span class='neutral'>            uint256 fromBalance = _balances[id][from];</span>
 383 |     | <span class='neutral'>            require(fromBalance &gt;= amount, &quot;ERC1155: burn amount exceeds balance&quot;);</span>
 384 |     | <span class='neutral'>            unchecked {</span>
 385 |     | <span class='neutral'>                _balances[id][from] = fromBalance - amount;</span>
 386 |     | <span class='neutral'>            }</span>
 387 |     | <span class='neutral'>        }</span>
 388 |     | <span class='neutral'></span>
 389 |     | <span class='neutral'>        emit TransferBatch(operator, from, address(0), ids, amounts);</span>
 390 |     | <span class='neutral'></span>
 391 |     | <span class='neutral'>        _afterTokenTransfer(operator, from, address(0), ids, amounts, &quot;&quot;);</span>
 392 |     | <span class='neutral'>    }</span>
 393 |     | <span class='neutral'></span>
 394 |     | <span class='neutral'>    /**</span>
 395 |     | <span class='neutral'>     * @dev Approve `operator` to operate on all of `owner` tokens</span>
 396 |     | <span class='neutral'>     *</span>
 397 |     | <span class='neutral'>     * Emits an {ApprovalForAll} event.</span>
 398 |     | <span class='neutral'>     */</span>
 399 |     | <span class='neutral'>    function _setApprovalForAll(</span>
 400 |     | <span class='neutral'>        address owner,</span>
 401 |     | <span class='neutral'>        address operator,</span>
 402 |     | <span class='neutral'>        bool approved</span>
 403 |     | <span class='neutral'>    ) internal virtual {</span>
 404 |     | <span class='neutral'>        require(owner != operator, &quot;ERC1155: setting approval status for self&quot;);</span>
 405 |     | <span class='neutral'>        _operatorApprovals[owner][operator] = approved;</span>
 406 |     | <span class='neutral'>        emit ApprovalForAll(owner, operator, approved);</span>
 407 |     | <span class='neutral'>    }</span>
 408 |     | <span class='neutral'></span>
 409 |     | <span class='neutral'>    /**</span>
 410 |     | <span class='neutral'>     * @dev Hook that is called before any token transfer. This includes minting</span>
 411 |     | <span class='neutral'>     * and burning, as well as batched variants.</span>
 412 |     | <span class='neutral'>     *</span>
 413 |     | <span class='neutral'>     * The same hook is called on both single and batched variants. For single</span>
 414 |     | <span class='neutral'>     * transfers, the length of the `ids` and `amounts` arrays will be 1.</span>
 415 |     | <span class='neutral'>     *</span>
 416 |     | <span class='neutral'>     * Calling conditions (for each `id` and `amount` pair):</span>
 417 |     | <span class='neutral'>     *</span>
 418 |     | <span class='neutral'>     * - When `from` and `to` are both non-zero, `amount` of ``from``&#39;s tokens</span>
 419 |     | <span class='neutral'>     * of token type `id` will be  transferred to `to`.</span>
 420 |     | <span class='neutral'>     * - When `from` is zero, `amount` tokens of token type `id` will be minted</span>
 421 |     | <span class='neutral'>     * for `to`.</span>
 422 |     | <span class='neutral'>     * - when `to` is zero, `amount` of ``from``&#39;s tokens of token type `id`</span>
 423 |     | <span class='neutral'>     * will be burned.</span>
 424 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 425 |     | <span class='neutral'>     * - `ids` and `amounts` have the same, non-zero length.</span>
 426 |     | <span class='neutral'>     *</span>
 427 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 428 |     | <span class='neutral'>     */</span>
 429 |     | <span class='neutral'>    function _beforeTokenTransfer(</span>
 430 |     | <span class='neutral'>        address operator,</span>
 431 |     | <span class='neutral'>        address from,</span>
 432 |     | <span class='neutral'>        address to,</span>
 433 |     | <span class='neutral'>        uint256[] memory ids,</span>
 434 |     | <span class='neutral'>        uint256[] memory amounts,</span>
 435 |     | <span class='neutral'>        bytes memory data</span>
 436 |     | <span class='neutral'>    ) internal virtual {}</span>
 437 |     | <span class='neutral'></span>
 438 |     | <span class='neutral'>    /**</span>
 439 |     | <span class='neutral'>     * @dev Hook that is called after any token transfer. This includes minting</span>
 440 |     | <span class='neutral'>     * and burning, as well as batched variants.</span>
 441 |     | <span class='neutral'>     *</span>
 442 |     | <span class='neutral'>     * The same hook is called on both single and batched variants. For single</span>
 443 |     | <span class='neutral'>     * transfers, the length of the `id` and `amount` arrays will be 1.</span>
 444 |     | <span class='neutral'>     *</span>
 445 |     | <span class='neutral'>     * Calling conditions (for each `id` and `amount` pair):</span>
 446 |     | <span class='neutral'>     *</span>
 447 |     | <span class='neutral'>     * - When `from` and `to` are both non-zero, `amount` of ``from``&#39;s tokens</span>
 448 |     | <span class='neutral'>     * of token type `id` will be  transferred to `to`.</span>
 449 |     | <span class='neutral'>     * - When `from` is zero, `amount` tokens of token type `id` will be minted</span>
 450 |     | <span class='neutral'>     * for `to`.</span>
 451 |     | <span class='neutral'>     * - when `to` is zero, `amount` of ``from``&#39;s tokens of token type `id`</span>
 452 |     | <span class='neutral'>     * will be burned.</span>
 453 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 454 |     | <span class='neutral'>     * - `ids` and `amounts` have the same, non-zero length.</span>
 455 |     | <span class='neutral'>     *</span>
 456 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 457 |     | <span class='neutral'>     */</span>
 458 |     | <span class='neutral'>    function _afterTokenTransfer(</span>
 459 |     | <span class='neutral'>        address operator,</span>
 460 |     | <span class='neutral'>        address from,</span>
 461 |     | <span class='neutral'>        address to,</span>
 462 |     | <span class='neutral'>        uint256[] memory ids,</span>
 463 |     | <span class='neutral'>        uint256[] memory amounts,</span>
 464 |     | <span class='neutral'>        bytes memory data</span>
 465 |     | <span class='neutral'>    ) internal virtual {}</span>
 466 |     | <span class='neutral'></span>
 467 |     | <span class='neutral'>    function _doSafeTransferAcceptanceCheck(</span>
 468 |     | <span class='neutral'>        address operator,</span>
 469 |     | <span class='neutral'>        address from,</span>
 470 |     | <span class='neutral'>        address to,</span>
 471 |     | <span class='neutral'>        uint256 id,</span>
 472 |     | <span class='neutral'>        uint256 amount,</span>
 473 |     | <span class='neutral'>        bytes memory data</span>
 474 |     | <span class='neutral'>    ) private {</span>
 475 |     | <span class='neutral'>        if (to.isContract()) {</span>
 476 |     | <span class='neutral'>            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {</span>
 477 |     | <span class='neutral'>                if (response != IERC1155Receiver.onERC1155Received.selector) {</span>
 478 |     | <span class='neutral'>                    revert(&quot;ERC1155: ERC1155Receiver rejected tokens&quot;);</span>
 479 |     | <span class='neutral'>                }</span>
 480 |     | <span class='neutral'>            } catch Error(string memory reason) {</span>
 481 |     | <span class='neutral'>                revert(reason);</span>
 482 |     | <span class='neutral'>            } catch {</span>
 483 |     | <span class='neutral'>                revert(&quot;ERC1155: transfer to non-ERC1155Receiver implementer&quot;);</span>
 484 |     | <span class='neutral'>            }</span>
 485 |     | <span class='neutral'>        }</span>
 486 |     | <span class='neutral'>    }</span>
 487 |     | <span class='neutral'></span>
 488 |     | <span class='neutral'>    function _doSafeBatchTransferAcceptanceCheck(</span>
 489 |     | <span class='neutral'>        address operator,</span>
 490 |     | <span class='neutral'>        address from,</span>
 491 |     | <span class='neutral'>        address to,</span>
 492 |     | <span class='neutral'>        uint256[] memory ids,</span>
 493 |     | <span class='neutral'>        uint256[] memory amounts,</span>
 494 |     | <span class='neutral'>        bytes memory data</span>
 495 |     | <span class='neutral'>    ) private {</span>
 496 |     | <span class='neutral'>        if (to.isContract()) {</span>
 497 |     | <span class='neutral'>            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (</span>
 498 |     | <span class='neutral'>                bytes4 response</span>
 499 |     | <span class='neutral'>            ) {</span>
 500 |     | <span class='neutral'>                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {</span>
 501 |     | <span class='neutral'>                    revert(&quot;ERC1155: ERC1155Receiver rejected tokens&quot;);</span>
 502 |     | <span class='neutral'>                }</span>
 503 |     | <span class='neutral'>            } catch Error(string memory reason) {</span>
 504 |     | <span class='neutral'>                revert(reason);</span>
 505 |     | <span class='neutral'>            } catch {</span>
 506 |     | <span class='neutral'>                revert(&quot;ERC1155: transfer to non-ERC1155Receiver implementer&quot;);</span>
 507 |     | <span class='neutral'>            }</span>
 508 |     | <span class='neutral'>        }</span>
 509 |     | <span class='neutral'>    }</span>
 510 |     | <span class='neutral'></span>
 511 |     | <span class='neutral'>    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {</span>
 512 |     | <span class='neutral'>        uint256[] memory array = new uint256[](1);</span>
 513 |     | <span class='neutral'>        array[0] = element;</span>
 514 |     | <span class='neutral'></span>
 515 |     | <span class='neutral'>        return array;</span>
 516 |     | <span class='neutral'>    }</span>
 517 |     | <span class='neutral'>}</span>
 518 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/token/ERC1155/IERC1155.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;../../utils/introspection/IERC165.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/**</span>
   9 |     | <span class='neutral'> * @dev Required interface of an ERC1155 compliant contract, as defined in the</span>
  10 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-1155[EIP].</span>
  11 |     | <span class='neutral'> *</span>
  12 |     | <span class='neutral'> * _Available since v3.1._</span>
  13 |     | <span class='neutral'> */</span>
  14 |     | <span class='neutral'>interface IERC1155 is IERC165 {</span>
  15 |     | <span class='neutral'>    /**</span>
  16 |     | <span class='neutral'>     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.</span>
  17 |     | <span class='neutral'>     */</span>
  18 |     | <span class='neutral'>    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    /**</span>
  21 |     | <span class='neutral'>     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all</span>
  22 |     | <span class='unexecuted'>     * transfers.</span>
  23 |     | <span class='neutral'>     */</span>
  24 |     | <span class='neutral'>    event TransferBatch(</span>
  25 |     | <span class='neutral'>        address indexed operator,</span>
  26 |     | <span class='neutral'>        address indexed from,</span>
  27 |     | <span class='neutral'>        address indexed to,</span>
  28 |     | <span class='unexecuted'>        uint256[] ids,</span>
  29 |     | <span class='unexecuted'>        uint256[] values</span>
  30 |     | <span class='neutral'>    );</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='unexecuted'>    /**</span>
  33 |     | <span class='unexecuted'>     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to</span>
  34 |     | <span class='neutral'>     * `approved`.</span>
  35 |     | <span class='neutral'>     */</span>
  36 |     | <span class='neutral'>    event ApprovalForAll(address indexed account, address indexed operator, bool approved);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    /**</span>
  39 |     | <span class='neutral'>     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.</span>
  40 |     | <span class='neutral'>     *</span>
  41 |     | <span class='unexecuted'>     * If an {URI} event was emitted for `id`, the standard</span>
  42 |     | <span class='unexecuted'>     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value</span>
  43 |     | <span class='neutral'>     * returned by {IERC1155MetadataURI-uri}.</span>
  44 |     | <span class='neutral'>     */</span>
  45 |     | <span class='unexecuted'>    event URI(string value, uint256 indexed id);</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    /**</span>
  48 |     | <span class='unexecuted'>     * @dev Returns the amount of tokens of token type `id` owned by `account`.</span>
  49 |     | <span class='neutral'>     *</span>
  50 |     | <span class='neutral'>     * Requirements:</span>
  51 |     | <span class='neutral'>     *</span>
  52 |     | <span class='unexecuted'>     * - `account` cannot be the zero address.</span>
  53 |     | <span class='neutral'>     */</span>
  54 |     | <span class='neutral'>    function balanceOf(address account, uint256 id) external view returns (uint256);</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /**</span>
  57 |     | <span class='unexecuted'>     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.</span>
  58 |     | <span class='neutral'>     *</span>
  59 |     | <span class='neutral'>     * Requirements:</span>
  60 |     | <span class='neutral'>     *</span>
  61 |     | <span class='unexecuted'>     * - `accounts` and `ids` must have the same length.</span>
  62 |     | <span class='neutral'>     */</span>
  63 |     | <span class='unexecuted'>    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)</span>
  64 |     | <span class='unexecuted'>        external</span>
  65 |     | <span class='neutral'>        view</span>
  66 |     | <span class='unexecuted'>        returns (uint256[] memory);</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='unexecuted'>    /**</span>
  69 |     | <span class='unexecuted'>     * @dev Grants or revokes permission to `operator` to transfer the caller&#39;s tokens, according to `approved`,</span>
  70 |     | <span class='neutral'>     *</span>
  71 |     | <span class='neutral'>     * Emits an {ApprovalForAll} event.</span>
  72 |     | <span class='neutral'>     *</span>
  73 |     | <span class='neutral'>     * Requirements:</span>
  74 |     | <span class='neutral'>     *</span>
  75 |     | <span class='neutral'>     * - `operator` cannot be the caller.</span>
  76 |     | <span class='neutral'>     */</span>
  77 |     | <span class='unexecuted'>    function setApprovalForAll(address operator, bool approved) external;</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    /**</span>
  80 |     | <span class='neutral'>     * @dev Returns true if `operator` is approved to transfer ``account``&#39;s tokens.</span>
  81 |     | <span class='neutral'>     *</span>
  82 |     | <span class='neutral'>     * See {setApprovalForAll}.</span>
  83 |     | <span class='neutral'>     */</span>
  84 |     | <span class='neutral'>    function isApprovedForAll(address account, address operator) external view returns (bool);</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    /**</span>
  87 |     | <span class='neutral'>     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.</span>
  88 |     | <span class='neutral'>     *</span>
  89 |     | <span class='unexecuted'>     * Emits a {TransferSingle} event.</span>
  90 |     | <span class='neutral'>     *</span>
  91 |     | <span class='neutral'>     * Requirements:</span>
  92 |     | <span class='neutral'>     *</span>
  93 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
  94 |     | <span class='unexecuted'>     * - If the caller is not `from`, it must have been approved to spend ``from``&#39;s tokens via {setApprovalForAll}.</span>
  95 |     | <span class='unexecuted'>     * - `from` must have a balance of tokens of type `id` of at least `amount`.</span>
  96 |     | <span class='unexecuted'>     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the</span>
  97 |     | <span class='neutral'>     * acceptance magic value.</span>
  98 |     | <span class='neutral'>     */</span>
  99 |     | <span class='unexecuted'>    function safeTransferFrom(</span>
 100 |     | <span class='neutral'>        address from,</span>
 101 |     | <span class='neutral'>        address to,</span>
 102 |     | <span class='neutral'>        uint256 id,</span>
 103 |     | <span class='neutral'>        uint256 amount,</span>
 104 |     | <span class='neutral'>        bytes calldata data</span>
 105 |     | <span class='neutral'>    ) external;</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='unexecuted'>    /**</span>
 108 |     | <span class='unexecuted'>     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.</span>
 109 |     | <span class='neutral'>     *</span>
 110 |     | <span class='neutral'>     * Emits a {TransferBatch} event.</span>
 111 |     | <span class='neutral'>     *</span>
 112 |     | <span class='unexecuted'>     * Requirements:</span>
 113 |     | <span class='neutral'>     *</span>
 114 |     | <span class='neutral'>     * - `ids` and `amounts` must have the same length.</span>
 115 |     | <span class='unexecuted'>     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the</span>
 116 |     | <span class='neutral'>     * acceptance magic value.</span>
 117 |     | <span class='neutral'>     */</span>
 118 |     | <span class='neutral'>    function safeBatchTransferFrom(</span>
 119 |     | <span class='unexecuted'>        address from,</span>
 120 |     | <span class='neutral'>        address to,</span>
 121 |     | <span class='unexecuted'>        uint256[] calldata ids,</span>
 122 |     | <span class='neutral'>        uint256[] calldata amounts,</span>
 123 |     | <span class='neutral'>        bytes calldata data</span>
 124 |     | <span class='neutral'>    ) external;</span>
 125 |     | <span class='neutral'>}</span>
 126 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../../utils/introspection/IERC165.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev _Available since v3.1._</span>
 10 |     | <span class='neutral'> */</span>
 11 |     | <span class='neutral'>interface IERC1155Receiver is IERC165 {</span>
 12 |     | <span class='neutral'>    /**</span>
 13 |     | <span class='neutral'>     * @dev Handles the receipt of a single ERC1155 token type. This function is</span>
 14 |     | <span class='neutral'>     * called at the end of a `safeTransferFrom` after the balance has been updated.</span>
 15 |     | <span class='neutral'>     *</span>
 16 |     | <span class='neutral'>     * NOTE: To accept the transfer, this must return</span>
 17 |     | <span class='neutral'>     * `bytes4(keccak256(&quot;onERC1155Received(address,address,uint256,uint256,bytes)&quot;))`</span>
 18 |     | <span class='neutral'>     * (i.e. 0xf23a6e61, or its own function selector).</span>
 19 |     | <span class='neutral'>     *</span>
 20 |     | <span class='unexecuted'>     * @param operator The address which initiated the transfer (i.e. msg.sender)</span>
 21 |     | <span class='unexecuted'>     * @param from The address which previously owned the token</span>
 22 |     | <span class='unexecuted'>     * @param id The ID of the token being transferred</span>
 23 |     | <span class='unexecuted'>     * @param value The amount of tokens being transferred</span>
 24 |     | <span class='unexecuted'>     * @param data Additional data with no specified format</span>
 25 |     | <span class='unexecuted'>     * @return `bytes4(keccak256(&quot;onERC1155Received(address,address,uint256,uint256,bytes)&quot;))` if transfer is allowed</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='unexecuted'>    function onERC1155Received(</span>
 28 |     | <span class='unexecuted'>        address operator,</span>
 29 |     | <span class='neutral'>        address from,</span>
 30 |     | <span class='neutral'>        uint256 id,</span>
 31 |     | <span class='unexecuted'>        uint256 value,</span>
 32 |     | <span class='neutral'>        bytes calldata data</span>
 33 |     | <span class='neutral'>    ) external returns (bytes4);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    /**</span>
 36 |     | <span class='neutral'>     * @dev Handles the receipt of a multiple ERC1155 token types. This function</span>
 37 |     | <span class='neutral'>     * is called at the end of a `safeBatchTransferFrom` after the balances have</span>
 38 |     | <span class='neutral'>     * been updated.</span>
 39 |     | <span class='neutral'>     *</span>
 40 |     | <span class='neutral'>     * NOTE: To accept the transfer(s), this must return</span>
 41 |     | <span class='neutral'>     * `bytes4(keccak256(&quot;onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)&quot;))`</span>
 42 |     | <span class='unexecuted'>     * (i.e. 0xbc197c81, or its own function selector).</span>
 43 |     | <span class='neutral'>     *</span>
 44 |     | <span class='unexecuted'>     * @param operator The address which initiated the batch transfer (i.e. msg.sender)</span>
 45 |     | <span class='unexecuted'>     * @param from The address which previously owned the token</span>
 46 |     | <span class='unexecuted'>     * @param ids An array containing ids of each token being transferred (order and length must match values array)</span>
 47 |     | <span class='unexecuted'>     * @param values An array containing amounts of each token being transferred (order and length must match ids array)</span>
 48 |     | <span class='unexecuted'>     * @param data Additional data with no specified format</span>
 49 |     | <span class='unexecuted'>     * @return `bytes4(keccak256(&quot;onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)&quot;))` if transfer is allowed</span>
 50 |     | <span class='neutral'>     */</span>
 51 |     | <span class='neutral'>    function onERC1155BatchReceived(</span>
 52 |     | <span class='unexecuted'>        address operator,</span>
 53 |     | <span class='neutral'>        address from,</span>
 54 |     | <span class='neutral'>        uint256[] calldata ids,</span>
 55 |     | <span class='neutral'>        uint256[] calldata values,</span>
 56 |     | <span class='unexecuted'>        bytes calldata data</span>
 57 |     | <span class='neutral'>    ) external returns (bytes4);</span>
 58 |     | <span class='neutral'>}</span>
 59 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Burnable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC1155/extensions/ERC1155Burnable.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../ERC1155.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Extension of {ERC1155} that allows token holders to destroy both their</span>
 10 |     | <span class='neutral'> * own tokens and those that they have been approved to use.</span>
 11 |     | <span class='neutral'> *</span>
 12 |     | <span class='neutral'> * _Available since v3.1._</span>
 13 |     | <span class='neutral'> */</span>
 14 |     | <span class='neutral'>abstract contract ERC1155Burnable is ERC1155 {</span>
 15 |     | <span class='neutral'>    function burn(</span>
 16 |     | <span class='neutral'>        address account,</span>
 17 |     | <span class='neutral'>        uint256 id,</span>
 18 |     | <span class='neutral'>        uint256 value</span>
 19 |     | <span class='neutral'>    ) public virtual {</span>
 20 |     | <span class='neutral'>        require(</span>
 21 |     | <span class='neutral'>            account == _msgSender() || isApprovedForAll(account, _msgSender()),</span>
 22 |     | <span class='neutral'>            &quot;ERC1155: caller is not token owner or approved&quot;</span>
 23 |     | <span class='neutral'>        );</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>        _burn(account, id, value);</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>    function burnBatch(</span>
 29 |     | <span class='neutral'>        address account,</span>
 30 |     | <span class='neutral'>        uint256[] memory ids,</span>
 31 |     | <span class='neutral'>        uint256[] memory values</span>
 32 |     | <span class='neutral'>    ) public virtual {</span>
 33 |     | <span class='neutral'>        require(</span>
 34 |     | <span class='neutral'>            account == _msgSender() || isApprovedForAll(account, _msgSender()),</span>
 35 |     | <span class='neutral'>            &quot;ERC1155: caller is not token owner or approved&quot;</span>
 36 |     | <span class='neutral'>        );</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='neutral'>        _burnBatch(account, ids, values);</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'>}</span>
 41 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../IERC1155.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Interface of the optional ERC1155MetadataExtension interface, as defined</span>
 10 |     | <span class='neutral'> * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].</span>
 11 |     | <span class='neutral'> *</span>
 12 |     | <span class='neutral'> * _Available since v3.1._</span>
 13 |     | <span class='neutral'> */</span>
 14 |     | <span class='neutral'>interface IERC1155MetadataURI is IERC1155 {</span>
 15 |     | <span class='neutral'>    /**</span>
 16 |     | <span class='neutral'>     * @dev Returns the URI for token type `id`.</span>
 17 |     | <span class='neutral'>     *</span>
 18 |     | <span class='neutral'>     * If the `\{id\}` substring is present in the URI, it must be replaced by</span>
 19 |     | <span class='neutral'>     * clients with the actual token type ID.</span>
 20 |     | <span class='neutral'>     */</span>
 21 |     | <span class='neutral'>    function uri(uint256 id) external view returns (string memory);</span>
 22 |     | <span class='neutral'>}</span>
 23 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../IERC1155Receiver.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../../../utils/introspection/ERC165.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/**</span>
 10 |     | <span class='neutral'> * @dev _Available since v3.1._</span>
 11 |     | <span class='neutral'> */</span>
 12 |     | <span class='neutral'>abstract contract ERC1155Receiver is ERC165, IERC1155Receiver {</span>
 13 |     | <span class='neutral'>    /**</span>
 14 |     | <span class='neutral'>     * @dev See {IERC165-supportsInterface}.</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {</span>
 17 |     | <span class='neutral'>        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'>}</span>
 20 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;./IERC20.sol&quot;;</span>
   7 |     | <span class='unexecuted'>import &quot;./extensions/IERC20Metadata.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../utils/Context.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @dev Implementation of the {IERC20} interface.</span>
  12 |     | <span class='neutral'> *</span>
  13 |     | <span class='unexecuted'> * This implementation is agnostic to the way tokens are created. This means</span>
  14 |     | <span class='neutral'> * that a supply mechanism has to be added in a derived contract using {_mint}.</span>
  15 |     | <span class='unexecuted'> * For a generic mechanism see {ERC20PresetMinterPauser}.</span>
  16 |     | <span class='neutral'> *</span>
  17 |     | <span class='unexecuted'> * TIP: For a detailed writeup see our guide</span>
  18 |     | <span class='unexecuted'> * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How</span>
  19 |     | <span class='neutral'> * to implement supply mechanisms].</span>
  20 |     | <span class='neutral'> *</span>
  21 |     | <span class='neutral'> * We have followed general OpenZeppelin Contracts guidelines: functions revert</span>
  22 |     | <span class='unexecuted'> * instead returning `false` on failure. This behavior is nonetheless</span>
  23 |     | <span class='neutral'> * conventional and does not conflict with the expectations of ERC20</span>
  24 |     | <span class='neutral'> * applications.</span>
  25 |     | <span class='neutral'> *</span>
  26 |     | <span class='unexecuted'> * Additionally, an {Approval} event is emitted on calls to {transferFrom}.</span>
  27 |     | <span class='unexecuted'> * This allows applications to reconstruct the allowance for all accounts just</span>
  28 |     | <span class='unexecuted'> * by listening to said events. Other implementations of the EIP may not emit</span>
  29 |     | <span class='neutral'> * these events, as it isn&#39;t required by the specification.</span>
  30 |     | <span class='neutral'> *</span>
  31 |     | <span class='unexecuted'> * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}</span>
  32 |     | <span class='neutral'> * functions have been added to mitigate the well-known issues around setting</span>
  33 |     | <span class='neutral'> * allowances. See {IERC20-approve}.</span>
  34 |     | <span class='neutral'> */</span>
  35 |     | <span class='neutral'>contract ERC20 is Context, IERC20, IERC20Metadata {</span>
  36 |     | <span class='neutral'>    mapping(address =&gt; uint256) private _balances;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='unexecuted'>    uint256 private _totalSupply;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    string private _name;</span>
  43 |     | <span class='neutral'>    string private _symbol;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    /**</span>
  46 |     | <span class='neutral'>     * @dev Sets the values for {name} and {symbol}.</span>
  47 |     | <span class='neutral'>     *</span>
  48 |     | <span class='unexecuted'>     * The default value of {decimals} is 18. To select a different value for</span>
  49 |     | <span class='neutral'>     * {decimals} you should overload it.</span>
  50 |     | <span class='unexecuted'>     *</span>
  51 |     | <span class='unexecuted'>     * All two of these values are immutable: they can only be set once during</span>
  52 |     | <span class='unexecuted'>     * construction.</span>
  53 |     | <span class='unexecuted'>     */</span>
  54 |     | <span class='neutral'>    constructor(string memory name_, string memory symbol_) {</span>
  55 |     | <span class='neutral'>        _name = name_;</span>
  56 |     | <span class='neutral'>        _symbol = symbol_;</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /**</span>
  60 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
  61 |     | <span class='unexecuted'>     */</span>
  62 |     | <span class='neutral'>    function name() public view virtual override returns (string memory) {</span>
  63 |     | <span class='neutral'>        return _name;</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    /**</span>
  67 |     | <span class='unexecuted'>     * @dev Returns the symbol of the token, usually a shorter version of the</span>
  68 |     | <span class='neutral'>     * name.</span>
  69 |     | <span class='neutral'>     */</span>
  70 |     | <span class='unexecuted'>    function symbol() public view virtual override returns (string memory) {</span>
  71 |     | <span class='neutral'>        return _symbol;</span>
  72 |     | <span class='unexecuted'>    }</span>
  73 |     | <span class='unexecuted'></span>
  74 |     | <span class='neutral'>    /**</span>
  75 |     | <span class='neutral'>     * @dev Returns the number of decimals used to get its user representation.</span>
  76 |     | <span class='unexecuted'>     * For example, if `decimals` equals `2`, a balance of `505` tokens should</span>
  77 |     | <span class='neutral'>     * be displayed to a user as `5.05` (`505 / 10 ** 2`).</span>
  78 |     | <span class='neutral'>     *</span>
  79 |     | <span class='neutral'>     * Tokens usually opt for a value of 18, imitating the relationship between</span>
  80 |     | <span class='unexecuted'>     * Ether and Wei. This is the value {ERC20} uses, unless this function is</span>
  81 |     | <span class='unexecuted'>     * overridden;</span>
  82 |     | <span class='neutral'>     *</span>
  83 |     | <span class='unexecuted'>     * NOTE: This information is only used for _display_ purposes: it in</span>
  84 |     | <span class='unexecuted'>     * no way affects any of the arithmetic of the contract, including</span>
  85 |     | <span class='neutral'>     * {IERC20-balanceOf} and {IERC20-transfer}.</span>
  86 |     | <span class='neutral'>     */</span>
  87 |     | <span class='unexecuted'>    function decimals() public view virtual override returns (uint8) {</span>
  88 |     | <span class='neutral'>        return 18;</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /**</span>
  92 |     | <span class='neutral'>     * @dev See {IERC20-totalSupply}.</span>
  93 |     | <span class='neutral'>     */</span>
  94 |     | <span class='unexecuted'>    function totalSupply() public view virtual override returns (uint256) {</span>
  95 |     | <span class='neutral'>        return _totalSupply;</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /**</span>
  99 |     | <span class='neutral'>     * @dev See {IERC20-balanceOf}.</span>
 100 |     | <span class='neutral'>     */</span>
 101 |     | <span class='unexecuted'>    function balanceOf(address account) public view virtual override returns (uint256) {</span>
 102 |     | <span class='neutral'>        return _balances[account];</span>
 103 |     | <span class='unexecuted'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='unexecuted'>    /**</span>
 106 |     | <span class='unexecuted'>     * @dev See {IERC20-transfer}.</span>
 107 |     | <span class='neutral'>     *</span>
 108 |     | <span class='neutral'>     * Requirements:</span>
 109 |     | <span class='neutral'>     *</span>
 110 |     | <span class='unexecuted'>     * - `to` cannot be the zero address.</span>
 111 |     | <span class='unexecuted'>     * - the caller must have a balance of at least `amount`.</span>
 112 |     | <span class='neutral'>     */</span>
 113 |     | <span class='unexecuted'>    function transfer(address to, uint256 amount) public virtual override returns (bool) {</span>
 114 |     | <span class='neutral'>        address owner = _msgSender();</span>
 115 |     | <span class='unexecuted'>        _transfer(owner, to, amount);</span>
 116 |     | <span class='neutral'>        return true;</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    /**</span>
 120 |     | <span class='neutral'>     * @dev See {IERC20-allowance}.</span>
 121 |     | <span class='neutral'>     */</span>
 122 |     | <span class='unexecuted'>    function allowance(address owner, address spender) public view virtual override returns (uint256) {</span>
 123 |     | <span class='neutral'>        return _allowances[owner][spender];</span>
 124 |     | <span class='unexecuted'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /**</span>
 127 |     | <span class='neutral'>     * @dev See {IERC20-approve}.</span>
 128 |     | <span class='neutral'>     *</span>
 129 |     | <span class='unexecuted'>     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on</span>
 130 |     | <span class='unexecuted'>     * `transferFrom`. This is semantically equivalent to an infinite approval.</span>
 131 |     | <span class='unexecuted'>     *</span>
 132 |     | <span class='unexecuted'>     * Requirements:</span>
 133 |     | <span class='unexecuted'>     *</span>
 134 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 135 |     | <span class='neutral'>     */</span>
 136 |     | <span class='unexecuted'>    function approve(address spender, uint256 amount) public virtual override returns (bool) {</span>
 137 |     | <span class='neutral'>        address owner = _msgSender();</span>
 138 |     | <span class='neutral'>        _approve(owner, spender, amount);</span>
 139 |     | <span class='neutral'>        return true;</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    /**</span>
 143 |     | <span class='unexecuted'>     * @dev See {IERC20-transferFrom}.</span>
 144 |     | <span class='unexecuted'>     *</span>
 145 |     | <span class='unexecuted'>     * Emits an {Approval} event indicating the updated allowance. This is not</span>
 146 |     | <span class='unexecuted'>     * required by the EIP. See the note at the beginning of {ERC20}.</span>
 147 |     | <span class='unexecuted'>     *</span>
 148 |     | <span class='unexecuted'>     * NOTE: Does not update the allowance if the current allowance</span>
 149 |     | <span class='unexecuted'>     * is the maximum `uint256`.</span>
 150 |     | <span class='neutral'>     *</span>
 151 |     | <span class='unexecuted'>     * Requirements:</span>
 152 |     | <span class='unexecuted'>     *</span>
 153 |     | <span class='unexecuted'>     * - `from` and `to` cannot be the zero address.</span>
 154 |     | <span class='neutral'>     * - `from` must have a balance of at least `amount`.</span>
 155 |     | <span class='neutral'>     * - the caller must have allowance for ``from``&#39;s tokens of at least</span>
 156 |     | <span class='neutral'>     * `amount`.</span>
 157 |     | <span class='neutral'>     */</span>
 158 |     | <span class='neutral'>    function transferFrom(</span>
 159 |     | <span class='neutral'>        address from,</span>
 160 |     | <span class='neutral'>        address to,</span>
 161 |     | <span class='neutral'>        uint256 amount</span>
 162 |     | <span class='neutral'>    ) public virtual override returns (bool) {</span>
 163 |     | <span class='neutral'>        address spender = _msgSender();</span>
 164 |     | <span class='neutral'>        _spendAllowance(from, spender, amount);</span>
 165 |     | <span class='neutral'>        _transfer(from, to, amount);</span>
 166 |     | <span class='neutral'>        return true;</span>
 167 |     | <span class='neutral'>    }</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='neutral'>    /**</span>
 170 |     | <span class='neutral'>     * @dev Atomically increases the allowance granted to `spender` by the caller.</span>
 171 |     | <span class='neutral'>     *</span>
 172 |     | <span class='neutral'>     * This is an alternative to {approve} that can be used as a mitigation for</span>
 173 |     | <span class='neutral'>     * problems described in {IERC20-approve}.</span>
 174 |     | <span class='neutral'>     *</span>
 175 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance.</span>
 176 |     | <span class='neutral'>     *</span>
 177 |     | <span class='neutral'>     * Requirements:</span>
 178 |     | <span class='neutral'>     *</span>
 179 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 180 |     | <span class='neutral'>     */</span>
 181 |     | <span class='neutral'>    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {</span>
 182 |     | <span class='neutral'>        address owner = _msgSender();</span>
 183 |     | <span class='neutral'>        _approve(owner, spender, allowance(owner, spender) + addedValue);</span>
 184 |     | <span class='neutral'>        return true;</span>
 185 |     | <span class='neutral'>    }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>    /**</span>
 188 |     | <span class='neutral'>     * @dev Atomically decreases the allowance granted to `spender` by the caller.</span>
 189 |     | <span class='neutral'>     *</span>
 190 |     | <span class='neutral'>     * This is an alternative to {approve} that can be used as a mitigation for</span>
 191 |     | <span class='neutral'>     * problems described in {IERC20-approve}.</span>
 192 |     | <span class='neutral'>     *</span>
 193 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance.</span>
 194 |     | <span class='neutral'>     *</span>
 195 |     | <span class='neutral'>     * Requirements:</span>
 196 |     | <span class='neutral'>     *</span>
 197 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 198 |     | <span class='neutral'>     * - `spender` must have allowance for the caller of at least</span>
 199 |     | <span class='neutral'>     * `subtractedValue`.</span>
 200 |     | <span class='neutral'>     */</span>
 201 |     | <span class='neutral'>    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {</span>
 202 |     | <span class='neutral'>        address owner = _msgSender();</span>
 203 |     | <span class='neutral'>        uint256 currentAllowance = allowance(owner, spender);</span>
 204 |     | <span class='neutral'>        require(currentAllowance &gt;= subtractedValue, &quot;ERC20: decreased allowance below zero&quot;);</span>
 205 |     | <span class='neutral'>        unchecked {</span>
 206 |     | <span class='neutral'>            _approve(owner, spender, currentAllowance - subtractedValue);</span>
 207 |     | <span class='neutral'>        }</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='neutral'>        return true;</span>
 210 |     | <span class='neutral'>    }</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>    /**</span>
 213 |     | <span class='neutral'>     * @dev Moves `amount` of tokens from `from` to `to`.</span>
 214 |     | <span class='neutral'>     *</span>
 215 |     | <span class='neutral'>     * This internal function is equivalent to {transfer}, and can be used to</span>
 216 |     | <span class='neutral'>     * e.g. implement automatic token fees, slashing mechanisms, etc.</span>
 217 |     | <span class='neutral'>     *</span>
 218 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 219 |     | <span class='neutral'>     *</span>
 220 |     | <span class='neutral'>     * Requirements:</span>
 221 |     | <span class='neutral'>     *</span>
 222 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
 223 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 224 |     | <span class='neutral'>     * - `from` must have a balance of at least `amount`.</span>
 225 |     | <span class='neutral'>     */</span>
 226 |     | <span class='neutral'>    function _transfer(</span>
 227 |     | <span class='neutral'>        address from,</span>
 228 |     | <span class='neutral'>        address to,</span>
 229 |     | <span class='neutral'>        uint256 amount</span>
 230 |     | <span class='neutral'>    ) internal virtual {</span>
 231 |     | <span class='neutral'>        require(from != address(0), &quot;ERC20: transfer from the zero address&quot;);</span>
 232 |     | <span class='neutral'>        require(to != address(0), &quot;ERC20: transfer to the zero address&quot;);</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='neutral'>        _beforeTokenTransfer(from, to, amount);</span>
 235 |     | <span class='neutral'></span>
 236 |     | <span class='neutral'>        uint256 fromBalance = _balances[from];</span>
 237 |     | <span class='neutral'>        require(fromBalance &gt;= amount, &quot;ERC20: transfer amount exceeds balance&quot;);</span>
 238 |     | <span class='neutral'>        unchecked {</span>
 239 |     | <span class='neutral'>            _balances[from] = fromBalance - amount;</span>
 240 |     | <span class='neutral'>            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by</span>
 241 |     | <span class='neutral'>            // decrementing then incrementing.</span>
 242 |     | <span class='neutral'>            _balances[to] += amount;</span>
 243 |     | <span class='neutral'>        }</span>
 244 |     | <span class='neutral'></span>
 245 |     | <span class='neutral'>        emit Transfer(from, to, amount);</span>
 246 |     | <span class='neutral'></span>
 247 |     | <span class='neutral'>        _afterTokenTransfer(from, to, amount);</span>
 248 |     | <span class='neutral'>    }</span>
 249 |     | <span class='neutral'></span>
 250 |     | <span class='neutral'>    /** @dev Creates `amount` tokens and assigns them to `account`, increasing</span>
 251 |     | <span class='neutral'>     * the total supply.</span>
 252 |     | <span class='neutral'>     *</span>
 253 |     | <span class='neutral'>     * Emits a {Transfer} event with `from` set to the zero address.</span>
 254 |     | <span class='neutral'>     *</span>
 255 |     | <span class='neutral'>     * Requirements:</span>
 256 |     | <span class='neutral'>     *</span>
 257 |     | <span class='neutral'>     * - `account` cannot be the zero address.</span>
 258 |     | <span class='neutral'>     */</span>
 259 |     | <span class='neutral'>    function _mint(address account, uint256 amount) internal virtual {</span>
 260 |     | <span class='neutral'>        require(account != address(0), &quot;ERC20: mint to the zero address&quot;);</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='neutral'>        _beforeTokenTransfer(address(0), account, amount);</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='neutral'>        _totalSupply += amount;</span>
 265 |     | <span class='neutral'>        unchecked {</span>
 266 |     | <span class='neutral'>            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.</span>
 267 |     | <span class='neutral'>            _balances[account] += amount;</span>
 268 |     | <span class='neutral'>        }</span>
 269 |     | <span class='neutral'>        emit Transfer(address(0), account, amount);</span>
 270 |     | <span class='neutral'></span>
 271 |     | <span class='neutral'>        _afterTokenTransfer(address(0), account, amount);</span>
 272 |     | <span class='neutral'>    }</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='neutral'>    /**</span>
 275 |     | <span class='neutral'>     * @dev Destroys `amount` tokens from `account`, reducing the</span>
 276 |     | <span class='neutral'>     * total supply.</span>
 277 |     | <span class='neutral'>     *</span>
 278 |     | <span class='neutral'>     * Emits a {Transfer} event with `to` set to the zero address.</span>
 279 |     | <span class='neutral'>     *</span>
 280 |     | <span class='neutral'>     * Requirements:</span>
 281 |     | <span class='neutral'>     *</span>
 282 |     | <span class='neutral'>     * - `account` cannot be the zero address.</span>
 283 |     | <span class='neutral'>     * - `account` must have at least `amount` tokens.</span>
 284 |     | <span class='neutral'>     */</span>
 285 |     | <span class='neutral'>    function _burn(address account, uint256 amount) internal virtual {</span>
 286 |     | <span class='neutral'>        require(account != address(0), &quot;ERC20: burn from the zero address&quot;);</span>
 287 |     | <span class='neutral'></span>
 288 |     | <span class='neutral'>        _beforeTokenTransfer(account, address(0), amount);</span>
 289 |     | <span class='neutral'></span>
 290 |     | <span class='neutral'>        uint256 accountBalance = _balances[account];</span>
 291 |     | <span class='neutral'>        require(accountBalance &gt;= amount, &quot;ERC20: burn amount exceeds balance&quot;);</span>
 292 |     | <span class='neutral'>        unchecked {</span>
 293 |     | <span class='neutral'>            _balances[account] = accountBalance - amount;</span>
 294 |     | <span class='neutral'>            // Overflow not possible: amount &lt;= accountBalance &lt;= totalSupply.</span>
 295 |     | <span class='neutral'>            _totalSupply -= amount;</span>
 296 |     | <span class='neutral'>        }</span>
 297 |     | <span class='neutral'></span>
 298 |     | <span class='neutral'>        emit Transfer(account, address(0), amount);</span>
 299 |     | <span class='neutral'></span>
 300 |     | <span class='neutral'>        _afterTokenTransfer(account, address(0), amount);</span>
 301 |     | <span class='neutral'>    }</span>
 302 |     | <span class='neutral'></span>
 303 |     | <span class='neutral'>    /**</span>
 304 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.</span>
 305 |     | <span class='neutral'>     *</span>
 306 |     | <span class='neutral'>     * This internal function is equivalent to `approve`, and can be used to</span>
 307 |     | <span class='neutral'>     * e.g. set automatic allowances for certain subsystems, etc.</span>
 308 |     | <span class='neutral'>     *</span>
 309 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 310 |     | <span class='neutral'>     *</span>
 311 |     | <span class='neutral'>     * Requirements:</span>
 312 |     | <span class='neutral'>     *</span>
 313 |     | <span class='neutral'>     * - `owner` cannot be the zero address.</span>
 314 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 315 |     | <span class='neutral'>     */</span>
 316 |     | <span class='neutral'>    function _approve(</span>
 317 |     | <span class='neutral'>        address owner,</span>
 318 |     | <span class='neutral'>        address spender,</span>
 319 |     | <span class='neutral'>        uint256 amount</span>
 320 |     | <span class='neutral'>    ) internal virtual {</span>
 321 |     | <span class='neutral'>        require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);</span>
 322 |     | <span class='neutral'>        require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);</span>
 323 |     | <span class='neutral'></span>
 324 |     | <span class='neutral'>        _allowances[owner][spender] = amount;</span>
 325 |     | <span class='neutral'>        emit Approval(owner, spender, amount);</span>
 326 |     | <span class='neutral'>    }</span>
 327 |     | <span class='neutral'></span>
 328 |     | <span class='neutral'>    /**</span>
 329 |     | <span class='neutral'>     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.</span>
 330 |     | <span class='neutral'>     *</span>
 331 |     | <span class='neutral'>     * Does not update the allowance amount in case of infinite allowance.</span>
 332 |     | <span class='neutral'>     * Revert if not enough allowance is available.</span>
 333 |     | <span class='neutral'>     *</span>
 334 |     | <span class='neutral'>     * Might emit an {Approval} event.</span>
 335 |     | <span class='neutral'>     */</span>
 336 |     | <span class='neutral'>    function _spendAllowance(</span>
 337 |     | <span class='neutral'>        address owner,</span>
 338 |     | <span class='neutral'>        address spender,</span>
 339 |     | <span class='neutral'>        uint256 amount</span>
 340 |     | <span class='neutral'>    ) internal virtual {</span>
 341 |     | <span class='neutral'>        uint256 currentAllowance = allowance(owner, spender);</span>
 342 |     | <span class='neutral'>        if (currentAllowance != type(uint256).max) {</span>
 343 |     | <span class='neutral'>            require(currentAllowance &gt;= amount, &quot;ERC20: insufficient allowance&quot;);</span>
 344 |     | <span class='neutral'>            unchecked {</span>
 345 |     | <span class='neutral'>                _approve(owner, spender, currentAllowance - amount);</span>
 346 |     | <span class='neutral'>            }</span>
 347 |     | <span class='neutral'>        }</span>
 348 |     | <span class='neutral'>    }</span>
 349 |     | <span class='neutral'></span>
 350 |     | <span class='neutral'>    /**</span>
 351 |     | <span class='neutral'>     * @dev Hook that is called before any transfer of tokens. This includes</span>
 352 |     | <span class='neutral'>     * minting and burning.</span>
 353 |     | <span class='neutral'>     *</span>
 354 |     | <span class='neutral'>     * Calling conditions:</span>
 355 |     | <span class='neutral'>     *</span>
 356 |     | <span class='neutral'>     * - when `from` and `to` are both non-zero, `amount` of ``from``&#39;s tokens</span>
 357 |     | <span class='neutral'>     * will be transferred to `to`.</span>
 358 |     | <span class='neutral'>     * - when `from` is zero, `amount` tokens will be minted for `to`.</span>
 359 |     | <span class='neutral'>     * - when `to` is zero, `amount` of ``from``&#39;s tokens will be burned.</span>
 360 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 361 |     | <span class='neutral'>     *</span>
 362 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 363 |     | <span class='neutral'>     */</span>
 364 |     | <span class='neutral'>    function _beforeTokenTransfer(</span>
 365 |     | <span class='neutral'>        address from,</span>
 366 |     | <span class='neutral'>        address to,</span>
 367 |     | <span class='neutral'>        uint256 amount</span>
 368 |     | <span class='neutral'>    ) internal virtual {}</span>
 369 |     | <span class='neutral'></span>
 370 |     | <span class='neutral'>    /**</span>
 371 |     | <span class='neutral'>     * @dev Hook that is called after any transfer of tokens. This includes</span>
 372 |     | <span class='neutral'>     * minting and burning.</span>
 373 |     | <span class='neutral'>     *</span>
 374 |     | <span class='neutral'>     * Calling conditions:</span>
 375 |     | <span class='neutral'>     *</span>
 376 |     | <span class='neutral'>     * - when `from` and `to` are both non-zero, `amount` of ``from``&#39;s tokens</span>
 377 |     | <span class='neutral'>     * has been transferred to `to`.</span>
 378 |     | <span class='neutral'>     * - when `from` is zero, `amount` tokens have been minted for `to`.</span>
 379 |     | <span class='neutral'>     * - when `to` is zero, `amount` of ``from``&#39;s tokens have been burned.</span>
 380 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 381 |     | <span class='neutral'>     *</span>
 382 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 383 |     | <span class='neutral'>     */</span>
 384 |     | <span class='neutral'>    function _afterTokenTransfer(</span>
 385 |     | <span class='neutral'>        address from,</span>
 386 |     | <span class='neutral'>        address to,</span>
 387 |     | <span class='neutral'>        uint256 amount</span>
 388 |     | <span class='neutral'>    ) internal virtual {}</span>
 389 |     | <span class='neutral'>}</span>
 390 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='unexecuted'>// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='unexecuted'> * @dev Interface of the ERC20 standard as defined in the EIP.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='neutral'>interface IERC20 {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='unexecuted'>     * @dev Emitted when `value` tokens are moved from one account (`from`) to</span>
 12 |     | <span class='neutral'>     * another (`to`).</span>
 13 |     | <span class='neutral'>     *</span>
 14 |     | <span class='unexecuted'>     * Note that `value` may be zero.</span>
 15 |     | <span class='unexecuted'>     */</span>
 16 |     | <span class='unexecuted'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='unexecuted'>     * @dev Emitted when the allowance of a `spender` for an `owner` is set by</span>
 20 |     | <span class='unexecuted'>     * a call to {approve}. `value` is the new allowance.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the amount of tokens in existence.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /**</span>
 30 |     | <span class='neutral'>     * @dev Returns the amount of tokens owned by `account`.</span>
 31 |     | <span class='neutral'>     */</span>
 32 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /**</span>
 35 |     | <span class='neutral'>     * @dev Moves `amount` tokens from the caller&#39;s account to `to`.</span>
 36 |     | <span class='neutral'>     *</span>
 37 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 38 |     | <span class='neutral'>     *</span>
 39 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 40 |     | <span class='neutral'>     */</span>
 41 |     | <span class='neutral'>    function transfer(address to, uint256 amount) external returns (bool);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    /**</span>
 44 |     | <span class='neutral'>     * @dev Returns the remaining number of tokens that `spender` will be</span>
 45 |     | <span class='neutral'>     * allowed to spend on behalf of `owner` through {transferFrom}. This is</span>
 46 |     | <span class='neutral'>     * zero by default.</span>
 47 |     | <span class='neutral'>     *</span>
 48 |     | <span class='neutral'>     * This value changes when {approve} or {transferFrom} are called.</span>
 49 |     | <span class='neutral'>     */</span>
 50 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    /**</span>
 53 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the caller&#39;s tokens.</span>
 54 |     | <span class='neutral'>     *</span>
 55 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 56 |     | <span class='neutral'>     *</span>
 57 |     | <span class='neutral'>     * IMPORTANT: Beware that changing an allowance with this method brings the risk</span>
 58 |     | <span class='neutral'>     * that someone may use both the old and the new allowance by unfortunate</span>
 59 |     | <span class='neutral'>     * transaction ordering. One possible solution to mitigate this race</span>
 60 |     | <span class='neutral'>     * condition is to first reduce the spender&#39;s allowance to 0 and set the</span>
 61 |     | <span class='neutral'>     * desired value afterwards:</span>
 62 |     | <span class='neutral'>     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span>
 63 |     | <span class='neutral'>     *</span>
 64 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 65 |     | <span class='neutral'>     */</span>
 66 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='neutral'>    /**</span>
 69 |     | <span class='neutral'>     * @dev Moves `amount` tokens from `from` to `to` using the</span>
 70 |     | <span class='neutral'>     * allowance mechanism. `amount` is then deducted from the caller&#39;s</span>
 71 |     | <span class='neutral'>     * allowance.</span>
 72 |     | <span class='neutral'>     *</span>
 73 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 74 |     | <span class='neutral'>     *</span>
 75 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 76 |     | <span class='neutral'>     */</span>
 77 |     | <span class='neutral'>    function transferFrom(</span>
 78 |     | <span class='neutral'>        address from,</span>
 79 |     | <span class='neutral'>        address to,</span>
 80 |     | <span class='neutral'>        uint256 amount</span>
 81 |     | <span class='neutral'>    ) external returns (bool);</span>
 82 |     | <span class='neutral'>}</span>
 83 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../IERC20.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='unexecuted'> * @dev Interface for the optional metadata functions from the ERC20 standard.</span>
 10 |     | <span class='neutral'> *</span>
 11 |     | <span class='neutral'> * _Available since v4.1._</span>
 12 |     | <span class='neutral'> */</span>
 13 |     | <span class='unexecuted'>interface IERC20Metadata is IERC20 {</span>
 14 |     | <span class='neutral'>    /**</span>
 15 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
 16 |     | <span class='neutral'>     */</span>
 17 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    /**</span>
 20 |     | <span class='unexecuted'>     * @dev Returns the symbol of the token.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the decimals places of the token.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in</span>
  8 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].</span>
  9 |     | <span class='neutral'> *</span>
 10 |     | <span class='neutral'> * Adds the {permit} method, which can be used to change an account&#39;s ERC20 allowance (see {IERC20-allowance}) by</span>
 11 |     | <span class='neutral'> * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn&#39;t</span>
 12 |     | <span class='neutral'> * need to send a transaction, and thus is not required to hold Ether at all.</span>
 13 |     | <span class='neutral'> */</span>
 14 |     | <span class='neutral'>interface IERC20Permit {</span>
 15 |     | <span class='neutral'>    /**</span>
 16 |     | <span class='neutral'>     * @dev Sets `value` as the allowance of `spender` over ``owner``&#39;s tokens,</span>
 17 |     | <span class='neutral'>     * given ``owner``&#39;s signed approval.</span>
 18 |     | <span class='neutral'>     *</span>
 19 |     | <span class='neutral'>     * IMPORTANT: The same issues {IERC20-approve} has related to transaction</span>
 20 |     | <span class='neutral'>     * ordering also apply here.</span>
 21 |     | <span class='neutral'>     *</span>
 22 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 23 |     | <span class='neutral'>     *</span>
 24 |     | <span class='neutral'>     * Requirements:</span>
 25 |     | <span class='neutral'>     *</span>
 26 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 27 |     | <span class='neutral'>     * - `deadline` must be a timestamp in the future.</span>
 28 |     | <span class='neutral'>     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`</span>
 29 |     | <span class='neutral'>     * over the EIP712-formatted function arguments.</span>
 30 |     | <span class='neutral'>     * - the signature must use ``owner``&#39;s current nonce (see {nonces}).</span>
 31 |     | <span class='neutral'>     *</span>
 32 |     | <span class='neutral'>     * For more information on the signature format, see the</span>
 33 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP</span>
 34 |     | <span class='neutral'>     * section].</span>
 35 |     | <span class='neutral'>     */</span>
 36 |     | <span class='neutral'>    function permit(</span>
 37 |     | <span class='neutral'>        address owner,</span>
 38 |     | <span class='neutral'>        address spender,</span>
 39 |     | <span class='neutral'>        uint256 value,</span>
 40 |     | <span class='neutral'>        uint256 deadline,</span>
 41 |     | <span class='neutral'>        uint8 v,</span>
 42 |     | <span class='neutral'>        bytes32 r,</span>
 43 |     | <span class='neutral'>        bytes32 s</span>
 44 |     | <span class='neutral'>    ) external;</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    /**</span>
 47 |     | <span class='neutral'>     * @dev Returns the current nonce for `owner`. This value must be</span>
 48 |     | <span class='neutral'>     * included whenever a signature is generated for {permit}.</span>
 49 |     | <span class='neutral'>     *</span>
 50 |     | <span class='neutral'>     * Every successful call to {permit} increases ``owner``&#39;s nonce by one. This</span>
 51 |     | <span class='neutral'>     * prevents a signature from being used multiple times.</span>
 52 |     | <span class='neutral'>     */</span>
 53 |     | <span class='neutral'>    function nonces(address owner) external view returns (uint256);</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='neutral'>    /**</span>
 56 |     | <span class='neutral'>     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.</span>
 57 |     | <span class='neutral'>     */</span>
 58 |     | <span class='neutral'>    // solhint-disable-next-line func-name-mixedcase</span>
 59 |     | <span class='neutral'>    function DOMAIN_SEPARATOR() external view returns (bytes32);</span>
 60 |     | <span class='neutral'>}</span>
 61 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;../IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../extensions/draft-IERC20Permit.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../../utils/Address.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @title SafeERC20</span>
  12 |     | <span class='neutral'> * @dev Wrappers around ERC20 operations that throw on failure (when the token</span>
  13 |     | <span class='neutral'> * contract returns false). Tokens that return no value (and instead revert or</span>
  14 |     | <span class='neutral'> * throw on failure) are also supported, non-reverting calls are assumed to be</span>
  15 |     | <span class='neutral'> * successful.</span>
  16 |     | <span class='neutral'> * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,</span>
  17 |     | <span class='neutral'> * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.</span>
  18 |     | <span class='neutral'> */</span>
  19 |     | <span class='neutral'>library SafeERC20 {</span>
  20 |     | <span class='neutral'>    using Address for address;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    function safeTransfer(</span>
  23 |     | <span class='neutral'>        IERC20 token,</span>
  24 |     | <span class='neutral'>        address to,</span>
  25 |     | <span class='neutral'>        uint256 value</span>
  26 |     | <span class='neutral'>    ) internal {</span>
  27 |     | <span class='neutral'>        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    function safeTransferFrom(</span>
  31 |     | <span class='neutral'>        IERC20 token,</span>
  32 |     | <span class='neutral'>        address from,</span>
  33 |     | <span class='neutral'>        address to,</span>
  34 |     | <span class='neutral'>        uint256 value</span>
  35 |     | <span class='neutral'>    ) internal {</span>
  36 |     | <span class='neutral'>        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    /**</span>
  40 |     | <span class='neutral'>     * @dev Deprecated. This function has issues similar to the ones found in</span>
  41 |     | <span class='neutral'>     * {IERC20-approve}, and its usage is discouraged.</span>
  42 |     | <span class='neutral'>     *</span>
  43 |     | <span class='neutral'>     * Whenever possible, use {safeIncreaseAllowance} and</span>
  44 |     | <span class='neutral'>     * {safeDecreaseAllowance} instead.</span>
  45 |     | <span class='neutral'>     */</span>
  46 |     | <span class='neutral'>    function safeApprove(</span>
  47 |     | <span class='neutral'>        IERC20 token,</span>
  48 |     | <span class='neutral'>        address spender,</span>
  49 |     | <span class='neutral'>        uint256 value</span>
  50 |     | <span class='neutral'>    ) internal {</span>
  51 |     | <span class='neutral'>        // safeApprove should only be called when setting an initial allowance,</span>
  52 |     | <span class='neutral'>        // or when resetting it to zero. To increase and decrease it, use</span>
  53 |     | <span class='neutral'>        // &#39;safeIncreaseAllowance&#39; and &#39;safeDecreaseAllowance&#39;</span>
  54 |     | <span class='neutral'>        require(</span>
  55 |     | <span class='neutral'>            (value == 0) || (token.allowance(address(this), spender) == 0),</span>
  56 |     | <span class='neutral'>            &quot;SafeERC20: approve from non-zero to non-zero allowance&quot;</span>
  57 |     | <span class='neutral'>        );</span>
  58 |     | <span class='neutral'>        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    function safeIncreaseAllowance(</span>
  62 |     | <span class='neutral'>        IERC20 token,</span>
  63 |     | <span class='neutral'>        address spender,</span>
  64 |     | <span class='neutral'>        uint256 value</span>
  65 |     | <span class='neutral'>    ) internal {</span>
  66 |     | <span class='neutral'>        uint256 newAllowance = token.allowance(address(this), spender) + value;</span>
  67 |     | <span class='neutral'>        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    function safeDecreaseAllowance(</span>
  71 |     | <span class='neutral'>        IERC20 token,</span>
  72 |     | <span class='neutral'>        address spender,</span>
  73 |     | <span class='neutral'>        uint256 value</span>
  74 |     | <span class='neutral'>    ) internal {</span>
  75 |     | <span class='neutral'>        unchecked {</span>
  76 |     | <span class='neutral'>            uint256 oldAllowance = token.allowance(address(this), spender);</span>
  77 |     | <span class='neutral'>            require(oldAllowance &gt;= value, &quot;SafeERC20: decreased allowance below zero&quot;);</span>
  78 |     | <span class='neutral'>            uint256 newAllowance = oldAllowance - value;</span>
  79 |     | <span class='neutral'>            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));</span>
  80 |     | <span class='neutral'>        }</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    function safePermit(</span>
  84 |     | <span class='neutral'>        IERC20Permit token,</span>
  85 |     | <span class='neutral'>        address owner,</span>
  86 |     | <span class='neutral'>        address spender,</span>
  87 |     | <span class='neutral'>        uint256 value,</span>
  88 |     | <span class='neutral'>        uint256 deadline,</span>
  89 |     | <span class='neutral'>        uint8 v,</span>
  90 |     | <span class='neutral'>        bytes32 r,</span>
  91 |     | <span class='neutral'>        bytes32 s</span>
  92 |     | <span class='neutral'>    ) internal {</span>
  93 |     | <span class='neutral'>        uint256 nonceBefore = token.nonces(owner);</span>
  94 |     | <span class='neutral'>        token.permit(owner, spender, value, deadline, v, r, s);</span>
  95 |     | <span class='neutral'>        uint256 nonceAfter = token.nonces(owner);</span>
  96 |     | <span class='neutral'>        require(nonceAfter == nonceBefore + 1, &quot;SafeERC20: permit did not succeed&quot;);</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    /**</span>
 100 |     | <span class='neutral'>     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement</span>
 101 |     | <span class='neutral'>     * on the return value: the return value is optional (but if data is returned, it must not be false).</span>
 102 |     | <span class='neutral'>     * @param token The token targeted by the call.</span>
 103 |     | <span class='neutral'>     * @param data The call data (encoded using abi.encode or one of its variants).</span>
 104 |     | <span class='neutral'>     */</span>
 105 |     | <span class='neutral'>    function _callOptionalReturn(IERC20 token, bytes memory data) private {</span>
 106 |     | <span class='neutral'>        // We need to perform a low level call here, to bypass Solidity&#39;s return data size checking mechanism, since</span>
 107 |     | <span class='neutral'>        // we&#39;re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that</span>
 108 |     | <span class='neutral'>        // the target address contains contract code and also asserts for success in the low-level call.</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>        bytes memory returndata = address(token).functionCall(data, &quot;SafeERC20: low-level call failed&quot;);</span>
 111 |     | <span class='neutral'>        if (returndata.length &gt; 0) {</span>
 112 |     | <span class='neutral'>            // Return data is optional</span>
 113 |     | <span class='neutral'>            require(abi.decode(returndata, (bool)), &quot;SafeERC20: ERC20 operation did not succeed&quot;);</span>
 114 |     | <span class='neutral'>        }</span>
 115 |     | <span class='neutral'>    }</span>
 116 |     | <span class='neutral'>}</span>
 117 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/ERC721.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;./IERC721.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./IERC721Receiver.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;./extensions/IERC721Metadata.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;../../utils/Address.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;../../utils/Context.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;../../utils/Strings.sol&quot;;</span>
  12 |     | <span class='neutral'>import &quot;../../utils/introspection/ERC165.sol&quot;;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>/**</span>
  15 |     | <span class='neutral'> * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including</span>
  16 |     | <span class='neutral'> * the Metadata extension, but not including the Enumerable extension, which is available separately as</span>
  17 |     | <span class='neutral'> * {ERC721Enumerable}.</span>
  18 |     | <span class='neutral'> */</span>
  19 |     | <span class='neutral'>contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {</span>
  20 |     | <span class='neutral'>    using Address for address;</span>
  21 |     | <span class='neutral'>    using Strings for uint256;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    // Token name</span>
  24 |     | <span class='neutral'>    string private _name;</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    // Token symbol</span>
  27 |     | <span class='neutral'>    string private _symbol;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    // Mapping from token ID to owner address</span>
  30 |     | <span class='neutral'>    mapping(uint256 =&gt; address) private _owners;</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    // Mapping owner address to token count</span>
  33 |     | <span class='neutral'>    mapping(address =&gt; uint256) private _balances;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    // Mapping from token ID to approved address</span>
  36 |     | <span class='neutral'>    mapping(uint256 =&gt; address) private _tokenApprovals;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    // Mapping from owner to operator approvals</span>
  39 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; bool)) private _operatorApprovals;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    /**</span>
  42 |     | <span class='neutral'>     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.</span>
  43 |     | <span class='unexecuted'>     */</span>
  44 |     | <span class='neutral'>    constructor(string memory name_, string memory symbol_) {</span>
  45 |     | <span class='neutral'>        _name = name_;</span>
  46 |     | <span class='neutral'>        _symbol = symbol_;</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    /**</span>
  50 |     | <span class='neutral'>     * @dev See {IERC165-supportsInterface}.</span>
  51 |     | <span class='neutral'>     */</span>
  52 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {</span>
  53 |     | <span class='neutral'>        return</span>
  54 |     | <span class='neutral'>            interfaceId == type(IERC721).interfaceId ||</span>
  55 |     | <span class='neutral'>            interfaceId == type(IERC721Metadata).interfaceId ||</span>
  56 |     | <span class='neutral'>            super.supportsInterface(interfaceId);</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /**</span>
  60 |     | <span class='neutral'>     * @dev See {IERC721-balanceOf}.</span>
  61 |     | <span class='neutral'>     */</span>
  62 |     | <span class='neutral'>    function balanceOf(address owner) public view virtual override returns (uint256) {</span>
  63 |     | <span class='neutral'>        require(owner != address(0), &quot;ERC721: address zero is not a valid owner&quot;);</span>
  64 |     | <span class='neutral'>        return _balances[owner];</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    /**</span>
  68 |     | <span class='neutral'>     * @dev See {IERC721-ownerOf}.</span>
  69 |     | <span class='neutral'>     */</span>
  70 |     | <span class='neutral'>    function ownerOf(uint256 tokenId) public view virtual override returns (address) {</span>
  71 |     | <span class='neutral'>        address owner = _ownerOf(tokenId);</span>
  72 |     | <span class='neutral'>        require(owner != address(0), &quot;ERC721: invalid token ID&quot;);</span>
  73 |     | <span class='neutral'>        return owner;</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    /**</span>
  77 |     | <span class='neutral'>     * @dev See {IERC721Metadata-name}.</span>
  78 |     | <span class='neutral'>     */</span>
  79 |     | <span class='neutral'>    function name() public view virtual override returns (string memory) {</span>
  80 |     | <span class='neutral'>        return _name;</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    /**</span>
  84 |     | <span class='neutral'>     * @dev See {IERC721Metadata-symbol}.</span>
  85 |     | <span class='neutral'>     */</span>
  86 |     | <span class='neutral'>    function symbol() public view virtual override returns (string memory) {</span>
  87 |     | <span class='neutral'>        return _symbol;</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    /**</span>
  91 |     | <span class='neutral'>     * @dev See {IERC721Metadata-tokenURI}.</span>
  92 |     | <span class='neutral'>     */</span>
  93 |     | <span class='neutral'>    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {</span>
  94 |     | <span class='neutral'>        _requireMinted(tokenId);</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>        string memory baseURI = _baseURI();</span>
  97 |     | <span class='neutral'>        return bytes(baseURI).length &gt; 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : &quot;&quot;;</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    /**</span>
 101 |     | <span class='neutral'>     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each</span>
 102 |     | <span class='neutral'>     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty</span>
 103 |     | <span class='neutral'>     * by default, can be overridden in child contracts.</span>
 104 |     | <span class='neutral'>     */</span>
 105 |     | <span class='neutral'>    function _baseURI() internal view virtual returns (string memory) {</span>
 106 |     | <span class='neutral'>        return &quot;&quot;;</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    /**</span>
 110 |     | <span class='neutral'>     * @dev See {IERC721-approve}.</span>
 111 |     | <span class='neutral'>     */</span>
 112 |     | <span class='neutral'>    function approve(address to, uint256 tokenId) public virtual override {</span>
 113 |     | <span class='neutral'>        address owner = ERC721.ownerOf(tokenId);</span>
 114 |     | <span class='neutral'>        require(to != owner, &quot;ERC721: approval to current owner&quot;);</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>        require(</span>
 117 |     | <span class='neutral'>            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),</span>
 118 |     | <span class='neutral'>            &quot;ERC721: approve caller is not token owner or approved for all&quot;</span>
 119 |     | <span class='neutral'>        );</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>        _approve(to, tokenId);</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>    /**</span>
 125 |     | <span class='neutral'>     * @dev See {IERC721-getApproved}.</span>
 126 |     | <span class='neutral'>     */</span>
 127 |     | <span class='neutral'>    function getApproved(uint256 tokenId) public view virtual override returns (address) {</span>
 128 |     | <span class='neutral'>        _requireMinted(tokenId);</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>        return _tokenApprovals[tokenId];</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>    /**</span>
 134 |     | <span class='neutral'>     * @dev See {IERC721-setApprovalForAll}.</span>
 135 |     | <span class='neutral'>     */</span>
 136 |     | <span class='neutral'>    function setApprovalForAll(address operator, bool approved) public virtual override {</span>
 137 |     | <span class='neutral'>        _setApprovalForAll(_msgSender(), operator, approved);</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    /**</span>
 141 |     | <span class='neutral'>     * @dev See {IERC721-isApprovedForAll}.</span>
 142 |     | <span class='neutral'>     */</span>
 143 |     | <span class='neutral'>    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {</span>
 144 |     | <span class='neutral'>        return _operatorApprovals[owner][operator];</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    /**</span>
 148 |     | <span class='neutral'>     * @dev See {IERC721-transferFrom}.</span>
 149 |     | <span class='neutral'>     */</span>
 150 |     | <span class='neutral'>    function transferFrom(</span>
 151 |     | <span class='neutral'>        address from,</span>
 152 |     | <span class='neutral'>        address to,</span>
 153 |     | <span class='neutral'>        uint256 tokenId</span>
 154 |     | <span class='neutral'>    ) public virtual override {</span>
 155 |     | <span class='neutral'>        //solhint-disable-next-line max-line-length</span>
 156 |     | <span class='neutral'>        require(_isApprovedOrOwner(_msgSender(), tokenId), &quot;ERC721: caller is not token owner or approved&quot;);</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>        _transfer(from, to, tokenId);</span>
 159 |     | <span class='neutral'>    }</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>    /**</span>
 162 |     | <span class='neutral'>     * @dev See {IERC721-safeTransferFrom}.</span>
 163 |     | <span class='neutral'>     */</span>
 164 |     | <span class='neutral'>    function safeTransferFrom(</span>
 165 |     | <span class='neutral'>        address from,</span>
 166 |     | <span class='neutral'>        address to,</span>
 167 |     | <span class='neutral'>        uint256 tokenId</span>
 168 |     | <span class='neutral'>    ) public virtual override {</span>
 169 |     | <span class='neutral'>        safeTransferFrom(from, to, tokenId, &quot;&quot;);</span>
 170 |     | <span class='neutral'>    }</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='neutral'>    /**</span>
 173 |     | <span class='neutral'>     * @dev See {IERC721-safeTransferFrom}.</span>
 174 |     | <span class='neutral'>     */</span>
 175 |     | <span class='neutral'>    function safeTransferFrom(</span>
 176 |     | <span class='neutral'>        address from,</span>
 177 |     | <span class='neutral'>        address to,</span>
 178 |     | <span class='neutral'>        uint256 tokenId,</span>
 179 |     | <span class='neutral'>        bytes memory data</span>
 180 |     | <span class='neutral'>    ) public virtual override {</span>
 181 |     | <span class='neutral'>        require(_isApprovedOrOwner(_msgSender(), tokenId), &quot;ERC721: caller is not token owner or approved&quot;);</span>
 182 |     | <span class='neutral'>        _safeTransfer(from, to, tokenId, data);</span>
 183 |     | <span class='neutral'>    }</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>    /**</span>
 186 |     | <span class='neutral'>     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients</span>
 187 |     | <span class='neutral'>     * are aware of the ERC721 protocol to prevent tokens from being forever locked.</span>
 188 |     | <span class='neutral'>     *</span>
 189 |     | <span class='neutral'>     * `data` is additional data, it has no specified format and it is sent in call to `to`.</span>
 190 |     | <span class='neutral'>     *</span>
 191 |     | <span class='neutral'>     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.</span>
 192 |     | <span class='neutral'>     * implement alternative mechanisms to perform token transfer, such as signature-based.</span>
 193 |     | <span class='neutral'>     *</span>
 194 |     | <span class='neutral'>     * Requirements:</span>
 195 |     | <span class='neutral'>     *</span>
 196 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
 197 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 198 |     | <span class='neutral'>     * - `tokenId` token must exist and be owned by `from`.</span>
 199 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.</span>
 200 |     | <span class='neutral'>     *</span>
 201 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 202 |     | <span class='neutral'>     */</span>
 203 |     | <span class='neutral'>    function _safeTransfer(</span>
 204 |     | <span class='neutral'>        address from,</span>
 205 |     | <span class='neutral'>        address to,</span>
 206 |     | <span class='neutral'>        uint256 tokenId,</span>
 207 |     | <span class='neutral'>        bytes memory data</span>
 208 |     | <span class='neutral'>    ) internal virtual {</span>
 209 |     | <span class='neutral'>        _transfer(from, to, tokenId);</span>
 210 |     | <span class='neutral'>        require(_checkOnERC721Received(from, to, tokenId, data), &quot;ERC721: transfer to non ERC721Receiver implementer&quot;);</span>
 211 |     | <span class='neutral'>    }</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='neutral'>    /**</span>
 214 |     | <span class='neutral'>     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn&#39;t exist</span>
 215 |     | <span class='neutral'>     */</span>
 216 |     | <span class='neutral'>    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {</span>
 217 |     | <span class='neutral'>        return _owners[tokenId];</span>
 218 |     | <span class='neutral'>    }</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>    /**</span>
 221 |     | <span class='neutral'>     * @dev Returns whether `tokenId` exists.</span>
 222 |     | <span class='neutral'>     *</span>
 223 |     | <span class='neutral'>     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.</span>
 224 |     | <span class='neutral'>     *</span>
 225 |     | <span class='neutral'>     * Tokens start existing when they are minted (`_mint`),</span>
 226 |     | <span class='neutral'>     * and stop existing when they are burned (`_burn`).</span>
 227 |     | <span class='neutral'>     */</span>
 228 |     | <span class='neutral'>    function _exists(uint256 tokenId) internal view virtual returns (bool) {</span>
 229 |     | <span class='neutral'>        return _ownerOf(tokenId) != address(0);</span>
 230 |     | <span class='neutral'>    }</span>
 231 |     | <span class='neutral'></span>
 232 |     | <span class='neutral'>    /**</span>
 233 |     | <span class='neutral'>     * @dev Returns whether `spender` is allowed to manage `tokenId`.</span>
 234 |     | <span class='neutral'>     *</span>
 235 |     | <span class='neutral'>     * Requirements:</span>
 236 |     | <span class='neutral'>     *</span>
 237 |     | <span class='neutral'>     * - `tokenId` must exist.</span>
 238 |     | <span class='neutral'>     */</span>
 239 |     | <span class='neutral'>    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {</span>
 240 |     | <span class='neutral'>        address owner = ERC721.ownerOf(tokenId);</span>
 241 |     | <span class='neutral'>        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);</span>
 242 |     | <span class='neutral'>    }</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='neutral'>    /**</span>
 245 |     | <span class='neutral'>     * @dev Safely mints `tokenId` and transfers it to `to`.</span>
 246 |     | <span class='neutral'>     *</span>
 247 |     | <span class='neutral'>     * Requirements:</span>
 248 |     | <span class='neutral'>     *</span>
 249 |     | <span class='neutral'>     * - `tokenId` must not exist.</span>
 250 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.</span>
 251 |     | <span class='neutral'>     *</span>
 252 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 253 |     | <span class='neutral'>     */</span>
 254 |     | <span class='neutral'>    function _safeMint(address to, uint256 tokenId) internal virtual {</span>
 255 |     | <span class='neutral'>        _safeMint(to, tokenId, &quot;&quot;);</span>
 256 |     | <span class='neutral'>    }</span>
 257 |     | <span class='neutral'></span>
 258 |     | <span class='neutral'>    /**</span>
 259 |     | <span class='neutral'>     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is</span>
 260 |     | <span class='neutral'>     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.</span>
 261 |     | <span class='neutral'>     */</span>
 262 |     | <span class='neutral'>    function _safeMint(</span>
 263 |     | <span class='neutral'>        address to,</span>
 264 |     | <span class='neutral'>        uint256 tokenId,</span>
 265 |     | <span class='neutral'>        bytes memory data</span>
 266 |     | <span class='neutral'>    ) internal virtual {</span>
 267 |     | <span class='neutral'>        _mint(to, tokenId);</span>
 268 |     | <span class='neutral'>        require(</span>
 269 |     | <span class='neutral'>            _checkOnERC721Received(address(0), to, tokenId, data),</span>
 270 |     | <span class='neutral'>            &quot;ERC721: transfer to non ERC721Receiver implementer&quot;</span>
 271 |     | <span class='neutral'>        );</span>
 272 |     | <span class='neutral'>    }</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='neutral'>    /**</span>
 275 |     | <span class='neutral'>     * @dev Mints `tokenId` and transfers it to `to`.</span>
 276 |     | <span class='neutral'>     *</span>
 277 |     | <span class='neutral'>     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible</span>
 278 |     | <span class='neutral'>     *</span>
 279 |     | <span class='neutral'>     * Requirements:</span>
 280 |     | <span class='neutral'>     *</span>
 281 |     | <span class='neutral'>     * - `tokenId` must not exist.</span>
 282 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 283 |     | <span class='neutral'>     *</span>
 284 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 285 |     | <span class='neutral'>     */</span>
 286 |     | <span class='neutral'>    function _mint(address to, uint256 tokenId) internal virtual {</span>
 287 |     | <span class='neutral'>        require(to != address(0), &quot;ERC721: mint to the zero address&quot;);</span>
 288 |     | <span class='neutral'>        require(!_exists(tokenId), &quot;ERC721: token already minted&quot;);</span>
 289 |     | <span class='neutral'></span>
 290 |     | <span class='neutral'>        _beforeTokenTransfer(address(0), to, tokenId, 1);</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='neutral'>        // Check that tokenId was not minted by `_beforeTokenTransfer` hook</span>
 293 |     | <span class='neutral'>        require(!_exists(tokenId), &quot;ERC721: token already minted&quot;);</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='neutral'>        unchecked {</span>
 296 |     | <span class='neutral'>            // Will not overflow unless all 2**256 token ids are minted to the same owner.</span>
 297 |     | <span class='neutral'>            // Given that tokens are minted one by one, it is impossible in practice that</span>
 298 |     | <span class='neutral'>            // this ever happens. Might change if we allow batch minting.</span>
 299 |     | <span class='neutral'>            // The ERC fails to describe this case.</span>
 300 |     | <span class='neutral'>            _balances[to] += 1;</span>
 301 |     | <span class='neutral'>        }</span>
 302 |     | <span class='neutral'></span>
 303 |     | <span class='neutral'>        _owners[tokenId] = to;</span>
 304 |     | <span class='neutral'></span>
 305 |     | <span class='neutral'>        emit Transfer(address(0), to, tokenId);</span>
 306 |     | <span class='neutral'></span>
 307 |     | <span class='neutral'>        _afterTokenTransfer(address(0), to, tokenId, 1);</span>
 308 |     | <span class='neutral'>    }</span>
 309 |     | <span class='neutral'></span>
 310 |     | <span class='neutral'>    /**</span>
 311 |     | <span class='neutral'>     * @dev Destroys `tokenId`.</span>
 312 |     | <span class='neutral'>     * The approval is cleared when the token is burned.</span>
 313 |     | <span class='neutral'>     * This is an internal function that does not check if the sender is authorized to operate on the token.</span>
 314 |     | <span class='neutral'>     *</span>
 315 |     | <span class='neutral'>     * Requirements:</span>
 316 |     | <span class='neutral'>     *</span>
 317 |     | <span class='neutral'>     * - `tokenId` must exist.</span>
 318 |     | <span class='neutral'>     *</span>
 319 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 320 |     | <span class='neutral'>     */</span>
 321 |     | <span class='neutral'>    function _burn(uint256 tokenId) internal virtual {</span>
 322 |     | <span class='neutral'>        address owner = ERC721.ownerOf(tokenId);</span>
 323 |     | <span class='neutral'></span>
 324 |     | <span class='neutral'>        _beforeTokenTransfer(owner, address(0), tokenId, 1);</span>
 325 |     | <span class='neutral'></span>
 326 |     | <span class='neutral'>        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook</span>
 327 |     | <span class='neutral'>        owner = ERC721.ownerOf(tokenId);</span>
 328 |     | <span class='neutral'></span>
 329 |     | <span class='neutral'>        // Clear approvals</span>
 330 |     | <span class='neutral'>        delete _tokenApprovals[tokenId];</span>
 331 |     | <span class='neutral'></span>
 332 |     | <span class='neutral'>        unchecked {</span>
 333 |     | <span class='neutral'>            // Cannot overflow, as that would require more tokens to be burned/transferred</span>
 334 |     | <span class='neutral'>            // out than the owner initially received through minting and transferring in.</span>
 335 |     | <span class='neutral'>            _balances[owner] -= 1;</span>
 336 |     | <span class='neutral'>        }</span>
 337 |     | <span class='neutral'>        delete _owners[tokenId];</span>
 338 |     | <span class='neutral'></span>
 339 |     | <span class='neutral'>        emit Transfer(owner, address(0), tokenId);</span>
 340 |     | <span class='neutral'></span>
 341 |     | <span class='neutral'>        _afterTokenTransfer(owner, address(0), tokenId, 1);</span>
 342 |     | <span class='neutral'>    }</span>
 343 |     | <span class='neutral'></span>
 344 |     | <span class='neutral'>    /**</span>
 345 |     | <span class='neutral'>     * @dev Transfers `tokenId` from `from` to `to`.</span>
 346 |     | <span class='neutral'>     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.</span>
 347 |     | <span class='neutral'>     *</span>
 348 |     | <span class='neutral'>     * Requirements:</span>
 349 |     | <span class='neutral'>     *</span>
 350 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 351 |     | <span class='neutral'>     * - `tokenId` token must be owned by `from`.</span>
 352 |     | <span class='neutral'>     *</span>
 353 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 354 |     | <span class='neutral'>     */</span>
 355 |     | <span class='neutral'>    function _transfer(</span>
 356 |     | <span class='neutral'>        address from,</span>
 357 |     | <span class='neutral'>        address to,</span>
 358 |     | <span class='neutral'>        uint256 tokenId</span>
 359 |     | <span class='neutral'>    ) internal virtual {</span>
 360 |     | <span class='neutral'>        require(ERC721.ownerOf(tokenId) == from, &quot;ERC721: transfer from incorrect owner&quot;);</span>
 361 |     | <span class='neutral'>        require(to != address(0), &quot;ERC721: transfer to the zero address&quot;);</span>
 362 |     | <span class='neutral'></span>
 363 |     | <span class='neutral'>        _beforeTokenTransfer(from, to, tokenId, 1);</span>
 364 |     | <span class='neutral'></span>
 365 |     | <span class='neutral'>        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook</span>
 366 |     | <span class='neutral'>        require(ERC721.ownerOf(tokenId) == from, &quot;ERC721: transfer from incorrect owner&quot;);</span>
 367 |     | <span class='neutral'></span>
 368 |     | <span class='neutral'>        // Clear approvals from the previous owner</span>
 369 |     | <span class='neutral'>        delete _tokenApprovals[tokenId];</span>
 370 |     | <span class='neutral'></span>
 371 |     | <span class='neutral'>        unchecked {</span>
 372 |     | <span class='neutral'>            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:</span>
 373 |     | <span class='neutral'>            // `from`&#39;s balance is the number of token held, which is at least one before the current</span>
 374 |     | <span class='neutral'>            // transfer.</span>
 375 |     | <span class='neutral'>            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require</span>
 376 |     | <span class='neutral'>            // all 2**256 token ids to be minted, which in practice is impossible.</span>
 377 |     | <span class='neutral'>            _balances[from] -= 1;</span>
 378 |     | <span class='neutral'>            _balances[to] += 1;</span>
 379 |     | <span class='neutral'>        }</span>
 380 |     | <span class='neutral'>        _owners[tokenId] = to;</span>
 381 |     | <span class='neutral'></span>
 382 |     | <span class='neutral'>        emit Transfer(from, to, tokenId);</span>
 383 |     | <span class='neutral'></span>
 384 |     | <span class='neutral'>        _afterTokenTransfer(from, to, tokenId, 1);</span>
 385 |     | <span class='neutral'>    }</span>
 386 |     | <span class='neutral'></span>
 387 |     | <span class='neutral'>    /**</span>
 388 |     | <span class='neutral'>     * @dev Approve `to` to operate on `tokenId`</span>
 389 |     | <span class='neutral'>     *</span>
 390 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 391 |     | <span class='neutral'>     */</span>
 392 |     | <span class='neutral'>    function _approve(address to, uint256 tokenId) internal virtual {</span>
 393 |     | <span class='neutral'>        _tokenApprovals[tokenId] = to;</span>
 394 |     | <span class='neutral'>        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);</span>
 395 |     | <span class='neutral'>    }</span>
 396 |     | <span class='neutral'></span>
 397 |     | <span class='neutral'>    /**</span>
 398 |     | <span class='neutral'>     * @dev Approve `operator` to operate on all of `owner` tokens</span>
 399 |     | <span class='neutral'>     *</span>
 400 |     | <span class='neutral'>     * Emits an {ApprovalForAll} event.</span>
 401 |     | <span class='neutral'>     */</span>
 402 |     | <span class='neutral'>    function _setApprovalForAll(</span>
 403 |     | <span class='neutral'>        address owner,</span>
 404 |     | <span class='neutral'>        address operator,</span>
 405 |     | <span class='neutral'>        bool approved</span>
 406 |     | <span class='neutral'>    ) internal virtual {</span>
 407 |     | <span class='neutral'>        require(owner != operator, &quot;ERC721: approve to caller&quot;);</span>
 408 |     | <span class='neutral'>        _operatorApprovals[owner][operator] = approved;</span>
 409 |     | <span class='neutral'>        emit ApprovalForAll(owner, operator, approved);</span>
 410 |     | <span class='neutral'>    }</span>
 411 |     | <span class='neutral'></span>
 412 |     | <span class='neutral'>    /**</span>
 413 |     | <span class='neutral'>     * @dev Reverts if the `tokenId` has not been minted yet.</span>
 414 |     | <span class='neutral'>     */</span>
 415 |     | <span class='neutral'>    function _requireMinted(uint256 tokenId) internal view virtual {</span>
 416 |     | <span class='neutral'>        require(_exists(tokenId), &quot;ERC721: invalid token ID&quot;);</span>
 417 |     | <span class='neutral'>    }</span>
 418 |     | <span class='neutral'></span>
 419 |     | <span class='neutral'>    /**</span>
 420 |     | <span class='neutral'>     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.</span>
 421 |     | <span class='neutral'>     * The call is not executed if the target address is not a contract.</span>
 422 |     | <span class='neutral'>     *</span>
 423 |     | <span class='neutral'>     * @param from address representing the previous owner of the given token ID</span>
 424 |     | <span class='neutral'>     * @param to target address that will receive the tokens</span>
 425 |     | <span class='neutral'>     * @param tokenId uint256 ID of the token to be transferred</span>
 426 |     | <span class='neutral'>     * @param data bytes optional data to send along with the call</span>
 427 |     | <span class='neutral'>     * @return bool whether the call correctly returned the expected magic value</span>
 428 |     | <span class='neutral'>     */</span>
 429 |     | <span class='neutral'>    function _checkOnERC721Received(</span>
 430 |     | <span class='neutral'>        address from,</span>
 431 |     | <span class='neutral'>        address to,</span>
 432 |     | <span class='neutral'>        uint256 tokenId,</span>
 433 |     | <span class='neutral'>        bytes memory data</span>
 434 |     | <span class='neutral'>    ) private returns (bool) {</span>
 435 |     | <span class='neutral'>        if (to.isContract()) {</span>
 436 |     | <span class='neutral'>            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {</span>
 437 |     | <span class='neutral'>                return retval == IERC721Receiver.onERC721Received.selector;</span>
 438 |     | <span class='neutral'>            } catch (bytes memory reason) {</span>
 439 |     | <span class='neutral'>                if (reason.length == 0) {</span>
 440 |     | <span class='neutral'>                    revert(&quot;ERC721: transfer to non ERC721Receiver implementer&quot;);</span>
 441 |     | <span class='neutral'>                } else {</span>
 442 |     | <span class='neutral'>                    /// @solidity memory-safe-assembly</span>
 443 |     | <span class='neutral'>                    assembly {</span>
 444 |     | <span class='neutral'>                        revert(add(32, reason), mload(reason))</span>
 445 |     | <span class='neutral'>                    }</span>
 446 |     | <span class='neutral'>                }</span>
 447 |     | <span class='neutral'>            }</span>
 448 |     | <span class='neutral'>        } else {</span>
 449 |     | <span class='neutral'>            return true;</span>
 450 |     | <span class='neutral'>        }</span>
 451 |     | <span class='neutral'>    }</span>
 452 |     | <span class='neutral'></span>
 453 |     | <span class='neutral'>    /**</span>
 454 |     | <span class='neutral'>     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is</span>
 455 |     | <span class='neutral'>     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.</span>
 456 |     | <span class='neutral'>     *</span>
 457 |     | <span class='neutral'>     * Calling conditions:</span>
 458 |     | <span class='neutral'>     *</span>
 459 |     | <span class='neutral'>     * - When `from` and `to` are both non-zero, ``from``&#39;s tokens will be transferred to `to`.</span>
 460 |     | <span class='neutral'>     * - When `from` is zero, the tokens will be minted for `to`.</span>
 461 |     | <span class='neutral'>     * - When `to` is zero, ``from``&#39;s tokens will be burned.</span>
 462 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 463 |     | <span class='neutral'>     * - `batchSize` is non-zero.</span>
 464 |     | <span class='neutral'>     *</span>
 465 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 466 |     | <span class='neutral'>     */</span>
 467 |     | <span class='neutral'>    function _beforeTokenTransfer(</span>
 468 |     | <span class='neutral'>        address from,</span>
 469 |     | <span class='neutral'>        address to,</span>
 470 |     | <span class='neutral'>        uint256, /* firstTokenId */</span>
 471 |     | <span class='neutral'>        uint256 batchSize</span>
 472 |     | <span class='neutral'>    ) internal virtual {</span>
 473 |     | <span class='neutral'>        if (batchSize &gt; 1) {</span>
 474 |     | <span class='neutral'>            if (from != address(0)) {</span>
 475 |     | <span class='neutral'>                _balances[from] -= batchSize;</span>
 476 |     | <span class='neutral'>            }</span>
 477 |     | <span class='neutral'>            if (to != address(0)) {</span>
 478 |     | <span class='neutral'>                _balances[to] += batchSize;</span>
 479 |     | <span class='neutral'>            }</span>
 480 |     | <span class='neutral'>        }</span>
 481 |     | <span class='neutral'>    }</span>
 482 |     | <span class='neutral'></span>
 483 |     | <span class='neutral'>    /**</span>
 484 |     | <span class='neutral'>     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is</span>
 485 |     | <span class='neutral'>     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.</span>
 486 |     | <span class='neutral'>     *</span>
 487 |     | <span class='neutral'>     * Calling conditions:</span>
 488 |     | <span class='neutral'>     *</span>
 489 |     | <span class='neutral'>     * - When `from` and `to` are both non-zero, ``from``&#39;s tokens were transferred to `to`.</span>
 490 |     | <span class='neutral'>     * - When `from` is zero, the tokens were minted for `to`.</span>
 491 |     | <span class='neutral'>     * - When `to` is zero, ``from``&#39;s tokens were burned.</span>
 492 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 493 |     | <span class='neutral'>     * - `batchSize` is non-zero.</span>
 494 |     | <span class='neutral'>     *</span>
 495 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 496 |     | <span class='neutral'>     */</span>
 497 |     | <span class='neutral'>    function _afterTokenTransfer(</span>
 498 |     | <span class='neutral'>        address from,</span>
 499 |     | <span class='neutral'>        address to,</span>
 500 |     | <span class='neutral'>        uint256 firstTokenId,</span>
 501 |     | <span class='neutral'>        uint256 batchSize</span>
 502 |     | <span class='neutral'>    ) internal virtual {}</span>
 503 |     | <span class='neutral'>}</span>
 504 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;../../utils/introspection/IERC165.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/**</span>
   9 |     | <span class='neutral'> * @dev Required interface of an ERC721 compliant contract.</span>
  10 |     | <span class='neutral'> */</span>
  11 |     | <span class='neutral'>interface IERC721 is IERC165 {</span>
  12 |     | <span class='neutral'>    /**</span>
  13 |     | <span class='neutral'>     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.</span>
  14 |     | <span class='neutral'>     */</span>
  15 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /**</span>
  18 |     | <span class='neutral'>     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.</span>
  19 |     | <span class='neutral'>     */</span>
  20 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    /**</span>
  23 |     | <span class='neutral'>     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.</span>
  24 |     | <span class='neutral'>     */</span>
  25 |     | <span class='neutral'>    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /**</span>
  28 |     | <span class='neutral'>     * @dev Returns the number of tokens in ``owner``&#39;s account.</span>
  29 |     | <span class='neutral'>     */</span>
  30 |     | <span class='neutral'>    function balanceOf(address owner) external view returns (uint256 balance);</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    /**</span>
  33 |     | <span class='neutral'>     * @dev Returns the owner of the `tokenId` token.</span>
  34 |     | <span class='neutral'>     *</span>
  35 |     | <span class='neutral'>     * Requirements:</span>
  36 |     | <span class='neutral'>     *</span>
  37 |     | <span class='neutral'>     * - `tokenId` must exist.</span>
  38 |     | <span class='neutral'>     */</span>
  39 |     | <span class='neutral'>    function ownerOf(uint256 tokenId) external view returns (address owner);</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    /**</span>
  42 |     | <span class='neutral'>     * @dev Safely transfers `tokenId` token from `from` to `to`.</span>
  43 |     | <span class='neutral'>     *</span>
  44 |     | <span class='neutral'>     * Requirements:</span>
  45 |     | <span class='neutral'>     *</span>
  46 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
  47 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
  48 |     | <span class='neutral'>     * - `tokenId` token must exist and be owned by `from`.</span>
  49 |     | <span class='neutral'>     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.</span>
  50 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.</span>
  51 |     | <span class='neutral'>     *</span>
  52 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
  53 |     | <span class='neutral'>     */</span>
  54 |     | <span class='neutral'>    function safeTransferFrom(</span>
  55 |     | <span class='neutral'>        address from,</span>
  56 |     | <span class='neutral'>        address to,</span>
  57 |     | <span class='neutral'>        uint256 tokenId,</span>
  58 |     | <span class='neutral'>        bytes calldata data</span>
  59 |     | <span class='neutral'>    ) external;</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    /**</span>
  62 |     | <span class='neutral'>     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients</span>
  63 |     | <span class='neutral'>     * are aware of the ERC721 protocol to prevent tokens from being forever locked.</span>
  64 |     | <span class='neutral'>     *</span>
  65 |     | <span class='neutral'>     * Requirements:</span>
  66 |     | <span class='neutral'>     *</span>
  67 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
  68 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
  69 |     | <span class='neutral'>     * - `tokenId` token must exist and be owned by `from`.</span>
  70 |     | <span class='neutral'>     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.</span>
  71 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.</span>
  72 |     | <span class='neutral'>     *</span>
  73 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
  74 |     | <span class='neutral'>     */</span>
  75 |     | <span class='neutral'>    function safeTransferFrom(</span>
  76 |     | <span class='neutral'>        address from,</span>
  77 |     | <span class='neutral'>        address to,</span>
  78 |     | <span class='neutral'>        uint256 tokenId</span>
  79 |     | <span class='neutral'>    ) external;</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    /**</span>
  82 |     | <span class='neutral'>     * @dev Transfers `tokenId` token from `from` to `to`.</span>
  83 |     | <span class='neutral'>     *</span>
  84 |     | <span class='neutral'>     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721</span>
  85 |     | <span class='neutral'>     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must</span>
  86 |     | <span class='neutral'>     * understand this adds an external call which potentially creates a reentrancy vulnerability.</span>
  87 |     | <span class='neutral'>     *</span>
  88 |     | <span class='neutral'>     * Requirements:</span>
  89 |     | <span class='neutral'>     *</span>
  90 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
  91 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
  92 |     | <span class='neutral'>     * - `tokenId` token must be owned by `from`.</span>
  93 |     | <span class='neutral'>     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.</span>
  94 |     | <span class='neutral'>     *</span>
  95 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
  96 |     | <span class='neutral'>     */</span>
  97 |     | <span class='neutral'>    function transferFrom(</span>
  98 |     | <span class='neutral'>        address from,</span>
  99 |     | <span class='neutral'>        address to,</span>
 100 |     | <span class='neutral'>        uint256 tokenId</span>
 101 |     | <span class='neutral'>    ) external;</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    /**</span>
 104 |     | <span class='neutral'>     * @dev Gives permission to `to` to transfer `tokenId` token to another account.</span>
 105 |     | <span class='neutral'>     * The approval is cleared when the token is transferred.</span>
 106 |     | <span class='neutral'>     *</span>
 107 |     | <span class='neutral'>     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.</span>
 108 |     | <span class='neutral'>     *</span>
 109 |     | <span class='neutral'>     * Requirements:</span>
 110 |     | <span class='neutral'>     *</span>
 111 |     | <span class='neutral'>     * - The caller must own the token or be an approved operator.</span>
 112 |     | <span class='neutral'>     * - `tokenId` must exist.</span>
 113 |     | <span class='neutral'>     *</span>
 114 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 115 |     | <span class='neutral'>     */</span>
 116 |     | <span class='neutral'>    function approve(address to, uint256 tokenId) external;</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    /**</span>
 119 |     | <span class='neutral'>     * @dev Approve or remove `operator` as an operator for the caller.</span>
 120 |     | <span class='neutral'>     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.</span>
 121 |     | <span class='neutral'>     *</span>
 122 |     | <span class='neutral'>     * Requirements:</span>
 123 |     | <span class='neutral'>     *</span>
 124 |     | <span class='neutral'>     * - The `operator` cannot be the caller.</span>
 125 |     | <span class='neutral'>     *</span>
 126 |     | <span class='neutral'>     * Emits an {ApprovalForAll} event.</span>
 127 |     | <span class='neutral'>     */</span>
 128 |     | <span class='neutral'>    function setApprovalForAll(address operator, bool _approved) external;</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    /**</span>
 131 |     | <span class='neutral'>     * @dev Returns the account approved for `tokenId` token.</span>
 132 |     | <span class='neutral'>     *</span>
 133 |     | <span class='neutral'>     * Requirements:</span>
 134 |     | <span class='neutral'>     *</span>
 135 |     | <span class='neutral'>     * - `tokenId` must exist.</span>
 136 |     | <span class='neutral'>     */</span>
 137 |     | <span class='neutral'>    function getApproved(uint256 tokenId) external view returns (address operator);</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    /**</span>
 140 |     | <span class='neutral'>     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.</span>
 141 |     | <span class='neutral'>     *</span>
 142 |     | <span class='neutral'>     * See {setApprovalForAll}</span>
 143 |     | <span class='neutral'>     */</span>
 144 |     | <span class='neutral'>    function isApprovedForAll(address owner, address operator) external view returns (bool);</span>
 145 |     | <span class='neutral'>}</span>
 146 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @title ERC721 token receiver interface</span>
  8 |     | <span class='neutral'> * @dev Interface for any contract that wants to support safeTransfers</span>
  9 |     | <span class='neutral'> * from ERC721 asset contracts.</span>
 10 |     | <span class='neutral'> */</span>
 11 |     | <span class='neutral'>interface IERC721Receiver {</span>
 12 |     | <span class='neutral'>    /**</span>
 13 |     | <span class='neutral'>     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}</span>
 14 |     | <span class='neutral'>     * by `operator` from `from`, this function is called.</span>
 15 |     | <span class='neutral'>     *</span>
 16 |     | <span class='neutral'>     * It must return its Solidity selector to confirm the token transfer.</span>
 17 |     | <span class='neutral'>     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.</span>
 18 |     | <span class='neutral'>     *</span>
 19 |     | <span class='neutral'>     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.</span>
 20 |     | <span class='neutral'>     */</span>
 21 |     | <span class='unexecuted'>    function onERC721Received(</span>
 22 |     | <span class='neutral'>        address operator,</span>
 23 |     | <span class='neutral'>        address from,</span>
 24 |     | <span class='neutral'>        uint256 tokenId,</span>
 25 |     | <span class='neutral'>        bytes calldata data</span>
 26 |     | <span class='neutral'>    ) external returns (bytes4);</span>
 27 |     | <span class='neutral'>}</span>
 28 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../IERC721.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @title ERC-721 Non-Fungible Token Standard, optional metadata extension</span>
 10 |     | <span class='neutral'> * @dev See https://eips.ethereum.org/EIPS/eip-721</span>
 11 |     | <span class='neutral'> */</span>
 12 |     | <span class='neutral'>interface IERC721Metadata is IERC721 {</span>
 13 |     | <span class='neutral'>    /**</span>
 14 |     | <span class='neutral'>     * @dev Returns the token collection name.</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>     * @dev Returns the token collection symbol.</span>
 20 |     | <span class='neutral'>     */</span>
 21 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    /**</span>
 24 |     | <span class='neutral'>     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.</span>
 25 |     | <span class='neutral'>     */</span>
 26 |     | <span class='neutral'>    function tokenURI(uint256 tokenId) external view returns (string memory);</span>
 27 |     | <span class='neutral'>}</span>
 28 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/utils/Address.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.1;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @dev Collection of functions related to the address type</span>
   8 |     | <span class='neutral'> */</span>
   9 |     | <span class='neutral'>library Address {</span>
  10 |     | <span class='neutral'>    /**</span>
  11 |     | <span class='unexecuted'>     * @dev Returns true if `account` is a contract.</span>
  12 |     | <span class='neutral'>     *</span>
  13 |     | <span class='neutral'>     * [IMPORTANT]</span>
  14 |     | <span class='neutral'>     * ====</span>
  15 |     | <span class='unexecuted'>     * It is unsafe to assume that an address for which this function returns</span>
  16 |     | <span class='unexecuted'>     * false is an externally-owned account (EOA) and not a contract.</span>
  17 |     | <span class='neutral'>     *</span>
  18 |     | <span class='unexecuted'>     * Among others, `isContract` will return false for the following</span>
  19 |     | <span class='neutral'>     * types of addresses:</span>
  20 |     | <span class='neutral'>     *</span>
  21 |     | <span class='neutral'>     *  - an externally-owned account</span>
  22 |     | <span class='neutral'>     *  - a contract in construction</span>
  23 |     | <span class='neutral'>     *  - an address where a contract will be created</span>
  24 |     | <span class='neutral'>     *  - an address where a contract lived, but was destroyed</span>
  25 |     | <span class='neutral'>     * ====</span>
  26 |     | <span class='neutral'>     *</span>
  27 |     | <span class='unexecuted'>     * [IMPORTANT]</span>
  28 |     | <span class='neutral'>     * ====</span>
  29 |     | <span class='neutral'>     * You shouldn&#39;t rely on `isContract` to protect against flash loan attacks!</span>
  30 |     | <span class='neutral'>     *</span>
  31 |     | <span class='unexecuted'>     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets</span>
  32 |     | <span class='neutral'>     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract</span>
  33 |     | <span class='neutral'>     * constructor.</span>
  34 |     | <span class='unexecuted'>     * ====</span>
  35 |     | <span class='neutral'>     */</span>
  36 |     | <span class='unexecuted'>    function isContract(address account) internal view returns (bool) {</span>
  37 |     | <span class='unexecuted'>        // This method relies on extcodesize/address.code.length, which returns 0</span>
  38 |     | <span class='neutral'>        // for contracts in construction, since the code is only stored at the end</span>
  39 |     | <span class='unexecuted'>        // of the constructor execution.</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='unexecuted'>        return account.code.length &gt; 0;</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    /**</span>
  45 |     | <span class='unexecuted'>     * @dev Replacement for Solidity&#39;s `transfer`: sends `amount` wei to</span>
  46 |     | <span class='unexecuted'>     * `recipient`, forwarding all available gas and reverting on errors.</span>
  47 |     | <span class='neutral'>     *</span>
  48 |     | <span class='unexecuted'>     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost</span>
  49 |     | <span class='unexecuted'>     * of certain opcodes, possibly making contracts go over the 2300 gas limit</span>
  50 |     | <span class='neutral'>     * imposed by `transfer`, making them unable to receive funds via</span>
  51 |     | <span class='neutral'>     * `transfer`. {sendValue} removes this limitation.</span>
  52 |     | <span class='neutral'>     *</span>
  53 |     | <span class='unexecuted'>     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].</span>
  54 |     | <span class='neutral'>     *</span>
  55 |     | <span class='unexecuted'>     * IMPORTANT: because control is transferred to `recipient`, care must be</span>
  56 |     | <span class='unexecuted'>     * taken to not create reentrancy vulnerabilities. Consider using</span>
  57 |     | <span class='neutral'>     * {ReentrancyGuard} or the</span>
  58 |     | <span class='unexecuted'>     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].</span>
  59 |     | <span class='neutral'>     */</span>
  60 |     | <span class='neutral'>    function sendValue(address payable recipient, uint256 amount) internal {</span>
  61 |     | <span class='neutral'>        require(address(this).balance &gt;= amount, &quot;Address: insufficient balance&quot;);</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>        (bool success, ) = recipient.call{value: amount}(&quot;&quot;);</span>
  64 |     | <span class='neutral'>        require(success, &quot;Address: unable to send value, recipient may have reverted&quot;);</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    /**</span>
  68 |     | <span class='neutral'>     * @dev Performs a Solidity function call using a low level `call`. A</span>
  69 |     | <span class='neutral'>     * plain `call` is an unsafe replacement for a function call: use this</span>
  70 |     | <span class='neutral'>     * function instead.</span>
  71 |     | <span class='neutral'>     *</span>
  72 |     | <span class='neutral'>     * If `target` reverts with a revert reason, it is bubbled up by this</span>
  73 |     | <span class='neutral'>     * function (like regular Solidity function calls).</span>
  74 |     | <span class='neutral'>     *</span>
  75 |     | <span class='neutral'>     * Returns the raw returned data. To convert to the expected return value,</span>
  76 |     | <span class='neutral'>     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].</span>
  77 |     | <span class='neutral'>     *</span>
  78 |     | <span class='neutral'>     * Requirements:</span>
  79 |     | <span class='neutral'>     *</span>
  80 |     | <span class='neutral'>     * - `target` must be a contract.</span>
  81 |     | <span class='neutral'>     * - calling `target` with `data` must not revert.</span>
  82 |     | <span class='neutral'>     *</span>
  83 |     | <span class='neutral'>     * _Available since v3.1._</span>
  84 |     | <span class='neutral'>     */</span>
  85 |     | <span class='neutral'>    function functionCall(address target, bytes memory data) internal returns (bytes memory) {</span>
  86 |     | <span class='neutral'>        return functionCallWithValue(target, data, 0, &quot;Address: low-level call failed&quot;);</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    /**</span>
  90 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with</span>
  91 |     | <span class='neutral'>     * `errorMessage` as a fallback revert reason when `target` reverts.</span>
  92 |     | <span class='neutral'>     *</span>
  93 |     | <span class='neutral'>     * _Available since v3.1._</span>
  94 |     | <span class='neutral'>     */</span>
  95 |     | <span class='neutral'>    function functionCall(</span>
  96 |     | <span class='neutral'>        address target,</span>
  97 |     | <span class='neutral'>        bytes memory data,</span>
  98 |     | <span class='neutral'>        string memory errorMessage</span>
  99 |     | <span class='neutral'>    ) internal returns (bytes memory) {</span>
 100 |     | <span class='neutral'>        return functionCallWithValue(target, data, 0, errorMessage);</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    /**</span>
 104 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
 105 |     | <span class='neutral'>     * but also transferring `value` wei to `target`.</span>
 106 |     | <span class='neutral'>     *</span>
 107 |     | <span class='neutral'>     * Requirements:</span>
 108 |     | <span class='neutral'>     *</span>
 109 |     | <span class='neutral'>     * - the calling contract must have an ETH balance of at least `value`.</span>
 110 |     | <span class='neutral'>     * - the called Solidity function must be `payable`.</span>
 111 |     | <span class='neutral'>     *</span>
 112 |     | <span class='neutral'>     * _Available since v3.1._</span>
 113 |     | <span class='neutral'>     */</span>
 114 |     | <span class='neutral'>    function functionCallWithValue(</span>
 115 |     | <span class='neutral'>        address target,</span>
 116 |     | <span class='neutral'>        bytes memory data,</span>
 117 |     | <span class='neutral'>        uint256 value</span>
 118 |     | <span class='neutral'>    ) internal returns (bytes memory) {</span>
 119 |     | <span class='neutral'>        return functionCallWithValue(target, data, value, &quot;Address: low-level call with value failed&quot;);</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    /**</span>
 123 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but</span>
 124 |     | <span class='neutral'>     * with `errorMessage` as a fallback revert reason when `target` reverts.</span>
 125 |     | <span class='neutral'>     *</span>
 126 |     | <span class='neutral'>     * _Available since v3.1._</span>
 127 |     | <span class='neutral'>     */</span>
 128 |     | <span class='neutral'>    function functionCallWithValue(</span>
 129 |     | <span class='neutral'>        address target,</span>
 130 |     | <span class='neutral'>        bytes memory data,</span>
 131 |     | <span class='neutral'>        uint256 value,</span>
 132 |     | <span class='neutral'>        string memory errorMessage</span>
 133 |     | <span class='neutral'>    ) internal returns (bytes memory) {</span>
 134 |     | <span class='neutral'>        require(address(this).balance &gt;= value, &quot;Address: insufficient balance for call&quot;);</span>
 135 |     | <span class='neutral'>        (bool success, bytes memory returndata) = target.call{value: value}(data);</span>
 136 |     | <span class='neutral'>        return verifyCallResultFromTarget(target, success, returndata, errorMessage);</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    /**</span>
 140 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
 141 |     | <span class='neutral'>     * but performing a static call.</span>
 142 |     | <span class='neutral'>     *</span>
 143 |     | <span class='neutral'>     * _Available since v3.3._</span>
 144 |     | <span class='neutral'>     */</span>
 145 |     | <span class='neutral'>    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {</span>
 146 |     | <span class='neutral'>        return functionStaticCall(target, data, &quot;Address: low-level static call failed&quot;);</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /**</span>
 150 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],</span>
 151 |     | <span class='neutral'>     * but performing a static call.</span>
 152 |     | <span class='neutral'>     *</span>
 153 |     | <span class='neutral'>     * _Available since v3.3._</span>
 154 |     | <span class='neutral'>     */</span>
 155 |     | <span class='neutral'>    function functionStaticCall(</span>
 156 |     | <span class='neutral'>        address target,</span>
 157 |     | <span class='neutral'>        bytes memory data,</span>
 158 |     | <span class='neutral'>        string memory errorMessage</span>
 159 |     | <span class='neutral'>    ) internal view returns (bytes memory) {</span>
 160 |     | <span class='neutral'>        (bool success, bytes memory returndata) = target.staticcall(data);</span>
 161 |     | <span class='neutral'>        return verifyCallResultFromTarget(target, success, returndata, errorMessage);</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    /**</span>
 165 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
 166 |     | <span class='neutral'>     * but performing a delegate call.</span>
 167 |     | <span class='neutral'>     *</span>
 168 |     | <span class='neutral'>     * _Available since v3.4._</span>
 169 |     | <span class='neutral'>     */</span>
 170 |     | <span class='neutral'>    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {</span>
 171 |     | <span class='neutral'>        return functionDelegateCall(target, data, &quot;Address: low-level delegate call failed&quot;);</span>
 172 |     | <span class='neutral'>    }</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>    /**</span>
 175 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],</span>
 176 |     | <span class='neutral'>     * but performing a delegate call.</span>
 177 |     | <span class='neutral'>     *</span>
 178 |     | <span class='neutral'>     * _Available since v3.4._</span>
 179 |     | <span class='neutral'>     */</span>
 180 |     | <span class='neutral'>    function functionDelegateCall(</span>
 181 |     | <span class='neutral'>        address target,</span>
 182 |     | <span class='neutral'>        bytes memory data,</span>
 183 |     | <span class='neutral'>        string memory errorMessage</span>
 184 |     | <span class='neutral'>    ) internal returns (bytes memory) {</span>
 185 |     | <span class='neutral'>        (bool success, bytes memory returndata) = target.delegatecall(data);</span>
 186 |     | <span class='neutral'>        return verifyCallResultFromTarget(target, success, returndata, errorMessage);</span>
 187 |     | <span class='neutral'>    }</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>    /**</span>
 190 |     | <span class='neutral'>     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling</span>
 191 |     | <span class='neutral'>     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.</span>
 192 |     | <span class='neutral'>     *</span>
 193 |     | <span class='neutral'>     * _Available since v4.8._</span>
 194 |     | <span class='neutral'>     */</span>
 195 |     | <span class='neutral'>    function verifyCallResultFromTarget(</span>
 196 |     | <span class='neutral'>        address target,</span>
 197 |     | <span class='neutral'>        bool success,</span>
 198 |     | <span class='neutral'>        bytes memory returndata,</span>
 199 |     | <span class='neutral'>        string memory errorMessage</span>
 200 |     | <span class='neutral'>    ) internal view returns (bytes memory) {</span>
 201 |     | <span class='neutral'>        if (success) {</span>
 202 |     | <span class='neutral'>            if (returndata.length == 0) {</span>
 203 |     | <span class='neutral'>                // only check isContract if the call was successful and the return data is empty</span>
 204 |     | <span class='neutral'>                // otherwise we already know that it was a contract</span>
 205 |     | <span class='neutral'>                require(isContract(target), &quot;Address: call to non-contract&quot;);</span>
 206 |     | <span class='neutral'>            }</span>
 207 |     | <span class='neutral'>            return returndata;</span>
 208 |     | <span class='neutral'>        } else {</span>
 209 |     | <span class='neutral'>            _revert(returndata, errorMessage);</span>
 210 |     | <span class='neutral'>        }</span>
 211 |     | <span class='neutral'>    }</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='neutral'>    /**</span>
 214 |     | <span class='neutral'>     * @dev Tool to verify that a low level call was successful, and revert if it wasn&#39;t, either by bubbling the</span>
 215 |     | <span class='neutral'>     * revert reason or using the provided one.</span>
 216 |     | <span class='neutral'>     *</span>
 217 |     | <span class='neutral'>     * _Available since v4.3._</span>
 218 |     | <span class='neutral'>     */</span>
 219 |     | <span class='neutral'>    function verifyCallResult(</span>
 220 |     | <span class='neutral'>        bool success,</span>
 221 |     | <span class='neutral'>        bytes memory returndata,</span>
 222 |     | <span class='neutral'>        string memory errorMessage</span>
 223 |     | <span class='neutral'>    ) internal pure returns (bytes memory) {</span>
 224 |     | <span class='neutral'>        if (success) {</span>
 225 |     | <span class='neutral'>            return returndata;</span>
 226 |     | <span class='neutral'>        } else {</span>
 227 |     | <span class='neutral'>            _revert(returndata, errorMessage);</span>
 228 |     | <span class='neutral'>        }</span>
 229 |     | <span class='neutral'>    }</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='neutral'>    function _revert(bytes memory returndata, string memory errorMessage) private pure {</span>
 232 |     | <span class='neutral'>        // Look for revert reason and bubble it up if present</span>
 233 |     | <span class='neutral'>        if (returndata.length &gt; 0) {</span>
 234 |     | <span class='neutral'>            // The easiest way to bubble the revert reason is using memory via assembly</span>
 235 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 236 |     | <span class='neutral'>            assembly {</span>
 237 |     | <span class='neutral'>                let returndata_size := mload(returndata)</span>
 238 |     | <span class='neutral'>                revert(add(32, returndata), returndata_size)</span>
 239 |     | <span class='neutral'>            }</span>
 240 |     | <span class='neutral'>        } else {</span>
 241 |     | <span class='neutral'>            revert(errorMessage);</span>
 242 |     | <span class='neutral'>        }</span>
 243 |     | <span class='neutral'>    }</span>
 244 |     | <span class='neutral'>}</span>
 245 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/utils/Context.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Provides information about the current execution context, including the</span>
  8 |     | <span class='neutral'> * sender of the transaction and its data. While these are generally available</span>
  9 |     | <span class='neutral'> * via msg.sender and msg.data, they should not be accessed in such a direct</span>
 10 |     | <span class='neutral'> * manner, since when dealing with meta-transactions the account sending and</span>
 11 |     | <span class='unexecuted'> * paying for execution may not be the actual sender (as far as an application</span>
 12 |     | <span class='neutral'> * is concerned).</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * This contract is only required for intermediate, library-like contracts.</span>
 15 |     | <span class='neutral'> */</span>
 16 |     | <span class='neutral'>abstract contract Context {</span>
 17 |     | <span class='neutral'>    function _msgSender() internal view virtual returns (address) {</span>
 18 |     | <span class='neutral'>        return msg.sender;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function _msgData() internal view virtual returns (bytes calldata) {</span>
 22 |     | <span class='neutral'>        return msg.data;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/utils/Counters.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @title Counters</span>
  8 |     | <span class='neutral'> * @author Matt Condon (@shrugs)</span>
  9 |     | <span class='neutral'> * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number</span>
 10 |     | <span class='neutral'> * of elements in a mapping, issuing ERC721 ids, or counting request ids.</span>
 11 |     | <span class='neutral'> *</span>
 12 |     | <span class='neutral'> * Include with `using Counters for Counters.Counter;`</span>
 13 |     | <span class='neutral'> */</span>
 14 |     | <span class='neutral'>library Counters {</span>
 15 |     | <span class='neutral'>    struct Counter {</span>
 16 |     | <span class='neutral'>        // This variable should never be directly accessed by users of the library: interactions must be restricted to</span>
 17 |     | <span class='neutral'>        // the library&#39;s function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add</span>
 18 |     | <span class='neutral'>        // this feature: see https://github.com/ethereum/solidity/issues/4637</span>
 19 |     | <span class='neutral'>        uint256 _value; // default: 0</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    function current(Counter storage counter) internal view returns (uint256) {</span>
 23 |     | <span class='neutral'>        return counter._value;</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    function increment(Counter storage counter) internal {</span>
 27 |     | <span class='neutral'>        unchecked {</span>
 28 |     | <span class='neutral'>            counter._value += 1;</span>
 29 |     | <span class='neutral'>        }</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    function decrement(Counter storage counter) internal {</span>
 33 |     | <span class='neutral'>        uint256 value = counter._value;</span>
 34 |     | <span class='neutral'>        require(value &gt; 0, &quot;Counter: decrement overflow&quot;);</span>
 35 |     | <span class='neutral'>        unchecked {</span>
 36 |     | <span class='neutral'>            counter._value = value - 1;</span>
 37 |     | <span class='neutral'>        }</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    function reset(Counter storage counter) internal {</span>
 41 |     | <span class='neutral'>        counter._value = 0;</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'>}</span>
 44 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/utils/Strings.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;./math/Math.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev String operations.</span>
 10 |     | <span class='neutral'> */</span>
 11 |     | <span class='neutral'>library Strings {</span>
 12 |     | <span class='neutral'>    bytes16 private constant _SYMBOLS = &quot;0123456789abcdef&quot;;</span>
 13 |     | <span class='neutral'>    uint8 private constant _ADDRESS_LENGTH = 20;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    /**</span>
 16 |     | <span class='neutral'>     * @dev Converts a `uint256` to its ASCII `string` decimal representation.</span>
 17 |     | <span class='neutral'>     */</span>
 18 |     | <span class='neutral'>    function toString(uint256 value) internal pure returns (string memory) {</span>
 19 |     | <span class='neutral'>        unchecked {</span>
 20 |     | <span class='neutral'>            uint256 length = Math.log10(value) + 1;</span>
 21 |     | <span class='neutral'>            string memory buffer = new string(length);</span>
 22 |     | <span class='neutral'>            uint256 ptr;</span>
 23 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 24 |     | <span class='neutral'>            assembly {</span>
 25 |     | <span class='neutral'>                ptr := add(buffer, add(32, length))</span>
 26 |     | <span class='neutral'>            }</span>
 27 |     | <span class='neutral'>            while (true) {</span>
 28 |     | <span class='neutral'>                ptr--;</span>
 29 |     | <span class='neutral'>                /// @solidity memory-safe-assembly</span>
 30 |     | <span class='neutral'>                assembly {</span>
 31 |     | <span class='neutral'>                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))</span>
 32 |     | <span class='neutral'>                }</span>
 33 |     | <span class='neutral'>                value /= 10;</span>
 34 |     | <span class='neutral'>                if (value == 0) break;</span>
 35 |     | <span class='neutral'>            }</span>
 36 |     | <span class='neutral'>            return buffer;</span>
 37 |     | <span class='neutral'>        }</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    /**</span>
 41 |     | <span class='neutral'>     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.</span>
 42 |     | <span class='neutral'>     */</span>
 43 |     | <span class='neutral'>    function toHexString(uint256 value) internal pure returns (string memory) {</span>
 44 |     | <span class='neutral'>        unchecked {</span>
 45 |     | <span class='neutral'>            return toHexString(value, Math.log256(value) + 1);</span>
 46 |     | <span class='neutral'>        }</span>
 47 |     | <span class='neutral'>    }</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='neutral'>    /**</span>
 50 |     | <span class='neutral'>     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.</span>
 51 |     | <span class='neutral'>     */</span>
 52 |     | <span class='neutral'>    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {</span>
 53 |     | <span class='neutral'>        bytes memory buffer = new bytes(2 * length + 2);</span>
 54 |     | <span class='neutral'>        buffer[0] = &quot;0&quot;;</span>
 55 |     | <span class='neutral'>        buffer[1] = &quot;x&quot;;</span>
 56 |     | <span class='neutral'>        for (uint256 i = 2 * length + 1; i &gt; 1; --i) {</span>
 57 |     | <span class='neutral'>            buffer[i] = _SYMBOLS[value &amp; 0xf];</span>
 58 |     | <span class='neutral'>            value &gt;&gt;= 4;</span>
 59 |     | <span class='neutral'>        }</span>
 60 |     | <span class='neutral'>        require(value == 0, &quot;Strings: hex length insufficient&quot;);</span>
 61 |     | <span class='neutral'>        return string(buffer);</span>
 62 |     | <span class='neutral'>    }</span>
 63 |     | <span class='neutral'></span>
 64 |     | <span class='neutral'>    /**</span>
 65 |     | <span class='neutral'>     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.</span>
 66 |     | <span class='neutral'>     */</span>
 67 |     | <span class='neutral'>    function toHexString(address addr) internal pure returns (string memory) {</span>
 68 |     | <span class='neutral'>        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);</span>
 69 |     | <span class='neutral'>    }</span>
 70 |     | <span class='neutral'>}</span>
 71 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;../Strings.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/**</span>
   9 |     | <span class='neutral'> * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.</span>
  10 |     | <span class='neutral'> *</span>
  11 |     | <span class='neutral'> * These functions can be used to verify that a message was signed by the holder</span>
  12 |     | <span class='neutral'> * of the private keys of a given address.</span>
  13 |     | <span class='neutral'> */</span>
  14 |     | <span class='neutral'>library ECDSA {</span>
  15 |     | <span class='neutral'>    enum RecoverError {</span>
  16 |     | <span class='neutral'>        NoError,</span>
  17 |     | <span class='neutral'>        InvalidSignature,</span>
  18 |     | <span class='neutral'>        InvalidSignatureLength,</span>
  19 |     | <span class='neutral'>        InvalidSignatureS,</span>
  20 |     | <span class='neutral'>        InvalidSignatureV // Deprecated in v4.8</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    function _throwError(RecoverError error) private pure {</span>
  24 |     | <span class='neutral'>        if (error == RecoverError.NoError) {</span>
  25 |     | <span class='neutral'>            return; // no error: do nothing</span>
  26 |     | <span class='neutral'>        } else if (error == RecoverError.InvalidSignature) {</span>
  27 |     | <span class='neutral'>            revert(&quot;ECDSA: invalid signature&quot;);</span>
  28 |     | <span class='neutral'>        } else if (error == RecoverError.InvalidSignatureLength) {</span>
  29 |     | <span class='neutral'>            revert(&quot;ECDSA: invalid signature length&quot;);</span>
  30 |     | <span class='neutral'>        } else if (error == RecoverError.InvalidSignatureS) {</span>
  31 |     | <span class='neutral'>            revert(&quot;ECDSA: invalid signature &#39;s&#39; value&quot;);</span>
  32 |     | <span class='neutral'>        }</span>
  33 |     | <span class='neutral'>    }</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    /**</span>
  36 |     | <span class='neutral'>     * @dev Returns the address that signed a hashed message (`hash`) with</span>
  37 |     | <span class='neutral'>     * `signature` or error string. This address can then be used for verification purposes.</span>
  38 |     | <span class='neutral'>     *</span>
  39 |     | <span class='neutral'>     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:</span>
  40 |     | <span class='neutral'>     * this function rejects them by requiring the `s` value to be in the lower</span>
  41 |     | <span class='neutral'>     * half order, and the `v` value to be either 27 or 28.</span>
  42 |     | <span class='neutral'>     *</span>
  43 |     | <span class='neutral'>     * IMPORTANT: `hash` _must_ be the result of a hash operation for the</span>
  44 |     | <span class='neutral'>     * verification to be secure: it is possible to craft signatures that</span>
  45 |     | <span class='neutral'>     * recover to arbitrary addresses for non-hashed data. A safe way to ensure</span>
  46 |     | <span class='neutral'>     * this is by receiving a hash of the original message (which may otherwise</span>
  47 |     | <span class='neutral'>     * be too long), and then calling {toEthSignedMessageHash} on it.</span>
  48 |     | <span class='neutral'>     *</span>
  49 |     | <span class='neutral'>     * Documentation for signature generation:</span>
  50 |     | <span class='neutral'>     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]</span>
  51 |     | <span class='neutral'>     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]</span>
  52 |     | <span class='neutral'>     *</span>
  53 |     | <span class='neutral'>     * _Available since v4.3._</span>
  54 |     | <span class='neutral'>     */</span>
  55 |     | <span class='neutral'>    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {</span>
  56 |     | <span class='neutral'>        if (signature.length == 65) {</span>
  57 |     | <span class='neutral'>            bytes32 r;</span>
  58 |     | <span class='neutral'>            bytes32 s;</span>
  59 |     | <span class='neutral'>            uint8 v;</span>
  60 |     | <span class='neutral'>            // ecrecover takes the signature parameters, and the only way to get them</span>
  61 |     | <span class='neutral'>            // currently is to use assembly.</span>
  62 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
  63 |     | <span class='neutral'>            assembly {</span>
  64 |     | <span class='neutral'>                r := mload(add(signature, 0x20))</span>
  65 |     | <span class='neutral'>                s := mload(add(signature, 0x40))</span>
  66 |     | <span class='neutral'>                v := byte(0, mload(add(signature, 0x60)))</span>
  67 |     | <span class='neutral'>            }</span>
  68 |     | <span class='neutral'>            return tryRecover(hash, v, r, s);</span>
  69 |     | <span class='neutral'>        } else {</span>
  70 |     | <span class='neutral'>            return (address(0), RecoverError.InvalidSignatureLength);</span>
  71 |     | <span class='neutral'>        }</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    /**</span>
  75 |     | <span class='neutral'>     * @dev Returns the address that signed a hashed message (`hash`) with</span>
  76 |     | <span class='neutral'>     * `signature`. This address can then be used for verification purposes.</span>
  77 |     | <span class='neutral'>     *</span>
  78 |     | <span class='neutral'>     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:</span>
  79 |     | <span class='neutral'>     * this function rejects them by requiring the `s` value to be in the lower</span>
  80 |     | <span class='neutral'>     * half order, and the `v` value to be either 27 or 28.</span>
  81 |     | <span class='neutral'>     *</span>
  82 |     | <span class='neutral'>     * IMPORTANT: `hash` _must_ be the result of a hash operation for the</span>
  83 |     | <span class='neutral'>     * verification to be secure: it is possible to craft signatures that</span>
  84 |     | <span class='neutral'>     * recover to arbitrary addresses for non-hashed data. A safe way to ensure</span>
  85 |     | <span class='neutral'>     * this is by receiving a hash of the original message (which may otherwise</span>
  86 |     | <span class='neutral'>     * be too long), and then calling {toEthSignedMessageHash} on it.</span>
  87 |     | <span class='neutral'>     */</span>
  88 |     | <span class='neutral'>    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {</span>
  89 |     | <span class='neutral'>        (address recovered, RecoverError error) = tryRecover(hash, signature);</span>
  90 |     | <span class='neutral'>        _throwError(error);</span>
  91 |     | <span class='neutral'>        return recovered;</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    /**</span>
  95 |     | <span class='neutral'>     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.</span>
  96 |     | <span class='neutral'>     *</span>
  97 |     | <span class='neutral'>     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]</span>
  98 |     | <span class='neutral'>     *</span>
  99 |     | <span class='neutral'>     * _Available since v4.3._</span>
 100 |     | <span class='neutral'>     */</span>
 101 |     | <span class='neutral'>    function tryRecover(</span>
 102 |     | <span class='neutral'>        bytes32 hash,</span>
 103 |     | <span class='neutral'>        bytes32 r,</span>
 104 |     | <span class='neutral'>        bytes32 vs</span>
 105 |     | <span class='neutral'>    ) internal pure returns (address, RecoverError) {</span>
 106 |     | <span class='neutral'>        bytes32 s = vs &amp; bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);</span>
 107 |     | <span class='neutral'>        uint8 v = uint8((uint256(vs) &gt;&gt; 255) + 27);</span>
 108 |     | <span class='neutral'>        return tryRecover(hash, v, r, s);</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    /**</span>
 112 |     | <span class='neutral'>     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.</span>
 113 |     | <span class='neutral'>     *</span>
 114 |     | <span class='neutral'>     * _Available since v4.2._</span>
 115 |     | <span class='neutral'>     */</span>
 116 |     | <span class='neutral'>    function recover(</span>
 117 |     | <span class='neutral'>        bytes32 hash,</span>
 118 |     | <span class='neutral'>        bytes32 r,</span>
 119 |     | <span class='neutral'>        bytes32 vs</span>
 120 |     | <span class='neutral'>    ) internal pure returns (address) {</span>
 121 |     | <span class='neutral'>        (address recovered, RecoverError error) = tryRecover(hash, r, vs);</span>
 122 |     | <span class='neutral'>        _throwError(error);</span>
 123 |     | <span class='neutral'>        return recovered;</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /**</span>
 127 |     | <span class='neutral'>     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,</span>
 128 |     | <span class='neutral'>     * `r` and `s` signature fields separately.</span>
 129 |     | <span class='neutral'>     *</span>
 130 |     | <span class='neutral'>     * _Available since v4.3._</span>
 131 |     | <span class='neutral'>     */</span>
 132 |     | <span class='neutral'>    function tryRecover(</span>
 133 |     | <span class='neutral'>        bytes32 hash,</span>
 134 |     | <span class='neutral'>        uint8 v,</span>
 135 |     | <span class='neutral'>        bytes32 r,</span>
 136 |     | <span class='neutral'>        bytes32 s</span>
 137 |     | <span class='neutral'>    ) internal pure returns (address, RecoverError) {</span>
 138 |     | <span class='neutral'>        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature</span>
 139 |     | <span class='neutral'>        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines</span>
 140 |     | <span class='neutral'>        // the valid range for s in (301): 0 &lt; s &lt; secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most</span>
 141 |     | <span class='neutral'>        // signatures from current libraries generate a unique signature with an s-value in the lower half order.</span>
 142 |     | <span class='neutral'>        //</span>
 143 |     | <span class='neutral'>        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value</span>
 144 |     | <span class='neutral'>        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or</span>
 145 |     | <span class='neutral'>        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept</span>
 146 |     | <span class='neutral'>        // these malleable signatures as well.</span>
 147 |     | <span class='neutral'>        if (uint256(s) &gt; 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {</span>
 148 |     | <span class='neutral'>            return (address(0), RecoverError.InvalidSignatureS);</span>
 149 |     | <span class='neutral'>        }</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='neutral'>        // If the signature is valid (and not malleable), return the signer address</span>
 152 |     | <span class='neutral'>        address signer = ecrecover(hash, v, r, s);</span>
 153 |     | <span class='neutral'>        if (signer == address(0)) {</span>
 154 |     | <span class='neutral'>            return (address(0), RecoverError.InvalidSignature);</span>
 155 |     | <span class='neutral'>        }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>        return (signer, RecoverError.NoError);</span>
 158 |     | <span class='neutral'>    }</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>    /**</span>
 161 |     | <span class='neutral'>     * @dev Overload of {ECDSA-recover} that receives the `v`,</span>
 162 |     | <span class='neutral'>     * `r` and `s` signature fields separately.</span>
 163 |     | <span class='neutral'>     */</span>
 164 |     | <span class='neutral'>    function recover(</span>
 165 |     | <span class='neutral'>        bytes32 hash,</span>
 166 |     | <span class='neutral'>        uint8 v,</span>
 167 |     | <span class='neutral'>        bytes32 r,</span>
 168 |     | <span class='neutral'>        bytes32 s</span>
 169 |     | <span class='neutral'>    ) internal pure returns (address) {</span>
 170 |     | <span class='neutral'>        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);</span>
 171 |     | <span class='neutral'>        _throwError(error);</span>
 172 |     | <span class='neutral'>        return recovered;</span>
 173 |     | <span class='neutral'>    }</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>    /**</span>
 176 |     | <span class='neutral'>     * @dev Returns an Ethereum Signed Message, created from a `hash`. This</span>
 177 |     | <span class='neutral'>     * produces hash corresponding to the one signed with the</span>
 178 |     | <span class='neutral'>     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]</span>
 179 |     | <span class='neutral'>     * JSON-RPC method as part of EIP-191.</span>
 180 |     | <span class='neutral'>     *</span>
 181 |     | <span class='neutral'>     * See {recover}.</span>
 182 |     | <span class='neutral'>     */</span>
 183 |     | <span class='neutral'>    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {</span>
 184 |     | <span class='neutral'>        // 32 is the length in bytes of hash,</span>
 185 |     | <span class='neutral'>        // enforced by the type signature above</span>
 186 |     | <span class='neutral'>        return keccak256(abi.encodePacked(&quot;\x19Ethereum Signed Message:\n32&quot;, hash));</span>
 187 |     | <span class='neutral'>    }</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>    /**</span>
 190 |     | <span class='neutral'>     * @dev Returns an Ethereum Signed Message, created from `s`. This</span>
 191 |     | <span class='neutral'>     * produces hash corresponding to the one signed with the</span>
 192 |     | <span class='neutral'>     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]</span>
 193 |     | <span class='neutral'>     * JSON-RPC method as part of EIP-191.</span>
 194 |     | <span class='neutral'>     *</span>
 195 |     | <span class='neutral'>     * See {recover}.</span>
 196 |     | <span class='neutral'>     */</span>
 197 |     | <span class='neutral'>    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {</span>
 198 |     | <span class='neutral'>        return keccak256(abi.encodePacked(&quot;\x19Ethereum Signed Message:\n&quot;, Strings.toString(s.length), s));</span>
 199 |     | <span class='neutral'>    }</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='neutral'>    /**</span>
 202 |     | <span class='neutral'>     * @dev Returns an Ethereum Signed Typed Data, created from a</span>
 203 |     | <span class='neutral'>     * `domainSeparator` and a `structHash`. This produces hash corresponding</span>
 204 |     | <span class='neutral'>     * to the one signed with the</span>
 205 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]</span>
 206 |     | <span class='neutral'>     * JSON-RPC method as part of EIP-712.</span>
 207 |     | <span class='neutral'>     *</span>
 208 |     | <span class='neutral'>     * See {recover}.</span>
 209 |     | <span class='neutral'>     */</span>
 210 |     | <span class='neutral'>    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {</span>
 211 |     | <span class='neutral'>        return keccak256(abi.encodePacked(&quot;\x19\x01&quot;, domainSeparator, structHash));</span>
 212 |     | <span class='neutral'>    }</span>
 213 |     | <span class='neutral'>}</span>
 214 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/utils/cryptography/EIP712.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/EIP712.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;./ECDSA.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/**</span>
   9 |     | <span class='neutral'> * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.</span>
  10 |     | <span class='neutral'> *</span>
  11 |     | <span class='neutral'> * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,</span>
  12 |     | <span class='neutral'> * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding</span>
  13 |     | <span class='neutral'> * they need in their contracts using a combination of `abi.encode` and `keccak256`.</span>
  14 |     | <span class='neutral'> *</span>
  15 |     | <span class='neutral'> * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding</span>
  16 |     | <span class='neutral'> * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA</span>
  17 |     | <span class='neutral'> * ({_hashTypedDataV4}).</span>
  18 |     | <span class='neutral'> *</span>
  19 |     | <span class='neutral'> * The implementation of the domain separator was designed to be as efficient as possible while still properly updating</span>
  20 |     | <span class='neutral'> * the chain id to protect against replay attacks on an eventual fork of the chain.</span>
  21 |     | <span class='neutral'> *</span>
  22 |     | <span class='neutral'> * NOTE: This contract implements the version of the encoding known as &quot;v4&quot;, as implemented by the JSON RPC method</span>
  23 |     | <span class='neutral'> * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].</span>
  24 |     | <span class='neutral'> *</span>
  25 |     | <span class='neutral'> * _Available since v3.4._</span>
  26 |     | <span class='neutral'> */</span>
  27 |     | <span class='neutral'>abstract contract EIP712 {</span>
  28 |     | <span class='neutral'>    /* solhint-disable var-name-mixedcase */</span>
  29 |     | <span class='neutral'>    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to</span>
  30 |     | <span class='neutral'>    // invalidate the cached domain separator if the chain id changes.</span>
  31 |     | <span class='neutral'>    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;</span>
  32 |     | <span class='neutral'>    uint256 private immutable _CACHED_CHAIN_ID;</span>
  33 |     | <span class='neutral'>    address private immutable _CACHED_THIS;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    bytes32 private immutable _HASHED_NAME;</span>
  36 |     | <span class='neutral'>    bytes32 private immutable _HASHED_VERSION;</span>
  37 |     | <span class='neutral'>    bytes32 private immutable _TYPE_HASH;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    /* solhint-enable var-name-mixedcase */</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    /**</span>
  42 |     | <span class='neutral'>     * @dev Initializes the domain separator and parameter caches.</span>
  43 |     | <span class='neutral'>     *</span>
  44 |     | <span class='neutral'>     * The meaning of `name` and `version` is specified in</span>
  45 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:</span>
  46 |     | <span class='neutral'>     *</span>
  47 |     | <span class='neutral'>     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.</span>
  48 |     | <span class='neutral'>     * - `version`: the current major version of the signing domain.</span>
  49 |     | <span class='neutral'>     *</span>
  50 |     | <span class='neutral'>     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart</span>
  51 |     | <span class='neutral'>     * contract upgrade].</span>
  52 |     | <span class='neutral'>     */</span>
  53 |     | <span class='neutral'>    constructor(string memory name, string memory version) {</span>
  54 |     | <span class='neutral'>        bytes32 hashedName = keccak256(bytes(name));</span>
  55 |     | <span class='neutral'>        bytes32 hashedVersion = keccak256(bytes(version));</span>
  56 |     | <span class='neutral'>        bytes32 typeHash = keccak256(</span>
  57 |     | <span class='neutral'>            &quot;EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)&quot;</span>
  58 |     | <span class='neutral'>        );</span>
  59 |     | <span class='neutral'>        _HASHED_NAME = hashedName;</span>
  60 |     | <span class='neutral'>        _HASHED_VERSION = hashedVersion;</span>
  61 |     | <span class='neutral'>        _CACHED_CHAIN_ID = block.chainid;</span>
  62 |     | <span class='neutral'>        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);</span>
  63 |     | <span class='neutral'>        _CACHED_THIS = address(this);</span>
  64 |     | <span class='neutral'>        _TYPE_HASH = typeHash;</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    /**</span>
  68 |     | <span class='neutral'>     * @dev Returns the domain separator for the current chain.</span>
  69 |     | <span class='neutral'>     */</span>
  70 |     | <span class='neutral'>    function _domainSeparatorV4() internal view returns (bytes32) {</span>
  71 |     | <span class='neutral'>        if (address(this) == _CACHED_THIS &amp;&amp; block.chainid == _CACHED_CHAIN_ID) {</span>
  72 |     | <span class='neutral'>            return _CACHED_DOMAIN_SEPARATOR;</span>
  73 |     | <span class='neutral'>        } else {</span>
  74 |     | <span class='neutral'>            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);</span>
  75 |     | <span class='neutral'>        }</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    function _buildDomainSeparator(</span>
  79 |     | <span class='neutral'>        bytes32 typeHash,</span>
  80 |     | <span class='neutral'>        bytes32 nameHash,</span>
  81 |     | <span class='neutral'>        bytes32 versionHash</span>
  82 |     | <span class='neutral'>    ) private view returns (bytes32) {</span>
  83 |     | <span class='neutral'>        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    /**</span>
  87 |     | <span class='neutral'>     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this</span>
  88 |     | <span class='neutral'>     * function returns the hash of the fully encoded EIP712 message for this domain.</span>
  89 |     | <span class='neutral'>     *</span>
  90 |     | <span class='neutral'>     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:</span>
  91 |     | <span class='neutral'>     *</span>
  92 |     | <span class='neutral'>     * ```solidity</span>
  93 |     | <span class='neutral'>     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(</span>
  94 |     | <span class='neutral'>     *     keccak256(&quot;Mail(address to,string contents)&quot;),</span>
  95 |     | <span class='neutral'>     *     mailTo,</span>
  96 |     | <span class='neutral'>     *     keccak256(bytes(mailContents))</span>
  97 |     | <span class='neutral'>     * )));</span>
  98 |     | <span class='neutral'>     * address signer = ECDSA.recover(digest, signature);</span>
  99 |     | <span class='neutral'>     * ```</span>
 100 |     | <span class='neutral'>     */</span>
 101 |     | <span class='neutral'>    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {</span>
 102 |     | <span class='neutral'>        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'>}</span>
 105 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/SignatureChecker.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;./ECDSA.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../Address.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;../../interfaces/IERC1271.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>/**</span>
 11 |     | <span class='neutral'> * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA</span>
 12 |     | <span class='neutral'> * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like</span>
 13 |     | <span class='neutral'> * Argent and Gnosis Safe.</span>
 14 |     | <span class='neutral'> *</span>
 15 |     | <span class='neutral'> * _Available since v4.1._</span>
 16 |     | <span class='neutral'> */</span>
 17 |     | <span class='neutral'>library SignatureChecker {</span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the</span>
 20 |     | <span class='neutral'>     * signature is validated against that smart contract using ERC1271, otherwise it&#39;s validated using `ECDSA.recover`.</span>
 21 |     | <span class='neutral'>     *</span>
 22 |     | <span class='neutral'>     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus</span>
 23 |     | <span class='neutral'>     * change through time. It could return true at block N and false at block N+1 (or the opposite).</span>
 24 |     | <span class='neutral'>     */</span>
 25 |     | <span class='neutral'>    function isValidSignatureNow(</span>
 26 |     | <span class='neutral'>        address signer,</span>
 27 |     | <span class='neutral'>        bytes32 hash,</span>
 28 |     | <span class='neutral'>        bytes memory signature</span>
 29 |     | <span class='neutral'>    ) internal view returns (bool) {</span>
 30 |     | <span class='neutral'>        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);</span>
 31 |     | <span class='neutral'>        if (error == ECDSA.RecoverError.NoError &amp;&amp; recovered == signer) {</span>
 32 |     | <span class='neutral'>            return true;</span>
 33 |     | <span class='neutral'>        }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>        (bool success, bytes memory result) = signer.staticcall(</span>
 36 |     | <span class='neutral'>            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)</span>
 37 |     | <span class='neutral'>        );</span>
 38 |     | <span class='neutral'>        return (success &amp;&amp;</span>
 39 |     | <span class='neutral'>            result.length == 32 &amp;&amp;</span>
 40 |     | <span class='neutral'>            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'>}</span>
 43 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;./IERC165.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Implementation of the {IERC165} interface.</span>
 10 |     | <span class='neutral'> *</span>
 11 |     | <span class='neutral'> * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check</span>
 12 |     | <span class='neutral'> * for the additional interface id that will be supported. For example:</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * ```solidity</span>
 15 | r   | <span class='reverted'> * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {</span>
 16 |     | <span class='neutral'> *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);</span>
 17 |     | <span class='neutral'> * }</span>
 18 |     | <span class='neutral'> * ```</span>
 19 |     | <span class='neutral'> *</span>
 20 |     | <span class='neutral'> * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.</span>
 21 |     | <span class='neutral'> */</span>
 22 |     | <span class='neutral'>abstract contract ERC165 is IERC165 {</span>
 23 |     | <span class='neutral'>    /**</span>
 24 |     | <span class='neutral'>     * @dev See {IERC165-supportsInterface}.</span>
 25 |     | <span class='neutral'>     */</span>
 26 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {</span>
 27 |     | <span class='neutral'>        return interfaceId == type(IERC165).interfaceId;</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'>}</span>
 30 | r   | <span class='reverted'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC165 standard, as defined in the</span>
  8 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-165[EIP].</span>
  9 |     | <span class='neutral'> *</span>
 10 |     | <span class='neutral'> * Implementers can declare support of contract interfaces, which can then be</span>
 11 |     | <span class='neutral'> * queried by others ({ERC165Checker}).</span>
 12 |     | <span class='neutral'> *</span>
 13 |     | <span class='neutral'> * For an implementation, see {ERC165}.</span>
 14 |     | <span class='neutral'> */</span>
 15 |     | <span class='neutral'>interface IERC165 {</span>
 16 |     | <span class='neutral'>    /**</span>
 17 |     | <span class='neutral'>     * @dev Returns true if this contract implements the interface defined by</span>
 18 |     | <span class='neutral'>     * `interfaceId`. See the corresponding</span>
 19 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]</span>
 20 |     | <span class='neutral'>     * to learn more about how these ids are created.</span>
 21 |     | <span class='neutral'>     *</span>
 22 |     | <span class='neutral'>     * This function call must use less than 30 000 gas.</span>
 23 |     | <span class='neutral'>     */</span>
 24 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceId) external view returns (bool);</span>
 25 |     | <span class='neutral'>}</span>
 26 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/utils/math/Math.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @dev Standard math utilities missing in the Solidity language.</span>
   8 |     | <span class='neutral'> */</span>
   9 |     | <span class='neutral'>library Math {</span>
  10 |     | <span class='neutral'>    enum Rounding {</span>
  11 |     | <span class='neutral'>        Down, // Toward negative infinity</span>
  12 |     | <span class='neutral'>        Up, // Toward infinity</span>
  13 |     | <span class='neutral'>        Zero // Toward zero</span>
  14 |     | <span class='neutral'>    }</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    /**</span>
  17 |     | <span class='unexecuted'>     * @dev Returns the largest of two numbers.</span>
  18 |     | <span class='neutral'>     */</span>
  19 |     | <span class='neutral'>    function max(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  20 |     | <span class='neutral'>        return a &gt; b ? a : b;</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    /**</span>
  24 |     | <span class='neutral'>     * @dev Returns the smallest of two numbers.</span>
  25 |     | <span class='neutral'>     */</span>
  26 |     | <span class='neutral'>    function min(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  27 |     | <span class='neutral'>        return a &lt; b ? a : b;</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /**</span>
  31 |     | <span class='unexecuted'>     * @dev Returns the average of two numbers. The result is rounded towards</span>
  32 |     | <span class='unexecuted'>     * zero.</span>
  33 |     | <span class='neutral'>     */</span>
  34 |     | <span class='neutral'>    function average(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  35 |     | <span class='neutral'>        // (a + b) / 2 can overflow.</span>
  36 |     | <span class='neutral'>        return (a &amp; b) + (a ^ b) / 2;</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    /**</span>
  40 |     | <span class='neutral'>     * @dev Returns the ceiling of the division of two numbers.</span>
  41 |     | <span class='neutral'>     *</span>
  42 |     | <span class='unexecuted'>     * This differs from standard division with `/` in that it rounds up instead</span>
  43 |     | <span class='neutral'>     * of rounding down.</span>
  44 |     | <span class='neutral'>     */</span>
  45 |     | <span class='unexecuted'>    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  46 |     | <span class='unexecuted'>        // (a + b - 1) / b can overflow on addition, so we distribute.</span>
  47 |     | <span class='neutral'>        return a == 0 ? 0 : (a - 1) / b + 1;</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /**</span>
  51 |     | <span class='unexecuted'>     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0</span>
  52 |     | <span class='neutral'>     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)</span>
  53 |     | <span class='neutral'>     * with further edits by Uniswap Labs also under MIT license.</span>
  54 |     | <span class='neutral'>     */</span>
  55 |     | <span class='neutral'>    function mulDiv(</span>
  56 |     | <span class='neutral'>        uint256 x,</span>
  57 |     | <span class='neutral'>        uint256 y,</span>
  58 |     | <span class='neutral'>        uint256 denominator</span>
  59 |     | <span class='neutral'>    ) internal pure returns (uint256 result) {</span>
  60 |     | <span class='neutral'>        unchecked {</span>
  61 |     | <span class='neutral'>            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use</span>
  62 |     | <span class='neutral'>            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256</span>
  63 |     | <span class='neutral'>            // variables such that product = prod1 * 2^256 + prod0.</span>
  64 |     | <span class='neutral'>            uint256 prod0; // Least significant 256 bits of the product</span>
  65 |     | <span class='neutral'>            uint256 prod1; // Most significant 256 bits of the product</span>
  66 |     | <span class='neutral'>            assembly {</span>
  67 |     | <span class='neutral'>                let mm := mulmod(x, y, not(0))</span>
  68 |     | <span class='neutral'>                prod0 := mul(x, y)</span>
  69 |     | <span class='neutral'>                prod1 := sub(sub(mm, prod0), lt(mm, prod0))</span>
  70 |     | <span class='neutral'>            }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>            // Handle non-overflow cases, 256 by 256 division.</span>
  73 |     | <span class='neutral'>            if (prod1 == 0) {</span>
  74 |     | <span class='neutral'>                return prod0 / denominator;</span>
  75 |     | <span class='neutral'>            }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>            // Make sure the result is less than 2^256. Also prevents denominator == 0.</span>
  78 |     | <span class='neutral'>            require(denominator &gt; prod1);</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>            ///////////////////////////////////////////////</span>
  81 |     | <span class='neutral'>            // 512 by 256 division.</span>
  82 |     | <span class='neutral'>            ///////////////////////////////////////////////</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>            // Make division exact by subtracting the remainder from [prod1 prod0].</span>
  85 |     | <span class='neutral'>            uint256 remainder;</span>
  86 |     | <span class='neutral'>            assembly {</span>
  87 |     | <span class='neutral'>                // Compute remainder using mulmod.</span>
  88 |     | <span class='neutral'>                remainder := mulmod(x, y, denominator)</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>                // Subtract 256 bit number from 512 bit number.</span>
  91 |     | <span class='neutral'>                prod1 := sub(prod1, gt(remainder, prod0))</span>
  92 |     | <span class='neutral'>                prod0 := sub(prod0, remainder)</span>
  93 |     | <span class='neutral'>            }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always &gt;= 1.</span>
  96 |     | <span class='neutral'>            // See https://cs.stackexchange.com/q/138556/92363.</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>            // Does not overflow because the denominator cannot be zero at this stage in the function.</span>
  99 |     | <span class='neutral'>            uint256 twos = denominator &amp; (~denominator + 1);</span>
 100 |     | <span class='neutral'>            assembly {</span>
 101 |     | <span class='neutral'>                // Divide denominator by twos.</span>
 102 |     | <span class='neutral'>                denominator := div(denominator, twos)</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>                // Divide [prod1 prod0] by twos.</span>
 105 |     | <span class='neutral'>                prod0 := div(prod0, twos)</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.</span>
 108 |     | <span class='neutral'>                twos := add(div(sub(0, twos), twos), 1)</span>
 109 |     | <span class='neutral'>            }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>            // Shift in bits from prod1 into prod0.</span>
 112 |     | <span class='neutral'>            prod0 |= prod1 * twos;</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such</span>
 115 |     | <span class='neutral'>            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for</span>
 116 |     | <span class='neutral'>            // four bits. That is, denominator * inv = 1 mod 2^4.</span>
 117 |     | <span class='neutral'>            uint256 inverse = (3 * denominator) ^ 2;</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel&#39;s lifting lemma, this also works</span>
 120 |     | <span class='neutral'>            // in modular arithmetic, doubling the correct bits in each step.</span>
 121 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^8</span>
 122 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^16</span>
 123 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^32</span>
 124 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^64</span>
 125 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^128</span>
 126 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^256</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='neutral'>            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.</span>
 129 |     | <span class='neutral'>            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is</span>
 130 |     | <span class='neutral'>            // less than 2^256, this is the final result. We don&#39;t need to compute the high bits of the result and prod1</span>
 131 |     | <span class='neutral'>            // is no longer required.</span>
 132 |     | <span class='neutral'>            result = prod0 * inverse;</span>
 133 |     | <span class='neutral'>            return result;</span>
 134 |     | <span class='neutral'>        }</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>    /**</span>
 138 |     | <span class='neutral'>     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.</span>
 139 |     | <span class='neutral'>     */</span>
 140 |     | <span class='neutral'>    function mulDiv(</span>
 141 |     | <span class='neutral'>        uint256 x,</span>
 142 |     | <span class='neutral'>        uint256 y,</span>
 143 |     | <span class='neutral'>        uint256 denominator,</span>
 144 |     | <span class='neutral'>        Rounding rounding</span>
 145 |     | <span class='neutral'>    ) internal pure returns (uint256) {</span>
 146 |     | <span class='neutral'>        uint256 result = mulDiv(x, y, denominator);</span>
 147 |     | <span class='neutral'>        if (rounding == Rounding.Up &amp;&amp; mulmod(x, y, denominator) &gt; 0) {</span>
 148 |     | <span class='neutral'>            result += 1;</span>
 149 |     | <span class='neutral'>        }</span>
 150 |     | <span class='neutral'>        return result;</span>
 151 |     | <span class='neutral'>    }</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>    /**</span>
 154 |     | <span class='neutral'>     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.</span>
 155 |     | <span class='neutral'>     *</span>
 156 |     | <span class='neutral'>     * Inspired by Henry S. Warren, Jr.&#39;s &quot;Hacker&#39;s Delight&quot; (Chapter 11).</span>
 157 |     | <span class='neutral'>     */</span>
 158 |     | <span class='neutral'>    function sqrt(uint256 a) internal pure returns (uint256) {</span>
 159 |     | <span class='neutral'>        if (a == 0) {</span>
 160 |     | <span class='neutral'>            return 0;</span>
 161 |     | <span class='neutral'>        }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.</span>
 164 |     | <span class='neutral'>        //</span>
 165 |     | <span class='neutral'>        // We know that the &quot;msb&quot; (most significant bit) of our target number `a` is a power of 2 such that we have</span>
 166 |     | <span class='neutral'>        // `msb(a) &lt;= a &lt; 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.</span>
 167 |     | <span class='neutral'>        //</span>
 168 |     | <span class='neutral'>        // This can be rewritten `2**log2(a) &lt;= a &lt; 2**(log2(a) + 1)`</span>
 169 |     | <span class='neutral'>        //  `sqrt(2**k) &lt;= sqrt(a) &lt; sqrt(2**(k+1))`</span>
 170 |     | <span class='neutral'>        //  `2**(k/2) &lt;= sqrt(a) &lt; 2**((k+1)/2) &lt;= 2**(k/2 + 1)`</span>
 171 |     | <span class='neutral'>        //</span>
 172 |     | <span class='neutral'>        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.</span>
 173 |     | <span class='neutral'>        uint256 result = 1 &lt;&lt; (log2(a) &gt;&gt; 1);</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,</span>
 176 |     | <span class='neutral'>        // since it is the square root of a uint256. Newton&#39;s method converges quadratically (precision doubles at</span>
 177 |     | <span class='neutral'>        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision</span>
 178 |     | <span class='neutral'>        // into the expected uint128 result.</span>
 179 |     | <span class='neutral'>        unchecked {</span>
 180 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 181 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 182 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 183 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 184 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 185 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 186 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 187 |     | <span class='neutral'>            return min(result, a / result);</span>
 188 |     | <span class='neutral'>        }</span>
 189 |     | <span class='neutral'>    }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>    /**</span>
 192 |     | <span class='neutral'>     * @notice Calculates sqrt(a), following the selected rounding direction.</span>
 193 |     | <span class='neutral'>     */</span>
 194 |     | <span class='neutral'>    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {</span>
 195 |     | <span class='neutral'>        unchecked {</span>
 196 |     | <span class='neutral'>            uint256 result = sqrt(a);</span>
 197 |     | <span class='neutral'>            return result + (rounding == Rounding.Up &amp;&amp; result * result &lt; a ? 1 : 0);</span>
 198 |     | <span class='neutral'>        }</span>
 199 |     | <span class='neutral'>    }</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='neutral'>    /**</span>
 202 |     | <span class='neutral'>     * @dev Return the log in base 2, rounded down, of a positive value.</span>
 203 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 204 |     | <span class='neutral'>     */</span>
 205 |     | <span class='neutral'>    function log2(uint256 value) internal pure returns (uint256) {</span>
 206 |     | <span class='neutral'>        uint256 result = 0;</span>
 207 |     | <span class='neutral'>        unchecked {</span>
 208 |     | <span class='neutral'>            if (value &gt;&gt; 128 &gt; 0) {</span>
 209 |     | <span class='neutral'>                value &gt;&gt;= 128;</span>
 210 |     | <span class='neutral'>                result += 128;</span>
 211 |     | <span class='neutral'>            }</span>
 212 |     | <span class='neutral'>            if (value &gt;&gt; 64 &gt; 0) {</span>
 213 |     | <span class='neutral'>                value &gt;&gt;= 64;</span>
 214 |     | <span class='neutral'>                result += 64;</span>
 215 |     | <span class='neutral'>            }</span>
 216 |     | <span class='neutral'>            if (value &gt;&gt; 32 &gt; 0) {</span>
 217 |     | <span class='neutral'>                value &gt;&gt;= 32;</span>
 218 |     | <span class='neutral'>                result += 32;</span>
 219 |     | <span class='neutral'>            }</span>
 220 |     | <span class='neutral'>            if (value &gt;&gt; 16 &gt; 0) {</span>
 221 |     | <span class='neutral'>                value &gt;&gt;= 16;</span>
 222 |     | <span class='neutral'>                result += 16;</span>
 223 |     | <span class='neutral'>            }</span>
 224 |     | <span class='neutral'>            if (value &gt;&gt; 8 &gt; 0) {</span>
 225 |     | <span class='neutral'>                value &gt;&gt;= 8;</span>
 226 |     | <span class='neutral'>                result += 8;</span>
 227 |     | <span class='neutral'>            }</span>
 228 |     | <span class='neutral'>            if (value &gt;&gt; 4 &gt; 0) {</span>
 229 |     | <span class='neutral'>                value &gt;&gt;= 4;</span>
 230 |     | <span class='neutral'>                result += 4;</span>
 231 |     | <span class='neutral'>            }</span>
 232 |     | <span class='neutral'>            if (value &gt;&gt; 2 &gt; 0) {</span>
 233 |     | <span class='neutral'>                value &gt;&gt;= 2;</span>
 234 |     | <span class='neutral'>                result += 2;</span>
 235 |     | <span class='neutral'>            }</span>
 236 |     | <span class='neutral'>            if (value &gt;&gt; 1 &gt; 0) {</span>
 237 |     | <span class='neutral'>                result += 1;</span>
 238 |     | <span class='neutral'>            }</span>
 239 |     | <span class='neutral'>        }</span>
 240 |     | <span class='neutral'>        return result;</span>
 241 |     | <span class='neutral'>    }</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='neutral'>    /**</span>
 244 |     | <span class='neutral'>     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.</span>
 245 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 246 |     | <span class='neutral'>     */</span>
 247 |     | <span class='neutral'>    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {</span>
 248 |     | <span class='neutral'>        unchecked {</span>
 249 |     | <span class='neutral'>            uint256 result = log2(value);</span>
 250 |     | <span class='neutral'>            return result + (rounding == Rounding.Up &amp;&amp; 1 &lt;&lt; result &lt; value ? 1 : 0);</span>
 251 |     | <span class='neutral'>        }</span>
 252 |     | <span class='neutral'>    }</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='neutral'>    /**</span>
 255 |     | <span class='neutral'>     * @dev Return the log in base 10, rounded down, of a positive value.</span>
 256 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 257 |     | <span class='neutral'>     */</span>
 258 |     | <span class='neutral'>    function log10(uint256 value) internal pure returns (uint256) {</span>
 259 |     | <span class='neutral'>        uint256 result = 0;</span>
 260 |     | <span class='neutral'>        unchecked {</span>
 261 |     | <span class='neutral'>            if (value &gt;= 10**64) {</span>
 262 |     | <span class='neutral'>                value /= 10**64;</span>
 263 |     | <span class='neutral'>                result += 64;</span>
 264 |     | <span class='neutral'>            }</span>
 265 |     | <span class='neutral'>            if (value &gt;= 10**32) {</span>
 266 |     | <span class='neutral'>                value /= 10**32;</span>
 267 |     | <span class='neutral'>                result += 32;</span>
 268 |     | <span class='neutral'>            }</span>
 269 |     | <span class='neutral'>            if (value &gt;= 10**16) {</span>
 270 |     | <span class='neutral'>                value /= 10**16;</span>
 271 |     | <span class='neutral'>                result += 16;</span>
 272 |     | <span class='neutral'>            }</span>
 273 |     | <span class='neutral'>            if (value &gt;= 10**8) {</span>
 274 |     | <span class='neutral'>                value /= 10**8;</span>
 275 |     | <span class='neutral'>                result += 8;</span>
 276 |     | <span class='neutral'>            }</span>
 277 |     | <span class='neutral'>            if (value &gt;= 10**4) {</span>
 278 |     | <span class='neutral'>                value /= 10**4;</span>
 279 |     | <span class='neutral'>                result += 4;</span>
 280 |     | <span class='neutral'>            }</span>
 281 |     | <span class='neutral'>            if (value &gt;= 10**2) {</span>
 282 |     | <span class='neutral'>                value /= 10**2;</span>
 283 |     | <span class='neutral'>                result += 2;</span>
 284 |     | <span class='neutral'>            }</span>
 285 |     | <span class='neutral'>            if (value &gt;= 10**1) {</span>
 286 |     | <span class='neutral'>                result += 1;</span>
 287 |     | <span class='neutral'>            }</span>
 288 |     | <span class='neutral'>        }</span>
 289 |     | <span class='neutral'>        return result;</span>
 290 |     | <span class='neutral'>    }</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='neutral'>    /**</span>
 293 |     | <span class='neutral'>     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.</span>
 294 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 295 |     | <span class='neutral'>     */</span>
 296 |     | <span class='neutral'>    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {</span>
 297 |     | <span class='neutral'>        unchecked {</span>
 298 |     | <span class='neutral'>            uint256 result = log10(value);</span>
 299 |     | <span class='neutral'>            return result + (rounding == Rounding.Up &amp;&amp; 10**result &lt; value ? 1 : 0);</span>
 300 |     | <span class='neutral'>        }</span>
 301 |     | <span class='neutral'>    }</span>
 302 |     | <span class='neutral'></span>
 303 |     | <span class='neutral'>    /**</span>
 304 |     | <span class='neutral'>     * @dev Return the log in base 256, rounded down, of a positive value.</span>
 305 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 306 |     | <span class='neutral'>     *</span>
 307 |     | <span class='neutral'>     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.</span>
 308 |     | <span class='neutral'>     */</span>
 309 |     | <span class='neutral'>    function log256(uint256 value) internal pure returns (uint256) {</span>
 310 |     | <span class='neutral'>        uint256 result = 0;</span>
 311 |     | <span class='neutral'>        unchecked {</span>
 312 |     | <span class='neutral'>            if (value &gt;&gt; 128 &gt; 0) {</span>
 313 |     | <span class='neutral'>                value &gt;&gt;= 128;</span>
 314 |     | <span class='neutral'>                result += 16;</span>
 315 |     | <span class='neutral'>            }</span>
 316 |     | <span class='neutral'>            if (value &gt;&gt; 64 &gt; 0) {</span>
 317 |     | <span class='neutral'>                value &gt;&gt;= 64;</span>
 318 |     | <span class='neutral'>                result += 8;</span>
 319 |     | <span class='neutral'>            }</span>
 320 |     | <span class='neutral'>            if (value &gt;&gt; 32 &gt; 0) {</span>
 321 |     | <span class='neutral'>                value &gt;&gt;= 32;</span>
 322 |     | <span class='neutral'>                result += 4;</span>
 323 |     | <span class='neutral'>            }</span>
 324 |     | <span class='neutral'>            if (value &gt;&gt; 16 &gt; 0) {</span>
 325 |     | <span class='neutral'>                value &gt;&gt;= 16;</span>
 326 |     | <span class='neutral'>                result += 2;</span>
 327 |     | <span class='neutral'>            }</span>
 328 |     | <span class='neutral'>            if (value &gt;&gt; 8 &gt; 0) {</span>
 329 |     | <span class='neutral'>                result += 1;</span>
 330 |     | <span class='neutral'>            }</span>
 331 |     | <span class='neutral'>        }</span>
 332 |     | <span class='neutral'>        return result;</span>
 333 |     | <span class='neutral'>    }</span>
 334 |     | <span class='neutral'></span>
 335 |     | <span class='neutral'>    /**</span>
 336 |     | <span class='neutral'>     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.</span>
 337 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 338 |     | <span class='neutral'>     */</span>
 339 |     | <span class='neutral'>    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {</span>
 340 |     | <span class='neutral'>        unchecked {</span>
 341 |     | <span class='neutral'>            uint256 result = log256(value);</span>
 342 |     | <span class='neutral'>            return result + (rounding == Rounding.Up &amp;&amp; 1 &lt;&lt; (result * 8) &lt; value ? 1 : 0);</span>
 343 |     | <span class='neutral'>        }</span>
 344 |     | <span class='neutral'>    }</span>
 345 |     | <span class='neutral'>}</span>
 346 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@openzeppelin/contracts/utils/structs/BitMaps.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/BitMaps.sol)</span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>/**</span>
  6 |     | <span class='neutral'> * @dev Library for managing uint256 to bool mapping in a compact and efficient way, providing the keys are sequential.</span>
  7 |     | <span class='neutral'> * Largely inspired by Uniswap&#39;s https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol[merkle-distributor].</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='neutral'>library BitMaps {</span>
 10 |     | <span class='neutral'>    struct BitMap {</span>
 11 |     | <span class='neutral'>        mapping(uint256 =&gt; uint256) _data;</span>
 12 |     | <span class='neutral'>    }</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    /**</span>
 15 |     | <span class='neutral'>     * @dev Returns whether the bit at `index` is set.</span>
 16 |     | <span class='neutral'>     */</span>
 17 |     | <span class='neutral'>    function get(BitMap storage bitmap, uint256 index) internal view returns (bool) {</span>
 18 |     | <span class='neutral'>        uint256 bucket = index &gt;&gt; 8;</span>
 19 |     | <span class='unexecuted'>        uint256 mask = 1 &lt;&lt; (index &amp; 0xff);</span>
 20 |     | <span class='neutral'>        return bitmap._data[bucket] &amp; mask != 0;</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    /**</span>
 24 | r   | <span class='reverted'>     * @dev Sets the bit at `index` to the boolean `value`.</span>
 25 |     | <span class='neutral'>     */</span>
 26 |     | <span class='neutral'>    function setTo(</span>
 27 | r   | <span class='reverted'>        BitMap storage bitmap,</span>
 28 |     | <span class='neutral'>        uint256 index,</span>
 29 |     | <span class='neutral'>        bool value</span>
 30 |     | <span class='neutral'>    ) internal {</span>
 31 |     | <span class='neutral'>        if (value) {</span>
 32 |     | <span class='neutral'>            set(bitmap, index);</span>
 33 |     | <span class='neutral'>        } else {</span>
 34 |     | <span class='neutral'>            unset(bitmap, index);</span>
 35 |     | <span class='neutral'>        }</span>
 36 |     | <span class='neutral'>    }</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='unexecuted'>    /**</span>
 39 |     | <span class='neutral'>     * @dev Sets the bit at `index`.</span>
 40 |     | <span class='neutral'>     */</span>
 41 |     | <span class='neutral'>    function set(BitMap storage bitmap, uint256 index) internal {</span>
 42 |     | <span class='neutral'>        uint256 bucket = index &gt;&gt; 8;</span>
 43 |     | <span class='neutral'>        uint256 mask = 1 &lt;&lt; (index &amp; 0xff);</span>
 44 |     | <span class='neutral'>        bitmap._data[bucket] |= mask;</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='unexecuted'>    /**</span>
 48 |     | <span class='neutral'>     * @dev Unsets the bit at `index`.</span>
 49 |     | <span class='neutral'>     */</span>
 50 |     | <span class='neutral'>    function unset(BitMap storage bitmap, uint256 index) internal {</span>
 51 |     | <span class='neutral'>        uint256 bucket = index &gt;&gt; 8;</span>
 52 |     | <span class='neutral'>        uint256 mask = 1 &lt;&lt; (index &amp; 0xff);</span>
 53 |     | <span class='unexecuted'>        bitmap._data[bucket] &amp;= ~mask;</span>
 54 |     | <span class='neutral'>    }</span>
 55 |     | <span class='neutral'>}</span>
 56 | r   | <span class='reverted'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@uniswap/lib/contracts/libraries/TransferHelper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity &gt;=0.6.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false</span>
  6 |     | <span class='neutral'>library TransferHelper {</span>
  7 |     | <span class='neutral'>    function safeApprove(</span>
  8 |     | <span class='neutral'>        address token,</span>
  9 |     | <span class='neutral'>        address to,</span>
 10 |     | <span class='neutral'>        uint256 value</span>
 11 |     | <span class='neutral'>    ) internal {</span>
 12 |     | <span class='neutral'>        // bytes4(keccak256(bytes(&#39;approve(address,uint256)&#39;)));</span>
 13 |     | <span class='neutral'>        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));</span>
 14 |     | <span class='neutral'>        require(</span>
 15 |     | <span class='unexecuted'>            success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))),</span>
 16 |     | <span class='neutral'>            &#39;TransferHelper::safeApprove: approve failed&#39;</span>
 17 |     | <span class='neutral'>        );</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>    function safeTransfer(</span>
 21 |     | <span class='neutral'>        address token,</span>
 22 |     | <span class='neutral'>        address to,</span>
 23 |     | <span class='neutral'>        uint256 value</span>
 24 |     | <span class='neutral'>    ) internal {</span>
 25 |     | <span class='neutral'>        // bytes4(keccak256(bytes(&#39;transfer(address,uint256)&#39;)));</span>
 26 |     | <span class='neutral'>        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));</span>
 27 |     | <span class='neutral'>        require(</span>
 28 |     | <span class='neutral'>            success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))),</span>
 29 |     | <span class='unexecuted'>            &#39;TransferHelper::safeTransfer: transfer failed&#39;</span>
 30 |     | <span class='neutral'>        );</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    function safeTransferFrom(</span>
 34 | *   | <span class='executed'>        address token,</span>
 35 |     | <span class='unexecuted'>        address from,</span>
 36 |     | <span class='neutral'>        address to,</span>
 37 |     | <span class='neutral'>        uint256 value</span>
 38 |     | <span class='neutral'>    ) internal {</span>
 39 |     | <span class='unexecuted'>        // bytes4(keccak256(bytes(&#39;transferFrom(address,address,uint256)&#39;)));</span>
 40 |     | <span class='unexecuted'>        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));</span>
 41 |     | <span class='neutral'>        require(</span>
 42 |     | <span class='neutral'>            success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))),</span>
 43 |     | <span class='neutral'>            &#39;TransferHelper::transferFrom: transferFrom failed&#39;</span>
 44 |     | <span class='neutral'>        );</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='unexecuted'>    function safeTransferETH(address to, uint256 value) internal {</span>
 48 |     | <span class='unexecuted'>        (bool success, ) = to.call{value: value}(new bytes(0));</span>
 49 |     | <span class='unexecuted'>        require(success, &#39;TransferHelper::safeTransferETH: ETH transfer failed&#39;);</span>
 50 |     | <span class='neutral'>    }</span>
 51 |     | <span class='neutral'>}</span>
 52 | *   | <span class='executed'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@uniswap/v2-core/contracts/interfaces/IUniswapV2Callee.sol</b>
<code>
 1 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
 2 |     | <span class='neutral'></span>
 3 |     | <span class='neutral'>interface IUniswapV2Callee {</span>
 4 |     | <span class='neutral'>    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;</span>
 5 |     | <span class='neutral'>}</span>
 6 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@uniswap/v2-core/contracts/interfaces/IUniswapV2ERC20.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>interface IUniswapV2ERC20 {</span>
  4 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint value);</span>
  5 |     | <span class='unexecuted'>    event Transfer(address indexed from, address indexed to, uint value);</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function name() external pure returns (string memory);</span>
  8 |     | <span class='neutral'>    function symbol() external pure returns (string memory);</span>
  9 | *   | <span class='executed'>    function decimals() external pure returns (uint8);</span>
 10 |     | <span class='neutral'>    function totalSupply() external view returns (uint);</span>
 11 |     | <span class='neutral'>    function balanceOf(address owner) external view returns (uint);</span>
 12 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    function approve(address spender, uint value) external returns (bool);</span>
 15 |     | <span class='neutral'>    function transfer(address to, uint value) external returns (bool);</span>
 16 |     | <span class='neutral'>    function transferFrom(address from, address to, uint value) external returns (bool);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    function DOMAIN_SEPARATOR() external view returns (bytes32);</span>
 19 |     | <span class='neutral'>    function PERMIT_TYPEHASH() external pure returns (bytes32);</span>
 20 |     | <span class='neutral'>    function nonces(address owner) external view returns (uint);</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;</span>
 23 |     | <span class='neutral'>}</span>
 24 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>interface IUniswapV2Factory {</span>
  4 |     | <span class='neutral'>    event PairCreated(address indexed token0, address indexed token1, address pair, uint);</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>    function feeTo() external view returns (address);</span>
  7 | *   | <span class='executed'>    function feeToSetter() external view returns (address);</span>
  8 |     | <span class='neutral'></span>
  9 | r   | <span class='reverted'>    function getPair(address tokenA, address tokenB) external view returns (address pair);</span>
 10 |     | <span class='neutral'>    function allPairs(uint) external view returns (address pair);</span>
 11 |     | <span class='neutral'>    function allPairsLength() external view returns (uint);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>    function createPair(address tokenA, address tokenB) external returns (address pair);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function setFeeTo(address) external;</span>
 16 |     | <span class='neutral'>    function setFeeToSetter(address) external;</span>
 17 |     | <span class='neutral'>}</span>
 18 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title The interface for the Uniswap V3 Factory</span>
  5 |     | <span class='neutral'>/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees</span>
  6 |     | <span class='neutral'>interface IUniswapV3Factory {</span>
  7 |     | <span class='unexecuted'>    /// @notice Emitted when the owner of the factory is changed</span>
  8 | *   | <span class='executed'>    /// @param oldOwner The owner before the owner was changed</span>
  9 |     | <span class='neutral'>    /// @param newOwner The owner after the owner was changed</span>
 10 |     | <span class='unexecuted'>    event OwnerChanged(address indexed oldOwner, address indexed newOwner);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='unexecuted'>    /// @notice Emitted when a pool is created</span>
 13 |     | <span class='neutral'>    /// @param token0 The first token of the pool by address sort order</span>
 14 |     | <span class='neutral'>    /// @param token1 The second token of the pool by address sort order</span>
 15 |     | <span class='neutral'>    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip</span>
 16 |     | <span class='neutral'>    /// @param tickSpacing The minimum number of ticks between initialized ticks</span>
 17 |     | <span class='neutral'>    /// @param pool The address of the created pool</span>
 18 |     | <span class='neutral'>    event PoolCreated(</span>
 19 |     | <span class='neutral'>        address indexed token0,</span>
 20 |     | <span class='neutral'>        address indexed token1,</span>
 21 |     | <span class='neutral'>        uint24 indexed fee,</span>
 22 |     | <span class='neutral'>        int24 tickSpacing,</span>
 23 |     | <span class='neutral'>        address pool</span>
 24 |     | <span class='neutral'>    );</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory</span>
 27 |     | <span class='neutral'>    /// @param fee The enabled fee, denominated in hundredths of a bip</span>
 28 |     | <span class='neutral'>    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee</span>
 29 |     | <span class='neutral'>    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    /// @notice Returns the current owner of the factory</span>
 32 |     | <span class='neutral'>    /// @dev Can be changed by the current owner via setOwner</span>
 33 |     | <span class='neutral'>    /// @return The address of the factory owner</span>
 34 |     | <span class='neutral'>    function owner() external view returns (address);</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled</span>
 37 |     | <span class='neutral'>    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context</span>
 38 |     | <span class='neutral'>    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee</span>
 39 |     | <span class='neutral'>    /// @return The tick spacing</span>
 40 |     | <span class='neutral'>    function feeAmountTickSpacing(uint24 fee) external view returns (int24);</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist</span>
 43 |     | <span class='neutral'>    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order</span>
 44 |     | <span class='neutral'>    /// @param tokenA The contract address of either token0 or token1</span>
 45 |     | <span class='neutral'>    /// @param tokenB The contract address of the other token</span>
 46 |     | <span class='neutral'>    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip</span>
 47 |     | <span class='neutral'>    /// @return pool The pool address</span>
 48 |     | <span class='neutral'>    function getPool(</span>
 49 |     | <span class='neutral'>        address tokenA,</span>
 50 |     | <span class='neutral'>        address tokenB,</span>
 51 |     | <span class='neutral'>        uint24 fee</span>
 52 |     | <span class='neutral'>    ) external view returns (address pool);</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    /// @notice Creates a pool for the given two tokens and fee</span>
 55 |     | <span class='neutral'>    /// @param tokenA One of the two tokens in the desired pool</span>
 56 |     | <span class='neutral'>    /// @param tokenB The other of the two tokens in the desired pool</span>
 57 |     | <span class='neutral'>    /// @param fee The desired fee for the pool</span>
 58 |     | <span class='neutral'>    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved</span>
 59 |     | <span class='neutral'>    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments</span>
 60 |     | <span class='neutral'>    /// are invalid.</span>
 61 |     | <span class='neutral'>    /// @return pool The address of the newly created pool</span>
 62 |     | <span class='neutral'>    function createPool(</span>
 63 |     | <span class='neutral'>        address tokenA,</span>
 64 |     | <span class='neutral'>        address tokenB,</span>
 65 |     | <span class='neutral'>        uint24 fee</span>
 66 |     | <span class='neutral'>    ) external returns (address pool);</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='neutral'>    /// @notice Updates the owner of the factory</span>
 69 |     | <span class='neutral'>    /// @dev Must be called by the current owner</span>
 70 |     | <span class='neutral'>    /// @param _owner The new owner of the factory</span>
 71 |     | <span class='neutral'>    function setOwner(address _owner) external;</span>
 72 |     | <span class='neutral'></span>
 73 |     | <span class='neutral'>    /// @notice Enables a fee amount with the given tickSpacing</span>
 74 |     | <span class='neutral'>    /// @dev Fee amounts may never be removed once enabled</span>
 75 |     | <span class='neutral'>    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)</span>
 76 |     | <span class='neutral'>    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount</span>
 77 |     | <span class='neutral'>    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;</span>
 78 |     | <span class='neutral'>}</span>
 79 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;./pool/IUniswapV3PoolImmutables.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;./pool/IUniswapV3PoolState.sol&#39;;</span>
  6 |     | <span class='unexecuted'>import &#39;./pool/IUniswapV3PoolDerivedState.sol&#39;;</span>
  7 | r   | <span class='reverted'>import &#39;./pool/IUniswapV3PoolActions.sol&#39;;</span>
  8 |     | <span class='neutral'>import &#39;./pool/IUniswapV3PoolOwnerActions.sol&#39;;</span>
  9 |     | <span class='unexecuted'>import &#39;./pool/IUniswapV3PoolEvents.sol&#39;;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>/// @title The interface for a Uniswap V3 Pool</span>
 12 |     | <span class='neutral'>/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform</span>
 13 |     | <span class='unexecuted'>/// to the ERC20 specification</span>
 14 |     | <span class='neutral'>/// @dev The pool interface is broken up into many smaller pieces</span>
 15 |     | <span class='neutral'>interface IUniswapV3Pool is</span>
 16 |     | <span class='neutral'>    IUniswapV3PoolImmutables,</span>
 17 |     | <span class='neutral'>    IUniswapV3PoolState,</span>
 18 |     | <span class='neutral'>    IUniswapV3PoolDerivedState,</span>
 19 |     | <span class='neutral'>    IUniswapV3PoolActions,</span>
 20 |     | <span class='neutral'>    IUniswapV3PoolOwnerActions,</span>
 21 |     | <span class='neutral'>    IUniswapV3PoolEvents</span>
 22 |     | <span class='neutral'>{</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Callback for IUniswapV3PoolActions#swap</span>
  5 |     | <span class='unexecuted'>/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface</span>
  6 |     | <span class='unexecuted'>interface IUniswapV3SwapCallback {</span>
  7 |     | <span class='neutral'>    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.</span>
  8 |     | <span class='unexecuted'>    /// @dev In the implementation you must pay the pool tokens owed for the swap.</span>
  9 |     | <span class='unexecuted'>    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.</span>
 10 |     | <span class='neutral'>    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.</span>
 11 |     | <span class='unexecuted'>    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by</span>
 12 |     | <span class='neutral'>    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.</span>
 13 |     | <span class='unexecuted'>    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by</span>
 14 |     | <span class='unexecuted'>    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.</span>
 15 |     | <span class='unexecuted'>    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call</span>
 16 |     | <span class='unexecuted'>    function uniswapV3SwapCallback(</span>
 17 |     | <span class='unexecuted'>        int256 amount0Delta,</span>
 18 |     | <span class='neutral'>        int256 amount1Delta,</span>
 19 |     | <span class='neutral'>        bytes calldata data</span>
 20 |     | <span class='neutral'>    ) external;</span>
 21 |     | <span class='neutral'>}</span>
 22 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @title Permissionless pool actions</span>
   5 |     | <span class='neutral'>/// @notice Contains pool methods that can be called by anyone</span>
   6 |     | <span class='neutral'>interface IUniswapV3PoolActions {</span>
   7 |     | <span class='neutral'>    /// @notice Sets the initial price for the pool</span>
   8 |     | <span class='unexecuted'>    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value</span>
   9 |     | <span class='neutral'>    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96</span>
  10 |     | <span class='neutral'>    function initialize(uint160 sqrtPriceX96) external;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='unexecuted'>    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position</span>
  13 |     | <span class='unexecuted'>    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback</span>
  14 |     | <span class='unexecuted'>    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends</span>
  15 |     | <span class='unexecuted'>    /// on tickLower, tickUpper, the amount of liquidity, and the current price.</span>
  16 |     | <span class='neutral'>    /// @param recipient The address for which the liquidity will be created</span>
  17 |     | <span class='neutral'>    /// @param tickLower The lower tick of the position in which to add liquidity</span>
  18 |     | <span class='neutral'>    /// @param tickUpper The upper tick of the position in which to add liquidity</span>
  19 |     | <span class='neutral'>    /// @param amount The amount of liquidity to mint</span>
  20 |     | <span class='neutral'>    /// @param data Any data that should be passed through to the callback</span>
  21 |     | <span class='unexecuted'>    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback</span>
  22 |     | <span class='neutral'>    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback</span>
  23 |     | <span class='neutral'>    function mint(</span>
  24 |     | <span class='neutral'>        address recipient,</span>
  25 |     | <span class='neutral'>        int24 tickLower,</span>
  26 |     | <span class='neutral'>        int24 tickUpper,</span>
  27 |     | <span class='neutral'>        uint128 amount,</span>
  28 |     | <span class='neutral'>        bytes calldata data</span>
  29 |     | <span class='unexecuted'>    ) external returns (uint256 amount0, uint256 amount1);</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    /// @notice Collects tokens owed to a position</span>
  32 |     | <span class='unexecuted'>    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.</span>
  33 |     | <span class='unexecuted'>    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or</span>
  34 |     | <span class='unexecuted'>    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the</span>
  35 |     | <span class='neutral'>    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.</span>
  36 |     | <span class='neutral'>    /// @param recipient The address which should receive the fees collected</span>
  37 |     | <span class='neutral'>    /// @param tickLower The lower tick of the position for which to collect fees</span>
  38 |     | <span class='neutral'>    /// @param tickUpper The upper tick of the position for which to collect fees</span>
  39 |     | <span class='neutral'>    /// @param amount0Requested How much token0 should be withdrawn from the fees owed</span>
  40 |     | <span class='neutral'>    /// @param amount1Requested How much token1 should be withdrawn from the fees owed</span>
  41 |     | <span class='neutral'>    /// @return amount0 The amount of fees collected in token0</span>
  42 |     | <span class='neutral'>    /// @return amount1 The amount of fees collected in token1</span>
  43 |     | <span class='neutral'>    function collect(</span>
  44 |     | <span class='neutral'>        address recipient,</span>
  45 |     | <span class='neutral'>        int24 tickLower,</span>
  46 |     | <span class='neutral'>        int24 tickUpper,</span>
  47 |     | <span class='neutral'>        uint128 amount0Requested,</span>
  48 |     | <span class='neutral'>        uint128 amount1Requested</span>
  49 |     | <span class='neutral'>    ) external returns (uint128 amount0, uint128 amount1);</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position</span>
  52 |     | <span class='neutral'>    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0</span>
  53 |     | <span class='neutral'>    /// @dev Fees must be collected separately via a call to #collect</span>
  54 |     | <span class='neutral'>    /// @param tickLower The lower tick of the position for which to burn liquidity</span>
  55 |     | <span class='neutral'>    /// @param tickUpper The upper tick of the position for which to burn liquidity</span>
  56 |     | <span class='neutral'>    /// @param amount How much liquidity to burn</span>
  57 |     | <span class='neutral'>    /// @return amount0 The amount of token0 sent to the recipient</span>
  58 |     | <span class='neutral'>    /// @return amount1 The amount of token1 sent to the recipient</span>
  59 |     | <span class='neutral'>    function burn(</span>
  60 |     | <span class='neutral'>        int24 tickLower,</span>
  61 |     | <span class='neutral'>        int24 tickUpper,</span>
  62 |     | <span class='neutral'>        uint128 amount</span>
  63 |     | <span class='neutral'>    ) external returns (uint256 amount0, uint256 amount1);</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /// @notice Swap token0 for token1, or token1 for token0</span>
  66 |     | <span class='neutral'>    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback</span>
  67 |     | <span class='neutral'>    /// @param recipient The address to receive the output of the swap</span>
  68 |     | <span class='neutral'>    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0</span>
  69 |     | <span class='neutral'>    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)</span>
  70 |     | <span class='neutral'>    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this</span>
  71 |     | <span class='neutral'>    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap</span>
  72 |     | <span class='neutral'>    /// @param data Any data to be passed through to the callback</span>
  73 |     | <span class='neutral'>    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive</span>
  74 |     | <span class='neutral'>    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive</span>
  75 |     | <span class='neutral'>    function swap(</span>
  76 |     | <span class='neutral'>        address recipient,</span>
  77 |     | <span class='neutral'>        bool zeroForOne,</span>
  78 |     | <span class='neutral'>        int256 amountSpecified,</span>
  79 |     | <span class='neutral'>        uint160 sqrtPriceLimitX96,</span>
  80 |     | <span class='neutral'>        bytes calldata data</span>
  81 |     | <span class='neutral'>    ) external returns (int256 amount0, int256 amount1);</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback</span>
  84 |     | <span class='neutral'>    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback</span>
  85 |     | <span class='neutral'>    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling</span>
  86 |     | <span class='neutral'>    /// with 0 amount{0,1} and sending the donation amount(s) from the callback</span>
  87 |     | <span class='neutral'>    /// @param recipient The address which will receive the token0 and token1 amounts</span>
  88 |     | <span class='neutral'>    /// @param amount0 The amount of token0 to send</span>
  89 |     | <span class='neutral'>    /// @param amount1 The amount of token1 to send</span>
  90 |     | <span class='neutral'>    /// @param data Any data to be passed through to the callback</span>
  91 |     | <span class='neutral'>    function flash(</span>
  92 |     | <span class='neutral'>        address recipient,</span>
  93 |     | <span class='neutral'>        uint256 amount0,</span>
  94 |     | <span class='neutral'>        uint256 amount1,</span>
  95 |     | <span class='neutral'>        bytes calldata data</span>
  96 |     | <span class='neutral'>    ) external;</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /// @notice Increase the maximum number of price and liquidity observations that this pool will store</span>
  99 |     | <span class='neutral'>    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to</span>
 100 |     | <span class='neutral'>    /// the input observationCardinalityNext.</span>
 101 |     | <span class='neutral'>    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store</span>
 102 |     | <span class='neutral'>    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;</span>
 103 |     | <span class='neutral'>}</span>
 104 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Pool state that is not stored</span>
  5 |     | <span class='neutral'>/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the</span>
  6 |     | <span class='neutral'>/// blockchain. The functions here may have variable gas costs.</span>
  7 |     | <span class='neutral'>interface IUniswapV3PoolDerivedState {</span>
  8 |     | <span class='unexecuted'>    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp</span>
  9 |     | <span class='unexecuted'>    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing</span>
 10 |     | <span class='neutral'>    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,</span>
 11 |     | <span class='neutral'>    /// you must call it with secondsAgos = [3600, 0].</span>
 12 |     | <span class='unexecuted'>    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in</span>
 13 |     | <span class='unexecuted'>    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.</span>
 14 |     | <span class='unexecuted'>    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned</span>
 15 |     | <span class='neutral'>    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp</span>
 16 |     | <span class='neutral'>    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block</span>
 17 |     | <span class='neutral'>    /// timestamp</span>
 18 |     | <span class='neutral'>    function observe(uint32[] calldata secondsAgos)</span>
 19 |     | <span class='neutral'>        external</span>
 20 |     | <span class='neutral'>        view</span>
 21 |     | <span class='neutral'>        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range</span>
 24 |     | <span class='unexecuted'>    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.</span>
 25 |     | <span class='unexecuted'>    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first</span>
 26 |     | <span class='unexecuted'>    /// snapshot is taken and the second snapshot is taken.</span>
 27 |     | <span class='unexecuted'>    /// @param tickLower The lower tick of the range</span>
 28 |     | <span class='unexecuted'>    /// @param tickUpper The upper tick of the range</span>
 29 |     | <span class='unexecuted'>    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range</span>
 30 |     | <span class='unexecuted'>    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range</span>
 31 |     | <span class='unexecuted'>    /// @return secondsInside The snapshot of seconds per liquidity for the range</span>
 32 |     | <span class='unexecuted'>    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)</span>
 33 |     | <span class='neutral'>        external</span>
 34 |     | <span class='neutral'>        view</span>
 35 |     | <span class='neutral'>        returns (</span>
 36 |     | <span class='unexecuted'>            int56 tickCumulativeInside,</span>
 37 |     | <span class='unexecuted'>            uint160 secondsPerLiquidityInsideX128,</span>
 38 |     | <span class='neutral'>            uint32 secondsInside</span>
 39 |     | <span class='unexecuted'>        );</span>
 40 |     | <span class='neutral'>}</span>
 41 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @title Events emitted by a pool</span>
   5 |     | <span class='neutral'>/// @notice Contains all events emitted by the pool</span>
   6 |     | <span class='neutral'>interface IUniswapV3PoolEvents {</span>
   7 |     | <span class='neutral'>    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool</span>
   8 |     | <span class='neutral'>    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize</span>
   9 |     | <span class='neutral'>    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96</span>
  10 |     | <span class='neutral'>    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool</span>
  11 |     | <span class='unexecuted'>    event Initialize(uint160 sqrtPriceX96, int24 tick);</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    /// @notice Emitted when liquidity is minted for a given position</span>
  14 |     | <span class='neutral'>    /// @param sender The address that minted the liquidity</span>
  15 |     | <span class='unexecuted'>    /// @param owner The owner of the position and recipient of any minted liquidity</span>
  16 |     | <span class='neutral'>    /// @param tickLower The lower tick of the position</span>
  17 |     | <span class='unexecuted'>    /// @param tickUpper The upper tick of the position</span>
  18 |     | <span class='neutral'>    /// @param amount The amount of liquidity minted to the position range</span>
  19 |     | <span class='neutral'>    /// @param amount0 How much token0 was required for the minted liquidity</span>
  20 |     | <span class='neutral'>    /// @param amount1 How much token1 was required for the minted liquidity</span>
  21 |     | <span class='neutral'>    event Mint(</span>
  22 |     | <span class='neutral'>        address sender,</span>
  23 |     | <span class='neutral'>        address indexed owner,</span>
  24 |     | <span class='neutral'>        int24 indexed tickLower,</span>
  25 |     | <span class='neutral'>        int24 indexed tickUpper,</span>
  26 |     | <span class='neutral'>        uint128 amount,</span>
  27 |     | <span class='neutral'>        uint256 amount0,</span>
  28 |     | <span class='neutral'>        uint256 amount1</span>
  29 |     | <span class='neutral'>    );</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    /// @notice Emitted when fees are collected by the owner of a position</span>
  32 |     | <span class='neutral'>    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees</span>
  33 |     | <span class='unexecuted'>    /// @param owner The owner of the position for which fees are collected</span>
  34 |     | <span class='neutral'>    /// @param tickLower The lower tick of the position</span>
  35 |     | <span class='unexecuted'>    /// @param tickUpper The upper tick of the position</span>
  36 |     | <span class='neutral'>    /// @param amount0 The amount of token0 fees collected</span>
  37 |     | <span class='unexecuted'>    /// @param amount1 The amount of token1 fees collected</span>
  38 |     | <span class='unexecuted'>    event Collect(</span>
  39 |     | <span class='unexecuted'>        address indexed owner,</span>
  40 |     | <span class='neutral'>        address recipient,</span>
  41 |     | <span class='neutral'>        int24 indexed tickLower,</span>
  42 |     | <span class='unexecuted'>        int24 indexed tickUpper,</span>
  43 |     | <span class='unexecuted'>        uint128 amount0,</span>
  44 |     | <span class='unexecuted'>        uint128 amount1</span>
  45 |     | <span class='neutral'>    );</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='unexecuted'>    /// @notice Emitted when a position&#39;s liquidity is removed</span>
  48 |     | <span class='unexecuted'>    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect</span>
  49 |     | <span class='unexecuted'>    /// @param owner The owner of the position for which liquidity is removed</span>
  50 |     | <span class='unexecuted'>    /// @param tickLower The lower tick of the position</span>
  51 |     | <span class='unexecuted'>    /// @param tickUpper The upper tick of the position</span>
  52 |     | <span class='unexecuted'>    /// @param amount The amount of liquidity to remove</span>
  53 |     | <span class='unexecuted'>    /// @param amount0 The amount of token0 withdrawn</span>
  54 |     | <span class='unexecuted'>    /// @param amount1 The amount of token1 withdrawn</span>
  55 |     | <span class='neutral'>    event Burn(</span>
  56 |     | <span class='unexecuted'>        address indexed owner,</span>
  57 |     | <span class='unexecuted'>        int24 indexed tickLower,</span>
  58 |     | <span class='unexecuted'>        int24 indexed tickUpper,</span>
  59 |     | <span class='neutral'>        uint128 amount,</span>
  60 |     | <span class='neutral'>        uint256 amount0,</span>
  61 |     | <span class='unexecuted'>        uint256 amount1</span>
  62 |     | <span class='neutral'>    );</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='unexecuted'>    /// @notice Emitted by the pool for any swaps between token0 and token1</span>
  65 |     | <span class='unexecuted'>    /// @param sender The address that initiated the swap call, and that received the callback</span>
  66 |     | <span class='unexecuted'>    /// @param recipient The address that received the output of the swap</span>
  67 |     | <span class='unexecuted'>    /// @param amount0 The delta of the token0 balance of the pool</span>
  68 |     | <span class='unexecuted'>    /// @param amount1 The delta of the token1 balance of the pool</span>
  69 |     | <span class='unexecuted'>    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96</span>
  70 |     | <span class='unexecuted'>    /// @param liquidity The liquidity of the pool after the swap</span>
  71 |     | <span class='unexecuted'>    /// @param tick The log base 1.0001 of price of the pool after the swap</span>
  72 |     | <span class='neutral'>    event Swap(</span>
  73 |     | <span class='unexecuted'>        address indexed sender,</span>
  74 |     | <span class='unexecuted'>        address indexed recipient,</span>
  75 |     | <span class='neutral'>        int256 amount0,</span>
  76 |     | <span class='unexecuted'>        int256 amount1,</span>
  77 |     | <span class='unexecuted'>        uint160 sqrtPriceX96,</span>
  78 |     | <span class='unexecuted'>        uint128 liquidity,</span>
  79 |     | <span class='neutral'>        int24 tick</span>
  80 |     | <span class='neutral'>    );</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>    /// @notice Emitted by the pool for any flashes of token0/token1</span>
  83 |     | <span class='unexecuted'>    /// @param sender The address that initiated the swap call, and that received the callback</span>
  84 |     | <span class='unexecuted'>    /// @param recipient The address that received the tokens from flash</span>
  85 |     | <span class='neutral'>    /// @param amount0 The amount of token0 that was flashed</span>
  86 |     | <span class='neutral'>    /// @param amount1 The amount of token1 that was flashed</span>
  87 |     | <span class='neutral'>    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee</span>
  88 |     | <span class='unexecuted'>    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee</span>
  89 |     | <span class='neutral'>    event Flash(</span>
  90 |     | <span class='unexecuted'>        address indexed sender,</span>
  91 |     | <span class='unexecuted'>        address indexed recipient,</span>
  92 |     | <span class='neutral'>        uint256 amount0,</span>
  93 |     | <span class='unexecuted'>        uint256 amount1,</span>
  94 |     | <span class='neutral'>        uint256 paid0,</span>
  95 |     | <span class='neutral'>        uint256 paid1</span>
  96 |     | <span class='neutral'>    );</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='unexecuted'>    /// @notice Emitted by the pool for increases to the number of observations that can be stored</span>
  99 |     | <span class='unexecuted'>    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index</span>
 100 |     | <span class='neutral'>    /// just before a mint/swap/burn.</span>
 101 |     | <span class='unexecuted'>    /// @param observationCardinalityNextOld The previous value of the next observation cardinality</span>
 102 |     | <span class='unexecuted'>    /// @param observationCardinalityNextNew The updated value of the next observation cardinality</span>
 103 |     | <span class='neutral'>    event IncreaseObservationCardinalityNext(</span>
 104 |     | <span class='neutral'>        uint16 observationCardinalityNextOld,</span>
 105 |     | <span class='neutral'>        uint16 observationCardinalityNextNew</span>
 106 |     | <span class='neutral'>    );</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    /// @notice Emitted when the protocol fee is changed by the pool</span>
 109 |     | <span class='neutral'>    /// @param feeProtocol0Old The previous value of the token0 protocol fee</span>
 110 |     | <span class='neutral'>    /// @param feeProtocol1Old The previous value of the token1 protocol fee</span>
 111 |     | <span class='neutral'>    /// @param feeProtocol0New The updated value of the token0 protocol fee</span>
 112 |     | <span class='neutral'>    /// @param feeProtocol1New The updated value of the token1 protocol fee</span>
 113 |     | <span class='neutral'>    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner</span>
 116 |     | <span class='neutral'>    /// @param sender The address that collects the protocol fees</span>
 117 |     | <span class='unexecuted'>    /// @param recipient The address that receives the collected protocol fees</span>
 118 |     | <span class='neutral'>    /// @param amount0 The amount of token0 protocol fees that is withdrawn</span>
 119 |     | <span class='unexecuted'>    /// @param amount0 The amount of token1 protocol fees that is withdrawn</span>
 120 |     | <span class='unexecuted'>    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);</span>
 121 |     | <span class='neutral'>}</span>
 122 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Pool state that never changes</span>
  5 |     | <span class='neutral'>/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values</span>
  6 |     | <span class='neutral'>interface IUniswapV3PoolImmutables {</span>
  7 |     | <span class='unexecuted'>    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface</span>
  8 |     | <span class='neutral'>    /// @return The contract address</span>
  9 |     | <span class='neutral'>    function factory() external view returns (address);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>    /// @notice The first of the two tokens of the pool, sorted by address</span>
 12 |     | <span class='neutral'>    /// @return The token contract address</span>
 13 |     | <span class='neutral'>    function token0() external view returns (address);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    /// @notice The second of the two tokens of the pool, sorted by address</span>
 16 |     | <span class='unexecuted'>    /// @return The token contract address</span>
 17 |     | <span class='unexecuted'>    function token1() external view returns (address);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    /// @notice The pool&#39;s fee in hundredths of a bip, i.e. 1e-6</span>
 20 |     | <span class='unexecuted'>    /// @return The fee</span>
 21 |     | <span class='neutral'>    function fee() external view returns (uint24);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    /// @notice The pool tick spacing</span>
 24 |     | <span class='unexecuted'>    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive</span>
 25 |     | <span class='unexecuted'>    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...</span>
 26 |     | <span class='unexecuted'>    /// This value is an int24 to avoid casting even though it is always positive.</span>
 27 |     | <span class='unexecuted'>    /// @return The tick spacing</span>
 28 |     | <span class='unexecuted'>    function tickSpacing() external view returns (int24);</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='unexecuted'>    /// @notice The maximum amount of position liquidity that can use any tick in the range</span>
 31 |     | <span class='unexecuted'>    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and</span>
 32 |     | <span class='unexecuted'>    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool</span>
 33 |     | <span class='unexecuted'>    /// @return The max amount of liquidity per tick</span>
 34 |     | <span class='unexecuted'>    function maxLiquidityPerTick() external view returns (uint128);</span>
 35 |     | <span class='neutral'>}</span>
 36 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Permissioned pool actions</span>
  5 |     | <span class='neutral'>/// @notice Contains pool methods that may only be called by the factory owner</span>
  6 |     | <span class='neutral'>interface IUniswapV3PoolOwnerActions {</span>
  7 | *r  | <span class='executed'>    /// @notice Set the denominator of the protocol&#39;s % share of the fees</span>
  8 |     | <span class='neutral'>    /// @param feeProtocol0 new protocol fee for token0 of the pool</span>
  9 |     | <span class='neutral'>    /// @param feeProtocol1 new protocol fee for token1 of the pool</span>
 10 | *   | <span class='executed'>    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='unexecuted'>    /// @notice Collect the protocol fee accrued to the pool</span>
 13 |     | <span class='unexecuted'>    /// @param recipient The address to which collected protocol fees should be sent</span>
 14 |     | <span class='unexecuted'>    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1</span>
 15 |     | <span class='unexecuted'>    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0</span>
 16 |     | <span class='neutral'>    /// @return amount0 The protocol fee collected in token0</span>
 17 |     | <span class='unexecuted'>    /// @return amount1 The protocol fee collected in token1</span>
 18 |     | <span class='neutral'>    function collectProtocol(</span>
 19 |     | <span class='unexecuted'>        address recipient,</span>
 20 |     | <span class='neutral'>        uint128 amount0Requested,</span>
 21 |     | <span class='neutral'>        uint128 amount1Requested</span>
 22 |     | <span class='unexecuted'>    ) external returns (uint128 amount0, uint128 amount1);</span>
 23 |     | <span class='neutral'>}</span>
 24 | *r  | <span class='executed'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @title Pool state that can change</span>
   5 |     | <span class='unexecuted'>/// @notice These methods compose the pool&#39;s state, and can change with any frequency including multiple times</span>
   6 |     | <span class='neutral'>/// per transaction</span>
   7 |     | <span class='neutral'>interface IUniswapV3PoolState {</span>
   8 |     | <span class='unexecuted'>    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas</span>
   9 |     | <span class='neutral'>    /// when accessed externally.</span>
  10 |     | <span class='unexecuted'>    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value</span>
  11 |     | <span class='unexecuted'>    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.</span>
  12 |     | <span class='neutral'>    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick</span>
  13 |     | <span class='neutral'>    /// boundary.</span>
  14 |     | <span class='neutral'>    /// observationIndex The index of the last oracle observation that was written,</span>
  15 |     | <span class='unexecuted'>    /// observationCardinality The current maximum number of observations stored in the pool,</span>
  16 |     | <span class='neutral'>    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.</span>
  17 |     | <span class='neutral'>    /// feeProtocol The protocol fee for both tokens of the pool.</span>
  18 |     | <span class='neutral'>    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0</span>
  19 |     | <span class='neutral'>    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.</span>
  20 |     | <span class='neutral'>    /// unlocked Whether the pool is currently locked to reentrancy</span>
  21 |     | <span class='neutral'>    function slot0()</span>
  22 |     | <span class='neutral'>        external</span>
  23 |     | <span class='neutral'>        view</span>
  24 |     | <span class='neutral'>        returns (</span>
  25 |     | <span class='neutral'>            uint160 sqrtPriceX96,</span>
  26 |     | <span class='neutral'>            int24 tick,</span>
  27 |     | <span class='neutral'>            uint16 observationIndex,</span>
  28 |     | <span class='neutral'>            uint16 observationCardinality,</span>
  29 |     | <span class='neutral'>            uint16 observationCardinalityNext,</span>
  30 |     | <span class='neutral'>            uint8 feeProtocol,</span>
  31 |     | <span class='neutral'>            bool unlocked</span>
  32 |     | <span class='neutral'>        );</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool</span>
  35 |     | <span class='neutral'>    /// @dev This value can overflow the uint256</span>
  36 |     | <span class='neutral'>    function feeGrowthGlobal0X128() external view returns (uint256);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool</span>
  39 |     | <span class='neutral'>    /// @dev This value can overflow the uint256</span>
  40 |     | <span class='neutral'>    function feeGrowthGlobal1X128() external view returns (uint256);</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    /// @notice The amounts of token0 and token1 that are owed to the protocol</span>
  43 |     | <span class='neutral'>    /// @dev Protocol fees will never exceed uint128 max in either token</span>
  44 |     | <span class='neutral'>    function protocolFees() external view returns (uint128 token0, uint128 token1);</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    /// @notice The currently in range liquidity available to the pool</span>
  47 |     | <span class='neutral'>    /// @dev This value has no relationship to the total liquidity across all ticks</span>
  48 |     | <span class='neutral'>    function liquidity() external view returns (uint128);</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /// @notice Look up information about a specific tick in the pool</span>
  51 |     | <span class='neutral'>    /// @param tick The tick to look up</span>
  52 |     | <span class='neutral'>    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or</span>
  53 |     | <span class='neutral'>    /// tick upper,</span>
  54 |     | <span class='neutral'>    /// liquidityNet how much liquidity changes when the pool price crosses the tick,</span>
  55 |     | <span class='neutral'>    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,</span>
  56 |     | <span class='neutral'>    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,</span>
  57 |     | <span class='neutral'>    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick</span>
  58 |     | <span class='neutral'>    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,</span>
  59 |     | <span class='neutral'>    /// secondsOutside the seconds spent on the other side of the tick from the current tick,</span>
  60 |     | <span class='neutral'>    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.</span>
  61 |     | <span class='neutral'>    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.</span>
  62 |     | <span class='neutral'>    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for</span>
  63 |     | <span class='neutral'>    /// a specific position.</span>
  64 |     | <span class='neutral'>    function ticks(int24 tick)</span>
  65 |     | <span class='neutral'>        external</span>
  66 |     | <span class='neutral'>        view</span>
  67 |     | <span class='neutral'>        returns (</span>
  68 |     | <span class='neutral'>            uint128 liquidityGross,</span>
  69 |     | <span class='neutral'>            int128 liquidityNet,</span>
  70 |     | <span class='neutral'>            uint256 feeGrowthOutside0X128,</span>
  71 |     | <span class='neutral'>            uint256 feeGrowthOutside1X128,</span>
  72 |     | <span class='neutral'>            int56 tickCumulativeOutside,</span>
  73 |     | <span class='neutral'>            uint160 secondsPerLiquidityOutsideX128,</span>
  74 |     | <span class='neutral'>            uint32 secondsOutside,</span>
  75 |     | <span class='neutral'>            bool initialized</span>
  76 |     | <span class='neutral'>        );</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information</span>
  79 |     | <span class='neutral'>    function tickBitmap(int16 wordPosition) external view returns (uint256);</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    /// @notice Returns the information about a position by the position&#39;s key</span>
  82 |     | <span class='neutral'>    /// @param key The position&#39;s key is a hash of a preimage composed by the owner, tickLower and tickUpper</span>
  83 |     | <span class='neutral'>    /// @return _liquidity The amount of liquidity in the position,</span>
  84 |     | <span class='neutral'>    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,</span>
  85 |     | <span class='neutral'>    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,</span>
  86 |     | <span class='neutral'>    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,</span>
  87 |     | <span class='neutral'>    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke</span>
  88 |     | <span class='neutral'>    function positions(bytes32 key)</span>
  89 |     | <span class='neutral'>        external</span>
  90 |     | <span class='neutral'>        view</span>
  91 |     | <span class='neutral'>        returns (</span>
  92 |     | <span class='neutral'>            uint128 _liquidity,</span>
  93 |     | <span class='neutral'>            uint256 feeGrowthInside0LastX128,</span>
  94 |     | <span class='neutral'>            uint256 feeGrowthInside1LastX128,</span>
  95 |     | <span class='neutral'>            uint128 tokensOwed0,</span>
  96 |     | <span class='neutral'>            uint128 tokensOwed1</span>
  97 |     | <span class='neutral'>        );</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    /// @notice Returns data about a specific observation index</span>
 100 |     | <span class='neutral'>    /// @param index The element of the observations array to fetch</span>
 101 |     | <span class='neutral'>    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time</span>
 102 |     | <span class='neutral'>    /// ago, rather than at a specific index in the array.</span>
 103 |     | <span class='neutral'>    /// @return blockTimestamp The timestamp of the observation,</span>
 104 |     | <span class='neutral'>    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,</span>
 105 |     | <span class='neutral'>    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,</span>
 106 |     | <span class='neutral'>    /// Returns initialized whether the observation has been initialized and the values are safe to use</span>
 107 |     | <span class='neutral'>    function observations(uint256 index)</span>
 108 |     | <span class='neutral'>        external</span>
 109 |     | <span class='neutral'>        view</span>
 110 |     | <span class='neutral'>        returns (</span>
 111 |     | <span class='neutral'>            uint32 blockTimestamp,</span>
 112 |     | <span class='neutral'>            int56 tickCumulative,</span>
 113 |     | <span class='neutral'>            uint160 secondsPerLiquidityCumulativeX128,</span>
 114 |     | <span class='neutral'>            bool initialized</span>
 115 |     | <span class='neutral'>        );</span>
 116 |     | <span class='neutral'>}</span>
 117 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@uniswap/v3-core/contracts/libraries/FixedPoint96.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.4.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title FixedPoint96</span>
  5 |     | <span class='unexecuted'>/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)</span>
  6 |     | <span class='neutral'>/// @dev Used in SqrtPriceMath.sol</span>
  7 |     | <span class='neutral'>library FixedPoint96 {</span>
  8 |     | <span class='unexecuted'>    uint8 internal constant RESOLUTION = 96;</span>
  9 |     | <span class='unexecuted'>    uint256 internal constant Q96 = 0x1000000000000000000000000;</span>
 10 |     | <span class='neutral'>}</span>
 11 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.7.5;</span>
  3 |     | <span class='neutral'>pragma abicoder v2;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='unexecuted'>import &#39;@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>/// @title Router token swapping functionality</span>
  8 |     | <span class='neutral'>/// @notice Functions for swapping tokens via Uniswap V3</span>
  9 |     | <span class='unexecuted'>interface ISwapRouter is IUniswapV3SwapCallback {</span>
 10 |     | <span class='neutral'>    struct ExactInputSingleParams {</span>
 11 |     | <span class='neutral'>        address tokenIn;</span>
 12 |     | <span class='neutral'>        address tokenOut;</span>
 13 |     | <span class='neutral'>        uint24 fee;</span>
 14 |     | <span class='neutral'>        address recipient;</span>
 15 |     | <span class='neutral'>        uint256 deadline;</span>
 16 |     | <span class='unexecuted'>        uint256 amountIn;</span>
 17 |     | <span class='neutral'>        uint256 amountOutMinimum;</span>
 18 |     | <span class='neutral'>        uint160 sqrtPriceLimitX96;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    /// @notice Swaps `amountIn` of one token for as much as possible of another token</span>
 22 |     | <span class='neutral'>    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata</span>
 23 |     | <span class='neutral'>    /// @return amountOut The amount of the received token</span>
 24 |     | <span class='neutral'>    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    struct ExactInputParams {</span>
 27 |     | <span class='neutral'>        bytes path;</span>
 28 |     | <span class='neutral'>        address recipient;</span>
 29 |     | <span class='neutral'>        uint256 deadline;</span>
 30 |     | <span class='neutral'>        uint256 amountIn;</span>
 31 |     | <span class='neutral'>        uint256 amountOutMinimum;</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path</span>
 35 |     | <span class='neutral'>    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata</span>
 36 |     | <span class='neutral'>    /// @return amountOut The amount of the received token</span>
 37 |     | <span class='neutral'>    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    struct ExactOutputSingleParams {</span>
 40 |     | <span class='neutral'>        address tokenIn;</span>
 41 |     | <span class='neutral'>        address tokenOut;</span>
 42 |     | <span class='neutral'>        uint24 fee;</span>
 43 |     | <span class='neutral'>        address recipient;</span>
 44 |     | <span class='neutral'>        uint256 deadline;</span>
 45 |     | <span class='neutral'>        uint256 amountOut;</span>
 46 |     | <span class='neutral'>        uint256 amountInMaximum;</span>
 47 |     | <span class='neutral'>        uint160 sqrtPriceLimitX96;</span>
 48 |     | <span class='neutral'>    }</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    /// @notice Swaps as little as possible of one token for `amountOut` of another token</span>
 51 |     | <span class='neutral'>    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata</span>
 52 |     | <span class='neutral'>    /// @return amountIn The amount of the input token</span>
 53 |     | <span class='neutral'>    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='neutral'>    struct ExactOutputParams {</span>
 56 |     | <span class='neutral'>        bytes path;</span>
 57 |     | <span class='neutral'>        address recipient;</span>
 58 |     | <span class='neutral'>        uint256 deadline;</span>
 59 |     | <span class='neutral'>        uint256 amountOut;</span>
 60 |     | <span class='neutral'>        uint256 amountInMaximum;</span>
 61 |     | <span class='neutral'>    }</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='neutral'>    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)</span>
 64 |     | <span class='neutral'>    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata</span>
 65 |     | <span class='neutral'>    /// @return amountIn The amount of the input token</span>
 66 |     | <span class='neutral'>    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);</span>
 67 |     | <span class='neutral'>}</span>
 68 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/dos/DOS.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
    2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
    3 |     | <span class='neutral'></span>
    4 |     | <span class='unexecuted'>import &quot;@openzeppelin/contracts/proxy/Proxy.sol&quot;;</span>
    5 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span>
    6 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol&quot;;</span>
    7 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC721/ERC721.sol&quot;;</span>
    8 |     | <span class='unexecuted'>import &quot;@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol&quot;;</span>
    9 |     | <span class='unexecuted'>import &quot;@openzeppelin/contracts/utils/Address.sol&quot;;</span>
   10 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/security/Pausable.sol&quot;;</span>
   11 |     | <span class='neutral'>import &quot;../lib/FsUtils.sol&quot;;</span>
   12 |     | <span class='neutral'>import &quot;../lib/FsMath.sol&quot;;</span>
   13 |     | <span class='neutral'>import &quot;../interfaces/IDOS.sol&quot;;</span>
   14 |     | <span class='neutral'>import &quot;../interfaces/IERC20ValueOracle.sol&quot;;</span>
   15 |     | <span class='neutral'>import &quot;../interfaces/INFTValueOracle.sol&quot;;</span>
   16 |     | <span class='neutral'>import {PERMIT2, IPermit2} from &quot;../external/interfaces/IPermit2.sol&quot;;</span>
   17 |     | <span class='neutral'>import {DSafeProxy} from &quot;./DSafeProxy.sol&quot;;</span>
   18 |     | <span class='neutral'>import {IVersionManager} from &quot;../interfaces/IVersionManager.sol&quot;;</span>
   19 |     | <span class='neutral'>import &quot;../lib/Call.sol&quot;;</span>
   20 |     | <span class='neutral'>import &quot;../lib/ImmutableGovernance.sol&quot;;</span>
   21 |     | <span class='neutral'>import {IERC1363SpenderExtended, IERC1363ReceiverExtended} from &quot;../interfaces/IERC1363-extended.sol&quot;;</span>
   22 |     | <span class='neutral'></span>
   23 |     | <span class='neutral'>/// @notice Sender is not approved to spend dSafe erc20</span>
   24 |     | <span class='neutral'>error NotApprovedOrOwner();</span>
   25 |     | <span class='neutral'>/// @notice Sender is not the owner of the dSafe;</span>
   26 |     | <span class='unexecuted'>/// @param sender The address of the sender</span>
   27 |     | <span class='neutral'>/// @param owner The address of the owner</span>
   28 |     | <span class='neutral'>error NotOwner(address sender, address owner);</span>
   29 |     | <span class='neutral'>/// @notice Transfer amount exceeds allowance</span>
   30 |     | <span class='neutral'>error InsufficientAllowance();</span>
   31 |     | <span class='unexecuted'>/// @notice Cannot approve self as spender</span>
   32 |     | <span class='neutral'>error SelfApproval();</span>
   33 |     | <span class='neutral'>/// @notice The receiving address is not a contract</span>
   34 |     | <span class='neutral'>error ReceiverNotContract();</span>
   35 |     | <span class='neutral'>/// @notice The receiver does not implement the required interface</span>
   36 |     | <span class='neutral'>error ReceiverNoImplementation();</span>
   37 |     | <span class='neutral'>/// @notice The receiver did not return the correct value - transaction failed</span>
   38 |     | <span class='neutral'>error WrongDataReturned();</span>
   39 |     | <span class='neutral'>/// @notice Asset is not an NFT</span>
   40 |     | <span class='neutral'>error NotNFT();</span>
   41 |     | <span class='neutral'>/// @notice NFT must be in the user&#39;s dSafe</span>
   42 |     | <span class='neutral'>error NFTNotInDSafe();</span>
   43 |     | <span class='neutral'>/// @notice NFT must be owned the the user or user&#39;s dSafe</span>
   44 |     | <span class='neutral'>error NotNFTOwner();</span>
   45 |     | <span class='neutral'>/// @notice Asset is not registered</span>
   46 |     | <span class='neutral'>/// @param token The unregistered asset</span>
   47 |     | <span class='neutral'>error NotRegistered(address token);</span>
   48 |     | <span class='neutral'>/// @notice Only dSafe can call this function</span>
   49 |     | <span class='neutral'>error OnlyDSafe();</span>
   50 |     | <span class='neutral'>/// @notice Recipient is not a valid dSafe</span>
   51 |     | <span class='neutral'>error DSafeNonExistent();</span>
   52 |     | <span class='neutral'>/// @notice Operation leaves dSafe insolvent</span>
   53 |     | <span class='neutral'>error Insolvent();</span>
   54 |     | <span class='neutral'>/// @notice The address is not a registered ERC20</span>
   55 |     | <span class='neutral'>error NotERC20();</span>
   56 |     | <span class='neutral'></span>
   57 |     | <span class='neutral'>// ERC20 standard token</span>
   58 |     | <span class='neutral'>// ERC721 single non-fungible token support</span>
   59 |     | <span class='neutral'>// ERC677 transferAndCall (transferAndCall2 extension)</span>
   60 |     | <span class='neutral'>// ERC165 interface support (solidity IDOS.interfaceId)</span>
   61 |     | <span class='neutral'>// ERC777 token send</span>
   62 |     | <span class='neutral'>// ERC1155 multi-token support</span>
   63 |     | <span class='neutral'>// ERC1363 payable token (approveAndCall/transferAndCall)</span>
   64 |     | <span class='neutral'>// ERC1820 interface registry support</span>
   65 |     | <span class='neutral'>// EIP2612 permit support (uniswap permit2)</span>
   66 |     | <span class='neutral'>/*</span>
   67 |     | <span class='neutral'> * NFTs are stored in an array of nfts owned by some dSafe. To prevent looping over arrays we need to</span>
   68 |     | <span class='neutral'> * know the following information for each NFT in the system (erc721, tokenId, dSafe, array index).</span>
   69 |     | <span class='neutral'> * Given the expensive nature of storage on the EVM we want to store all information as small as possible.</span>
   70 |     | <span class='neutral'> * The pair (erc721, tokenId) is describes a particular NFT but would take two storage slots (as a token id)</span>
   71 |     | <span class='neutral'> * is 256 bits. The erc721 address is 160 bits however we only allow pre-approved erc721 contracts, so in</span>
   72 |     | <span class='neutral'> * practice 16 bits would be enough to store an index into the allowed erc721 contracts. We can hash (erc721 + tokenId)</span>
   73 |     | <span class='neutral'> * to get a unique number but that requires storing both tokenId, erc721 and array index. Instead we hash into</span>
   74 |     | <span class='neutral'> * 224 (256 - 32) bits which is still sufficiently large to avoid collisions. This leaves 32 bits for additional</span>
   75 |     | <span class='neutral'> * information. The 16 LSB are used to store the index in the dSafe array. The 16 RSB are used to store</span>
   76 |     | <span class='neutral'> * the 16 RSB of the tokenId. This allows us to store the tokenId + array index in a single storage slot as a map</span>
   77 |     | <span class='neutral'> * from NFTId to NFTData. Note that the index in the dSafe array might change and thus cannot be part of</span>
   78 |     | <span class='neutral'> * NFTId and thus has to be stored as part of NFTData, requiring the splitting of tokenId.</span>
   79 |     | <span class='neutral'> */</span>
   80 |     | <span class='neutral'></span>
   81 |     | <span class='neutral'>struct NFTTokenData {</span>
   82 |     | <span class='neutral'>    uint240 tokenId; // 240 LSB of the tokenId of the NFT</span>
   83 |     | <span class='neutral'>    uint16 dSafeIdx; // index in dSafe NFT array</span>
   84 |     | <span class='neutral'>    address approvedSpender; // approved spender for ERC721</span>
   85 |     | <span class='neutral'>}</span>
   86 |     | <span class='neutral'></span>
   87 |     | <span class='neutral'>struct ERC20Pool {</span>
   88 |     | <span class='neutral'>    int256 tokens;</span>
   89 |     | <span class='neutral'>    int256 shares;</span>
   90 |     | <span class='neutral'>}</span>
   91 |     | <span class='neutral'></span>
   92 |     | <span class='neutral'>struct ERC20Info {</span>
   93 |     | <span class='neutral'>    address erc20Contract;</span>
   94 |     | <span class='neutral'>    IERC20ValueOracle valueOracle;</span>
   95 |     | <span class='neutral'>    ERC20Pool collateral;</span>
   96 |     | <span class='neutral'>    ERC20Pool debt;</span>
   97 |     | <span class='neutral'>    uint256 baseRate;</span>
   98 |     | <span class='neutral'>    uint256 slope1;</span>
   99 |     | <span class='neutral'>    uint256 slope2;</span>
  100 |     | <span class='neutral'>    uint256 targetUtilization;</span>
  101 |     | <span class='neutral'>    uint256 timestamp;</span>
  102 |     | <span class='neutral'>}</span>
  103 |     | <span class='neutral'></span>
  104 |     | <span class='neutral'>struct ERC721Info {</span>
  105 |     | <span class='neutral'>    address erc721Contract;</span>
  106 |     | <span class='neutral'>    INFTValueOracle valueOracle;</span>
  107 |     | <span class='neutral'>}</span>
  108 |     | <span class='neutral'></span>
  109 |     | <span class='neutral'>struct ContractData {</span>
  110 |     | <span class='neutral'>    uint16 idx;</span>
  111 |     | <span class='neutral'>    ContractKind kind; // 0 invalid, 1 ERC20, 2 ERC721</span>
  112 |     | <span class='neutral'>}</span>
  113 |     | <span class='neutral'></span>
  114 |     | <span class='neutral'>enum ContractKind {</span>
  115 |     | <span class='neutral'>    Invalid,</span>
  116 |     | <span class='neutral'>    ERC20,</span>
  117 |     | <span class='neutral'>    ERC721</span>
  118 |     | <span class='neutral'>}</span>
  119 |     | <span class='neutral'></span>
  120 |     | <span class='neutral'>// We will initialize the system so that 0 is the base currency</span>
  121 |     | <span class='neutral'>// in which the system calculates value.</span>
  122 |     | <span class='neutral'>uint16 constant K_NUMERAIRE_IDX = 0;</span>
  123 |     | <span class='neutral'></span>
  124 |     | <span class='neutral'>library DSafeLib {</span>
  125 |     | <span class='neutral'>    type NFTId is uint256; // 16 bits (tokenId) + 224 bits (hash) + 16 bits (erc721 index)</span>
  126 |     | <span class='neutral'></span>
  127 |     | <span class='neutral'>    struct DSafe {</span>
  128 |     | <span class='neutral'>        address owner;</span>
  129 |     | <span class='neutral'>        mapping(uint16 =&gt; ERC20Share) erc20Share;</span>
  130 |     | <span class='neutral'>        NFTId[] nfts;</span>
  131 |     | <span class='neutral'>        // bitmask of DOS indexes of ERC20 present in a dSafe. `1` can be increased on updates</span>
  132 |     | <span class='neutral'>        uint256[1] dAccountErc20Idxs;</span>
  133 |     | <span class='neutral'>    }</span>
  134 |     | <span class='neutral'></span>
  135 |     | <span class='neutral'>    function removeERC20IdxFromDAccount(DSafe storage dSafe, uint16 erc20Idx) internal {</span>
  136 |     | <span class='neutral'>        dSafe.dAccountErc20Idxs[erc20Idx &gt;&gt; 8] &amp;= ~(1 &lt;&lt; (erc20Idx &amp; 255));</span>
  137 |     | <span class='neutral'>    }</span>
  138 |     | <span class='neutral'></span>
  139 |     | <span class='neutral'>    function accERC20IdxToDAccount(DSafe storage dSafe, uint16 erc20Idx) internal {</span>
  140 |     | <span class='neutral'>        dSafe.dAccountErc20Idxs[erc20Idx &gt;&gt; 8] |= (1 &lt;&lt; (erc20Idx &amp; 255));</span>
  141 |     | <span class='neutral'>    }</span>
  142 |     | <span class='neutral'></span>
  143 |     | <span class='neutral'>    function extractPosition(</span>
  144 |     | <span class='neutral'>        ERC20Pool storage pool,</span>
  145 |     | <span class='neutral'>        ERC20Share shares</span>
  146 |     | <span class='neutral'>    ) internal returns (int256 tokens) {</span>
  147 |     | <span class='neutral'>        tokens = computeERC20(pool, shares);</span>
  148 |     | <span class='neutral'>        pool.tokens -= tokens;</span>
  149 |     | <span class='neutral'>        pool.shares -= ERC20Share.unwrap(shares);</span>
  150 |     | <span class='neutral'>    }</span>
  151 |     | <span class='neutral'></span>
  152 |     | <span class='neutral'>    function insertPosition(ERC20Pool storage pool, int256 tokens) internal returns (ERC20Share) {</span>
  153 |     | <span class='neutral'>        int256 shares;</span>
  154 |     | <span class='neutral'>        if (pool.shares == 0) {</span>
  155 |     | <span class='neutral'>            FsUtils.Assert(pool.tokens == 0);</span>
  156 |     | <span class='neutral'>            shares = tokens;</span>
  157 |     | <span class='neutral'>        } else {</span>
  158 |     | <span class='neutral'>            shares = (pool.shares * tokens) / pool.tokens;</span>
  159 |     | <span class='neutral'>        }</span>
  160 |     | <span class='neutral'>        pool.tokens += tokens;</span>
  161 |     | <span class='neutral'>        pool.shares += shares;</span>
  162 |     | <span class='neutral'>        return ERC20Share.wrap(shares);</span>
  163 |     | <span class='neutral'>    }</span>
  164 |     | <span class='neutral'></span>
  165 |     | <span class='neutral'>    function extractNFT(</span>
  166 |     | <span class='neutral'>        DSafe storage dSafe,</span>
  167 |     | <span class='neutral'>        NFTId nftId,</span>
  168 |     | <span class='neutral'>        mapping(NFTId =&gt; NFTTokenData) storage map</span>
  169 |     | <span class='neutral'>    ) internal {</span>
  170 |     | <span class='neutral'>        uint16 idx = map[nftId].dSafeIdx;</span>
  171 |     | <span class='neutral'>        map[nftId].approvedSpender = address(0); // remove approval</span>
  172 |     | <span class='neutral'>        bool userOwnsNFT = dSafe.nfts.length &gt; 0 &amp;&amp;</span>
  173 |     | <span class='neutral'>            NFTId.unwrap(dSafe.nfts[idx]) == NFTId.unwrap(nftId);</span>
  174 |     | <span class='neutral'>        if (!userOwnsNFT) {</span>
  175 |     | <span class='neutral'>            revert NFTNotInDSafe();</span>
  176 |     | <span class='neutral'>        }</span>
  177 |     | <span class='neutral'>        if (idx == dSafe.nfts.length - 1) {</span>
  178 |     | <span class='neutral'>            dSafe.nfts.pop();</span>
  179 |     | <span class='neutral'>        } else {</span>
  180 |     | <span class='neutral'>            NFTId lastNFTId = dSafe.nfts[dSafe.nfts.length - 1];</span>
  181 |     | <span class='neutral'>            map[lastNFTId].dSafeIdx = idx;</span>
  182 |     | <span class='neutral'>            dSafe.nfts.pop();</span>
  183 |     | <span class='neutral'>        }</span>
  184 |     | <span class='neutral'>    }</span>
  185 |     | <span class='neutral'></span>
  186 |     | <span class='neutral'>    function insertNFT(</span>
  187 |     | <span class='neutral'>        DSafe storage dSafe,</span>
  188 |     | <span class='neutral'>        NFTId nftId,</span>
  189 |     | <span class='neutral'>        mapping(NFTId =&gt; NFTTokenData) storage map</span>
  190 |     | <span class='neutral'>    ) internal {</span>
  191 |     | <span class='neutral'>        uint16 idx = uint16(dSafe.nfts.length);</span>
  192 |     | <span class='neutral'>        dSafe.nfts.push(nftId);</span>
  193 |     | <span class='neutral'>        map[nftId].dSafeIdx = idx;</span>
  194 |     | <span class='neutral'>    }</span>
  195 |     | <span class='neutral'></span>
  196 |     | <span class='neutral'>    function getERC20s(DSafe storage dSafe) internal view returns (uint16[] memory erc20s) {</span>
  197 |     | <span class='neutral'>        uint256 numberOfERC20 = 0;</span>
  198 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; dSafe.dAccountErc20Idxs.length; i++) {</span>
  199 |     | <span class='neutral'>            numberOfERC20 += FsMath.bitCount(dSafe.dAccountErc20Idxs[i]);</span>
  200 |     | <span class='neutral'>        }</span>
  201 |     | <span class='neutral'>        erc20s = new uint16[](numberOfERC20);</span>
  202 |     | <span class='neutral'>        uint256 idx = 0;</span>
  203 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; dSafe.dAccountErc20Idxs.length; i++) {</span>
  204 |     | <span class='neutral'>            uint256 mask = dSafe.dAccountErc20Idxs[i];</span>
  205 |     | <span class='neutral'>            for (uint256 j = 0; j &lt; 256; j++) {</span>
  206 |     | <span class='neutral'>                uint256 x = mask &gt;&gt; j;</span>
  207 |     | <span class='neutral'>                if (x == 0) break;</span>
  208 |     | <span class='neutral'>                if ((x &amp; 1) != 0) {</span>
  209 |     | <span class='neutral'>                    erc20s[idx++] = uint16(i * 256 + j);</span>
  210 |     | <span class='neutral'>                }</span>
  211 |     | <span class='neutral'>            }</span>
  212 |     | <span class='neutral'>        }</span>
  213 |     | <span class='neutral'>    }</span>
  214 |     | <span class='neutral'></span>
  215 |     | <span class='neutral'>    function computeERC20(</span>
  216 |     | <span class='neutral'>        ERC20Pool storage pool,</span>
  217 |     | <span class='neutral'>        ERC20Share sharesWrapped</span>
  218 |     | <span class='neutral'>    ) internal view returns (int256 tokens) {</span>
  219 |     | <span class='neutral'>        int256 shares = ERC20Share.unwrap(sharesWrapped);</span>
  220 |     | <span class='neutral'>        if (shares == 0) return 0;</span>
  221 |     | <span class='neutral'>        FsUtils.Assert(pool.shares != 0);</span>
  222 |     | <span class='neutral'>        return (pool.tokens * shares) / pool.shares;</span>
  223 |     | <span class='neutral'>    }</span>
  224 |     | <span class='neutral'>}</span>
  225 |     | <span class='neutral'></span>
  226 |     | <span class='neutral'>/// @title DOS State</span>
  227 |     | <span class='neutral'>/// @notice Contract holds the configuration state for DOS</span>
  228 |     | <span class='neutral'>contract DOSState is Pausable {</span>
  229 |     | <span class='neutral'>    using DSafeLib for ERC20Pool;</span>
  230 |     | <span class='neutral'></span>
  231 |     | <span class='neutral'>    IVersionManager public versionManager;</span>
  232 |     | <span class='neutral'>    /// @notice mapping between dSafe address and DOS-specific dSafe data</span>
  233 |     | <span class='neutral'>    mapping(address =&gt; DSafeLib.DSafe) public dSafes;</span>
  234 |     | <span class='neutral'></span>
  235 |     | <span class='neutral'>    /// @notice mapping between dSafe address and an instance of deployed dSafeLogic contract.</span>
  236 |     | <span class='neutral'>    /// It means that this specific dSafeLogic version is setup to operate the dSafe.</span>
  237 |     | <span class='neutral'>    // @dev this could be a mapping to a version index instead of the implementation address</span>
  238 |     | <span class='neutral'>    mapping(address =&gt; address) public dSafeLogic;</span>
  239 |     | <span class='neutral'></span>
  240 |     | <span class='neutral'>    /// @notice mapping from</span>
  241 |     | <span class='neutral'>    /// dSafe owner address =&gt; ERC20 address =&gt; dSafe spender address =&gt; allowed amount of ERC20.</span>
  242 |     | <span class='neutral'>    /// It represent the allowance of `spender` to transfer up to `amount` of `erc20` balance of</span>
  243 |     | <span class='neutral'>    /// owner&#39;s dAccount to some other dAccount. E.g. 123 =&gt; abc =&gt; 456 =&gt; 1000, means that</span>
  244 |     | <span class='neutral'>    /// dSafe 456 can transfer up to 1000 of abc tokens from dAccount of dSafe 123 to some other dAccount.</span>
  245 |     | <span class='neutral'>    /// Note, that no ERC20 are actually getting transferred - dAccount is a DOS concept, and</span>
  246 |     | <span class='neutral'>    /// corresponding tokens are owned by DOS</span>
  247 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) public allowances;</span>
  248 |     | <span class='neutral'></span>
  249 |     | <span class='neutral'>    /// @notice Whether a spender is approved to operate a dSafe&#39;s NFTs for a specific collection</span>
  250 |     | <span class='neutral'>    /// @dev Mapping from dSafe owner address =&gt; NFT address =&gt; spender address =&gt; bool</span>
  251 |     | <span class='neutral'>    /// @dev erc721 &amp; erc1155 operator approvals</span>
  252 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; bool))) public operatorApprovals;</span>
  253 |     | <span class='neutral'></span>
  254 |     | <span class='neutral'>    mapping(DSafeLib.NFTId =&gt; NFTTokenData) public tokenDataByNFTId;</span>
  255 |     | <span class='neutral'></span>
  256 |     | <span class='neutral'>    ERC20Info[] public erc20Infos;</span>
  257 |     | <span class='neutral'>    ERC721Info[] public erc721Infos;</span>
  258 |     | <span class='neutral'></span>
  259 |     | <span class='neutral'>    /// @notice mapping of ERC20 or ERC721 address =&gt; DOS asset idx and contract kind.</span>
  260 |     | <span class='neutral'>    /// idx is the index of the ERC20 in `erc20Infos` or ERC721 in `erc721Infos`</span>
  261 |     | <span class='neutral'>    /// kind is ContractKind enum, that here can be ERC20 or ERC721</span>
  262 |     | <span class='neutral'>    mapping(address =&gt; ContractData) public infoIdx;</span>
  263 |     | <span class='neutral'></span>
  264 |     | <span class='neutral'>    IDOSConfig.Config public config;</span>
  265 |     | <span class='neutral'></span>
  266 |     | <span class='neutral'>    modifier onlyDSafe() {</span>
  267 |     | <span class='neutral'>        if (dSafes[msg.sender].owner == address(0)) {</span>
  268 |     | <span class='neutral'>            revert OnlyDSafe();</span>
  269 |     | <span class='neutral'>        }</span>
  270 |     | <span class='neutral'>        _;</span>
  271 |     | <span class='neutral'>    }</span>
  272 |     | <span class='neutral'></span>
  273 |     | <span class='neutral'>    modifier dSafeExists(address dSafe) {</span>
  274 |     | <span class='neutral'>        if (dSafes[dSafe].owner == address(0)) {</span>
  275 |     | <span class='neutral'>            revert DSafeNonExistent();</span>
  276 |     | <span class='neutral'>        }</span>
  277 |     | <span class='neutral'>        _;</span>
  278 |     | <span class='neutral'>    }</span>
  279 |     | <span class='neutral'></span>
  280 |     | <span class='neutral'>    function getBalance(</span>
  281 |     | <span class='neutral'>        ERC20Share shares,</span>
  282 |     | <span class='neutral'>        ERC20Info storage erc20Info</span>
  283 |     | <span class='neutral'>    ) internal view returns (int256) {</span>
  284 |     | <span class='neutral'>        ERC20Pool storage pool = ERC20Share.unwrap(shares) &gt; 0</span>
  285 |     | <span class='neutral'>            ? erc20Info.collateral</span>
  286 |     | <span class='neutral'>            : erc20Info.debt;</span>
  287 |     | <span class='neutral'>        return pool.computeERC20(shares);</span>
  288 |     | <span class='neutral'>    }</span>
  289 |     | <span class='neutral'></span>
  290 |     | <span class='neutral'>    function getNFTData(</span>
  291 |     | <span class='neutral'>        DSafeLib.NFTId nftId</span>
  292 |     | <span class='neutral'>    ) internal view returns (uint16 erc721Idx, uint256 tokenId) {</span>
  293 |     | <span class='neutral'>        uint256 unwrappedId = DSafeLib.NFTId.unwrap(nftId);</span>
  294 |     | <span class='neutral'>        erc721Idx = uint16(unwrappedId);</span>
  295 |     | <span class='neutral'>        tokenId = tokenDataByNFTId[nftId].tokenId | ((unwrappedId &gt;&gt; 240) &lt;&lt; 240);</span>
  296 |     | <span class='neutral'>    }</span>
  297 |     | <span class='neutral'></span>
  298 |     | <span class='neutral'>    function getERC20Info(IERC20 erc20) internal view returns (ERC20Info storage, uint16) {</span>
  299 |     | <span class='neutral'>        if (infoIdx[address(erc20)].kind != ContractKind.ERC20) {</span>
  300 |     | <span class='neutral'>            revert NotRegistered(address(erc20));</span>
  301 |     | <span class='neutral'>        }</span>
  302 |     | <span class='neutral'>        uint16 idx = infoIdx[address(erc20)].idx;</span>
  303 |     | <span class='neutral'>        return (erc20Infos[idx], idx);</span>
  304 |     | <span class='neutral'>    }</span>
  305 |     | <span class='neutral'></span>
  306 |     | <span class='neutral'>    function getERC721Info(IERC721 erc721) internal view returns (ERC721Info storage, uint16) {</span>
  307 |     | <span class='neutral'>        if (infoIdx[address(erc721)].kind != ContractKind.ERC721) {</span>
  308 |     | <span class='neutral'>            revert NotRegistered(address(erc721));</span>
  309 |     | <span class='neutral'>        }</span>
  310 |     | <span class='neutral'>        uint16 idx = infoIdx[address(erc721)].idx;</span>
  311 |     | <span class='neutral'>        return (erc721Infos[idx], idx);</span>
  312 |     | <span class='neutral'>    }</span>
  313 |     | <span class='neutral'>}</span>
  314 |     | <span class='neutral'></span>
  315 |     | <span class='neutral'>/// @title DeFi OS (DOS)</span>
  316 |     | <span class='neutral'>contract DOS is DOSState, IDOSCore, IERC721Receiver, Proxy {</span>
  317 |     | <span class='neutral'>    using DSafeLib for DSafeLib.DSafe;</span>
  318 |     | <span class='neutral'>    using DSafeLib for ERC20Pool;</span>
  319 |     | <span class='neutral'>    using SafeERC20 for IERC20;</span>
  320 |     | <span class='neutral'>    using Address for address;</span>
  321 |     | <span class='neutral'></span>
  322 |     | <span class='neutral'>    address immutable dosConfigAddress;</span>
  323 |     | <span class='neutral'></span>
  324 |     | <span class='neutral'>    modifier onlyRegisteredNFT(address nftContract, uint256 tokenId) {</span>
  325 |     | <span class='neutral'>        // how can we be sure that Oracle would have a price for any possible tokenId?</span>
  326 |     | <span class='neutral'>        // maybe we should check first if Oracle can return a value for this specific NFT?</span>
  327 |     | <span class='neutral'>        if (infoIdx[nftContract].kind == ContractKind.Invalid) {</span>
  328 |     | <span class='neutral'>            revert NotRegistered(nftContract);</span>
  329 |     | <span class='neutral'>        }</span>
  330 |     | <span class='neutral'>        _;</span>
  331 |     | <span class='neutral'>    }</span>
  332 |     | <span class='neutral'></span>
  333 |     | <span class='neutral'>    modifier onlyNFTOwner(address nftContract, uint256 tokenId) {</span>
  334 |     | <span class='neutral'>        address _owner = ERC721(nftContract).ownerOf(tokenId);</span>
  335 |     | <span class='neutral'>        bool isOwner = _owner == msg.sender || _owner == dSafes[msg.sender].owner;</span>
  336 |     | <span class='neutral'>        if (!isOwner) {</span>
  337 |     | <span class='neutral'>            revert NotNFTOwner();</span>
  338 |     | <span class='neutral'>        }</span>
  339 |     | <span class='neutral'>        _;</span>
  340 |     | <span class='neutral'>    }</span>
  341 |     | <span class='neutral'></span>
  342 |     | <span class='neutral'>    constructor(address _dosConfig, address _versionManager) {</span>
  343 |     | <span class='neutral'>        versionManager = IVersionManager(FsUtils.nonNull(_versionManager));</span>
  344 |     | <span class='neutral'>        dosConfigAddress = FsUtils.nonNull(_dosConfig);</span>
  345 |     | <span class='neutral'>    }</span>
  346 |     | <span class='neutral'></span>
  347 |     | <span class='neutral'>    /// @notice top up the dAccount owned by dSafe `to` with `amount` of `erc20`</span>
  348 |     | <span class='neutral'>    /// @param erc20 Address of the ERC20 token to be transferred</span>
  349 |     | <span class='neutral'>    /// @param to Address of the dSafe that dAccount should be top up</span>
  350 |     | <span class='neutral'>    /// @param amount The amount of `erc20` to be sent</span>
  351 |     | <span class='neutral'>    function depositERC20ForSafe(</span>
  352 |     | <span class='neutral'>        address erc20,</span>
  353 |     | <span class='neutral'>        address to,</span>
  354 |     | <span class='neutral'>        uint256 amount</span>
  355 |     | <span class='neutral'>    ) external override dSafeExists(to) whenNotPaused {</span>
  356 |     | <span class='neutral'>        if (amount == 0) return;</span>
  357 |     | <span class='neutral'>        (, uint16 erc20Idx) = getERC20Info(IERC20(erc20));</span>
  358 |     | <span class='neutral'>        int256 signedAmount = FsMath.safeCastToSigned(amount);</span>
  359 |     | <span class='neutral'>        _dAccountERC20ChangeBy(to, erc20Idx, signedAmount);</span>
  360 |     | <span class='neutral'>        emit IDOSCore.ERC20BalanceChanged(erc20, to, signedAmount);</span>
  361 |     | <span class='neutral'>        IERC20(erc20).safeTransferFrom(msg.sender, address(this), amount);</span>
  362 |     | <span class='neutral'>    }</span>
  363 |     | <span class='neutral'></span>
  364 |     | <span class='neutral'>    /// @notice deposit `amount` of `erc20` to dAccount from dSafe</span>
  365 |     | <span class='neutral'>    /// @param erc20 Address of the ERC20 token to be transferred</span>
  366 |     | <span class='neutral'>    /// @param amount The amount of `erc20` to be transferred</span>
  367 |     | <span class='neutral'>    function depositERC20(IERC20 erc20, uint256 amount) external override onlyDSafe whenNotPaused {</span>
  368 |     | <span class='neutral'>        if (amount == 0) return;</span>
  369 |     | <span class='neutral'>        (, uint16 erc20Idx) = getERC20Info(erc20);</span>
  370 |     | <span class='neutral'>        int256 signedAmount = FsMath.safeCastToSigned(amount);</span>
  371 |     | <span class='neutral'>        _dAccountERC20ChangeBy(msg.sender, erc20Idx, signedAmount);</span>
  372 |     | <span class='neutral'>        emit IDOSCore.ERC20BalanceChanged(address(erc20), msg.sender, signedAmount);</span>
  373 |     | <span class='neutral'>        erc20.safeTransferFrom(msg.sender, address(this), amount);</span>
  374 |     | <span class='neutral'>    }</span>
  375 |     | <span class='neutral'></span>
  376 |     | <span class='neutral'>    /// @notice deposit `amount` of `erc20` from dAccount tp dSafe</span>
  377 |     | <span class='neutral'>    /// @param erc20 Address of the ERC20 token to be transferred</span>
  378 |     | <span class='neutral'>    /// @param amount The amount of `erc20` to be transferred</span>
  379 |     | <span class='neutral'>    function withdrawERC20(IERC20 erc20, uint256 amount) external override onlyDSafe whenNotPaused {</span>
  380 |     | <span class='neutral'>        (, uint16 erc20Idx) = getERC20Info(erc20);</span>
  381 |     | <span class='neutral'>        int256 signedAmount = FsMath.safeCastToSigned(amount);</span>
  382 |     | <span class='neutral'>        _dAccountERC20ChangeBy(msg.sender, erc20Idx, -signedAmount);</span>
  383 |     | <span class='neutral'>        emit IDOSCore.ERC20BalanceChanged(address(erc20), msg.sender, -signedAmount);</span>
  384 |     | <span class='neutral'>        erc20.safeTransfer(msg.sender, amount);</span>
  385 |     | <span class='neutral'>    }</span>
  386 |     | <span class='neutral'></span>
  387 |     | <span class='neutral'>    /// @notice deposit all `erc20s` from dSafe to dAccount</span>
  388 |     | <span class='neutral'>    /// @param erc20s Array of addresses of ERC20 to be transferred</span>
  389 |     | <span class='neutral'>    function depositFull(IERC20[] calldata erc20s) external override onlyDSafe whenNotPaused {</span>
  390 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; erc20s.length; i++) {</span>
  391 |     | <span class='neutral'>            (ERC20Info storage erc20Info, uint16 erc20Idx) = getERC20Info(erc20s[i]);</span>
  392 |     | <span class='neutral'>            IERC20 erc20 = IERC20(erc20Info.erc20Contract);</span>
  393 |     | <span class='neutral'>            uint256 amount = erc20.balanceOf(msg.sender);</span>
  394 |     | <span class='neutral'>            int256 signedAmount = FsMath.safeCastToSigned(amount);</span>
  395 |     | <span class='neutral'>            _dAccountERC20ChangeBy(msg.sender, erc20Idx, signedAmount);</span>
  396 |     | <span class='neutral'>            emit IDOSCore.ERC20BalanceChanged(address(erc20), msg.sender, signedAmount);</span>
  397 |     | <span class='neutral'>            erc20.safeTransferFrom(msg.sender, address(this), amount);</span>
  398 |     | <span class='neutral'>        }</span>
  399 |     | <span class='neutral'>    }</span>
  400 |     | <span class='neutral'></span>
  401 |     | <span class='neutral'>    /// @notice withdraw all `erc20s` from dAccount to dSafe</span>
  402 |     | <span class='neutral'>    /// @param erc20s Array of addresses of ERC20 to be transferred</span>
  403 |     | <span class='neutral'>    function withdrawFull(IERC20[] calldata erc20s) external onlyDSafe whenNotPaused {</span>
  404 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; erc20s.length; i++) {</span>
  405 |     | <span class='neutral'>            (ERC20Info storage erc20Info, uint16 erc20Idx) = getERC20Info(erc20s[i]);</span>
  406 |     | <span class='neutral'>            IERC20 erc20 = IERC20(erc20Info.erc20Contract);</span>
  407 |     | <span class='neutral'>            int256 amount = _dAccountERC20Clear(msg.sender, erc20Idx);</span>
  408 |     | <span class='neutral'>            require(amount &gt;= 0, &quot;Can&#39;t withdraw debt&quot;);</span>
  409 |     | <span class='neutral'>            emit IDOSCore.ERC20BalanceChanged(address(erc20), msg.sender, amount);</span>
  410 |     | <span class='neutral'>            erc20.safeTransfer(msg.sender, uint256(amount));</span>
  411 |     | <span class='neutral'>        }</span>
  412 |     | <span class='neutral'>    }</span>
  413 |     | <span class='neutral'></span>
  414 |     | <span class='neutral'>    /// @notice deposit ERC721 `erc721Contract` token `tokenId` from dSafe to dAccount</span>
  415 |     | <span class='neutral'>    /// @dev the part when we track the ownership of deposit NFT to a specific dAccount is in</span>
  416 |     | <span class='neutral'>    /// `onERC721Received` function of this contract</span>
  417 |     | <span class='neutral'>    /// @param erc721Contract The address of the ERC721 contract that the token belongs to</span>
  418 |     | <span class='neutral'>    /// @param tokenId The id of the token to be transferred</span>
  419 |     | <span class='neutral'>    function depositERC721(</span>
  420 |     | <span class='neutral'>        address erc721Contract,</span>
  421 |     | <span class='neutral'>        uint256 tokenId</span>
  422 |     | <span class='neutral'>    )</span>
  423 |     | <span class='neutral'>        external</span>
  424 |     | <span class='neutral'>        override</span>
  425 |     | <span class='neutral'>        onlyDSafe</span>
  426 |     | <span class='neutral'>        whenNotPaused</span>
  427 |     | <span class='neutral'>        onlyRegisteredNFT(erc721Contract, tokenId)</span>
  428 |     | <span class='neutral'>        onlyNFTOwner(erc721Contract, tokenId)</span>
  429 |     | <span class='neutral'>    {</span>
  430 |     | <span class='neutral'>        address _owner = ERC721(erc721Contract).ownerOf(tokenId);</span>
  431 |     | <span class='neutral'>        emit IDOSCore.ERC721Deposited(erc721Contract, msg.sender, tokenId);</span>
  432 |     | <span class='neutral'>        ERC721(erc721Contract).safeTransferFrom(</span>
  433 |     | <span class='neutral'>            _owner,</span>
  434 |     | <span class='neutral'>            address(this),</span>
  435 |     | <span class='neutral'>            tokenId,</span>
  436 |     | <span class='neutral'>            abi.encode(msg.sender)</span>
  437 |     | <span class='neutral'>        );</span>
  438 |     | <span class='neutral'>    }</span>
  439 |     | <span class='neutral'></span>
  440 |     | <span class='neutral'>    /// @notice withdraw ERC721 `nftContract` token `tokenId` from dAccount to dSafe</span>
  441 |     | <span class='neutral'>    /// @param erc721 The address of the ERC721 contract that the token belongs to</span>
  442 |     | <span class='neutral'>    /// @param tokenId The id of the token to be transferred</span>
  443 |     | <span class='neutral'>    function withdrawERC721(</span>
  444 |     | <span class='neutral'>        address erc721,</span>
  445 |     | <span class='neutral'>        uint256 tokenId</span>
  446 |     | <span class='neutral'>    ) external override onlyDSafe whenNotPaused {</span>
  447 |     | <span class='neutral'>        DSafeLib.NFTId nftId = _getNFTId(erc721, tokenId);</span>
  448 |     | <span class='neutral'></span>
  449 |     | <span class='neutral'>        dSafes[msg.sender].extractNFT(nftId, tokenDataByNFTId);</span>
  450 |     | <span class='neutral'>        delete tokenDataByNFTId[nftId];</span>
  451 |     | <span class='neutral'>        emit IDOSCore.ERC721Withdrawn(erc721, msg.sender, tokenId);</span>
  452 |     | <span class='neutral'></span>
  453 |     | <span class='neutral'>        ERC721(erc721).safeTransferFrom(address(this), msg.sender, tokenId);</span>
  454 |     | <span class='neutral'>    }</span>
  455 |     | <span class='neutral'></span>
  456 |     | <span class='neutral'>    /// @notice transfer `amount` of `erc20` from dAccount of caller dSafe to dAccount of `to` dSafe</span>
  457 |     | <span class='neutral'>    /// @param erc20 Address of the ERC20 token to be transferred</span>
  458 |     | <span class='neutral'>    /// @param to dSafe address, whose dAccount is the transfer target</span>
  459 |     | <span class='neutral'>    /// @param amount The amount of `erc20` to be transferred</span>
  460 |     | <span class='neutral'>    function transferERC20(</span>
  461 |     | <span class='neutral'>        IERC20 erc20,</span>
  462 |     | <span class='neutral'>        address to,</span>
  463 |     | <span class='neutral'>        uint256 amount</span>
  464 |     | <span class='neutral'>    ) external override onlyDSafe whenNotPaused dSafeExists(to) {</span>
  465 |     | <span class='neutral'>        if (amount == 0) return;</span>
  466 |     | <span class='neutral'>        _transferERC20(erc20, msg.sender, to, FsMath.safeCastToSigned(amount));</span>
  467 |     | <span class='neutral'>    }</span>
  468 |     | <span class='neutral'></span>
  469 |     | <span class='neutral'>    /// @notice transfer NFT `erc721` token `tokenId` from dAccount of caller dSafe to dAccount of</span>
  470 |     | <span class='neutral'>    /// `to` dSafe</span>
  471 |     | <span class='neutral'>    /// @param erc721 The address of the ERC721 contract that the token belongs to</span>
  472 |     | <span class='neutral'>    /// @param tokenId The id of the token to be transferred</span>
  473 |     | <span class='neutral'>    /// @param to dSafe address, whose dAccount is the transfer target</span>
  474 |     | <span class='neutral'>    function transferERC721(</span>
  475 |     | <span class='neutral'>        address erc721,</span>
  476 |     | <span class='neutral'>        uint256 tokenId,</span>
  477 |     | <span class='neutral'>        address to</span>
  478 |     | <span class='neutral'>    ) external override onlyDSafe whenNotPaused dSafeExists(to) {</span>
  479 |     | <span class='neutral'>        DSafeLib.NFTId nftId = _getNFTId(erc721, tokenId);</span>
  480 |     | <span class='neutral'>        _transferNFT(nftId, msg.sender, to);</span>
  481 |     | <span class='neutral'>    }</span>
  482 |     | <span class='neutral'></span>
  483 |     | <span class='neutral'>    /// @notice Transfer ERC20 tokens from dAccount to another dAccount</span>
  484 |     | <span class='neutral'>    /// @dev Note: Allowance must be set with approveERC20</span>
  485 |     | <span class='neutral'>    /// @param erc20 The index of the ERC20 token in erc20Infos array</span>
  486 |     | <span class='neutral'>    /// @param from The address of the dSafe to transfer from</span>
  487 |     | <span class='neutral'>    /// @param to The address of the dSafe to transfer to</span>
  488 |     | <span class='neutral'>    /// @param amount The amount of tokens to transfer</span>
  489 |     | <span class='neutral'>    /// @return true, when the transfer has been successfully finished without been reverted</span>
  490 |     | <span class='neutral'>    function transferFromERC20(</span>
  491 |     | <span class='neutral'>        address erc20,</span>
  492 |     | <span class='neutral'>        address from,</span>
  493 |     | <span class='neutral'>        address to,</span>
  494 |     | <span class='neutral'>        uint256 amount</span>
  495 |     | <span class='neutral'>    ) external override whenNotPaused dSafeExists(from) dSafeExists(to) returns (bool) {</span>
  496 |     | <span class='neutral'>        address spender = msg.sender;</span>
  497 |     | <span class='neutral'>        _spendAllowance(erc20, from, spender, amount);</span>
  498 |     | <span class='neutral'>        _transferERC20(IERC20(erc20), from, to, FsMath.safeCastToSigned(amount));</span>
  499 |     | <span class='neutral'>        return true;</span>
  500 |     | <span class='neutral'>    }</span>
  501 |     | <span class='neutral'></span>
  502 |     | <span class='neutral'>    /// @notice Transfer ERC721 tokens from dAccount to another dAccount</span>
  503 |     | <span class='neutral'>    /// @param collection The address of the ERC721 token</span>
  504 |     | <span class='neutral'>    /// @param from The address of the dSafe to transfer from</span>
  505 |     | <span class='neutral'>    /// @param to The address of the dSafe to transfer to</span>
  506 |     | <span class='neutral'>    /// @param tokenId The id of the token to transfer</span>
  507 |     | <span class='neutral'>    function transferFromERC721(</span>
  508 |     | <span class='neutral'>        address collection,</span>
  509 |     | <span class='neutral'>        address from,</span>
  510 |     | <span class='neutral'>        address to,</span>
  511 |     | <span class='neutral'>        uint256 tokenId</span>
  512 |     | <span class='neutral'>    ) external override onlyDSafe whenNotPaused dSafeExists(to) {</span>
  513 |     | <span class='neutral'>        DSafeLib.NFTId nftId = _getNFTId(collection, tokenId);</span>
  514 |     | <span class='neutral'>        if (!_isApprovedOrOwner(msg.sender, from, nftId)) {</span>
  515 |     | <span class='neutral'>            revert NotApprovedOrOwner();</span>
  516 |     | <span class='neutral'>        }</span>
  517 |     | <span class='neutral'>        _transferNFT(nftId, from, to);</span>
  518 |     | <span class='neutral'>    }</span>
  519 |     | <span class='neutral'></span>
  520 |     | <span class='neutral'>    /// @notice Liquidate an undercollateralized position</span>
  521 |     | <span class='neutral'>    /// @dev if dAccount of `dSafe` has more debt then collateral then this function will</span>
  522 |     | <span class='neutral'>    /// transfer all debt and collateral ERC20s and ERC721 from dAccount of `dSafe` to dAccount of</span>
  523 |     | <span class='neutral'>    /// caller. Considering that market price of collateral is higher then market price of debt,</span>
  524 |     | <span class='neutral'>    /// a friction of that difference would be sent back to liquidated dAccount in DOS base currency.</span>
  525 |     | <span class='neutral'>    ///   More specific - &quot;some fraction&quot; is `liqFraction` parameter of DOS.</span>
  526 |     | <span class='neutral'>    ///   Considering that call to this function would create debt on caller (debt is less then</span>
  527 |     | <span class='neutral'>    /// gains, yet still), consider using `liquify` instead, that would liquidate and use</span>
  528 |     | <span class='neutral'>    /// obtained assets to cover all created debt</span>
  529 |     | <span class='neutral'>    ///   If dAccount of `dSafe` has less debt then collateral then the transaction will be reverted</span>
  530 |     | <span class='neutral'>    /// @param dSafe The address of dSafe whose dAccount to be liquidate</span>
  531 |     | <span class='neutral'>    function liquidate(address dSafe) external override onlyDSafe whenNotPaused dSafeExists(dSafe) {</span>
  532 |     | <span class='neutral'>        (int256 totalValue, int256 collateral, int256 debt) = getRiskAdjustedPositionValues(dSafe);</span>
  533 |     | <span class='neutral'>        require(collateral &lt; debt, &quot;DSafe is not liquidatable&quot;);</span>
  534 |     | <span class='neutral'>        uint16[] memory dSafeERC20s = dSafes[dSafe].getERC20s();</span>
  535 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; dSafeERC20s.length; i++) {</span>
  536 |     | <span class='neutral'>            uint16 erc20Idx = dSafeERC20s[i];</span>
  537 |     | <span class='neutral'>            _transferAllERC20(erc20Idx, dSafe, msg.sender);</span>
  538 |     | <span class='neutral'>        }</span>
  539 |     | <span class='neutral'>        while (dSafes[dSafe].nfts.length &gt; 0) {</span>
  540 |     | <span class='neutral'>            _transferNFT(dSafes[dSafe].nfts[dSafes[dSafe].nfts.length - 1], dSafe, msg.sender);</span>
  541 |     | <span class='neutral'>        }</span>
  542 |     | <span class='neutral'>        if (totalValue &gt; 0) {</span>
  543 |     | <span class='neutral'>            // totalValue of the liquidated dSafe is split between liquidatable and liquidator:</span>
  544 |     | <span class='neutral'>            // totalValue * (1 - liqFraction) - reward of the liquidator, and</span>
  545 |     | <span class='neutral'>            // totalValue * liqFraction - change, liquidator is sending back to liquidatable</span>
  546 |     | <span class='neutral'>            int256 percentUnderwater = (collateral * 1 ether) / debt;</span>
  547 |     | <span class='neutral'>            int256 leftover = ((totalValue * config.liqFraction * percentUnderwater) / 1 ether) /</span>
  548 |     | <span class='neutral'>                1 ether;</span>
  549 |     | <span class='neutral'>            _transferERC20(</span>
  550 |     | <span class='neutral'>                IERC20(erc20Infos[K_NUMERAIRE_IDX].erc20Contract),</span>
  551 |     | <span class='neutral'>                msg.sender,</span>
  552 |     | <span class='neutral'>                dSafe,</span>
  553 |     | <span class='neutral'>                leftover</span>
  554 |     | <span class='neutral'>            );</span>
  555 |     | <span class='neutral'>        }</span>
  556 |     | <span class='neutral'>        emit IDOSCore.SafeLiquidated(dSafe, msg.sender);</span>
  557 |     | <span class='neutral'>    }</span>
  558 |     | <span class='neutral'></span>
  559 |     | <span class='neutral'>    /// @notice Execute a batch of calls</span>
  560 |     | <span class='neutral'>    /// @dev execute a batch of commands on DOS from the name of dSafe owner. Eventual state of</span>
  561 |     | <span class='neutral'>    /// dAccount and DOS must be solvent, i.e. debt on dAccount cannot exceed collateral</span>
  562 |     | <span class='neutral'>    /// and DOS reserve/debt must be sufficient</span>
  563 |     | <span class='neutral'>    /// @param calls An array of transaction calls</span>
  564 |     | <span class='neutral'>    function executeBatch(Call[] memory calls) external override onlyDSafe whenNotPaused {</span>
  565 |     | <span class='neutral'>        DSafeProxy(payable(msg.sender)).executeBatch(calls);</span>
  566 |     | <span class='neutral'>        if (!isSolvent(msg.sender)) {</span>
  567 |     | <span class='neutral'>            revert Insolvent();</span>
  568 |     | <span class='neutral'>        }</span>
  569 |     | <span class='neutral'>    }</span>
  570 |     | <span class='neutral'></span>
  571 |     | <span class='neutral'>    /// @notice ERC721 transfer callback</span>
  572 |     | <span class='neutral'>    /// @dev it&#39;s a callback, required to be implemented by IERC721Receiver interface for the</span>
  573 |     | <span class='neutral'>    /// contract to be able to receive ERC721 NFTs.</span>
  574 |     | <span class='neutral'>    /// We are using it to track what dAccount owns what NFT.</span>
  575 |     | <span class='neutral'>    /// `return this.onERC721Received.selector;` is mandatory part for the NFT transfer to work -</span>
  576 |     | <span class='neutral'>    /// not a part of our business logic</span>
  577 |     | <span class='neutral'>    /// @param - operator The address which called `safeTransferFrom` function</span>
  578 |     | <span class='neutral'>    /// @param from The address which previously owned the token</span>
  579 |     | <span class='neutral'>    /// @param tokenId The NFT identifier which is being transferred</span>
  580 |     | <span class='neutral'>    /// @param data Additional data with no specified format</span>
  581 |     | <span class='neutral'>    /// @return `bytes4(keccak256(&quot;onERC721Received(address,address,uint256,bytes)&quot;))`</span>
  582 |     | <span class='neutral'>    function onERC721Received(</span>
  583 |     | <span class='neutral'>        address /* operator */,</span>
  584 |     | <span class='neutral'>        address from,</span>
  585 |     | <span class='neutral'>        uint256 tokenId,</span>
  586 |     | <span class='neutral'>        bytes calldata data</span>
  587 |     | <span class='neutral'>    ) external override whenNotPaused returns (bytes4) {</span>
  588 |     | <span class='neutral'>        DSafeLib.NFTId nftId = _getNFTId(msg.sender, tokenId);</span>
  589 |     | <span class='neutral'>        if (data.length != 0) {</span>
  590 |     | <span class='neutral'>            from = abi.decode(data, (address));</span>
  591 |     | <span class='neutral'>        }</span>
  592 |     | <span class='neutral'>        require(dSafes[from].owner != address(0), &quot;DSafe does not exist&quot;);</span>
  593 |     | <span class='neutral'>        tokenDataByNFTId[nftId].tokenId = uint240(tokenId);</span>
  594 |     | <span class='neutral'>        dSafes[from].insertNFT(nftId, tokenDataByNFTId);</span>
  595 |     | <span class='neutral'>        return this.onERC721Received.selector;</span>
  596 |     | <span class='neutral'>    }</span>
  597 |     | <span class='neutral'></span>
  598 |     | <span class='neutral'>    /// @notice Approve an array of tokens and then call `onApprovalReceived` on spender</span>
  599 |     | <span class='neutral'>    /// @param approvals An array of ERC20 tokens with amounts, or ERC721 contracts with tokenIds</span>
  600 |     | <span class='neutral'>    /// @param spender The address of the spender dSafe</span>
  601 |     | <span class='neutral'>    /// @param data Additional data with no specified format, sent in call to `spender`</span>
  602 |     | <span class='neutral'>    function approveAndCall(</span>
  603 |     | <span class='neutral'>        Approval[] calldata approvals,</span>
  604 |     | <span class='neutral'>        address spender,</span>
  605 |     | <span class='neutral'>        bytes calldata data</span>
  606 |     | <span class='neutral'>    ) external override onlyDSafe whenNotPaused {</span>
  607 |     | <span class='neutral'>        uint256[] memory prev = new uint256[](approvals.length);</span>
  608 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; approvals.length; i++) {</span>
  609 |     | <span class='neutral'>            prev[i] = _approve(</span>
  610 |     | <span class='neutral'>                msg.sender,</span>
  611 |     | <span class='neutral'>                spender,</span>
  612 |     | <span class='neutral'>                approvals[i].ercContract,</span>
  613 |     | <span class='neutral'>                approvals[i].amountOrTokenId,</span>
  614 |     | <span class='neutral'>                spender</span>
  615 |     | <span class='neutral'>            );</span>
  616 |     | <span class='neutral'>        }</span>
  617 |     | <span class='neutral'>        if (!_checkOnApprovalReceived(msg.sender, 0, spender, data)) {</span>
  618 |     | <span class='neutral'>            revert WrongDataReturned();</span>
  619 |     | <span class='neutral'>        }</span>
  620 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; approvals.length; i++) {</span>
  621 |     | <span class='neutral'>            _approve(msg.sender, spender, approvals[i].ercContract, prev[i], address(0)); // reset allowance</span>
  622 |     | <span class='neutral'>        }</span>
  623 |     | <span class='neutral'>    }</span>
  624 |     | <span class='neutral'></span>
  625 |     | <span class='neutral'>    /// @notice provides the specific version of dSafeLogic contract that is associated with `dSafe`</span>
  626 |     | <span class='neutral'>    /// @param dSafe Address of dSafe whose dSafeLogic contract should be returned</span>
  627 |     | <span class='neutral'>    /// @return the address of the dSafeLogic contract that is associated with the `dSafe`</span>
  628 |     | <span class='neutral'>    function getImplementation(address dSafe) external view override returns (address) {</span>
  629 |     | <span class='neutral'>        // not using msg.sender since this is an external view function</span>
  630 |     | <span class='neutral'>        return dSafeLogic[dSafe];</span>
  631 |     | <span class='neutral'>    }</span>
  632 |     | <span class='neutral'></span>
  633 |     | <span class='neutral'>    /// @notice provides the owner of `dSafe`. Owner of the dSafe is the address who created the dSafe</span>
  634 |     | <span class='neutral'>    /// @param dSafe The address of dSafe whose owner should be returned</span>
  635 |     | <span class='neutral'>    /// @return the owner address of the `dSafe`. Owner is the one who created the `dSafe`</span>
  636 |     | <span class='neutral'>    function getDSafeOwner(address dSafe) external view override returns (address) {</span>
  637 |     | <span class='neutral'>        return dSafes[dSafe].owner;</span>
  638 |     | <span class='neutral'>    }</span>
  639 |     | <span class='neutral'></span>
  640 |     | <span class='neutral'>    /// @notice returns the collateral, debt and total value of `dSafeAddress`.</span>
  641 |     | <span class='neutral'>    /// @dev Notice that both collateral and debt has some coefficients on the actual amount of deposit</span>
  642 |     | <span class='neutral'>    /// and loan assets! E.g.</span>
  643 |     | <span class='neutral'>    /// for a deposit of 1 ETH the collateral would be equivalent to like 0.8 ETH, and</span>
  644 |     | <span class='neutral'>    /// for a loan of 1 ETH the debt would be equivalent to like 1.2 ETH.</span>
  645 |     | <span class='neutral'>    /// At the same time, totalValue is the unmodified difference between deposits and loans.</span>
  646 |     | <span class='neutral'>    /// @param dSafeAddress The address of dSafe whose collateral, debt and total value would be returned</span>
  647 |     | <span class='neutral'>    /// @return totalValue The difference between equivalents of deposit and loan assets</span>
  648 |     | <span class='neutral'>    /// @return collateral The sum of deposited assets multiplied by their collateral factors</span>
  649 |     | <span class='neutral'>    /// @return debt The sum of borrowed assets multiplied by their borrow factors</span>
  650 |     | <span class='neutral'>    function getRiskAdjustedPositionValues(</span>
  651 |     | <span class='neutral'>        address dSafeAddress</span>
  652 |     | <span class='neutral'>    )</span>
  653 |     | <span class='neutral'>        public</span>
  654 |     | <span class='neutral'>        view</span>
  655 |     | <span class='neutral'>        override</span>
  656 |     | <span class='neutral'>        dSafeExists(dSafeAddress)</span>
  657 |     | <span class='neutral'>        returns (int256 totalValue, int256 collateral, int256 debt)</span>
  658 |     | <span class='neutral'>    {</span>
  659 |     | <span class='neutral'>        DSafeLib.DSafe storage dSafe = dSafes[dSafeAddress];</span>
  660 |     | <span class='neutral'>        uint16[] memory erc20Idxs = dSafe.getERC20s();</span>
  661 |     | <span class='neutral'>        totalValue = 0;</span>
  662 |     | <span class='neutral'>        collateral = 0;</span>
  663 |     | <span class='neutral'>        debt = 0;</span>
  664 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; erc20Idxs.length; i++) {</span>
  665 |     | <span class='neutral'>            uint16 erc20Idx = erc20Idxs[i];</span>
  666 |     | <span class='neutral'>            ERC20Info storage erc20Info = erc20Infos[erc20Idx];</span>
  667 |     | <span class='neutral'>            int256 balance = getBalance(dSafe.erc20Share[erc20Idx], erc20Info);</span>
  668 |     | <span class='neutral'>            (int256 value, int256 riskAdjustedValue) = erc20Info.valueOracle.calcValue(balance);</span>
  669 |     | <span class='neutral'>            totalValue += value;</span>
  670 |     | <span class='neutral'>            if (balance &gt;= 0) {</span>
  671 |     | <span class='neutral'>                collateral += riskAdjustedValue;</span>
  672 |     | <span class='neutral'>            } else {</span>
  673 |     | <span class='neutral'>                debt -= riskAdjustedValue;</span>
  674 |     | <span class='neutral'>            }</span>
  675 |     | <span class='neutral'>        }</span>
  676 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; dSafe.nfts.length; i++) {</span>
  677 |     | <span class='neutral'>            DSafeLib.NFTId nftId = dSafe.nfts[i];</span>
  678 |     | <span class='neutral'>            (uint16 erc721Idx, uint256 tokenId) = getNFTData(nftId);</span>
  679 |     | <span class='neutral'>            ERC721Info storage nftInfo = erc721Infos[erc721Idx];</span>
  680 |     | <span class='neutral'>            (int256 nftValue, int256 nftRiskAdjustedValue) = nftInfo.valueOracle.calcValue(tokenId);</span>
  681 |     | <span class='neutral'>            totalValue += nftValue;</span>
  682 |     | <span class='neutral'>            collateral += nftRiskAdjustedValue;</span>
  683 |     | <span class='neutral'>        }</span>
  684 |     | <span class='neutral'>    }</span>
  685 |     | <span class='neutral'></span>
  686 |     | <span class='neutral'>    /// @notice Returns the approved address for a token, or zero if no address set</span>
  687 |     | <span class='neutral'>    /// @param collection The address of the ERC721 token</span>
  688 |     | <span class='neutral'>    /// @param tokenId The id of the token to query</span>
  689 |     | <span class='neutral'>    /// @return The dSafe address that is allowed to transfer the ERC721 token</span>
  690 |     | <span class='neutral'>    function getApproved(</span>
  691 |     | <span class='neutral'>        address collection,</span>
  692 |     | <span class='neutral'>        uint256 tokenId</span>
  693 |     | <span class='neutral'>    ) public view override returns (address) {</span>
  694 |     | <span class='neutral'>        DSafeLib.NFTId nftId = _getNFTId(collection, tokenId);</span>
  695 |     | <span class='neutral'>        return tokenDataByNFTId[nftId].approvedSpender;</span>
  696 |     | <span class='neutral'>    }</span>
  697 |     | <span class='neutral'></span>
  698 |     | <span class='neutral'>    /// @notice Returns if the `operator` is allowed to manage all of the erc721s of `owner` on the `collection` contract</span>
  699 |     | <span class='neutral'>    /// @param collection The address of the collection contract</span>
  700 |     | <span class='neutral'>    /// @param _owner The address of the dSafe owner</span>
  701 |     | <span class='neutral'>    /// @param spender The address of the dSafe spender</span>
  702 |     | <span class='neutral'>    /// @return if the `spender` is allowed to operate the assets of `collection` of `_owner`</span>
  703 |     | <span class='neutral'>    function isApprovedForAll(</span>
  704 |     | <span class='neutral'>        address collection,</span>
  705 |     | <span class='neutral'>        address _owner,</span>
  706 |     | <span class='neutral'>        address spender</span>
  707 |     | <span class='neutral'>    ) public view override returns (bool) {</span>
  708 |     | <span class='neutral'>        return operatorApprovals[collection][_owner][spender];</span>
  709 |     | <span class='neutral'>    }</span>
  710 |     | <span class='neutral'></span>
  711 |     | <span class='neutral'>    /// @notice Returns the remaining amount of tokens that `spender` will be allowed to spend on</span>
  712 |     | <span class='neutral'>    /// behalf of `owner` through {transferFrom}</span>
  713 |     | <span class='neutral'>    /// @dev This value changes when {approve} or {transferFrom} are called</span>
  714 |     | <span class='neutral'>    /// @param erc20 The address of the ERC20 to be checked</span>
  715 |     | <span class='neutral'>    /// @param _owner The dSafe address whose `erc20` are allowed to be transferred by `spender`</span>
  716 |     | <span class='neutral'>    /// @param spender The dSafe address who is allowed to spend `erc20` of `_owner`</span>
  717 |     | <span class='neutral'>    /// @return the remaining amount of tokens that `spender` will be allowed to spend on</span>
  718 |     | <span class='neutral'>    /// behalf of `owner` through {transferFrom}</span>
  719 |     | <span class='neutral'>    function allowance(</span>
  720 |     | <span class='neutral'>        address erc20,</span>
  721 |     | <span class='neutral'>        address _owner,</span>
  722 |     | <span class='neutral'>        address spender</span>
  723 |     | <span class='neutral'>    ) public view override returns (uint256) {</span>
  724 |     | <span class='neutral'>        if (_owner == spender) return type(uint256).max;</span>
  725 |     | <span class='neutral'>        return allowances[_owner][erc20][spender];</span>
  726 |     | <span class='neutral'>    }</span>
  727 |     | <span class='neutral'></span>
  728 |     | <span class='neutral'>    /// @notice Compute the interest rate of `underlying`</span>
  729 |     | <span class='neutral'>    /// @param erc20Idx The underlying asset</span>
  730 |     | <span class='neutral'>    /// @return The interest rate of `erc20Idx`</span>
  731 |     | <span class='neutral'>    function computeInterestRate(uint16 erc20Idx) public view override returns (int96) {</span>
  732 |     | <span class='neutral'>        ERC20Info memory erc20Info = erc20Infos[erc20Idx];</span>
  733 |     | <span class='neutral'>        uint256 debt = FsMath.safeCastToUnsigned(-erc20Info.debt.tokens); // question: is debt ever positive?</span>
  734 |     | <span class='neutral'>        uint256 collateral = FsMath.safeCastToUnsigned(erc20Info.collateral.tokens); // question: is collateral ever negative?</span>
  735 |     | <span class='neutral'>        uint256 leverage = FsMath.safeCastToUnsigned(config.fractionalReserveLeverage);</span>
  736 |     | <span class='neutral'>        uint256 poolAssets = debt + collateral;</span>
  737 |     | <span class='neutral'></span>
  738 |     | <span class='neutral'>        uint256 ir = erc20Info.baseRate;</span>
  739 |     | <span class='neutral'>        uint256 utilization; // utilization of the pool</span>
  740 |     | <span class='neutral'>        if (poolAssets == 0)</span>
  741 |     | <span class='neutral'>            utilization = 0; // if there are no assets, utilization is 0</span>
  742 |     | <span class='neutral'>        else utilization = uint256((debt * 1e18) / ((collateral - debt) / leverage));</span>
  743 |     | <span class='neutral'></span>
  744 |     | <span class='neutral'>        if (utilization &lt;= erc20Info.targetUtilization) {</span>
  745 |     | <span class='neutral'>            ir += (utilization * erc20Info.slope1) / 1e15;</span>
  746 |     | <span class='neutral'>        } else {</span>
  747 |     | <span class='neutral'>            ir += (erc20Info.targetUtilization * erc20Info.slope1) / 1e15;</span>
  748 |     | <span class='neutral'>            ir += ((erc20Info.slope2 * (utilization - erc20Info.targetUtilization)) / 1e15);</span>
  749 |     | <span class='neutral'>        }</span>
  750 |     | <span class='neutral'></span>
  751 |     | <span class='neutral'>        return int96(int256(ir));</span>
  752 |     | <span class='neutral'>    }</span>
  753 |     | <span class='neutral'></span>
  754 |     | <span class='neutral'>    function _approve(</span>
  755 |     | <span class='neutral'>        address _owner,</span>
  756 |     | <span class='neutral'>        address spender,</span>
  757 |     | <span class='neutral'>        address ercContract,</span>
  758 |     | <span class='neutral'>        uint256 amountOrTokenId,</span>
  759 |     | <span class='neutral'>        address erc721Spender</span>
  760 |     | <span class='neutral'>    ) internal returns (uint256 prev) {</span>
  761 |     | <span class='neutral'>        FsUtils.Assert(spender != address(0));</span>
  762 |     | <span class='neutral'>        ContractData memory data = infoIdx[ercContract];</span>
  763 |     | <span class='neutral'>        if (data.kind == ContractKind.ERC20) {</span>
  764 |     | <span class='neutral'>            prev = allowance(ercContract, _owner, spender);</span>
  765 |     | <span class='neutral'>            allowances[_owner][ercContract][spender] = amountOrTokenId;</span>
  766 |     | <span class='neutral'>        } else if (data.kind == ContractKind.ERC721) {</span>
  767 |     | <span class='neutral'>            prev = amountOrTokenId;</span>
  768 |     | <span class='neutral'>            tokenDataByNFTId[_getNFTId(ercContract, amountOrTokenId)]</span>
  769 |     | <span class='neutral'>                .approvedSpender = erc721Spender;</span>
  770 |     | <span class='neutral'>        } else {</span>
  771 |     | <span class='neutral'>            FsUtils.Assert(false);</span>
  772 |     | <span class='neutral'>        }</span>
  773 |     | <span class='neutral'>    }</span>
  774 |     | <span class='neutral'></span>
  775 |     | <span class='neutral'>    /// @dev changes the quantity of `erc20` by `amount` that are allowed to transfer from dAccount</span>
  776 |     | <span class='neutral'>    /// of dSafe `_owner` by dSafe `spender`</span>
  777 |     | <span class='neutral'>    function _spendAllowance(</span>
  778 |     | <span class='neutral'>        address erc20,</span>
  779 |     | <span class='neutral'>        address _owner,</span>
  780 |     | <span class='neutral'>        address spender,</span>
  781 |     | <span class='neutral'>        uint256 amount</span>
  782 |     | <span class='neutral'>    ) internal {</span>
  783 |     | <span class='neutral'>        uint256 currentAllowance = allowance(erc20, _owner, spender);</span>
  784 |     | <span class='neutral'>        if (currentAllowance != type(uint256).max) {</span>
  785 |     | <span class='neutral'>            if (currentAllowance &lt; amount) {</span>
  786 |     | <span class='neutral'>                revert InsufficientAllowance();</span>
  787 |     | <span class='neutral'>            }</span>
  788 |     | <span class='neutral'>            unchecked {</span>
  789 |     | <span class='neutral'>                allowances[_owner][erc20][spender] = currentAllowance - amount;</span>
  790 |     | <span class='neutral'>            }</span>
  791 |     | <span class='neutral'>        }</span>
  792 |     | <span class='neutral'>    }</span>
  793 |     | <span class='neutral'></span>
  794 |     | <span class='neutral'>    /**</span>
  795 |     | <span class='neutral'>     * @dev Internal function to invoke {IERC1363Receiver-onApprovalReceived} on a target address</span>
  796 |     | <span class='neutral'>     *  The call is not executed if the target address is not a contract</span>
  797 |     | <span class='neutral'>     * @param spender address The address which will spend the funds</span>
  798 |     | <span class='neutral'>     * @param amount uint256 The amount of tokens to be spent</span>
  799 |     | <span class='neutral'>     * @param data bytes Optional data to send along with the call</span>
  800 |     | <span class='neutral'>     * @return whether the call correctly returned the expected magic value</span>
  801 |     | <span class='neutral'>     */</span>
  802 |     | <span class='neutral'>    function _checkOnApprovalReceived(</span>
  803 |     | <span class='neutral'>        address spender, // safe</span>
  804 |     | <span class='neutral'>        uint256 amount,</span>
  805 |     | <span class='neutral'>        address target, // router</span>
  806 |     | <span class='neutral'>        bytes memory data</span>
  807 |     | <span class='neutral'>    ) internal returns (bool) {</span>
  808 |     | <span class='neutral'>        if (!spender.isContract()) {</span>
  809 |     | <span class='neutral'>            revert ReceiverNotContract();</span>
  810 |     | <span class='neutral'>        }</span>
  811 |     | <span class='neutral'></span>
  812 |     | <span class='neutral'>        Call memory call = Call({to: target, callData: data, value: msg.value});</span>
  813 |     | <span class='neutral'></span>
  814 |     | <span class='neutral'>        try IERC1363SpenderExtended(spender).onApprovalReceived(msg.sender, amount, call) returns (</span>
  815 |     | <span class='neutral'>            bytes4 retval</span>
  816 |     | <span class='neutral'>        ) {</span>
  817 |     | <span class='neutral'>            return retval == IERC1363SpenderExtended.onApprovalReceived.selector;</span>
  818 |     | <span class='neutral'>        } catch (bytes memory reason) {</span>
  819 |     | <span class='neutral'>            if (reason.length == 0) {</span>
  820 |     | <span class='neutral'>                revert ReceiverNoImplementation();</span>
  821 |     | <span class='neutral'>            } else {</span>
  822 |     | <span class='neutral'>                FsUtils.revertBytes(reason);</span>
  823 |     | <span class='neutral'>            }</span>
  824 |     | <span class='neutral'>        }</span>
  825 |     | <span class='neutral'>    }</span>
  826 |     | <span class='neutral'></span>
  827 |     | <span class='neutral'>    /// @dev transfer ERC20 balances between dAccounts.</span>
  828 |     | <span class='neutral'>    /// Because all ERC20 tokens on dAccounts are owned by DOS, no tokens are getting transferred -</span>
  829 |     | <span class='neutral'>    /// all changes are inside DOS contract state</span>
  830 |     | <span class='neutral'>    /// @param erc20 The address of ERC20 token balance to transfer</span>
  831 |     | <span class='neutral'>    /// @param from The address of dSafe whose dAccount balance should be decreased by `amount`</span>
  832 |     | <span class='neutral'>    /// @param to The address of dSafe whose dAccount balance should be increased by `amount`</span>
  833 |     | <span class='neutral'>    /// @param amount The amount of `erc20` by witch the balance of</span>
  834 |     | <span class='neutral'>    /// dAccount of dSafe `from` should be decreased and</span>
  835 |     | <span class='neutral'>    /// dAccount of dSafe `to` should be increased.</span>
  836 |     | <span class='neutral'>    /// Note that amount it can be negative</span>
  837 |     | <span class='neutral'>    function _transferERC20(IERC20 erc20, address from, address to, int256 amount) internal {</span>
  838 |     | <span class='neutral'>        (, uint16 erc20Idx) = getERC20Info(erc20);</span>
  839 |     | <span class='neutral'>        _dAccountERC20ChangeBy(from, erc20Idx, -amount);</span>
  840 |     | <span class='neutral'>        _dAccountERC20ChangeBy(to, erc20Idx, amount);</span>
  841 |     | <span class='neutral'>        emit IDOSCore.ERC20Transfer(address(erc20), from, to, amount);</span>
  842 |     | <span class='neutral'>    }</span>
  843 |     | <span class='neutral'></span>
  844 |     | <span class='neutral'>    /// @dev transfer ERC721 NFT ownership between dAccounts.</span>
  845 |     | <span class='neutral'>    /// Because all ERC721 NFTs on dAccounts are owned by DOS, no NFT is getting transferred - all</span>
  846 |     | <span class='neutral'>    /// changes are inside DOS contract state</span>
  847 |     | <span class='neutral'>    function _transferNFT(DSafeLib.NFTId nftId, address from, address to) internal {</span>
  848 |     | <span class='neutral'>        dSafes[from].extractNFT(nftId, tokenDataByNFTId);</span>
  849 |     | <span class='neutral'>        dSafes[to].insertNFT(nftId, tokenDataByNFTId);</span>
  850 |     | <span class='neutral'>        emit ERC721Transferred(DSafeLib.NFTId.unwrap(nftId), from, to);</span>
  851 |     | <span class='neutral'>    }</span>
  852 |     | <span class='neutral'></span>
  853 |     | <span class='neutral'>    /// @dev transfer all `erc20Idx` from `from` to `to`</span>
  854 |     | <span class='neutral'>    function _transferAllERC20(uint16 erc20Idx, address from, address to) internal {</span>
  855 |     | <span class='neutral'>        int256 amount = _dAccountERC20Clear(from, erc20Idx);</span>
  856 |     | <span class='neutral'>        _dAccountERC20ChangeBy(to, erc20Idx, amount);</span>
  857 |     | <span class='neutral'>        address erc20 = erc20Infos[erc20Idx].erc20Contract;</span>
  858 |     | <span class='neutral'>        emit IDOSCore.ERC20Transfer(erc20, from, to, amount);</span>
  859 |     | <span class='neutral'>    }</span>
  860 |     | <span class='neutral'></span>
  861 |     | <span class='neutral'>    function _dAccountERC20ChangeBy(address dSafeAddress, uint16 erc20Idx, int256 amount) internal {</span>
  862 |     | <span class='neutral'>        _updateInterest(erc20Idx);</span>
  863 |     | <span class='neutral'>        DSafeLib.DSafe storage dSafe = dSafes[dSafeAddress];</span>
  864 |     | <span class='neutral'>        ERC20Share shares = dSafe.erc20Share[erc20Idx];</span>
  865 |     | <span class='neutral'>        ERC20Info storage erc20Info = erc20Infos[erc20Idx];</span>
  866 |     | <span class='neutral'>        int256 currentAmount = _extractPosition(shares, erc20Info);</span>
  867 |     | <span class='neutral'>        int256 newAmount = currentAmount + amount;</span>
  868 |     | <span class='neutral'>        dSafe.erc20Share[erc20Idx] = _insertPosition(newAmount, dSafe, erc20Idx);</span>
  869 |     | <span class='neutral'>    }</span>
  870 |     | <span class='neutral'></span>
  871 |     | <span class='neutral'>    function _dAccountERC20Clear(address dSafeAddress, uint16 erc20Idx) internal returns (int256) {</span>
  872 |     | <span class='neutral'>        _updateInterest(erc20Idx);</span>
  873 |     | <span class='neutral'>        DSafeLib.DSafe storage dSafe = dSafes[dSafeAddress];</span>
  874 |     | <span class='neutral'>        ERC20Share shares = dSafe.erc20Share[erc20Idx];</span>
  875 |     | <span class='neutral'>        int256 erc20Amount = _extractPosition(shares, erc20Infos[erc20Idx]);</span>
  876 |     | <span class='neutral'>        dSafe.erc20Share[erc20Idx] = ERC20Share.wrap(0);</span>
  877 |     | <span class='neutral'>        dSafe.removeERC20IdxFromDAccount(erc20Idx);</span>
  878 |     | <span class='neutral'>        return erc20Amount;</span>
  879 |     | <span class='neutral'>    }</span>
  880 |     | <span class='neutral'></span>
  881 |     | <span class='neutral'>    function _extractPosition(</span>
  882 |     | <span class='neutral'>        ERC20Share sharesWrapped,</span>
  883 |     | <span class='neutral'>        ERC20Info storage erc20Info</span>
  884 |     | <span class='neutral'>    ) internal returns (int256) {</span>
  885 |     | <span class='neutral'>        int256 shares = ERC20Share.unwrap(sharesWrapped);</span>
  886 |     | <span class='neutral'>        ERC20Pool storage pool = shares &gt; 0 ? erc20Info.collateral : erc20Info.debt;</span>
  887 |     | <span class='neutral'>        return pool.extractPosition(sharesWrapped);</span>
  888 |     | <span class='neutral'>    }</span>
  889 |     | <span class='neutral'></span>
  890 |     | <span class='neutral'>    function _insertPosition(</span>
  891 |     | <span class='neutral'>        int256 amount,</span>
  892 |     | <span class='neutral'>        DSafeLib.DSafe storage dSafe,</span>
  893 |     | <span class='neutral'>        uint16 erc20Idx</span>
  894 |     | <span class='neutral'>    ) internal returns (ERC20Share) {</span>
  895 |     | <span class='neutral'>        if (amount == 0) {</span>
  896 |     | <span class='neutral'>            dSafe.removeERC20IdxFromDAccount(erc20Idx);</span>
  897 |     | <span class='neutral'>        } else {</span>
  898 |     | <span class='neutral'>            dSafe.accERC20IdxToDAccount(erc20Idx);</span>
  899 |     | <span class='neutral'>        }</span>
  900 |     | <span class='neutral'>        ERC20Info storage erc20Info = erc20Infos[erc20Idx];</span>
  901 |     | <span class='neutral'>        ERC20Pool storage pool = amount &gt; 0 ? erc20Info.collateral : erc20Info.debt;</span>
  902 |     | <span class='neutral'>        return pool.insertPosition(amount);</span>
  903 |     | <span class='neutral'>    }</span>
  904 |     | <span class='neutral'></span>
  905 |     | <span class='neutral'>    function _updateInterest(uint16 erc20Idx) internal {</span>
  906 |     | <span class='neutral'>        ERC20Info storage erc20Info = erc20Infos[erc20Idx]; // retrieve ERC20Info and store in memory</span>
  907 |     | <span class='neutral'>        if (erc20Info.timestamp == block.timestamp) return; // already updated this block</span>
  908 |     | <span class='neutral'>        int256 delta = FsMath.safeCastToSigned(block.timestamp - erc20Info.timestamp); // time passed since last update</span>
  909 |     | <span class='neutral'>        erc20Info.timestamp = block.timestamp; // update timestamp to current timestamp</span>
  910 |     | <span class='neutral'>        int256 debt = -erc20Info.debt.tokens; // get the debt</span>
  911 |     | <span class='neutral'>        int256 interestRate = computeInterestRate(erc20Idx);</span>
  912 |     | <span class='neutral'>        int256 interest = (debt * (FsMath.exp(interestRate * delta) - FsMath.FIXED_POINT_SCALE)) /</span>
  913 |     | <span class='neutral'>            FsMath.FIXED_POINT_SCALE; // Get the interest</span>
  914 |     | <span class='neutral'>        int256 treasuryInterest = (interest *</span>
  915 |     | <span class='neutral'>            FsMath.safeCastToSigned(config.treasuryInterestFraction)) / 1 ether; // Get the treasury interest</span>
  916 |     | <span class='neutral'>        erc20Info.debt.tokens -= interest; // subtract interest from debt (increase)</span>
  917 |     | <span class='neutral'>        erc20Info.collateral.tokens += interest - treasuryInterest; // add interest to collateral (increase)</span>
  918 |     | <span class='neutral'></span>
  919 |     | <span class='neutral'>        _dAccountERC20ChangeBy(config.treasurySafe, erc20Idx, treasuryInterest); // add treasury interest to treasury</span>
  920 |     | <span class='neutral'>    }</span>
  921 |     | <span class='neutral'></span>
  922 |     | <span class='neutral'>    /// @notice Checks if the account&#39;s positions are overcollateralized</span>
  923 |     | <span class='neutral'>    /// @dev checks the eventual state of `executeBatch` function execution:</span>
  924 |     | <span class='neutral'>    /// * `dSafe` must have collateral &gt;= debt</span>
  925 |     | <span class='neutral'>    /// * DOS must have sufficient balance of deposits and loans for each ERC20 token</span>
  926 |     | <span class='neutral'>    /// @dev when called by the end of `executeBatch`, isSolvent checks the potential target state</span>
  927 |     | <span class='neutral'>    /// of DOS. Calling this function separately would check current state of DOS, that is always</span>
  928 |     | <span class='neutral'>    /// solvable, and so the return value would always be `true`, unless the `dSafe` is liquidatable</span>
  929 |     | <span class='neutral'>    /// @param dSafe The address of a dSafe who performed the `executeBatch`</span>
  930 |     | <span class='neutral'>    /// @return Whether the position is solvent.</span>
  931 |     | <span class='neutral'>    function isSolvent(address dSafe) internal view returns (bool) {</span>
  932 |     | <span class='neutral'>        uint gasBefore = gasleft();</span>
  933 |     | <span class='neutral'>        int256 leverage = config.fractionalReserveLeverage;</span>
  934 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; erc20Infos.length; i++) {</span>
  935 |     | <span class='neutral'>            int256 totalDebt = erc20Infos[i].debt.tokens;</span>
  936 |     | <span class='neutral'>            int256 reserve = erc20Infos[i].collateral.tokens + totalDebt;</span>
  937 |     | <span class='neutral'>            FsUtils.Assert(</span>
  938 |     | <span class='neutral'>                IERC20(erc20Infos[i].erc20Contract).balanceOf(address(this)) &gt;= uint256(reserve)</span>
  939 |     | <span class='neutral'>            );</span>
  940 |     | <span class='neutral'>            require(reserve &gt;= -totalDebt / leverage, &quot;Not enough reserve for debt&quot;);</span>
  941 |     | <span class='neutral'>        }</span>
  942 |     | <span class='neutral'>        (, int256 collateral, int256 debt) = getRiskAdjustedPositionValues(dSafe);</span>
  943 |     | <span class='neutral'>        if (gasBefore - gasleft() &gt; config.maxSolvencyCheckGasCost)</span>
  944 |     | <span class='neutral'>            revert SolvencyCheckTooExpensive();</span>
  945 |     | <span class='neutral'>        return collateral &gt;= debt;</span>
  946 |     | <span class='neutral'>    }</span>
  947 |     | <span class='neutral'></span>
  948 |     | <span class='neutral'>    function _getNFTId(address erc721, uint256 tokenId) internal view returns (DSafeLib.NFTId) {</span>
  949 |     | <span class='neutral'>        if (infoIdx[erc721].kind != ContractKind.ERC721) {</span>
  950 |     | <span class='neutral'>            revert NotNFT();</span>
  951 |     | <span class='neutral'>        }</span>
  952 |     | <span class='neutral'>        uint16 erc721Idx = infoIdx[erc721].idx;</span>
  953 |     | <span class='neutral'>        uint256 tokenHash = uint256(keccak256(abi.encodePacked(tokenId))) &gt;&gt; 32;</span>
  954 |     | <span class='neutral'>        return DSafeLib.NFTId.wrap(erc721Idx | (tokenHash &lt;&lt; 16) | ((tokenId &gt;&gt; 240) &lt;&lt; 240));</span>
  955 |     | <span class='neutral'>    }</span>
  956 |     | <span class='neutral'></span>
  957 |     | <span class='neutral'>    function _isApprovedOrOwner(</span>
  958 |     | <span class='neutral'>        address spender,</span>
  959 |     | <span class='neutral'>        address _owner,</span>
  960 |     | <span class='neutral'>        DSafeLib.NFTId nftId</span>
  961 |     | <span class='neutral'>    ) internal view returns (bool) {</span>
  962 |     | <span class='neutral'>        DSafeLib.DSafe storage p = dSafes[msg.sender];</span>
  963 |     | <span class='neutral'>        (uint16 infoIndex, uint256 tokenId) = getNFTData(nftId);</span>
  964 |     | <span class='neutral'>        address collection = erc721Infos[infoIndex].erc721Contract;</span>
  965 |     | <span class='neutral'>        uint16 idx = tokenDataByNFTId[nftId].dSafeIdx;</span>
  966 |     | <span class='neutral'>        bool isdepositERC721Owner = idx &lt; p.nfts.length &amp;&amp;</span>
  967 |     | <span class='neutral'>            DSafeLib.NFTId.unwrap(p.nfts[idx]) == DSafeLib.NFTId.unwrap(nftId);</span>
  968 |     | <span class='neutral'>        return (isdepositERC721Owner ||</span>
  969 |     | <span class='neutral'>            getApproved(collection, tokenId) == spender ||</span>
  970 |     | <span class='neutral'>            isApprovedForAll(collection, _owner, spender));</span>
  971 |     | <span class='neutral'>    }</span>
  972 |     | <span class='neutral'></span>
  973 |     | <span class='neutral'>    // Config functions are handled by DOSConfig</span>
  974 |     | <span class='neutral'>    function _implementation() internal view override returns (address) {</span>
  975 |     | <span class='neutral'>        return dosConfigAddress;</span>
  976 |     | <span class='neutral'>    }</span>
  977 |     | <span class='neutral'>}</span>
  978 |     | <span class='neutral'></span>
  979 |     | <span class='neutral'>/// @title DOS Config</span>
  980 |     | <span class='neutral'>contract DOSConfig is DOSState, ImmutableGovernance, IDOSConfig {</span>
  981 |     | <span class='neutral'>    using DSafeLib for DSafeLib.DSafe;</span>
  982 |     | <span class='neutral'>    using DSafeLib for ERC20Pool;</span>
  983 |     | <span class='neutral'>    using SafeERC20 for IERC20;</span>
  984 |     | <span class='neutral'>    using Address for address;</span>
  985 |     | <span class='neutral'></span>
  986 |     | <span class='neutral'>    constructor(address _owner) ImmutableGovernance(_owner) {}</span>
  987 |     | <span class='neutral'></span>
  988 |     | <span class='neutral'>    /// @notice upgrades the version of dSafeLogic contract for the `dSafe`</span>
  989 |     | <span class='neutral'>    /// @param version The new target version of dSafeLogic contract</span>
  990 |     | <span class='neutral'>    function upgradeDSafeImplementation(</span>
  991 |     | <span class='neutral'>        string calldata version</span>
  992 |     | <span class='neutral'>    ) external override onlyDSafe whenNotPaused {</span>
  993 |     | <span class='neutral'>        (</span>
  994 |     | <span class='neutral'>            ,</span>
  995 |     | <span class='neutral'>            IVersionManager.Status status,</span>
  996 |     | <span class='neutral'>            IVersionManager.BugLevel bugLevel,</span>
  997 |     | <span class='neutral'>            address implementation,</span>
  998 |     | <span class='neutral'></span>
  999 |     | <span class='neutral'>        ) = versionManager.getVersionDetails(version);</span>
 1000 |     | <span class='neutral'>        require(status != IVersionManager.Status.DEPRECATED, &quot;Version is deprecated&quot;);</span>
 1001 |     | <span class='neutral'>        require(bugLevel == IVersionManager.BugLevel.NONE, &quot;Version has bugs&quot;);</span>
 1002 |     | <span class='neutral'>        dSafeLogic[msg.sender] = implementation;</span>
 1003 |     | <span class='neutral'>        emit IDOSConfig.DSafeImplementationUpgraded(msg.sender, version, implementation);</span>
 1004 |     | <span class='neutral'>    }</span>
 1005 |     | <span class='neutral'></span>
 1006 |     | <span class='neutral'>    /// @notice transfers the ownership of the `dSafe` to the `newOwner`</span>
 1007 |     | <span class='neutral'>    /// @param newOwner The new owner of the `dSafe`</span>
 1008 |     | <span class='neutral'>    function transferDSafeOwnership(address newOwner) external override onlyDSafe whenNotPaused {</span>
 1009 |     | <span class='neutral'>        dSafes[msg.sender].owner = newOwner;</span>
 1010 |     | <span class='neutral'>        emit IDOSConfig.DSafeOwnershipTransferred(msg.sender, newOwner);</span>
 1011 |     | <span class='neutral'>    }</span>
 1012 |     | <span class='neutral'></span>
 1013 |     | <span class='neutral'>    /// @notice Pause the contract</span>
 1014 |     | <span class='neutral'>    function pause() external override onlyGovernance {</span>
 1015 |     | <span class='neutral'>        _pause();</span>
 1016 |     | <span class='neutral'>    }</span>
 1017 |     | <span class='neutral'></span>
 1018 |     | <span class='neutral'>    /// @notice Unpause the contract</span>
 1019 |     | <span class='neutral'>    function unpause() external override onlyGovernance {</span>
 1020 |     | <span class='neutral'>        _unpause();</span>
 1021 |     | <span class='neutral'>    }</span>
 1022 |     | <span class='neutral'></span>
 1023 |     | <span class='neutral'>    /// @notice add a new ERC20 to be used inside DOS</span>
 1024 |     | <span class='neutral'>    /// @dev For governance only.</span>
 1025 |     | <span class='neutral'>    /// @param erc20Contract The address of ERC20 to add</span>
 1026 |     | <span class='neutral'>    /// @param name The name of the ERC20. E.g. &quot;Wrapped ETH&quot;</span>
 1027 |     | <span class='neutral'>    /// @param symbol The symbol of the ERC20. E.g. &quot;WETH&quot;</span>
 1028 |     | <span class='neutral'>    /// @param decimals Decimals of the ERC20. E.g. 18 for WETH and 6 for USDC</span>
 1029 |     | <span class='neutral'>    /// @param valueOracle The address of the Value Oracle. Probably Uniswap one</span>
 1030 |     | <span class='neutral'>    /// @param baseRate The interest rate when utilization is 0</span>
 1031 |     | <span class='neutral'>    /// @param slope1 The interest rate slope when utilization is less than the targetUtilization</span>
 1032 |     | <span class='neutral'>    /// @param slope2 The interest rate slope when utilization is more than the targetUtilization</span>
 1033 |     | <span class='neutral'>    /// @param targetUtilization The target utilization for the asset</span>
 1034 |     | <span class='neutral'>    /// @return the index of the added ERC20 in the erc20Infos array</span>
 1035 |     | <span class='neutral'>    function addERC20Info(</span>
 1036 |     | <span class='neutral'>        address erc20Contract,</span>
 1037 |     | <span class='neutral'>        string calldata name,</span>
 1038 |     | <span class='neutral'>        string calldata symbol,</span>
 1039 |     | <span class='neutral'>        uint8 decimals,</span>
 1040 |     | <span class='neutral'>        address valueOracle,</span>
 1041 |     | <span class='neutral'>        uint256 baseRate,</span>
 1042 |     | <span class='neutral'>        uint256 slope1,</span>
 1043 |     | <span class='neutral'>        uint256 slope2,</span>
 1044 |     | <span class='neutral'>        uint256 targetUtilization</span>
 1045 |     | <span class='neutral'>    ) external override onlyGovernance returns (uint16) {</span>
 1046 |     | <span class='neutral'>        uint16 erc20Idx = uint16(erc20Infos.length);</span>
 1047 |     | <span class='neutral'>        erc20Infos.push(</span>
 1048 |     | <span class='neutral'>            ERC20Info(</span>
 1049 |     | <span class='neutral'>                erc20Contract,</span>
 1050 |     | <span class='neutral'>                IERC20ValueOracle(valueOracle),</span>
 1051 |     | <span class='neutral'>                ERC20Pool(0, 0),</span>
 1052 |     | <span class='neutral'>                ERC20Pool(0, 0),</span>
 1053 |     | <span class='neutral'>                baseRate,</span>
 1054 |     | <span class='neutral'>                slope1,</span>
 1055 |     | <span class='neutral'>                slope2,</span>
 1056 |     | <span class='neutral'>                targetUtilization,</span>
 1057 |     | <span class='neutral'>                block.timestamp</span>
 1058 |     | <span class='neutral'>            )</span>
 1059 |     | <span class='neutral'>        );</span>
 1060 |     | <span class='neutral'>        infoIdx[erc20Contract] = ContractData(erc20Idx, ContractKind.ERC20);</span>
 1061 |     | <span class='neutral'>        emit IDOSConfig.ERC20Added(</span>
 1062 |     | <span class='neutral'>            erc20Idx,</span>
 1063 |     | <span class='neutral'>            erc20Contract,</span>
 1064 |     | <span class='neutral'>            name,</span>
 1065 |     | <span class='neutral'>            symbol,</span>
 1066 |     | <span class='neutral'>            decimals,</span>
 1067 |     | <span class='neutral'>            valueOracle,</span>
 1068 |     | <span class='neutral'>            baseRate,</span>
 1069 |     | <span class='neutral'>            slope1,</span>
 1070 |     | <span class='neutral'>            slope2,</span>
 1071 |     | <span class='neutral'>            targetUtilization</span>
 1072 |     | <span class='neutral'>        );</span>
 1073 |     | <span class='neutral'>        return erc20Idx;</span>
 1074 |     | <span class='neutral'>    }</span>
 1075 |     | <span class='neutral'></span>
 1076 |     | <span class='neutral'>    /// @notice Add a new ERC721 to be used inside DOS.</span>
 1077 |     | <span class='neutral'>    /// @dev For governance only.</span>
 1078 |     | <span class='neutral'>    /// @param erc721Contract The address of the ERC721 to be added</span>
 1079 |     | <span class='neutral'>    /// @param valueOracleAddress The address of the Uniswap Oracle to get the price of a token</span>
 1080 |     | <span class='neutral'>    function addERC721Info(</span>
 1081 |     | <span class='neutral'>        address erc721Contract,</span>
 1082 |     | <span class='neutral'>        address valueOracleAddress</span>
 1083 |     | <span class='neutral'>    ) external override onlyGovernance {</span>
 1084 |     | <span class='neutral'>        if (IERC165(erc721Contract).supportsInterface(type(IERC721).interfaceId) == false) {</span>
 1085 |     | <span class='neutral'>            revert NotNFT();</span>
 1086 |     | <span class='neutral'>        }</span>
 1087 |     | <span class='neutral'>        INFTValueOracle valueOracle = INFTValueOracle(valueOracleAddress);</span>
 1088 |     | <span class='neutral'>        uint256 erc721Idx = erc721Infos.length;</span>
 1089 |     | <span class='neutral'>        erc721Infos.push(ERC721Info(erc721Contract, valueOracle));</span>
 1090 |     | <span class='neutral'>        infoIdx[erc721Contract] = ContractData(uint16(erc721Idx), ContractKind.ERC721);</span>
 1091 |     | <span class='neutral'>        emit IDOSConfig.ERC721Added(erc721Idx, erc721Contract, valueOracleAddress);</span>
 1092 |     | <span class='neutral'>    }</span>
 1093 |     | <span class='neutral'></span>
 1094 |     | <span class='neutral'>    /// @notice Updates the config of DOS</span>
 1095 |     | <span class='neutral'>    /// @dev for governance only.</span>
 1096 |     | <span class='neutral'>    /// @param _config the Config of IDOSConfig. A struct with DOS parameters</span>
 1097 |     | <span class='neutral'>    function setConfig(Config calldata _config) external override onlyGovernance {</span>
 1098 |     | <span class='neutral'>        config = _config;</span>
 1099 |     | <span class='neutral'>        emit IDOSConfig.ConfigSet(_config);</span>
 1100 |     | <span class='neutral'>    }</span>
 1101 |     | <span class='neutral'></span>
 1102 |     | <span class='neutral'>    /// @notice Set the address of Version Manager contract</span>
 1103 |     | <span class='neutral'>    /// @dev for governance only.</span>
 1104 |     | <span class='neutral'>    /// @param _versionManager The address of the Version Manager contract to be set</span>
 1105 |     | <span class='neutral'>    function setVersionManager(address _versionManager) external override onlyGovernance {</span>
 1106 |     | <span class='neutral'>        versionManager = IVersionManager(_versionManager);</span>
 1107 |     | <span class='neutral'>        emit IDOSConfig.VersionManagerSet(_versionManager);</span>
 1108 |     | <span class='neutral'>    }</span>
 1109 |     | <span class='neutral'></span>
 1110 |     | <span class='neutral'>    /// @notice Updates some of ERC20 config parameters</span>
 1111 |     | <span class='neutral'>    /// @dev for governance only.</span>
 1112 |     | <span class='neutral'>    /// @param erc20 The address of ERC20 contract for which DOS config parameters should be updated</span>
 1113 |     | <span class='neutral'>    /// @param baseRate The interest rate when utilization is 0</span>
 1114 |     | <span class='neutral'>    /// @param slope1 The interest rate slope when utilization is less than the targetUtilization</span>
 1115 |     | <span class='neutral'>    /// @param slope2 The interest rate slope when utilization is more than the targetUtilization</span>
 1116 |     | <span class='neutral'>    /// @param targetUtilization The target utilization for the asset</span>
 1117 |     | <span class='neutral'>    function setERC20Data(</span>
 1118 |     | <span class='neutral'>        address erc20,</span>
 1119 |     | <span class='neutral'>        uint256 baseRate,</span>
 1120 |     | <span class='neutral'>        uint256 slope1,</span>
 1121 |     | <span class='neutral'>        uint256 slope2,</span>
 1122 |     | <span class='neutral'>        uint256 targetUtilization</span>
 1123 |     | <span class='neutral'>    ) external override onlyGovernance {</span>
 1124 |     | <span class='neutral'>        uint16 erc20Idx = infoIdx[erc20].idx;</span>
 1125 |     | <span class='neutral'>        if (infoIdx[erc20].kind != ContractKind.ERC20) {</span>
 1126 |     | <span class='neutral'>            revert NotERC20();</span>
 1127 |     | <span class='neutral'>        }</span>
 1128 |     | <span class='neutral'>        erc20Infos[erc20Idx].baseRate = baseRate;</span>
 1129 |     | <span class='neutral'>        erc20Infos[erc20Idx].slope1 = slope1;</span>
 1130 |     | <span class='neutral'>        erc20Infos[erc20Idx].slope2 = slope2;</span>
 1131 |     | <span class='neutral'>        erc20Infos[erc20Idx].targetUtilization = targetUtilization;</span>
 1132 |     | <span class='neutral'>        emit IDOSConfig.ERC20DataSet(erc20, baseRate, slope1, slope2, targetUtilization);</span>
 1133 |     | <span class='neutral'>    }</span>
 1134 |     | <span class='neutral'></span>
 1135 |     | <span class='neutral'>    /// @notice creates a new dSafe with sender as the owner and returns the dSafe address</span>
 1136 |     | <span class='neutral'>    /// @return dSafe The address of the created dSafe</span>
 1137 |     | <span class='neutral'>    function createDSafe() external override whenNotPaused returns (address dSafe) {</span>
 1138 |     | <span class='neutral'>        _createDSafe(msg.sender);</span>
 1139 |     | <span class='neutral'>   }</span>
 1140 |     | <span class='neutral'></span>
 1141 |     | <span class='neutral'>    function _createDSafe(address sender) public returns (address dSafe) {</span>
 1142 |     | <span class='neutral'>        address[] memory erc20s = new address[](erc20Infos.length);</span>
 1143 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; erc20Infos.length; i++) {</span>
 1144 |     | <span class='neutral'>            erc20s[i] = erc20Infos[i].erc20Contract;</span>
 1145 |     | <span class='neutral'>        }</span>
 1146 |     | <span class='neutral'>        address[] memory erc721s = new address[](erc721Infos.length);</span>
 1147 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; erc721Infos.length; i++) {</span>
 1148 |     | <span class='neutral'>            erc721s[i] = erc721Infos[i].erc721Contract;</span>
 1149 |     | <span class='neutral'>        }</span>
 1150 |     | <span class='neutral'></span>
 1151 |     | <span class='neutral'>        dSafe = address(new DSafeProxy(address(this), erc20s, erc721s));</span>
 1152 |     | <span class='neutral'>        dSafes[dSafe].owner = sender;</span>
 1153 |     | <span class='neutral'></span>
 1154 |     | <span class='neutral'>        // add a version parameter if users should pick a specific version</span>
 1155 |     | <span class='neutral'>        (, , , address implementation, ) = versionManager.getRecommendedVersion();</span>
 1156 |     | <span class='neutral'>        dSafeLogic[dSafe] = implementation;</span>
 1157 |     | <span class='neutral'>        emit IDOSConfig.DSafeCreated(dSafe, sender);</span>
 1158 |     | <span class='neutral'>    }</span>
 1159 |     | <span class='neutral'></span>
 1160 |     | <span class='neutral'>    /// @notice Returns the amount of `erc20` tokens on dAccount of dSafe</span>
 1161 |     | <span class='neutral'>    /// @param dSafeAddr The address of the dSafe for which dAccount the amount of `erc20` should</span>
 1162 |     | <span class='neutral'>    /// be calculated</span>
 1163 |     | <span class='neutral'>    /// @param erc20 The address of ERC20 which balance on dAccount of `dSafe` should be calculated</span>
 1164 |     | <span class='neutral'>    /// @return the amount of `erc20` on the dAccount of `dSafe`</span>
 1165 |     | <span class='neutral'>    function getDAccountERC20(</span>
 1166 |     | <span class='neutral'>        address dSafeAddr,</span>
 1167 |     | <span class='neutral'>        IERC20 erc20</span>
 1168 |     | <span class='neutral'>    ) external view override returns (int256) {</span>
 1169 |     | <span class='neutral'>        DSafeLib.DSafe storage dSafe = dSafes[dSafeAddr];</span>
 1170 |     | <span class='neutral'>        (ERC20Info storage erc20Info, uint16 erc20Idx) = getERC20Info(erc20);</span>
 1171 |     | <span class='neutral'>        ERC20Share erc20Share = dSafe.erc20Share[erc20Idx];</span>
 1172 |     | <span class='neutral'>        return getBalance(erc20Share, erc20Info);</span>
 1173 |     | <span class='neutral'>    }</span>
 1174 |     | <span class='neutral'></span>
 1175 |     | <span class='neutral'>    /// @notice returns the NFTs on dAccount of `dSafe`</span>
 1176 |     | <span class='neutral'>    /// @param dSafe The address of dSafe which dAccount NFTs should be returned</span>
 1177 |     | <span class='neutral'>    /// @return The array of NFT deposited on the dAccount of `dSafe`</span>
 1178 |     | <span class='neutral'>    function getDAccountERC721(address dSafe) external view override returns (NFTData[] memory) {</span>
 1179 |     | <span class='neutral'>        NFTData[] memory nftData = new NFTData[](dSafes[dSafe].nfts.length);</span>
 1180 |     | <span class='neutral'>        for (uint i = 0; i &lt; nftData.length; i++) {</span>
 1181 |     | <span class='neutral'>            (uint16 erc721Idx, uint256 tokenId) = getNFTData(dSafes[dSafe].nfts[i]);</span>
 1182 |     | <span class='neutral'>            nftData[i] = NFTData(erc721Infos[erc721Idx].erc721Contract, tokenId);</span>
 1183 |     | <span class='neutral'>        }</span>
 1184 |     | <span class='neutral'>        return nftData;</span>
 1185 |     | <span class='neutral'>    }</span>
 1186 |     | <span class='neutral'>}</span>
 1187 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/dos/DSafeProxy.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span>
   5 |     | <span class='unexecuted'>import &quot;@openzeppelin/contracts/token/ERC721/IERC721.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/utils/cryptography/EIP712.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/Proxy.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol&quot;;</span>
  10 |     | <span class='unexecuted'>import &quot;@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/interfaces/IERC1271.sol&quot;;</span>
  12 |     | <span class='neutral'>import &quot;../lib/FsUtils.sol&quot;;</span>
  13 |     | <span class='unexecuted'>import &quot;../lib/Call.sol&quot;;</span>
  14 |     | <span class='neutral'>import &quot;../lib/ImmutableVersion.sol&quot;;</span>
  15 |     | <span class='neutral'>import &quot;../interfaces/IDOS.sol&quot;;</span>
  16 |     | <span class='unexecuted'>import &quot;../interfaces/IVersionManager.sol&quot;;</span>
  17 |     | <span class='neutral'>import &quot;../interfaces/ITransferReceiver2.sol&quot;;</span>
  18 |     | <span class='neutral'>import &quot;../external/interfaces/IPermit2.sol&quot;;</span>
  19 |     | <span class='neutral'>import {ISafe} from &quot;../interfaces/ISafe.sol&quot;;</span>
  20 |     | <span class='neutral'>import &quot;./DSafeState.sol&quot;;</span>
  21 |     | <span class='neutral'>import &quot;./Liquifier.sol&quot;;</span>
  22 |     | <span class='neutral'>import &quot;../interfaces/IERC1363-extended.sol&quot;;</span>
  23 |     | <span class='neutral'>import &quot;../lib/NonceMap.sol&quot;;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>/// @title DSafe Proxy</span>
  26 |     | <span class='neutral'>/// @notice Proxy contract for DOS Safes</span>
  27 |     | <span class='neutral'>// Inspired by TransparentUpdatableProxy</span>
  28 |     | <span class='neutral'>contract DSafeProxy is DSafeState, Proxy {</span>
  29 |     | <span class='neutral'>    modifier ifDos() {</span>
  30 |     | <span class='neutral'>        if (msg.sender == address(dos)) {</span>
  31 |     | <span class='neutral'>            _;</span>
  32 |     | <span class='neutral'>        } else {</span>
  33 |     | <span class='neutral'>            _fallback();</span>
  34 |     | <span class='neutral'>        }</span>
  35 |     | <span class='neutral'>    }</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    constructor(address _dos, address[] memory erc20s, address[] memory erc721s) DSafeState(_dos) {</span>
  38 |     | <span class='neutral'>        // Approve DOS and PERMIT2 to spend all ERC20s</span>
  39 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; erc20s.length; i++) {</span>
  40 |     | <span class='neutral'>            // slither-disable-next-line missing-zero-check</span>
  41 |     | <span class='neutral'>            IERC20 erc20 = IERC20(FsUtils.nonNull(erc20s[i]));</span>
  42 |     | <span class='neutral'>            erc20.approve(_dos, type(uint256).max);</span>
  43 |     | <span class='neutral'>            erc20.approve(address(PERMIT2), type(uint256).max);</span>
  44 |     | <span class='neutral'>            erc20.approve(address(TRANSFER_AND_CALL2), type(uint256).max);</span>
  45 |     | <span class='neutral'>        }</span>
  46 |     | <span class='neutral'>        // Approve DOS to spend all ERC721s</span>
  47 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; erc721s.length; i++) {</span>
  48 |     | <span class='neutral'>            // slither-disable-next-line missing-zero-check</span>
  49 |     | <span class='neutral'>            IERC721 erc721 = IERC721(FsUtils.nonNull(erc721s[i]));</span>
  50 |     | <span class='neutral'>            erc721.setApprovalForAll(_dos, true);</span>
  51 |     | <span class='neutral'>            // Add future uniswap permit for ERC721 support</span>
  52 |     | <span class='neutral'>        }</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    // Allow ETH transfers</span>
  56 |     | <span class='neutral'>    receive() external payable override {}</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    // Allow DOS to make arbitrary calls in lieu of this dSafe</span>
  59 |     | <span class='neutral'>    function executeBatch(Call[] calldata calls) external payable ifDos {</span>
  60 |     | <span class='neutral'>        // Function is payable to allow for ETH transfers to the logic</span>
  61 |     | <span class='neutral'>        // contract, but dos should never send eth (dos contract should</span>
  62 |     | <span class='neutral'>        // never contain eth / other than what&#39;s self-destructed into it)</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>        FsUtils.Assert(msg.value == 0);</span>
  65 |     | <span class='neutral'>        CallLib.executeBatch(calls);</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    // The implementation of the delegate is controlled by DOS</span>
  69 |     | <span class='neutral'>    function _implementation() internal view override returns (address) {</span>
  70 |     | <span class='neutral'>        return dos.getImplementation(address(this));</span>
  71 |     | <span class='neutral'>    }</span>
  72 |     | <span class='neutral'>}</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>// Calls to the contract not coming from DOS itself are routed to this logic</span>
  75 |     | <span class='neutral'>// contract. This allows for flexible extra addition to your dSafe.</span>
  76 |     | <span class='neutral'>contract DSafeLogic is</span>
  77 |     | <span class='neutral'>    DSafeState,</span>
  78 |     | <span class='neutral'>    ImmutableVersion,</span>
  79 |     | <span class='neutral'>    IERC721Receiver,</span>
  80 |     | <span class='neutral'>    IERC1271,</span>
  81 |     | <span class='neutral'>    ITransferReceiver2,</span>
  82 |     | <span class='neutral'>    EIP712,</span>
  83 |     | <span class='neutral'>    ISafe,</span>
  84 |     | <span class='neutral'>    Liquifier,</span>
  85 |     | <span class='neutral'>    IERC1363SpenderExtended</span>
  86 |     | <span class='neutral'>{</span>
  87 |     | <span class='neutral'>    using NonceMapLib for NonceMap;</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    bytes private constant EXECUTEBATCH_TYPESTRING =</span>
  90 |     | <span class='neutral'>        &quot;ExecuteBatch(Call[] calls,uint256 nonce,uint256 deadline)&quot;;</span>
  91 |     | <span class='neutral'>    bytes private constant TRANSFER_TYPESTRING = &quot;Transfer(address token,uint256 amount)&quot;;</span>
  92 |     | <span class='neutral'>    bytes private constant ONTRANSFERRECEIVED2CALL_TYPESTRING =</span>
  93 |     | <span class='neutral'>        &quot;OnTransferReceived2Call(address operator,address from,Transfer[] transfers,Call[] calls,uint256 nonce,uint256 deadline)&quot;;</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    bytes32 private constant EXECUTEBATCH_TYPEHASH =</span>
  96 |     | <span class='neutral'>        keccak256(abi.encodePacked(EXECUTEBATCH_TYPESTRING, CallLib.CALL_TYPESTRING));</span>
  97 |     | <span class='neutral'>    bytes32 private constant TRANSFER_TYPEHASH = keccak256(TRANSFER_TYPESTRING);</span>
  98 |     | <span class='neutral'>    bytes32 private constant ONTRANSFERRECEIVED2CALL_TYPEHASH =</span>
  99 |     | <span class='neutral'>        keccak256(</span>
 100 |     | <span class='neutral'>            abi.encodePacked(</span>
 101 |     | <span class='neutral'>                ONTRANSFERRECEIVED2CALL_TYPESTRING,</span>
 102 |     | <span class='neutral'>                CallLib.CALL_TYPESTRING,</span>
 103 |     | <span class='neutral'>                TRANSFER_TYPESTRING</span>
 104 |     | <span class='neutral'>            )</span>
 105 |     | <span class='neutral'>        );</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    string private constant VERSION = &quot;1.0.0&quot;;</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    bool internal forwardNFT;</span>
 110 |     | <span class='neutral'>    NonceMap private nonceMap;</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>    error InvalidData();</span>
 113 |     | <span class='neutral'>    error InvalidSignature();</span>
 114 |     | <span class='neutral'>    error NonceAlreadyUsed();</span>
 115 |     | <span class='neutral'>    error DeadlineExpired();</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>    modifier onlyOwner() {</span>
 118 |     | <span class='neutral'>        require(dos.getDSafeOwner(address(this)) == msg.sender, &quot;&quot;);</span>
 119 |     | <span class='neutral'>        _;</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    // Note EIP712 is implemented with immutable variables and is not using</span>
 123 |     | <span class='neutral'>    // storage and thus can be used in a proxy contract constructor.</span>
 124 |     | <span class='neutral'>    // Version number should be in sync with VersionManager version.</span>
 125 |     | <span class='neutral'>    constructor(</span>
 126 |     | <span class='neutral'>        address _dos</span>
 127 |     | <span class='neutral'>    ) EIP712(&quot;DOS dSafe&quot;, VERSION) ImmutableVersion(VERSION) DSafeState(_dos) {}</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    /// @notice makes a batch of different calls from the name of dSafe owner. Eventual state of</span>
 130 |     | <span class='neutral'>    /// dAccount and DOS must be solvent, i.e. debt on dAccount cannot exceed collateral on</span>
 131 |     | <span class='neutral'>    /// dAccount and dSafe and DOS reserve/debt must be sufficient</span>
 132 |     | <span class='neutral'>    /// @dev - this goes to dos.executeBatch that would immediately call DSafeProxy.executeBatch</span>
 133 |     | <span class='neutral'>    /// from above of this file</span>
 134 |     | <span class='neutral'>    /// @param calls {address to, bytes callData, uint256 value}[], where</span>
 135 |     | <span class='neutral'>    ///   * to - is the address of the contract whose function should be called</span>
 136 |     | <span class='neutral'>    ///   * callData - encoded function name and it&#39;s arguments</span>
 137 |     | <span class='neutral'>    ///   * value - the amount of ETH to sent with the call</span>
 138 |     | <span class='neutral'>    function executeBatch(Call[] memory calls) external payable onlyOwner {</span>
 139 |     | <span class='neutral'>        assert(false);</span>
 140 |     | <span class='neutral'>        bool saveForwardNFT = forwardNFT;</span>
 141 |     | <span class='neutral'>        forwardNFT = false;</span>
 142 |     | <span class='neutral'>        dos.executeBatch(calls);</span>
 143 |     | <span class='neutral'>        forwardNFT = saveForwardNFT;</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>    function executeSignedBatch(</span>
 147 |     | <span class='neutral'>        Call[] memory calls,</span>
 148 |     | <span class='neutral'>        uint256 nonce,</span>
 149 |     | <span class='neutral'>        uint256 deadline,</span>
 150 |     | <span class='neutral'>        bytes calldata signature</span>
 151 |     | <span class='neutral'>    ) external payable {</span>
 152 |     | <span class='neutral'>        if (deadline &lt; block.timestamp) revert DeadlineExpired();</span>
 153 |     | <span class='neutral'>        nonceMap.validateAndUseNonce(nonce);</span>
 154 |     | <span class='neutral'>        bytes32 digest = _hashTypedDataV4(</span>
 155 |     | <span class='neutral'>            keccak256(</span>
 156 |     | <span class='neutral'>                abi.encode(EXECUTEBATCH_TYPEHASH, CallLib.hashCallArray(calls), nonce, deadline)</span>
 157 |     | <span class='neutral'>            )</span>
 158 |     | <span class='neutral'>        );</span>
 159 |     | <span class='neutral'>        if (</span>
 160 |     | <span class='neutral'>            !SignatureChecker.isValidSignatureNow(</span>
 161 |     | <span class='neutral'>                dos.getDSafeOwner(address(this)),</span>
 162 |     | <span class='neutral'>                digest,</span>
 163 |     | <span class='neutral'>                signature</span>
 164 |     | <span class='neutral'>            )</span>
 165 |     | <span class='neutral'>        ) revert InvalidSignature();</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>        dos.executeBatch(calls);</span>
 168 |     | <span class='neutral'>    }</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>    function forwardNFTs(bool _forwardNFT) external {</span>
 171 |     | <span class='neutral'>        require(msg.sender == address(this), &quot;only this&quot;);</span>
 172 |     | <span class='neutral'>        forwardNFT = _forwardNFT;</span>
 173 |     | <span class='neutral'>    }</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>    /// @notice ERC721 transfer callback</span>
 176 |     | <span class='neutral'>    /// @dev it&#39;s a callback, required to be implemented by IERC721Receiver interface for the</span>
 177 |     | <span class='neutral'>    /// contract to be able to receive ERC721 NFTs.</span>
 178 |     | <span class='neutral'>    /// we are already using it to support &quot;forwardNFT&quot; of dSafe.</span>
 179 |     | <span class='neutral'>    /// `return this.onERC721Received.selector;` is mandatory part for the NFT transfer to work -</span>
 180 |     | <span class='neutral'>    /// not a part of owr business logic</span>
 181 |     | <span class='neutral'>    /// @param - operator The address which called `safeTransferFrom` function</span>
 182 |     | <span class='neutral'>    /// @param - from The address which previously owned the token</span>
 183 |     | <span class='neutral'>    /// @param tokenId The NFT identifier which is being transferred</span>
 184 |     | <span class='neutral'>    /// @param data Additional data with no specified format</span>
 185 |     | <span class='neutral'>    /// @return `bytes4(keccak256(&quot;onERC721Received(address,address,uint256,bytes)&quot;))`</span>
 186 |     | <span class='neutral'>    function onERC721Received(</span>
 187 |     | <span class='neutral'>        address /* operator */,</span>
 188 |     | <span class='neutral'>        address /* from */,</span>
 189 |     | <span class='neutral'>        uint256 tokenId,</span>
 190 |     | <span class='neutral'>        bytes memory data</span>
 191 |     | <span class='neutral'>    ) public virtual override returns (bytes4) {</span>
 192 |     | <span class='neutral'>        if (forwardNFT) {</span>
 193 |     | <span class='neutral'>            IERC721(msg.sender).safeTransferFrom(address(this), address(dos), tokenId, data);</span>
 194 |     | <span class='neutral'>        }</span>
 195 |     | <span class='neutral'>        return this.onERC721Received.selector;</span>
 196 |     | <span class='neutral'>    }</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>    function setNonce(uint256 nonce) external onlyOwner {</span>
 199 |     | <span class='neutral'>        nonceMap.validateAndUseNonce(nonce);</span>
 200 |     | <span class='neutral'>    }</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>    /// @inheritdoc ITransferReceiver2</span>
 203 |     | <span class='neutral'>    function onTransferReceived2(</span>
 204 |     | <span class='neutral'>        address operator,</span>
 205 |     | <span class='neutral'>        address from,</span>
 206 |     | <span class='neutral'>        ITransferReceiver2.Transfer[] calldata transfers,</span>
 207 |     | <span class='neutral'>        bytes calldata data</span>
 208 |     | <span class='neutral'>    ) external override onlyTransferAndCall2 returns (bytes4) {</span>
 209 |     | <span class='neutral'>        // options:</span>
 210 |     | <span class='neutral'>        // 1) just deposit into proxy, nothing to do</span>
 211 |     | <span class='neutral'>        // 2) execute a batch of calls (msg.sender is owner)</span>
 212 |     | <span class='neutral'>        // 3) directly deposit into dos contract</span>
 213 |     | <span class='neutral'>        // 3) execute a signed batch of tx&#39;s</span>
 214 |     | <span class='neutral'>        if (data.length == 0) {</span>
 215 |     | <span class='neutral'>            /* just deposit in the proxy, nothing to do */</span>
 216 |     | <span class='neutral'>        } else if (data[0] == 0x00) {</span>
 217 |     | <span class='neutral'>            // execute batch</span>
 218 |     | <span class='neutral'>            require(msg.sender == dos.getDSafeOwner(address(this)), &quot;Not owner&quot;);</span>
 219 |     | <span class='neutral'>            Call[] memory calls = abi.decode(data[1:], (Call[]));</span>
 220 |     | <span class='neutral'>            dos.executeBatch(calls);</span>
 221 |     | <span class='neutral'>        } else if (data[0] == 0x01) {</span>
 222 |     | <span class='neutral'>            require(data.length == 1, &quot;Invalid data - allowed are [], [0...], [1] and [2]&quot;);</span>
 223 |     | <span class='neutral'>            // deposit in the dos dSafe</span>
 224 |     | <span class='neutral'>            for (uint256 i = 0; i &lt; transfers.length; i++) {</span>
 225 |     | <span class='neutral'>                ITransferReceiver2.Transfer memory transfer = transfers[i];</span>
 226 |     | <span class='neutral'>                dos.depositERC20(IERC20(transfer.token), transfer.amount);</span>
 227 |     | <span class='neutral'>            }</span>
 228 |     | <span class='neutral'>        } else if (data[0] == 0x02) {</span>
 229 |     | <span class='neutral'>            // execute signed batch</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='neutral'>            // Verify signature matches</span>
 232 |     | <span class='neutral'>            (Call[] memory calls, uint256 nonce, uint256 deadline, bytes memory signature) = abi</span>
 233 |     | <span class='neutral'>                .decode(data[1:], (Call[], uint256, uint256, bytes));</span>
 234 |     | <span class='neutral'></span>
 235 |     | <span class='neutral'>            if (deadline &lt; block.timestamp) revert DeadlineExpired();</span>
 236 |     | <span class='neutral'>            nonceMap.validateAndUseNonce(nonce);</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='neutral'>            bytes32[] memory transferDigests = new bytes32[](transfers.length);</span>
 239 |     | <span class='neutral'>            for (uint256 i = 0; i &lt; transfers.length; i++) {</span>
 240 |     | <span class='neutral'>                transferDigests[i] = keccak256(</span>
 241 |     | <span class='neutral'>                    abi.encode(TRANSFER_TYPEHASH, transfers[i].token, transfers[i].amount)</span>
 242 |     | <span class='neutral'>                );</span>
 243 |     | <span class='neutral'>            }</span>
 244 |     | <span class='neutral'>            bytes32 digest = _hashTypedDataV4(</span>
 245 |     | <span class='neutral'>                keccak256(</span>
 246 |     | <span class='neutral'>                    abi.encode(</span>
 247 |     | <span class='neutral'>                        ONTRANSFERRECEIVED2CALL_TYPEHASH,</span>
 248 |     | <span class='neutral'>                        operator,</span>
 249 |     | <span class='neutral'>                        from,</span>
 250 |     | <span class='neutral'>                        keccak256(abi.encodePacked(transferDigests)),</span>
 251 |     | <span class='neutral'>                        CallLib.hashCallArray(calls),</span>
 252 |     | <span class='neutral'>                        nonce,</span>
 253 |     | <span class='neutral'>                        deadline</span>
 254 |     | <span class='neutral'>                    )</span>
 255 |     | <span class='neutral'>                )</span>
 256 |     | <span class='neutral'>            );</span>
 257 |     | <span class='neutral'>            if (</span>
 258 |     | <span class='neutral'>                !SignatureChecker.isValidSignatureNow(</span>
 259 |     | <span class='neutral'>                    dos.getDSafeOwner(address(this)),</span>
 260 |     | <span class='neutral'>                    digest,</span>
 261 |     | <span class='neutral'>                    signature</span>
 262 |     | <span class='neutral'>                )</span>
 263 |     | <span class='neutral'>            ) revert InvalidSignature();</span>
 264 |     | <span class='neutral'></span>
 265 |     | <span class='neutral'>            dos.executeBatch(calls);</span>
 266 |     | <span class='neutral'>        } else {</span>
 267 |     | <span class='neutral'>            revert(&quot;Invalid data - allowed are &#39;&#39;, &#39;0x00...&#39;, &#39;0x01&#39; and &#39;0x02...&#39;&quot;);</span>
 268 |     | <span class='neutral'>        }</span>
 269 |     | <span class='neutral'>        return ITransferReceiver2.onTransferReceived2.selector;</span>
 270 |     | <span class='neutral'>    }</span>
 271 |     | <span class='neutral'></span>
 272 |     | <span class='neutral'>    function onApprovalReceived(</span>
 273 |     | <span class='neutral'>        address sender,</span>
 274 |     | <span class='neutral'>        uint256 amount,</span>
 275 |     | <span class='neutral'>        Call memory call</span>
 276 |     | <span class='neutral'>    ) external returns (bytes4) {</span>
 277 |     | <span class='neutral'>        if (call.callData.length == 0) {</span>
 278 |     | <span class='neutral'>            revert(&quot;PL: INVALID_DATA&quot;);</span>
 279 |     | <span class='neutral'>        }</span>
 280 |     | <span class='neutral'>        emit TokensApproved(sender, amount, call.callData);</span>
 281 |     | <span class='neutral'></span>
 282 |     | <span class='neutral'>        Call[] memory calls = new Call[](1);</span>
 283 |     | <span class='neutral'>        calls[0] = call;</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='neutral'>        dos.executeBatch(calls);</span>
 286 |     | <span class='neutral'></span>
 287 |     | <span class='neutral'>        return this.onApprovalReceived.selector;</span>
 288 |     | <span class='neutral'>    }</span>
 289 |     | <span class='neutral'></span>
 290 |     | <span class='neutral'>    function owner() external view returns (address) {</span>
 291 |     | <span class='neutral'>        return dos.getDSafeOwner(address(this));</span>
 292 |     | <span class='neutral'>    }</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='neutral'>    /// @inheritdoc IERC1271</span>
 295 |     | <span class='neutral'>    function isValidSignature(</span>
 296 |     | <span class='neutral'>        bytes32 hash,</span>
 297 |     | <span class='neutral'>        bytes memory signature</span>
 298 |     | <span class='neutral'>    ) public view override returns (bytes4 magicValue) {</span>
 299 |     | <span class='neutral'>        magicValue = SignatureChecker.isValidSignatureNow(</span>
 300 |     | <span class='neutral'>            dos.getDSafeOwner(address(this)),</span>
 301 |     | <span class='neutral'>            hash,</span>
 302 |     | <span class='neutral'>            signature</span>
 303 |     | <span class='neutral'>        )</span>
 304 |     | <span class='neutral'>            ? this.isValidSignature.selector</span>
 305 |     | <span class='neutral'>            : bytes4(0);</span>
 306 |     | <span class='neutral'>    }</span>
 307 |     | <span class='neutral'></span>
 308 |     | <span class='neutral'>    function valueNonce(uint256 nonce) external view returns (bool) {</span>
 309 |     | <span class='neutral'>        return nonceMap.getNonce(nonce);</span>
 310 |     | <span class='neutral'>    }</span>
 311 |     | <span class='neutral'>}</span>
 312 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/dos/DSafeState.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='unexecuted'>import &quot;../interfaces/IDOS.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;../lib/FsUtils.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>/// @title the state part of the DSafeLogic. A parent to all contracts that form dSafe</span>
  8 |     | <span class='unexecuted'>/// @dev the contract is abstract because it is not expected to be used separately from dSafe</span>
  9 |     | <span class='unexecuted'>abstract contract DSafeState {</span>
 10 |     | <span class='neutral'>    /// @dev DOS instance to be used by all other dSafe contracts</span>
 11 |     | <span class='neutral'>    IDOS public immutable dos;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    /// @param _dos - address of a deployed DOS contract</span>
 14 |     | <span class='neutral'>    constructor(address _dos) {</span>
 15 |     | <span class='neutral'>        // slither-disable-next-line missing-zero-check</span>
 16 |     | <span class='neutral'>        dos = IDOS(FsUtils.nonNull(_dos));</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'>}</span>
 19 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/dos/Liquifier.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='unexecuted'>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../external/interfaces/INonfungiblePositionManager.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../interfaces/IDOS.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;./DSafeState.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>struct SqrtPricePriceRangeX96 {</span>
  11 |     | <span class='neutral'>    uint160 minSell;</span>
  12 |     | <span class='neutral'>    uint160 maxBuy;</span>
  13 |     | <span class='neutral'>}</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>/// @title Logic for liquify functionality of dSafe</span>
  16 |     | <span class='neutral'>/// @dev It is designed to be an extension for dSafeLogic contract.</span>
  17 |     | <span class='neutral'>/// Functionally, it&#39;s a part of the dSafeLogic contract, but has been extracted into a separate</span>
  18 |     | <span class='unexecuted'>/// contract for better code structuring. This is why the contract is declared as abstract</span>
  19 |     | <span class='neutral'>///   The only function it exports is `liquify`. The rest are private function that are parts of</span>
  20 |     | <span class='neutral'>/// `liquify`</span>
  21 |     | <span class='neutral'>abstract contract Liquifier is DSafeState {</span>
  22 |     | <span class='neutral'>    modifier selfOrDSafeOwner() {</span>
  23 |     | <span class='neutral'>        require(</span>
  24 |     | <span class='neutral'>            msg.sender == address(this) || msg.sender == dos.getDSafeOwner(address(this)),</span>
  25 |     | <span class='neutral'>            &quot;only self or owner&quot;</span>
  26 |     | <span class='neutral'>        );</span>
  27 |     | <span class='neutral'>        _;</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /// @notice Advanced version of liquidate function. Potentially unwanted side-affect of</span>
  31 |     | <span class='neutral'>    /// liquidation is a debt on the liquidator. So liquify would liquidate and then re-balance</span>
  32 |     | <span class='neutral'>    /// obtained assets to have no debt. This is the algorithm:</span>
  33 |     | <span class='neutral'>    ///   * liquidate dAccount of target `dSafe`</span>
  34 |     | <span class='neutral'>    ///   * terminate all obtained ERC721s (NFTs)</span>
  35 |     | <span class='neutral'>    ///   * buy/sell `erc20s` for `numeraire` so the balance of `dSafe` on that ERC20s matches the</span>
  36 |     | <span class='neutral'>    ///     debt of `dSafe` on it&#39;s dAccount. E.g.:</span>
  37 |     | <span class='neutral'>    ///     - for 1 WETH of debt on dAccount and 3 WETH on the balance of dSafe - sell 2 WETH</span>
  38 |     | <span class='neutral'>    ///     - for 3 WETH of debt on dAccount and 1 WETH on the balance of dSafe - buy 2 WETH</span>
  39 |     | <span class='neutral'>    ///     - for no debt on dAccount and 1 WETH on the balance of dSafe - sell 2 WETH</span>
  40 |     | <span class='neutral'>    ///     - for 1 WETH of debt on dAccount and no WETH on the balance of dSave - buy 1 WETH</span>
  41 |     | <span class='neutral'>    ///   * deposit `erc20s` and `numeraire` to cover debts</span>
  42 |     | <span class='neutral'>    ///</span>
  43 |     | <span class='neutral'>    /// !! IMPORTANT: because this function executes quite a lot of logic on top of DOS.liquidate(),</span>
  44 |     | <span class='neutral'>    /// there is a risk that for liquidatable position with a long list of NFTs it will run out</span>
  45 |     | <span class='neutral'>    /// of gas. As for now, it&#39;s up to liquidator to estimate if specific position is liquifiable,</span>
  46 |     | <span class='neutral'>    /// or DOS.liquidate() need to be used (with further assets re-balancing in other transactions)</span>
  47 |     | <span class='neutral'>    /// @dev notes on erc20s: the reason for erc20s been a call parameter, and not been calculated</span>
  48 |     | <span class='neutral'>    /// inside of liquify, is reducing gas costs</span>
  49 |     | <span class='neutral'>    ///   erc20s should NOT include numeraire. Otherwise, the transaction would be reverted with an</span>
  50 |     | <span class='neutral'>    /// error from uniswap router</span>
  51 |     | <span class='neutral'>    ///   It&#39;s the responsibility of caller to provide the correct list of erc20s. Assets</span>
  52 |     | <span class='neutral'>    /// re-balancing would be performed only by this list of tokens and numeraire.</span>
  53 |     | <span class='neutral'>    ///   * if erc20s misses a token that liquidatable have debt on - the debt on this erc20 would</span>
  54 |     | <span class='neutral'>    ///     persist on liquidator&#39;s dAccount as-is</span>
  55 |     | <span class='neutral'>    ///   * if erc20s misses a token that liquidatable have collateral on - the token would persist</span>
  56 |     | <span class='neutral'>    ///     on liquidator&#39;s dAccount. It may result in generating debt in numeraire on liquidator</span>
  57 |     | <span class='neutral'>    ///     dAccount by the end of liquify (because the token would not be soled for numeraire,</span>
  58 |     | <span class='neutral'>    ///     there may not be enough numeraire to buy tokens to cover debts, and so they will be</span>
  59 |     | <span class='neutral'>    ///     bought in debt)</span>
  60 |     | <span class='neutral'>    ///   * if erc20s misses a token that would be obtained as the result of NFT termination - same</span>
  61 |     | <span class='neutral'>    ///     as previous, except of the token to be persisted on dSafe instead of dAccount of</span>
  62 |     | <span class='neutral'>    ///     liquidator</span>
  63 |     | <span class='neutral'>    ///   Because no buy/sell would be done for prices from outside of the erc20sAllowedPriceRanges,</span>
  64 |     | <span class='neutral'>    /// too narrow range may result in not having enough of some ERC20 to cover the debt. So the</span>
  65 |     | <span class='neutral'>    /// eventual state would still include some debt</span>
  66 |     | <span class='neutral'>    /// @param dSafe - the address of a dSafe to liquidate</span>
  67 |     | <span class='neutral'>    /// @param swapRouter - the address of a Uniswap swap router to be used to buy/sell erc20s</span>
  68 |     | <span class='neutral'>    /// @param nftManager - the address of a Uniswap NonFungibleTokenManager to be used to terminate</span>
  69 |     | <span class='neutral'>    /// ERC721 (NFTs)</span>
  70 |     | <span class='neutral'>    /// @param numeraire - the address of an ERC20 to be used to convert to and from erc20s. The</span>
  71 |     | <span class='neutral'>    /// liquidation reward would be in this token</span>
  72 |     | <span class='neutral'>    /// @param erc20s - the list of ERC20 that liquidated has debt, collateral or that would be</span>
  73 |     | <span class='neutral'>    /// obtained from termination of any ERC721 that he owns. Except of numeraire, that should</span>
  74 |     | <span class='neutral'>    /// never be included in erc20s array</span>
  75 |     | <span class='neutral'>    /// @param erc20sAllowedPriceRanges - the list of root squares of allowed prices in Q96 for</span>
  76 |     | <span class='neutral'>    /// `erc20s` swaps on Uniswap in `numeraire`. This is the protection against sandwich-attack -</span>
  77 |     | <span class='neutral'>    /// if the price would be lower/higher for sell/buy</span>
  78 |     | <span class='neutral'>    ///   It&#39;s up to liquidator to decide what range is acceptable. +/- 1% of price before liquify</span>
  79 |     | <span class='neutral'>    /// call seems to be reasonable</span>
  80 |     | <span class='neutral'>    ///   Zero minSell/maxBuy value for a specific ERC20 would disable the corresponding check</span>
  81 |     | <span class='neutral'>    /// Uniswap docs - https://docs.uniswap.org/contracts/v3/guides/swaps/single-swaps</span>
  82 |     | <span class='neutral'>    /// It doesn&#39;t explained in Uniswap docs, but this is how it actually works:</span>
  83 |     | <span class='neutral'>    /// * if the price for each token would be below the specified limit</span>
  84 |     | <span class='neutral'>    /// then full amount would be converted and no error would be thrown</span>
  85 |     | <span class='neutral'>    /// * if at least some amount of tokens can be bought by the price that is below the limit</span>
  86 |     | <span class='neutral'>    /// then only that amount of tokens would be bought and no error would be thrown</span>
  87 |     | <span class='neutral'>    /// * if no tokens can be bought by the price below the limit</span>
  88 |     | <span class='neutral'>    /// then error would be thrown with message &quot;SPL&quot;</span>
  89 |     | <span class='neutral'>    function liquify(</span>
  90 |     | <span class='neutral'>        address dSafe,</span>
  91 |     | <span class='neutral'>        address swapRouter,</span>
  92 |     | <span class='neutral'>        address nftManager,</span>
  93 |     | <span class='neutral'>        address numeraire,</span>
  94 |     | <span class='neutral'>        IERC20[] calldata erc20s,</span>
  95 |     | <span class='neutral'>        SqrtPricePriceRangeX96[] calldata erc20sAllowedPriceRanges</span>
  96 |     | <span class='neutral'>    ) external selfOrDSafeOwner {</span>
  97 |     | <span class='neutral'>        if (msg.sender != address(this)) {</span>
  98 |     | <span class='neutral'>            /* prettier-ignore */ // list of liquify arguments as-is</span>
  99 |     | <span class='neutral'>            return callOverBatchExecute(dSafe, swapRouter, nftManager, numeraire, erc20s, erc20sAllowedPriceRanges);</span>
 100 |     | <span class='neutral'>        }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>        dos.liquidate(dSafe);</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>        (</span>
 105 |     | <span class='neutral'>            IERC20[] memory erc20sCollateral,</span>
 106 |     | <span class='neutral'>            uint256[] memory erc20sDebtAmounts</span>
 107 |     | <span class='neutral'>        ) = analyseDAccountStructure(erc20s, numeraire);</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>        dos.withdrawFull(erc20sCollateral);</span>
 110 |     | <span class='neutral'>        terminateERC721s(nftManager);</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>        (</span>
 113 |     | <span class='neutral'>            uint256[] memory erc20sToSellAmounts,</span>
 114 |     | <span class='neutral'>            uint256[] memory erc20sToBuyAmounts</span>
 115 |     | <span class='neutral'>        ) = calcSellAndBuyERC20Amounts(erc20s, erc20sDebtAmounts);</span>
 116 |     | <span class='neutral'>        sellERC20s(swapRouter, erc20s, erc20sToSellAmounts, numeraire, erc20sAllowedPriceRanges);</span>
 117 |     | <span class='neutral'>        buyERC20s(swapRouter, erc20s, erc20sToBuyAmounts, numeraire, erc20sAllowedPriceRanges);</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>        deposit(erc20s, numeraire);</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    function callOverBatchExecute(</span>
 123 |     | <span class='neutral'>        address dSafe,</span>
 124 |     | <span class='neutral'>        address swapRouter,</span>
 125 |     | <span class='neutral'>        address nftManager,</span>
 126 |     | <span class='neutral'>        address numeraire,</span>
 127 |     | <span class='neutral'>        IERC20[] calldata erc20s,</span>
 128 |     | <span class='neutral'>        SqrtPricePriceRangeX96[] calldata erc20sAllowedPriceRanges</span>
 129 |     | <span class='neutral'>    ) private {</span>
 130 |     | <span class='neutral'>        Call[] memory calls = new Call[](1);</span>
 131 |     | <span class='neutral'>        calls[0] = Call({</span>
 132 |     | <span class='neutral'>            to: address(this),</span>
 133 |     | <span class='neutral'>            callData: abi.encodeWithSelector(</span>
 134 |     | <span class='neutral'>                this.liquify.selector,</span>
 135 |     | <span class='neutral'>                dSafe,</span>
 136 |     | <span class='neutral'>                swapRouter,</span>
 137 |     | <span class='neutral'>                nftManager,</span>
 138 |     | <span class='neutral'>                numeraire,</span>
 139 |     | <span class='neutral'>                erc20s,</span>
 140 |     | <span class='neutral'>                erc20sAllowedPriceRanges</span>
 141 |     | <span class='neutral'>            ),</span>
 142 |     | <span class='neutral'>            value: 0</span>
 143 |     | <span class='neutral'>        });</span>
 144 |     | <span class='neutral'>        dos.executeBatch(calls);</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    /// @param nftManager - passed as-is from liquify function. The address of a Uniswap</span>
 148 |     | <span class='neutral'>    ///   NonFungibleTokenManager to be used to terminate ERC721 (NFTs)</span>
 149 |     | <span class='neutral'>    function terminateERC721s(address nftManager) private {</span>
 150 |     | <span class='neutral'>        INonfungiblePositionManager manager = INonfungiblePositionManager(nftManager);</span>
 151 |     | <span class='neutral'>        IDOS.NFTData[] memory nfts = dos.getDAccountERC721(address(this));</span>
 152 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; nfts.length; i++) {</span>
 153 |     | <span class='neutral'>            IDOS.NFTData memory nft = nfts[i];</span>
 154 |     | <span class='neutral'>            dos.withdrawERC721(nft.erc721, nft.tokenId);</span>
 155 |     | <span class='neutral'>            (, , , , , , , uint128 nftLiquidity, , , , ) = manager.positions(nft.tokenId);</span>
 156 |     | <span class='neutral'>            manager.decreaseLiquidity(</span>
 157 |     | <span class='neutral'>                INonfungiblePositionManager.DecreaseLiquidityParams({</span>
 158 |     | <span class='neutral'>                    tokenId: nft.tokenId,</span>
 159 |     | <span class='neutral'>                    liquidity: nftLiquidity,</span>
 160 |     | <span class='neutral'>                    amount0Min: 0,</span>
 161 |     | <span class='neutral'>                    amount1Min: 0,</span>
 162 |     | <span class='neutral'>                    deadline: type(uint256).max</span>
 163 |     | <span class='neutral'>                })</span>
 164 |     | <span class='neutral'>            );</span>
 165 |     | <span class='neutral'>            manager.collect(</span>
 166 |     | <span class='neutral'>                INonfungiblePositionManager.CollectParams({</span>
 167 |     | <span class='neutral'>                    tokenId: nft.tokenId,</span>
 168 |     | <span class='neutral'>                    recipient: address(this),</span>
 169 |     | <span class='neutral'>                    amount0Max: type(uint128).max,</span>
 170 |     | <span class='neutral'>                    amount1Max: type(uint128).max</span>
 171 |     | <span class='neutral'>                })</span>
 172 |     | <span class='neutral'>            );</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>            manager.burn(nft.tokenId);</span>
 175 |     | <span class='neutral'>        }</span>
 176 |     | <span class='neutral'>    }</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='neutral'>    function analyseDAccountStructure(</span>
 179 |     | <span class='neutral'>        IERC20[] calldata erc20s,</span>
 180 |     | <span class='neutral'>        address numeraire</span>
 181 |     | <span class='neutral'>    ) private view returns (IERC20[] memory erc20sCollateral, uint256[] memory erc20sDebtAmounts) {</span>
 182 |     | <span class='neutral'>        uint256 numOfERC20sCollateral = 0;</span>
 183 |     | <span class='neutral'>        int256[] memory balances = new int256[](erc20s.length);</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; erc20s.length; i++) {</span>
 186 |     | <span class='neutral'>            int256 balance = dos.getDAccountERC20(address(this), erc20s[i]);</span>
 187 |     | <span class='neutral'>            if (balance &gt; 0) {</span>
 188 |     | <span class='neutral'>                numOfERC20sCollateral++;</span>
 189 |     | <span class='neutral'>                balances[i] = balance;</span>
 190 |     | <span class='neutral'>            } else if (balance &lt; 0) {</span>
 191 |     | <span class='neutral'>                balances[i] = balance;</span>
 192 |     | <span class='neutral'>            }</span>
 193 |     | <span class='neutral'>        }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>        int256 dAccountNumeraireBalance = dos.getDAccountERC20(address(this), IERC20(numeraire));</span>
 196 |     | <span class='neutral'>        if (dAccountNumeraireBalance &gt; 0) {</span>
 197 |     | <span class='neutral'>            numOfERC20sCollateral++;</span>
 198 |     | <span class='neutral'>        }</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>        erc20sCollateral = new IERC20[](numOfERC20sCollateral);</span>
 201 |     | <span class='neutral'>        erc20sDebtAmounts = new uint256[](erc20s.length);</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>        if (dAccountNumeraireBalance &gt; 0) {</span>
 204 |     | <span class='neutral'>            erc20sCollateral[0] = IERC20(numeraire);</span>
 205 |     | <span class='neutral'>        }</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; erc20s.length; i++) {</span>
 208 |     | <span class='neutral'>            if (balances[i] &gt; 0) {</span>
 209 |     | <span class='neutral'>                erc20sCollateral[--numOfERC20sCollateral] = erc20s[i];</span>
 210 |     | <span class='neutral'>            } else if (balances[i] &lt; 0) {</span>
 211 |     | <span class='neutral'>                erc20sDebtAmounts[i] = uint256(-balances[i]);</span>
 212 |     | <span class='neutral'>            }</span>
 213 |     | <span class='neutral'>        }</span>
 214 |     | <span class='neutral'>    }</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='neutral'>    function calcSellAndBuyERC20Amounts(</span>
 217 |     | <span class='neutral'>        IERC20[] calldata erc20s,</span>
 218 |     | <span class='neutral'>        uint256[] memory erc20sDebtAmounts</span>
 219 |     | <span class='neutral'>    )</span>
 220 |     | <span class='neutral'>        private</span>
 221 |     | <span class='neutral'>        view</span>
 222 |     | <span class='neutral'>        returns (uint256[] memory erc20ToSellAmounts, uint256[] memory erc20ToBuyAmounts)</span>
 223 |     | <span class='neutral'>    {</span>
 224 |     | <span class='neutral'>        erc20ToBuyAmounts = new uint256[](erc20s.length);</span>
 225 |     | <span class='neutral'>        erc20ToSellAmounts = new uint256[](erc20s.length);</span>
 226 |     | <span class='neutral'></span>
 227 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; erc20s.length; i++) {</span>
 228 |     | <span class='neutral'>            uint256 balance = erc20s[i].balanceOf(address(this));</span>
 229 |     | <span class='neutral'>            if (balance &gt; erc20sDebtAmounts[i]) {</span>
 230 |     | <span class='neutral'>                erc20ToSellAmounts[i] = balance - erc20sDebtAmounts[i];</span>
 231 |     | <span class='neutral'>            } else if (balance &lt; erc20sDebtAmounts[i]) {</span>
 232 |     | <span class='neutral'>                erc20ToBuyAmounts[i] = erc20sDebtAmounts[i] - balance;</span>
 233 |     | <span class='neutral'>            }</span>
 234 |     | <span class='neutral'>        }</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>    function sellERC20s(</span>
 238 |     | <span class='neutral'>        address swapRouter,</span>
 239 |     | <span class='neutral'>        IERC20[] memory erc20sToSell,</span>
 240 |     | <span class='neutral'>        uint256[] memory amountsToSell,</span>
 241 |     | <span class='neutral'>        address erc20ToSellFor,</span>
 242 |     | <span class='neutral'>        SqrtPricePriceRangeX96[] calldata erc20sAllowedPriceRanges</span>
 243 |     | <span class='neutral'>    ) private {</span>
 244 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; erc20sToSell.length; i++) {</span>
 245 |     | <span class='neutral'>            if (amountsToSell[i] == 0) continue;</span>
 246 |     | <span class='neutral'></span>
 247 |     | <span class='neutral'>            ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({</span>
 248 |     | <span class='neutral'>                tokenIn: address(erc20sToSell[i]),</span>
 249 |     | <span class='neutral'>                tokenOut: erc20ToSellFor,</span>
 250 |     | <span class='neutral'>                fee: 500,</span>
 251 |     | <span class='neutral'>                recipient: address(this),</span>
 252 |     | <span class='neutral'>                deadline: type(uint256).max, // ignore - total transaction type should be limited at DOS level</span>
 253 |     | <span class='neutral'>                amountIn: amountsToSell[i],</span>
 254 |     | <span class='neutral'>                amountOutMinimum: 0,</span>
 255 |     | <span class='neutral'>                // see comments on `erc20sAllowedPriceRanges` parameter of `liquify`</span>
 256 |     | <span class='neutral'>                sqrtPriceLimitX96: erc20sAllowedPriceRanges[i].minSell</span>
 257 |     | <span class='neutral'>            });</span>
 258 |     | <span class='neutral'></span>
 259 |     | <span class='neutral'>            try ISwapRouter(swapRouter).exactInputSingle(params) {} catch Error(</span>
 260 |     | <span class='neutral'>                string memory reason</span>
 261 |     | <span class='neutral'>            ) {</span>
 262 |     | <span class='neutral'>                // &quot;SPL&quot; means that proposed sell price is too low. If so - silently skip conversion.</span>
 263 |     | <span class='neutral'>                // For any other error - revert</span>
 264 |     | <span class='neutral'>                // Consider emitting or logging</span>
 265 |     | <span class='neutral'>                // Consider ignoring some other errors if it&#39;s appropriate</span>
 266 |     | <span class='neutral'>                // Consider replacing with `Strings.equal` on OpenZeppelin next release</span>
 267 |     | <span class='neutral'>                if (keccak256(abi.encodePacked(reason)) != keccak256(abi.encodePacked(&quot;SPL&quot;))) {</span>
 268 |     | <span class='neutral'>                    revert(reason);</span>
 269 |     | <span class='neutral'>                }</span>
 270 |     | <span class='neutral'>            }</span>
 271 |     | <span class='neutral'>        }</span>
 272 |     | <span class='neutral'>    }</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='neutral'>    function buyERC20s(</span>
 275 |     | <span class='neutral'>        address swapRouter,</span>
 276 |     | <span class='neutral'>        IERC20[] memory erc20sToBuy,</span>
 277 |     | <span class='neutral'>        uint256[] memory amountsToBuy,</span>
 278 |     | <span class='neutral'>        address erc20ToBuyFor,</span>
 279 |     | <span class='neutral'>        SqrtPricePriceRangeX96[] calldata erc20sAllowedPriceRanges</span>
 280 |     | <span class='neutral'>    ) private {</span>
 281 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; erc20sToBuy.length; i++) {</span>
 282 |     | <span class='neutral'>            if (amountsToBuy[i] == 0) continue;</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='neutral'>            ISwapRouter.ExactOutputSingleParams memory params = ISwapRouter</span>
 285 |     | <span class='neutral'>                .ExactOutputSingleParams({</span>
 286 |     | <span class='neutral'>                    tokenIn: erc20ToBuyFor,</span>
 287 |     | <span class='neutral'>                    tokenOut: address(erc20sToBuy[i]),</span>
 288 |     | <span class='neutral'>                    fee: 500,</span>
 289 |     | <span class='neutral'>                    recipient: address(this),</span>
 290 |     | <span class='neutral'>                    deadline: type(uint256).max, // ignore - total transaction type should be limited at DOS level</span>
 291 |     | <span class='neutral'>                    amountOut: amountsToBuy[i],</span>
 292 |     | <span class='neutral'>                    amountInMaximum: type(uint256).max,</span>
 293 |     | <span class='neutral'>                    // see comments on `erc20sAllowedPriceRanges` parameter of `liquify`</span>
 294 |     | <span class='neutral'>                    sqrtPriceLimitX96: erc20sAllowedPriceRanges[i].maxBuy</span>
 295 |     | <span class='neutral'>                });</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='neutral'>            try ISwapRouter(swapRouter).exactOutputSingle(params) {} catch Error(</span>
 298 |     | <span class='neutral'>                string memory reason</span>
 299 |     | <span class='neutral'>            ) {</span>
 300 |     | <span class='neutral'>                // &quot;SPL&quot; means that proposed buy price is too high. If so - silently skip conversion.</span>
 301 |     | <span class='neutral'>                // For any other error - revert</span>
 302 |     | <span class='neutral'>                // Consider emitting or logging</span>
 303 |     | <span class='neutral'>                // Consider ignoring some other errors if it&#39;s appropriate</span>
 304 |     | <span class='neutral'>                // Consider replacing with `Strings.equal` on OpenZeppelin next release</span>
 305 |     | <span class='neutral'>                if (keccak256(abi.encodePacked(reason)) != keccak256(abi.encodePacked(&quot;SPL&quot;))) {</span>
 306 |     | <span class='neutral'>                    revert(reason);</span>
 307 |     | <span class='neutral'>                }</span>
 308 |     | <span class='neutral'>            }</span>
 309 |     | <span class='neutral'>        }</span>
 310 |     | <span class='neutral'>    }</span>
 311 |     | <span class='neutral'></span>
 312 |     | <span class='neutral'>    function deposit(IERC20[] memory erc20s, address numeraire) private {</span>
 313 |     | <span class='neutral'>        dos.depositFull(erc20s);</span>
 314 |     | <span class='neutral'>        IERC20[] memory numeraireArray = new IERC20[](1);</span>
 315 |     | <span class='neutral'>        numeraireArray[0] = IERC20(numeraire);</span>
 316 |     | <span class='neutral'>        dos.depositFull(numeraireArray);</span>
 317 |     | <span class='neutral'>    }</span>
 318 |     | <span class='neutral'>}</span>
 319 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/dos/TransferAndCall2.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/utils/cryptography/EIP712.sol&quot;;</span>
   5 |     | <span class='unexecuted'>import &quot;@openzeppelin/contracts/utils/cryptography/ECDSA.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol&quot;;</span>
   7 |     | <span class='unexecuted'>import &quot;@openzeppelin/contracts/utils/Address.sol&quot;;</span>
   8 |     | <span class='unexecuted'>import &quot;@openzeppelin/contracts/interfaces/IERC1363Receiver.sol&quot;;</span>
   9 |     | <span class='unexecuted'>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;../external/interfaces/IWETH9.sol&quot;;</span>
  12 |     | <span class='unexecuted'>import &quot;../interfaces/ITransferReceiver2.sol&quot;;</span>
  13 |     | <span class='neutral'>import &quot;../lib/NonceMap.sol&quot;;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>// Bringing ERC1363 to all tokens, it&#39;s to ERC1363 what Permit2 is to ERC2612.</span>
  16 |     | <span class='neutral'>// This should be proposed as an EIP and should be deployed cross chain on</span>
  17 |     | <span class='neutral'>// fixed address using AnyswapCreate2Deployer.</span>
  18 |     | <span class='neutral'>contract TransferAndCall2 is IERC1363Receiver, EIP712 {</span>
  19 |     | <span class='neutral'>    using Address for address;</span>
  20 |     | <span class='neutral'>    using SafeERC20 for IERC20;</span>
  21 |     | <span class='neutral'>    using NonceMapLib for NonceMap;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    bytes private constant TRANSFER_TYPESTRING = &quot;Transfer(address token,uint256 amount)&quot;;</span>
  24 |     | <span class='neutral'>    bytes private constant PERMIT_TYPESTRING =</span>
  25 |     | <span class='neutral'>        &quot;Permit(address receiver,Transfer[] transfers,bytes data,uint256 nonce,uint256 deadline)&quot;;</span>
  26 |     | <span class='neutral'>    bytes32 private constant TRANSFER_TYPEHASH = keccak256(TRANSFER_TYPESTRING);</span>
  27 |     | <span class='neutral'>    bytes32 private constant PERMIT_TYPEHASH =</span>
  28 |     | <span class='neutral'>        keccak256(abi.encodePacked(PERMIT_TYPESTRING, TRANSFER_TYPESTRING));</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; bool)) public approvalByOwnerByOperator;</span>
  31 |     | <span class='neutral'>    mapping(address =&gt; NonceMap) private nonceMap;</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    error onTransferReceivedFailed(</span>
  34 |     | <span class='neutral'>        address to,</span>
  35 |     | <span class='neutral'>        address operator,</span>
  36 |     | <span class='neutral'>        address from,</span>
  37 |     | <span class='neutral'>        ITransferReceiver2.Transfer[] transfers,</span>
  38 |     | <span class='neutral'>        bytes data</span>
  39 |     | <span class='neutral'>    );</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    error TransfersUnsorted();</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    error EthDoesntMatchWethTransfer();</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    error UnauthorizedOperator(address operator, address from);</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    constructor() EIP712(&quot;TransferAndCall2&quot;, &quot;1&quot;) {}</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    /// @dev Set approval for all token transfers from msg.sender to a particular operator</span>
  50 |     | <span class='neutral'>    function setApprovalForAll(address operator, bool approved) external {</span>
  51 |     | <span class='neutral'>        approvalByOwnerByOperator[msg.sender][operator] = approved;</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    /// @dev Called by a token to indicate a transfer into the callee</span>
  55 |     | <span class='neutral'>    /// @param receiver The account to sent the tokens</span>
  56 |     | <span class='neutral'>    /// @param transfers Transfers that have been made</span>
  57 |     | <span class='neutral'>    /// @param data The extra data being passed to the receiving contract</span>
  58 |     | <span class='neutral'>    function transferAndCall2(</span>
  59 |     | <span class='neutral'>        address receiver,</span>
  60 |     | <span class='neutral'>        ITransferReceiver2.Transfer[] calldata transfers,</span>
  61 |     | <span class='neutral'>        bytes calldata data</span>
  62 |     | <span class='neutral'>    ) external {</span>
  63 |     | <span class='neutral'>        return transferFromAndCall2Impl(msg.sender, receiver, address(0), transfers, data);</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    /// @dev Called by a token to indicate a transfer into the callee, converting ETH to WETH</span>
  67 |     | <span class='neutral'>    /// @param receiver The account to sent the tokens</span>
  68 |     | <span class='neutral'>    /// @param weth The WETH9 contract address</span>
  69 |     | <span class='neutral'>    /// @param transfers Transfers that have been made</span>
  70 |     | <span class='neutral'>    /// @param data The extra data being passed to the receiving contract</span>
  71 |     | <span class='neutral'>    function transferAndCall2WithValue(</span>
  72 |     | <span class='neutral'>        address receiver,</span>
  73 |     | <span class='neutral'>        address weth,</span>
  74 |     | <span class='neutral'>        ITransferReceiver2.Transfer[] calldata transfers,</span>
  75 |     | <span class='neutral'>        bytes calldata data</span>
  76 |     | <span class='neutral'>    ) external payable {</span>
  77 |     | <span class='neutral'>        return transferFromAndCall2Impl(msg.sender, receiver, weth, transfers, data);</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    /// @dev Called by a token to indicate a transfer into the callee</span>
  81 |     | <span class='neutral'>    /// @param from The account that has sent the tokens</span>
  82 |     | <span class='neutral'>    /// @param receiver The account to sent the tokens</span>
  83 |     | <span class='neutral'>    /// @param transfers Transfers that have been made</span>
  84 |     | <span class='neutral'>    /// @param data The extra data being passed to the receiving contract</span>
  85 |     | <span class='neutral'>    function transferFromAndCall2(</span>
  86 |     | <span class='neutral'>        address from,</span>
  87 |     | <span class='neutral'>        address receiver,</span>
  88 |     | <span class='neutral'>        ITransferReceiver2.Transfer[] calldata transfers,</span>
  89 |     | <span class='neutral'>        bytes calldata data</span>
  90 |     | <span class='neutral'>    ) external {</span>
  91 |     | <span class='neutral'>        if (!approvalByOwnerByOperator[from][msg.sender]) {</span>
  92 |     | <span class='neutral'>            revert UnauthorizedOperator(msg.sender, from);</span>
  93 |     | <span class='neutral'>        }</span>
  94 |     | <span class='neutral'>        return transferFromAndCall2Impl(from, receiver, address(0), transfers, data);</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    function transferAndCall2WithPermit(</span>
  98 |     | <span class='neutral'>        address from,</span>
  99 |     | <span class='neutral'>        address receiver,</span>
 100 |     | <span class='neutral'>        ITransferReceiver2.Transfer[] calldata transfers,</span>
 101 |     | <span class='neutral'>        bytes calldata data,</span>
 102 |     | <span class='neutral'>        uint256 nonce,</span>
 103 |     | <span class='neutral'>        uint256 deadline,</span>
 104 |     | <span class='neutral'>        bytes calldata signature</span>
 105 |     | <span class='neutral'>    ) external {</span>
 106 |     | <span class='neutral'>        nonceMap[from].validateAndUseNonce(nonce);</span>
 107 |     | <span class='neutral'>        require(block.timestamp &lt;= deadline, &quot;Expired permit&quot;);</span>
 108 |     | <span class='neutral'>        bytes32[] memory transferHashes = new bytes32[](transfers.length);</span>
 109 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; transfers.length; i++) {</span>
 110 |     | <span class='neutral'>            transferHashes[i] = keccak256(</span>
 111 |     | <span class='neutral'>                abi.encodePacked(TRANSFER_TYPEHASH, transfers[i].token, transfers[i].amount)</span>
 112 |     | <span class='neutral'>            );</span>
 113 |     | <span class='neutral'>        }</span>
 114 |     | <span class='neutral'>        bytes32 digest = _hashTypedDataV4(</span>
 115 |     | <span class='neutral'>            keccak256(</span>
 116 |     | <span class='neutral'>                abi.encode(</span>
 117 |     | <span class='neutral'>                    PERMIT_TYPEHASH,</span>
 118 |     | <span class='neutral'>                    receiver,</span>
 119 |     | <span class='neutral'>                    keccak256(abi.encodePacked(transferHashes)),</span>
 120 |     | <span class='neutral'>                    data,</span>
 121 |     | <span class='neutral'>                    nonce,</span>
 122 |     | <span class='neutral'>                    deadline</span>
 123 |     | <span class='neutral'>                )</span>
 124 |     | <span class='neutral'>            )</span>
 125 |     | <span class='neutral'>        );</span>
 126 |     | <span class='neutral'>        require(SignatureChecker.isValidSignatureNow(from, digest, signature), &quot;Invalid signature&quot;);</span>
 127 |     | <span class='neutral'>        return transferFromAndCall2Impl(from, receiver, address(0), transfers, data);</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    /// @notice Callback for ERC1363 transferAndCall</span>
 131 |     | <span class='neutral'>    /// @param _operator The address which called `transferAndCall` function</span>
 132 |     | <span class='neutral'>    /// @param _from The address which previously owned the token</span>
 133 |     | <span class='neutral'>    /// @param _amount The amount of tokens being transferred</span>
 134 |     | <span class='neutral'>    /// @param _data Additional data containing the receiver address and the extra data</span>
 135 |     | <span class='neutral'>    function onTransferReceived(</span>
 136 |     | <span class='neutral'>        address _operator,</span>
 137 |     | <span class='neutral'>        address _from,</span>
 138 |     | <span class='neutral'>        uint256 _amount,</span>
 139 |     | <span class='neutral'>        bytes calldata _data</span>
 140 |     | <span class='neutral'>    ) external override returns (bytes4) {</span>
 141 |     | <span class='neutral'>        (address to, bytes memory decodedData) = abi.decode(_data, (address, bytes));</span>
 142 |     | <span class='neutral'>        ITransferReceiver2.Transfer[] memory transfers = new ITransferReceiver2.Transfer[](1);</span>
 143 |     | <span class='neutral'>        transfers[0] = ITransferReceiver2.Transfer(msg.sender, _amount);</span>
 144 |     | <span class='neutral'>        callOnTransferReceived2(to, _operator, _from, transfers, decodedData);</span>
 145 |     | <span class='neutral'>        return IERC1363Receiver.onTransferReceived.selector;</span>
 146 |     | <span class='neutral'>    }</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>    function transferFromAndCall2Impl(</span>
 149 |     | <span class='neutral'>        address from,</span>
 150 |     | <span class='neutral'>        address receiver,</span>
 151 |     | <span class='neutral'>        address weth,</span>
 152 |     | <span class='neutral'>        ITransferReceiver2.Transfer[] calldata transfers,</span>
 153 |     | <span class='neutral'>        bytes memory data</span>
 154 |     | <span class='neutral'>    ) internal {</span>
 155 |     | <span class='neutral'>        uint256 ethAmount = msg.value;</span>
 156 |     | <span class='neutral'>        if (ethAmount != 0) {</span>
 157 |     | <span class='neutral'>            IWETH9(payable(weth)).deposit{value: msg.value}();</span>
 158 |     | <span class='neutral'>            IERC20(weth).safeTransfer(receiver, msg.value);</span>
 159 |     | <span class='neutral'>        }</span>
 160 |     | <span class='neutral'>        address prev = address(0);</span>
 161 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; transfers.length; i++) {</span>
 162 |     | <span class='neutral'>            address tokenAddress = transfers[i].token;</span>
 163 |     | <span class='neutral'>            if (prev &gt;= tokenAddress) revert TransfersUnsorted();</span>
 164 |     | <span class='neutral'>            prev = tokenAddress;</span>
 165 |     | <span class='neutral'>            uint256 amount = transfers[i].amount;</span>
 166 |     | <span class='neutral'>            if (tokenAddress == weth) {</span>
 167 |     | <span class='neutral'>                // Already send WETH</span>
 168 |     | <span class='neutral'>                amount -= ethAmount; // reverts if msg.value &gt; amount</span>
 169 |     | <span class='neutral'>                ethAmount = 0;</span>
 170 |     | <span class='neutral'>            }</span>
 171 |     | <span class='neutral'>            IERC20 token = IERC20(tokenAddress);</span>
 172 |     | <span class='neutral'>            if (amount &gt; 0) token.safeTransferFrom(from, receiver, amount);</span>
 173 |     | <span class='neutral'>        }</span>
 174 |     | <span class='neutral'>        if (ethAmount != 0) revert EthDoesntMatchWethTransfer();</span>
 175 |     | <span class='neutral'>        if (receiver.isContract()) {</span>
 176 |     | <span class='neutral'>            callOnTransferReceived2(receiver, msg.sender, from, transfers, data);</span>
 177 |     | <span class='neutral'>        }</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>    function callOnTransferReceived2(</span>
 181 |     | <span class='neutral'>        address to,</span>
 182 |     | <span class='neutral'>        address operator,</span>
 183 |     | <span class='neutral'>        address from,</span>
 184 |     | <span class='neutral'>        ITransferReceiver2.Transfer[] memory transfers,</span>
 185 |     | <span class='neutral'>        bytes memory data</span>
 186 |     | <span class='neutral'>    ) internal {</span>
 187 |     | <span class='neutral'>        if (</span>
 188 |     | <span class='neutral'>            ITransferReceiver2(to).onTransferReceived2(operator, from, transfers, data) !=</span>
 189 |     | <span class='neutral'>            ITransferReceiver2.onTransferReceived2.selector</span>
 190 |     | <span class='neutral'>        ) {</span>
 191 |     | <span class='neutral'>            revert onTransferReceivedFailed(to, operator, from, transfers, data);</span>
 192 |     | <span class='neutral'>        }</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'>}</span>
 195 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/dos/VersionManager.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>// Inspired by the following contract: https://github.com/OpenBazaar/smart-contracts/blob/22d3f190163102f9ceee95ac705001c82ca55624/contracts/registry/ContractManager.sol</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/utils/Address.sol&quot;;</span>
   7 |     | <span class='neutral'>import {FsUtils} from &quot;../lib/FsUtils.sol&quot;;</span>
   8 |     | <span class='neutral'>import {ImmutableGovernance} from &quot;../lib/ImmutableGovernance.sol&quot;;</span>
   9 |     | <span class='neutral'>import {ImmutableVersion} from &quot;../lib/ImmutableVersion.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;../interfaces/IVersionManager.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>/// @title DOS Version Manager</span>
  13 |     | <span class='neutral'>contract VersionManager is IVersionManager, ImmutableGovernance {</span>
  14 |     | <span class='neutral'>    /// @notice Array of all version names</span>
  15 |     | <span class='neutral'>    string[] internal _versionString;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /// @notice Mapping from version names to version structs</span>
  18 |     | <span class='neutral'>    mapping(string =&gt; Version) internal _versions;</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    /// @dev The recommended version</span>
  21 |     | <span class='neutral'>    string internal _recommendedVersion;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='unexecuted'>    modifier versionExists(string memory versionName) {</span>
  24 |     | <span class='neutral'>        if (_versions[versionName].implementation == address(0)) {</span>
  25 |     | <span class='neutral'>            revert VersionNotRegistered();</span>
  26 |     | <span class='neutral'>        }</span>
  27 |     | <span class='unexecuted'>        _;</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    modifier validStatus(Status status) {</span>
  31 |     | <span class='neutral'>        require(uint8(status) &lt;= uint8(Status.DEPRECATED), &quot;Invalid status&quot;);</span>
  32 |     | <span class='neutral'>        _;</span>
  33 |     | <span class='neutral'>    }</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    modifier validBugLevel(BugLevel bugLevel) {</span>
  36 |     | <span class='neutral'>        require(uint8(bugLevel) &lt;= uint8(BugLevel.CRITICAL), &quot;Invalid bug level&quot;);</span>
  37 |     | <span class='neutral'>        _;</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='unexecuted'>    constructor(address _owner) ImmutableGovernance(_owner) {}</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='unexecuted'>    /// @notice Registers a new version of the store contract</span>
  43 |     | <span class='neutral'>    /// @param status Status of the version to be added</span>
  44 |     | <span class='neutral'>    /// @param _implementation The address of the implementation of the version</span>
  45 |     | <span class='neutral'>    function addVersion(</span>
  46 |     | <span class='unexecuted'>        Status status,</span>
  47 |     | <span class='neutral'>        address _implementation</span>
  48 |     | <span class='neutral'>    ) external onlyGovernance validStatus(status) {</span>
  49 |     | <span class='unexecuted'>        address implementation = FsUtils.nonNull(_implementation);</span>
  50 |     | <span class='neutral'>        // implementation must be a contract</span>
  51 |     | <span class='unexecuted'>        if (!Address.isContract(implementation)) {</span>
  52 |     | <span class='unexecuted'>            revert InvalidImplementation();</span>
  53 |     | <span class='neutral'>        }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>        string memory versionName = &quot;&quot;;</span>
  56 |     | <span class='neutral'>        try ImmutableVersion(implementation).immutableVersion() returns (bytes32 immutableVersion) {</span>
  57 |     | <span class='neutral'>            versionName = string(FsUtils.decodeFromBytes32(immutableVersion));</span>
  58 |     | <span class='neutral'>        } catch {</span>
  59 |     | <span class='neutral'>            revert InvalidImplementation();</span>
  60 |     | <span class='neutral'>        }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>        // version name must not be the empty string</span>
  63 |     | <span class='neutral'>        if (bytes(versionName).length == 0) {</span>
  64 |     | <span class='neutral'>            revert InvalidVersionName();</span>
  65 |     | <span class='neutral'>        }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>        // the version name should not already be registered</span>
  68 |     | <span class='neutral'>        if (_versions[versionName].implementation != address(0)) {</span>
  69 |     | <span class='neutral'>            revert VersionAlreadyRegistered();</span>
  70 |     | <span class='neutral'>        }</span>
  71 |     | <span class='neutral'>        _versionString.push(versionName);</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>        _versions[versionName] = Version({</span>
  74 |     | <span class='neutral'>            versionName: versionName,</span>
  75 |     | <span class='neutral'>            status: status,</span>
  76 |     | <span class='neutral'>            bugLevel: BugLevel.NONE,</span>
  77 |     | <span class='neutral'>            implementation: implementation,</span>
  78 |     | <span class='neutral'>            dateAdded: block.timestamp</span>
  79 |     | <span class='neutral'>        });</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>        emit VersionAdded(versionName, implementation);</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    /// @notice Update a contract version</span>
  85 |     | <span class='neutral'>    /// @param versionName Version of the contract</span>
  86 |     | <span class='neutral'>    /// @param status Status of the contract</span>
  87 |     | <span class='neutral'>    /// @param bugLevel New bug level for the contract</span>
  88 |     | <span class='neutral'>    function updateVersion(</span>
  89 |     | <span class='neutral'>        string calldata versionName,</span>
  90 |     | <span class='neutral'>        Status status,</span>
  91 |     | <span class='neutral'>        BugLevel bugLevel</span>
  92 |     | <span class='neutral'>    )</span>
  93 |     | <span class='neutral'>        external</span>
  94 |     | <span class='neutral'>        onlyGovernance</span>
  95 |     | <span class='neutral'>        versionExists(versionName)</span>
  96 |     | <span class='neutral'>        validStatus(status)</span>
  97 |     | <span class='neutral'>        validBugLevel(bugLevel)</span>
  98 |     | <span class='neutral'>    {</span>
  99 |     | <span class='neutral'>        _versions[versionName].status = status;</span>
 100 |     | <span class='neutral'>        _versions[versionName].bugLevel = bugLevel;</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>        emit VersionUpdated(versionName, status, bugLevel);</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    /// @notice Set the recommended version</span>
 106 |     | <span class='neutral'>    /// @param versionName Version of the contract</span>
 107 |     | <span class='neutral'>    function markRecommendedVersion(</span>
 108 |     | <span class='neutral'>        string calldata versionName</span>
 109 |     | <span class='neutral'>    ) external onlyGovernance versionExists(versionName) {</span>
 110 |     | <span class='neutral'>        require(</span>
 111 |     | <span class='neutral'>            _versions[versionName].status != IVersionManager.Status.DEPRECATED &amp;&amp;</span>
 112 |     | <span class='neutral'>                _versions[versionName].bugLevel == IVersionManager.BugLevel.NONE,</span>
 113 |     | <span class='neutral'>            &quot;Version not valid&quot;</span>
 114 |     | <span class='neutral'>        );</span>
 115 |     | <span class='neutral'>        // set the version name as the recommended version</span>
 116 |     | <span class='neutral'>        _recommendedVersion = versionName;</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>        emit VersionRecommended(versionName);</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>    /// @notice Remove the recommended version</span>
 122 |     | <span class='neutral'>    function removeRecommendedVersion() external onlyGovernance {</span>
 123 |     | <span class='neutral'>        // delete the recommended version name</span>
 124 |     | <span class='neutral'>        delete _recommendedVersion;</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>        emit RecommendedVersionRemoved();</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    /// @notice Get recommended version for the contract.</span>
 130 |     | <span class='neutral'>    /// @return versionName The name of the recommended version</span>
 131 |     | <span class='neutral'>    /// @return status The status of the recommended version</span>
 132 |     | <span class='neutral'>    /// @return bugLevel The bug level of the recommended version</span>
 133 |     | <span class='neutral'>    /// @return implementation The address of the implementation of the recommended version</span>
 134 |     | <span class='neutral'>    /// @return dateAdded The date the recommended version was added</span>
 135 |     | <span class='neutral'>    function getRecommendedVersion()</span>
 136 |     | <span class='neutral'>        external</span>
 137 |     | <span class='neutral'>        view</span>
 138 |     | <span class='neutral'>        returns (</span>
 139 |     | <span class='neutral'>            string memory versionName,</span>
 140 |     | <span class='neutral'>            Status status,</span>
 141 |     | <span class='neutral'>            BugLevel bugLevel,</span>
 142 |     | <span class='neutral'>            address implementation,</span>
 143 |     | <span class='neutral'>            uint256 dateAdded</span>
 144 |     | <span class='neutral'>        )</span>
 145 |     | <span class='neutral'>    {</span>
 146 |     | <span class='neutral'>        require(bytes(_recommendedVersion).length != 0, &quot;Recommended version is not specified&quot;);</span>
 147 |     | <span class='neutral'>        versionName = _recommendedVersion;</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>        Version storage recommendedVersion = _versions[versionName];</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='neutral'>        status = recommendedVersion.status;</span>
 152 |     | <span class='neutral'>        bugLevel = recommendedVersion.bugLevel;</span>
 153 |     | <span class='neutral'>        implementation = recommendedVersion.implementation;</span>
 154 |     | <span class='neutral'>        dateAdded = recommendedVersion.dateAdded;</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='neutral'>        return (versionName, status, bugLevel, implementation, dateAdded);</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    /// @notice Get total count of versions</span>
 160 |     | <span class='neutral'>    function getVersionCount() external view returns (uint256 count) {</span>
 161 |     | <span class='neutral'>        count = _versionString.length;</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    /// @dev Returns the version name at specific index in the versionString[] array</span>
 165 |     | <span class='neutral'>    /// @param index The index to be searched for</span>
 166 |     | <span class='neutral'>    function getVersionAtIndex(uint256 index) external view returns (string memory versionName) {</span>
 167 |     | <span class='neutral'>        versionName = _versionString[index];</span>
 168 |     | <span class='neutral'>    }</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>    /// @notice Get the implementation address for a version</span>
 171 |     | <span class='neutral'>    /// @param index The index of the version</span>
 172 |     | <span class='neutral'>    function getVersionAddress(uint256 index) external view returns (address) {</span>
 173 |     | <span class='neutral'>        string memory versionName = _versionString[index];</span>
 174 |     | <span class='neutral'>        Version memory v = _versions[versionName];</span>
 175 |     | <span class='neutral'>        return v.implementation;</span>
 176 |     | <span class='neutral'>    }</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='neutral'>    /// @notice Returns the version details for the given version name</span>
 179 |     | <span class='neutral'>    /// @param versionName Version string</span>
 180 |     | <span class='neutral'>    function getVersionDetails(</span>
 181 |     | <span class='neutral'>        string calldata versionName</span>
 182 |     | <span class='neutral'>    )</span>
 183 |     | <span class='neutral'>        external</span>
 184 |     | <span class='neutral'>        view</span>
 185 |     | <span class='neutral'>        returns (</span>
 186 |     | <span class='neutral'>            string memory versionString,</span>
 187 |     | <span class='neutral'>            Status status,</span>
 188 |     | <span class='neutral'>            BugLevel bugLevel,</span>
 189 |     | <span class='neutral'>            address implementation,</span>
 190 |     | <span class='neutral'>            uint256 dateAdded</span>
 191 |     | <span class='neutral'>        )</span>
 192 |     | <span class='neutral'>    {</span>
 193 |     | <span class='neutral'>        Version storage v = _versions[versionName];</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>        versionString = v.versionName;</span>
 196 |     | <span class='neutral'>        status = v.status;</span>
 197 |     | <span class='neutral'>        bugLevel = v.bugLevel;</span>
 198 |     | <span class='neutral'>        implementation = v.implementation;</span>
 199 |     | <span class='neutral'>        dateAdded = v.dateAdded;</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='neutral'>        return (versionString, status, bugLevel, implementation, dateAdded);</span>
 202 |     | <span class='neutral'>    }</span>
 203 |     | <span class='neutral'>}</span>
 204 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/duoswapV2/DuoswapV2ERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.7;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;@uniswap/v2-core/contracts/interfaces/IUniswapV2ERC20.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>//solhint-disable var-name-mixedcase</span>
   7 |     | <span class='neutral'>//solhint-disable reason-string</span>
   8 |     | <span class='neutral'>//solhint-disable const-name-snakecase</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>contract DuoswapV2ERC20 is IUniswapV2ERC20 {</span>
  11 |     | <span class='neutral'>    string public constant override name = &quot;Uniswap V2&quot;;</span>
  12 |     | <span class='neutral'>    string public constant override symbol = &quot;UNI-V2&quot;;</span>
  13 |     | <span class='neutral'>    uint8 public constant override decimals = 18;</span>
  14 |     | <span class='neutral'>    uint256 public override totalSupply;</span>
  15 |     | <span class='neutral'>    mapping(address =&gt; uint256) public override balanceOf;</span>
  16 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; uint256)) public override allowance;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    bytes32 public override DOMAIN_SEPARATOR;</span>
  19 |     | <span class='neutral'>    // keccak256(&quot;Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)&quot;);</span>
  20 |     | <span class='neutral'>    bytes32 public constant override PERMIT_TYPEHASH =</span>
  21 |     | <span class='neutral'>        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;</span>
  22 |     | <span class='neutral'>    mapping(address =&gt; uint256) public override nonces;</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    constructor() {</span>
  25 |     | <span class='neutral'>        DOMAIN_SEPARATOR = keccak256(</span>
  26 |     | <span class='neutral'>            abi.encode(</span>
  27 |     | <span class='neutral'>                keccak256(</span>
  28 |     | <span class='neutral'>                    &quot;EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)&quot;</span>
  29 |     | <span class='neutral'>                ),</span>
  30 |     | <span class='neutral'>                keccak256(bytes(name)),</span>
  31 |     | <span class='neutral'>                keccak256(bytes(&quot;1&quot;)),</span>
  32 |     | <span class='neutral'>                block.chainid,</span>
  33 |     | <span class='neutral'>                address(this)</span>
  34 |     | <span class='neutral'>            )</span>
  35 |     | <span class='neutral'>        );</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    function approve(address spender, uint256 value) external override returns (bool) {</span>
  39 |     | <span class='neutral'>        _approve(msg.sender, spender, value);</span>
  40 |     | <span class='neutral'>        return true;</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    function transfer(address to, uint256 value) external override returns (bool) {</span>
  44 |     | <span class='neutral'>        _transfer(msg.sender, to, value);</span>
  45 |     | <span class='neutral'>        return true;</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    function transferFrom(</span>
  49 |     | <span class='neutral'>        address from,</span>
  50 |     | <span class='neutral'>        address to,</span>
  51 |     | <span class='neutral'>        uint256 value</span>
  52 |     | <span class='neutral'>    ) external override returns (bool) {</span>
  53 |     | <span class='neutral'>        if (allowance[from][msg.sender] != type(uint256).max) {</span>
  54 |     | <span class='neutral'>            allowance[from][msg.sender] -= value;</span>
  55 |     | <span class='neutral'>        }</span>
  56 |     | <span class='neutral'>        _transfer(from, to, value);</span>
  57 |     | <span class='neutral'>        return true;</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    function permit(</span>
  61 |     | <span class='neutral'>        address owner,</span>
  62 |     | <span class='neutral'>        address spender,</span>
  63 |     | <span class='neutral'>        uint256 value,</span>
  64 |     | <span class='neutral'>        uint256 deadline,</span>
  65 |     | <span class='neutral'>        uint8 v,</span>
  66 |     | <span class='neutral'>        bytes32 r,</span>
  67 |     | <span class='neutral'>        bytes32 s</span>
  68 |     | <span class='neutral'>    ) external override {</span>
  69 |     | <span class='neutral'>        //solhint-disable-next-line not-rely-on-time</span>
  70 |     | <span class='neutral'>        require(deadline &gt;= block.timestamp, &quot;UniswapV2: EXPIRED&quot;);</span>
  71 |     | <span class='neutral'>        bytes32 digest = keccak256(</span>
  72 |     | <span class='neutral'>            abi.encodePacked(</span>
  73 |     | <span class='neutral'>                &quot;\x19\x01&quot;,</span>
  74 |     | <span class='neutral'>                DOMAIN_SEPARATOR,</span>
  75 |     | <span class='neutral'>                keccak256(</span>
  76 |     | <span class='neutral'>                    abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline)</span>
  77 |     | <span class='neutral'>                )</span>
  78 |     | <span class='neutral'>            )</span>
  79 |     | <span class='neutral'>        );</span>
  80 |     | <span class='neutral'>        address recoveredAddress = ecrecover(digest, v, r, s);</span>
  81 |     | <span class='neutral'>        require(</span>
  82 |     | <span class='neutral'>            recoveredAddress != address(0) &amp;&amp; recoveredAddress == owner,</span>
  83 |     | <span class='neutral'>            &quot;UniswapV2: INVALID_SIGNATURE&quot;</span>
  84 |     | <span class='neutral'>        );</span>
  85 |     | <span class='neutral'>        _approve(owner, spender, value);</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    function _mint(address to, uint256 value) internal {</span>
  89 |     | <span class='neutral'>        totalSupply += value;</span>
  90 |     | <span class='neutral'>        balanceOf[to] += value;</span>
  91 |     | <span class='neutral'>        emit Transfer(address(0), to, value);</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    function _burn(address from, uint256 value) internal {</span>
  95 |     | <span class='neutral'>        balanceOf[from] -= value;</span>
  96 |     | <span class='neutral'>        totalSupply -= value;</span>
  97 |     | <span class='neutral'>        emit Transfer(from, address(0), value);</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    function _approve(address owner, address spender, uint256 value) internal {</span>
 101 |     | <span class='neutral'>        allowance[owner][spender] = value;</span>
 102 |     | <span class='neutral'>        emit Approval(owner, spender, value);</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    function _transfer(address from, address to, uint256 value) private {</span>
 106 |     | <span class='neutral'>        balanceOf[from] -= value;</span>
 107 |     | <span class='neutral'>        balanceOf[to] += value;</span>
 108 |     | <span class='neutral'>        emit Transfer(from, to, value);</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'>}</span>
 111 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/duoswapV2/DuoswapV2Factory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.7;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol&quot;;</span>
  5 |     | <span class='neutral'>import {IDuoswapV2Pair, DuoswapV2Pair} from &quot;./DuoswapV2Pair.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>contract DuoswapV2Factory is IUniswapV2Factory {</span>
  8 |     | <span class='neutral'>    bytes32 public constant PAIR_HASH = keccak256(type(DuoswapV2Pair).creationCode);</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    address public dos;</span>
 11 |     | <span class='neutral'>    address public override feeTo;</span>
 12 |     | <span class='neutral'>    address public override feeToSetter;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; address)) public override getPair;</span>
 15 |     | <span class='neutral'>    address[] public override allPairs;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    constructor(address _dos, address _feeToSetter) {</span>
 18 |     | <span class='neutral'>        dos = _dos;</span>
 19 |     | <span class='neutral'>        feeToSetter = _feeToSetter;</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>    function createPair(address tokenA, address tokenB) external override returns (address pair) {</span>
 23 |     | <span class='neutral'>        require(tokenA != tokenB, &quot;UniswapV2: IDENTICAL_ADDRESSES&quot;);</span>
 24 |     | <span class='neutral'>        (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);</span>
 25 |     | <span class='neutral'>        require(token0 != address(0), &quot;UniswapV2: ZERO_ADDRESS&quot;);</span>
 26 |     | <span class='neutral'>        require(getPair[token0][token1] == address(0), &quot;UniswapV2: PAIR_EXISTS&quot;); // single check is sufficient</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>        pair = address(new DuoswapV2Pair{salt: keccak256(abi.encodePacked(token0, token1))}());</span>
 29 |     | <span class='neutral'>        IDuoswapV2Pair(pair).initialize(dos, token0, token1);</span>
 30 |     | <span class='neutral'>        getPair[token0][token1] = pair;</span>
 31 |     | <span class='neutral'>        getPair[token1][token0] = pair; // populate mapping in the reverse direction</span>
 32 |     | <span class='neutral'>        allPairs.push(pair);</span>
 33 |     | <span class='neutral'>        emit PairCreated(token0, token1, pair, allPairs.length);</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    function setFeeTo(address _feeTo) external override {</span>
 37 |     | <span class='unexecuted'>        require(msg.sender == feeToSetter, &quot;UniswapV2: FORBIDDEN&quot;);</span>
 38 |     | <span class='neutral'>        feeTo = _feeTo;</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='unexecuted'>    function setFeeToSetter(address _feeToSetter) external override {</span>
 42 |     | <span class='neutral'>        require(msg.sender == feeToSetter, &quot;UniswapV2: FORBIDDEN&quot;);</span>
 43 |     | <span class='unexecuted'>        feeToSetter = _feeToSetter;</span>
 44 |     | <span class='neutral'>    }</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='unexecuted'>    function allPairsLength() external view override returns (uint256) {</span>
 47 |     | <span class='unexecuted'>        return allPairs.length;</span>
 48 |     | <span class='neutral'>    }</span>
 49 |     | <span class='neutral'>}</span>
 50 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/duoswapV2/DuoswapV2Pair.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.7;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>//solhint-disable ordering</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;@uniswap/v2-core/contracts/interfaces/IUniswapV2Callee.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>import &quot;./libraries/Math.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;./libraries/UQ112x112.sol&quot;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>import {IDuoswapV2Pair} from &quot;./interfaces/IDuoswapV2Pair.sol&quot;;</span>
  14 |     | <span class='unexecuted'>import {DuoswapV2ERC20} from &quot;./DuoswapV2ERC20.sol&quot;;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>import {IDOS} from &quot;../interfaces/IDOS.sol&quot;;</span>
  17 |     | <span class='neutral'>import {Call} from &quot;../lib/Call.sol&quot;;</span>
  18 |     | <span class='neutral'>import {ISafe} from &quot;../interfaces/ISafe.sol&quot;;</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>//solhint-disable func-name-mixedcase</span>
  21 |     | <span class='neutral'>//solhint-disable avoid-low-level-calls</span>
  22 |     | <span class='neutral'>//solhint-disable reason-string</span>
  23 |     | <span class='neutral'>//solhint-disable not-rely-on-time</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>contract DuoswapV2Pair is IDuoswapV2Pair, DuoswapV2ERC20 {</span>
  26 |     | <span class='neutral'>    using UQ112x112 for uint224;</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    uint256 public constant override MINIMUM_LIQUIDITY = 10 ** 3;</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    address public override factory;</span>
  31 |     | <span class='neutral'>    address public override token0;</span>
  32 |     | <span class='neutral'>    address public override token1;</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    address public dos;</span>
  35 |     | <span class='neutral'>    address public dSafe;</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    uint112 private reserve0; // uses single storage slot, accessible via getReserves</span>
  38 |     | <span class='neutral'>    uint112 private reserve1; // uses single storage slot, accessible via getReserves</span>
  39 |     | <span class='neutral'>    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    uint256 public override price0CumulativeLast;</span>
  42 |     | <span class='neutral'>    uint256 public override price1CumulativeLast;</span>
  43 |     | <span class='neutral'>    uint256 public override kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    uint256 private unlocked = 1;</span>
  46 |     | <span class='neutral'>    modifier lock() {</span>
  47 |     | <span class='neutral'>        require(unlocked == 1, &quot;UniswapV2: LOCKED&quot;);</span>
  48 |     | <span class='neutral'>        unlocked = 0;</span>
  49 |     | <span class='neutral'>        _;</span>
  50 |     | <span class='neutral'>        unlocked = 1;</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    function getReserves()</span>
  54 |     | <span class='neutral'>        public</span>
  55 |     | <span class='neutral'>        view</span>
  56 |     | <span class='neutral'>        override</span>
  57 |     | <span class='neutral'>        returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast)</span>
  58 |     | <span class='neutral'>    {</span>
  59 |     | <span class='neutral'>        _reserve0 = reserve0;</span>
  60 |     | <span class='neutral'>        _reserve1 = reserve1;</span>
  61 |     | <span class='neutral'>        _blockTimestampLast = blockTimestampLast;</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    function _safeTransfer(address token, address to, uint256 amount) private {</span>
  65 |     | <span class='neutral'>        Call[] memory call = new Call[](1);</span>
  66 |     | <span class='neutral'>        call[0] = (</span>
  67 |     | <span class='neutral'>            Call({</span>
  68 |     | <span class='neutral'>                to: address(dos),</span>
  69 |     | <span class='neutral'>                callData: abi.encodeWithSignature(</span>
  70 |     | <span class='neutral'>                    &quot;transferERC20(address,address,uint256)&quot;,</span>
  71 |     | <span class='neutral'>                    address(token),</span>
  72 |     | <span class='neutral'>                    to,</span>
  73 |     | <span class='neutral'>                    amount</span>
  74 |     | <span class='neutral'>                ),</span>
  75 |     | <span class='neutral'>                value: 0</span>
  76 |     | <span class='neutral'>            })</span>
  77 |     | <span class='neutral'>        );</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>        ISafe(dSafe).executeBatch(call);</span>
  80 |     | <span class='neutral'>        // (bool success, bytes memory data) = token.call(</span>
  81 |     | <span class='neutral'>        //     abi.encodeWithSelector(IERC20.transferFrom.selector, dSafe,to, value)</span>
  82 |     | <span class='neutral'>        // );</span>
  83 |     | <span class='neutral'>        // require(</span>
  84 |     | <span class='neutral'>        //     success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))),</span>
  85 |     | <span class='neutral'>        //     &quot;UniswapV2: TRANSFER_FAILED&quot;</span>
  86 |     | <span class='neutral'>        // );</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    constructor() {</span>
  90 |     | <span class='neutral'>        factory = msg.sender;</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    // called once by the factory at time of deployment</span>
  94 |     | <span class='neutral'>    function initialize(address _dos, address _token0, address _token1) external override {</span>
  95 |     | <span class='neutral'>        require(msg.sender == factory, &quot;UniswapV2: FORBIDDEN&quot;); // sufficient check</span>
  96 |     | <span class='neutral'>        dos = _dos;</span>
  97 |     | <span class='neutral'>        dSafe = IDOS(dos).createDSafe();</span>
  98 |     | <span class='neutral'>        token0 = _token0;</span>
  99 |     | <span class='neutral'>        token1 = _token1;</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    // update reserves and, on the first call per block, price accumulators</span>
 103 |     | <span class='neutral'>    function _update(</span>
 104 |     | <span class='neutral'>        uint256 balance0,</span>
 105 |     | <span class='neutral'>        uint256 balance1,</span>
 106 |     | <span class='neutral'>        uint112 _reserve0,</span>
 107 |     | <span class='neutral'>        uint112 _reserve1</span>
 108 |     | <span class='neutral'>    ) private {</span>
 109 |     | <span class='neutral'>        require(</span>
 110 |     | <span class='neutral'>            balance0 &lt;= type(uint112).max &amp;&amp; balance1 &lt;= type(uint112).max,</span>
 111 |     | <span class='neutral'>            &quot;UniswapV2: OVERFLOW&quot;</span>
 112 |     | <span class='neutral'>        );</span>
 113 |     | <span class='neutral'>        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);</span>
 114 |     | <span class='neutral'>        unchecked {</span>
 115 |     | <span class='neutral'>            uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired</span>
 116 |     | <span class='neutral'>            if (timeElapsed &gt; 0 &amp;&amp; _reserve0 != 0 &amp;&amp; _reserve1 != 0) {</span>
 117 |     | <span class='neutral'>                // * never overflows, and + overflow is desired</span>
 118 |     | <span class='neutral'>                price0CumulativeLast +=</span>
 119 |     | <span class='neutral'>                    uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) *</span>
 120 |     | <span class='neutral'>                    timeElapsed;</span>
 121 |     | <span class='neutral'>                price1CumulativeLast +=</span>
 122 |     | <span class='neutral'>                    uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) *</span>
 123 |     | <span class='neutral'>                    timeElapsed;</span>
 124 |     | <span class='neutral'>            }</span>
 125 |     | <span class='neutral'>        }</span>
 126 |     | <span class='neutral'>        reserve0 = uint112(balance0);</span>
 127 |     | <span class='neutral'>        reserve1 = uint112(balance1);</span>
 128 |     | <span class='neutral'>        blockTimestampLast = blockTimestamp;</span>
 129 |     | <span class='neutral'>        emit Sync(reserve0, reserve1);</span>
 130 |     | <span class='neutral'>    }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)</span>
 133 |     | <span class='neutral'>    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {</span>
 134 |     | <span class='neutral'>        address feeTo = IUniswapV2Factory(factory).feeTo();</span>
 135 |     | <span class='neutral'>        feeOn = feeTo != address(0);</span>
 136 |     | <span class='neutral'>        uint256 _kLast = kLast; // gas savings</span>
 137 |     | <span class='neutral'>        if (feeOn) {</span>
 138 |     | <span class='neutral'>            if (_kLast != 0) {</span>
 139 |     | <span class='neutral'>                uint256 rootK = Math.sqrt(uint256(_reserve0) * _reserve1);</span>
 140 |     | <span class='neutral'>                uint256 rootKLast = Math.sqrt(_kLast);</span>
 141 |     | <span class='neutral'>                if (rootK &gt; rootKLast) {</span>
 142 |     | <span class='neutral'>                    uint256 numerator = totalSupply * (rootK - rootKLast);</span>
 143 |     | <span class='neutral'>                    uint256 denominator = rootK * 5 + rootKLast;</span>
 144 |     | <span class='neutral'>                    uint256 liquidity = numerator / denominator;</span>
 145 |     | <span class='neutral'>                    if (liquidity &gt; 0) _mint(feeTo, liquidity);</span>
 146 |     | <span class='neutral'>                }</span>
 147 |     | <span class='neutral'>            }</span>
 148 |     | <span class='neutral'>        } else if (_kLast != 0) {</span>
 149 |     | <span class='neutral'>            kLast = 0;</span>
 150 |     | <span class='neutral'>        }</span>
 151 |     | <span class='neutral'>    }</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>    // this low-level function should be called from a contract which performs important safety checks</span>
 154 |     | <span class='neutral'>    function mint(address to) external override lock returns (uint256 liquidity) {</span>
 155 |     | <span class='neutral'>        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings</span>
 156 |     | <span class='neutral'>        uint256 balance0 = uint256(IDOS(dos).getDAccountERC20(dSafe, IERC20(token0)));</span>
 157 |     | <span class='neutral'>        uint256 balance1 = uint256(IDOS(dos).getDAccountERC20(dSafe, IERC20(token1)));</span>
 158 |     | <span class='neutral'>        uint256 amount0 = balance0 - _reserve0;</span>
 159 |     | <span class='neutral'>        uint256 amount1 = balance1 - _reserve1;</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>        bool feeOn = _mintFee(_reserve0, _reserve1);</span>
 162 |     | <span class='neutral'>        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee</span>
 163 |     | <span class='neutral'>        if (_totalSupply == 0) {</span>
 164 |     | <span class='neutral'>            liquidity = Math.sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY;</span>
 165 |     | <span class='neutral'>            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens</span>
 166 |     | <span class='neutral'>        } else {</span>
 167 |     | <span class='neutral'>            liquidity = Math.min(</span>
 168 |     | <span class='neutral'>                (amount0 * _totalSupply) / _reserve0,</span>
 169 |     | <span class='neutral'>                (amount1 * _totalSupply) / _reserve1</span>
 170 |     | <span class='neutral'>            );</span>
 171 |     | <span class='neutral'>        }</span>
 172 |     | <span class='neutral'>        require(liquidity &gt; 0, &quot;UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED&quot;);</span>
 173 |     | <span class='neutral'>        _mint(address(this), liquidity); // mint to this address</span>
 174 |     | <span class='neutral'>        _approve(address(this), address(dos), liquidity);</span>
 175 |     | <span class='neutral'>        IDOS(dos).depositERC20ForSafe(address(this), to, liquidity); // deposit LP tokens into DOS</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='neutral'>        _update(balance0, balance1, _reserve0, _reserve1);</span>
 178 |     | <span class='neutral'>        if (feeOn) kLast = uint256(reserve0) * reserve1; // reserve0 and reserve1 are up-to-date</span>
 179 |     | <span class='neutral'>        emit Mint(msg.sender, amount0, amount1);</span>
 180 |     | <span class='neutral'>    }</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>    // this low-level function should be called from a contract which performs important safety checks</span>
 183 |     | <span class='neutral'>    function burn(address to) external override lock returns (uint256 amount0, uint256 amount1) {</span>
 184 |     | <span class='neutral'>        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings</span>
 185 |     | <span class='neutral'>        address _token0 = token0; // gas savings</span>
 186 |     | <span class='neutral'>        address _token1 = token1; // gas savings</span>
 187 |     | <span class='neutral'>        uint256 balance0 = uint256(IDOS(dos).getDAccountERC20(dSafe, IERC20(_token0)));</span>
 188 |     | <span class='neutral'>        uint256 balance1 = uint256(IDOS(dos).getDAccountERC20(dSafe, IERC20(_token1)));</span>
 189 |     | <span class='neutral'>        uint256 liquidity = balanceOf[address(this)];</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>        bool feeOn = _mintFee(_reserve0, _reserve1);</span>
 192 |     | <span class='neutral'>        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee</span>
 193 |     | <span class='neutral'>        amount0 = (liquidity * balance0) / _totalSupply; // using balances ensures pro-rata distribution</span>
 194 |     | <span class='neutral'>        amount1 = (liquidity * balance1) / _totalSupply; // using balances ensures pro-rata distribution</span>
 195 |     | <span class='neutral'>        require(amount0 &gt; 0 &amp;&amp; amount1 &gt; 0, &quot;UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED&quot;);</span>
 196 |     | <span class='neutral'>        _burn(address(this), liquidity);</span>
 197 |     | <span class='neutral'>        _safeTransfer(_token0, to, amount0);</span>
 198 |     | <span class='neutral'>        _safeTransfer(_token1, to, amount1);</span>
 199 |     | <span class='neutral'>        balance0 = uint256(IDOS(dos).getDAccountERC20(dSafe, IERC20(_token0)));</span>
 200 |     | <span class='neutral'>        balance1 = uint256(IDOS(dos).getDAccountERC20(dSafe, IERC20(_token1)));</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>        _update(balance0, balance1, _reserve0, _reserve1);</span>
 203 |     | <span class='neutral'>        if (feeOn) kLast = uint256(reserve0) * reserve1; // reserve0 and reserve1 are up-to-date</span>
 204 |     | <span class='neutral'>        emit Burn(msg.sender, amount0, amount1, to);</span>
 205 |     | <span class='neutral'>    }</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='neutral'>    // this low-level function should be called from a contract which performs important safety checks</span>
 208 |     | <span class='neutral'>    function swap(</span>
 209 |     | <span class='neutral'>        uint256 amount0Out,</span>
 210 |     | <span class='neutral'>        uint256 amount1Out,</span>
 211 |     | <span class='neutral'>        address to,</span>
 212 |     | <span class='neutral'>        bytes calldata data</span>
 213 |     | <span class='neutral'>    ) external override lock {</span>
 214 |     | <span class='neutral'>        require(amount0Out &gt; 0 || amount1Out &gt; 0, &quot;UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT&quot;);</span>
 215 |     | <span class='neutral'>        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings</span>
 216 |     | <span class='neutral'>        require(</span>
 217 |     | <span class='neutral'>            amount0Out &lt; _reserve0 &amp;&amp; amount1Out &lt; _reserve1,</span>
 218 |     | <span class='neutral'>            &quot;UniswapV2: INSUFFICIENT_LIQUIDITY&quot;</span>
 219 |     | <span class='neutral'>        );</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='neutral'>        uint256 balance0;</span>
 222 |     | <span class='neutral'>        uint256 balance1;</span>
 223 |     | <span class='neutral'>        {</span>
 224 |     | <span class='neutral'>            // scope for _token{0,1}, avoids stack too deep errors</span>
 225 |     | <span class='neutral'>            address _token0 = token0;</span>
 226 |     | <span class='neutral'>            address _token1 = token1;</span>
 227 |     | <span class='neutral'>            require(to != _token0 &amp;&amp; to != _token1, &quot;UniswapV2: INVALID_TO&quot;);</span>
 228 |     | <span class='neutral'>            if (amount0Out &gt; 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens</span>
 229 |     | <span class='neutral'>            if (amount1Out &gt; 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens</span>
 230 |     | <span class='neutral'>            if (data.length &gt; 0)</span>
 231 |     | <span class='neutral'>                IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='neutral'>            balance0 = uint256(IDOS(dos).getDAccountERC20(dSafe, IERC20(_token0)));</span>
 234 |     | <span class='neutral'>            balance1 = uint256(IDOS(dos).getDAccountERC20(dSafe, IERC20(_token1)));</span>
 235 |     | <span class='neutral'>        }</span>
 236 |     | <span class='neutral'>        uint256 amount0In = balance0 &gt; _reserve0 - amount0Out</span>
 237 |     | <span class='neutral'>            ? balance0 - (_reserve0 - amount0Out)</span>
 238 |     | <span class='neutral'>            : 0;</span>
 239 |     | <span class='neutral'>        uint256 amount1In = balance1 &gt; _reserve1 - amount1Out</span>
 240 |     | <span class='neutral'>            ? balance1 - (_reserve1 - amount1Out)</span>
 241 |     | <span class='neutral'>            : 0;</span>
 242 |     | <span class='neutral'>        require(amount0In &gt; 0 || amount1In &gt; 0, &quot;UniswapV2: INSUFFICIENT_INPUT_AMOUNT&quot;);</span>
 243 |     | <span class='neutral'>        {</span>
 244 |     | <span class='neutral'>            // scope for reserve{0,1}Adjusted, avoids stack too deep errors</span>
 245 |     | <span class='neutral'>            uint256 balance0Adjusted = balance0 * 1000 - amount0In * 3;</span>
 246 |     | <span class='neutral'>            uint256 balance1Adjusted = balance1 * 1000 - amount1In * 3;</span>
 247 |     | <span class='neutral'>            require(</span>
 248 |     | <span class='neutral'>                balance0Adjusted * balance1Adjusted &gt;= uint256(_reserve0) * _reserve1 * 1e6,</span>
 249 |     | <span class='neutral'>                &quot;UniswapV2: K&quot;</span>
 250 |     | <span class='neutral'>            );</span>
 251 |     | <span class='neutral'>        }</span>
 252 |     | <span class='neutral'></span>
 253 |     | <span class='neutral'>        _update(balance0, balance1, _reserve0, _reserve1);</span>
 254 |     | <span class='neutral'>        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);</span>
 255 |     | <span class='neutral'>    }</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='neutral'>    // force balances to match reserves</span>
 258 |     | <span class='neutral'>    function skim(address to) external override lock {</span>
 259 |     | <span class='neutral'>        address _token0 = token0; // gas savings</span>
 260 |     | <span class='neutral'>        address _token1 = token1; // gas savings</span>
 261 |     | <span class='neutral'>        _safeTransfer(</span>
 262 |     | <span class='neutral'>            _token0,</span>
 263 |     | <span class='neutral'>            to,</span>
 264 |     | <span class='neutral'>            uint256(IDOS(dos).getDAccountERC20(dSafe, IERC20(token0))) - reserve0</span>
 265 |     | <span class='neutral'>        );</span>
 266 |     | <span class='neutral'>        _safeTransfer(_token1, to, uint256(IDOS(dos).getDAccountERC20(dSafe, IERC20(token1))));</span>
 267 |     | <span class='neutral'>    }</span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='neutral'>    // force reserves to match balances</span>
 270 |     | <span class='neutral'>    function sync() external override lock {</span>
 271 |     | <span class='neutral'>        _update(</span>
 272 |     | <span class='neutral'>            uint256(IDOS(dos).getDAccountERC20(dSafe, IERC20(token0))),</span>
 273 |     | <span class='neutral'>            uint256(IDOS(dos).getDAccountERC20(dSafe, IERC20(token1))),</span>
 274 |     | <span class='neutral'>            reserve0,</span>
 275 |     | <span class='neutral'>            reserve1</span>
 276 |     | <span class='neutral'>        );</span>
 277 |     | <span class='neutral'>    }</span>
 278 |     | <span class='neutral'>}</span>
 279 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/duoswapV2/DuoswapV2Router.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.7;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>//solhint-disable not-rely-on-time</span>
   5 |     | <span class='neutral'>//solhint-disable var-name-mixedcase</span>
   6 |     | <span class='neutral'>//solhint-disable func-name-mixedcase</span>
   7 |     | <span class='neutral'>//solhint-disable func-param-name-mixedcase</span>
   8 |     | <span class='neutral'>//solhint-disable reason-string</span>
   9 |     | <span class='neutral'>//solhint-disable ordering</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>import &quot;@uniswap/lib/contracts/libraries/TransferHelper.sol&quot;;</span>
  12 |     | <span class='neutral'>import &quot;@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol&quot;;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>import &quot;./interfaces/IDuoswapV2Router.sol&quot;;</span>
  17 |     | <span class='neutral'>import &quot;./libraries/DuoswapV2Library.sol&quot;;</span>
  18 |     | <span class='neutral'>import &quot;../external/interfaces/IWETH9.sol&quot;;</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>import {IDuoswapV2Pair} from &quot;./interfaces/IDuoswapV2Pair.sol&quot;;</span>
  21 |     | <span class='neutral'>import {IDOS} from &quot;../interfaces/IDOS.sol&quot;;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>contract DuoswapV2Router is IDuoswapV2Router {</span>
  24 |     | <span class='neutral'>    address public immutable override factory;</span>
  25 |     | <span class='neutral'>    address public immutable override WETH;</span>
  26 |     | <span class='neutral'>    address public immutable dos;</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    modifier ensure(uint256 deadline) {</span>
  29 |     | <span class='neutral'>        require(deadline &gt;= block.timestamp, &quot;UniswapV2Router: EXPIRED&quot;);</span>
  30 |     | <span class='neutral'>        _;</span>
  31 |     | <span class='neutral'>    }</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    constructor(address _factory, address _WETH, address _dos) {</span>
  34 |     | <span class='neutral'>        factory = _factory;</span>
  35 |     | <span class='neutral'>        WETH = _WETH;</span>
  36 |     | <span class='neutral'>        dos = _dos;</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    receive() external payable {</span>
  40 |     | <span class='neutral'>        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    // **** ADD LIQUIDITY ****</span>
  44 |     | <span class='neutral'>    function _addLiquidity(</span>
  45 |     | <span class='neutral'>        address tokenA,</span>
  46 |     | <span class='neutral'>        address tokenB,</span>
  47 |     | <span class='neutral'>        uint256 amountADesired,</span>
  48 |     | <span class='neutral'>        uint256 amountBDesired,</span>
  49 |     | <span class='neutral'>        uint256 amountAMin,</span>
  50 |     | <span class='neutral'>        uint256 amountBMin</span>
  51 |     | <span class='neutral'>    ) internal virtual returns (uint256 amountA, uint256 amountB) {</span>
  52 |     | <span class='neutral'>        // create the pair if it doesn&#39;t exist yet</span>
  53 |     | <span class='neutral'>        if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {</span>
  54 |     | <span class='neutral'>            IUniswapV2Factory(factory).createPair(tokenA, tokenB);</span>
  55 |     | <span class='neutral'>        }</span>
  56 |     | <span class='neutral'>        (uint256 reserveA, uint256 reserveB) = DuoswapV2Library.getReserves(</span>
  57 |     | <span class='neutral'>            factory,</span>
  58 |     | <span class='neutral'>            tokenA,</span>
  59 |     | <span class='neutral'>            tokenB</span>
  60 |     | <span class='neutral'>        );</span>
  61 |     | <span class='neutral'>        if (reserveA == 0 &amp;&amp; reserveB == 0) {</span>
  62 |     | <span class='neutral'>            (amountA, amountB) = (amountADesired, amountBDesired);</span>
  63 |     | <span class='neutral'>        } else {</span>
  64 |     | <span class='neutral'>            uint256 amountBOptimal = DuoswapV2Library.quote(amountADesired, reserveA, reserveB);</span>
  65 |     | <span class='neutral'>            if (amountBOptimal &lt;= amountBDesired) {</span>
  66 |     | <span class='neutral'>                require(amountBOptimal &gt;= amountBMin, &quot;UniswapV2Router: INSUFFICIENT_B_AMOUNT&quot;);</span>
  67 |     | <span class='neutral'>                (amountA, amountB) = (amountADesired, amountBOptimal);</span>
  68 |     | <span class='neutral'>            } else {</span>
  69 |     | <span class='neutral'>                uint256 amountAOptimal = DuoswapV2Library.quote(amountBDesired, reserveB, reserveA);</span>
  70 |     | <span class='neutral'>                assert(amountAOptimal &lt;= amountADesired);</span>
  71 |     | <span class='neutral'>                require(amountAOptimal &gt;= amountAMin, &quot;UniswapV2Router: INSUFFICIENT_A_AMOUNT&quot;);</span>
  72 |     | <span class='neutral'>                (amountA, amountB) = (amountAOptimal, amountBDesired);</span>
  73 |     | <span class='neutral'>            }</span>
  74 |     | <span class='neutral'>        }</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    function addLiquidity(</span>
  78 |     | <span class='neutral'>        address tokenA,</span>
  79 |     | <span class='neutral'>        address tokenB,</span>
  80 |     | <span class='neutral'>        uint256 amountADesired,</span>
  81 |     | <span class='neutral'>        uint256 amountBDesired,</span>
  82 |     | <span class='neutral'>        uint256 amountAMin,</span>
  83 |     | <span class='neutral'>        uint256 amountBMin,</span>
  84 |     | <span class='neutral'>        address to,</span>
  85 |     | <span class='neutral'>        uint256 deadline</span>
  86 |     | <span class='neutral'>    )</span>
  87 |     | <span class='neutral'>        external</span>
  88 |     | <span class='neutral'>        virtual</span>
  89 |     | <span class='neutral'>        override</span>
  90 |     | <span class='neutral'>        ensure(deadline)</span>
  91 |     | <span class='neutral'>        returns (uint256 amountA, uint256 amountB, uint256 liquidity)</span>
  92 |     | <span class='neutral'>    {</span>
  93 |     | <span class='neutral'>        // require(msg.sender == address(dos));</span>
  94 |     | <span class='neutral'>        (amountA, amountB) = _addLiquidity(</span>
  95 |     | <span class='neutral'>            tokenA,</span>
  96 |     | <span class='neutral'>            tokenB,</span>
  97 |     | <span class='neutral'>            amountADesired,</span>
  98 |     | <span class='neutral'>            amountBDesired,</span>
  99 |     | <span class='neutral'>            amountAMin,</span>
 100 |     | <span class='neutral'>            amountBMin</span>
 101 |     | <span class='neutral'>        );</span>
 102 |     | <span class='neutral'>        address pair = DuoswapV2Library.pairFor(factory, tokenA, tokenB);</span>
 103 |     | <span class='neutral'>        address pairSafe = IDuoswapV2Pair(pair).dSafe();</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>        IDOS(dos).transferFromERC20(tokenA, msg.sender, pairSafe, amountA);</span>
 106 |     | <span class='neutral'>        IDOS(dos).transferFromERC20(tokenB, msg.sender, pairSafe, amountB);</span>
 107 |     | <span class='neutral'>        liquidity = IDuoswapV2Pair(pair).mint(to);</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>    // **** REMOVE LIQUIDITY ****</span>
 111 |     | <span class='neutral'>    function removeLiquidity(</span>
 112 |     | <span class='neutral'>        address tokenA,</span>
 113 |     | <span class='neutral'>        address tokenB,</span>
 114 |     | <span class='neutral'>        uint256 liquidity,</span>
 115 |     | <span class='neutral'>        uint256 amountAMin,</span>
 116 |     | <span class='neutral'>        uint256 amountBMin,</span>
 117 |     | <span class='neutral'>        address to,</span>
 118 |     | <span class='neutral'>        uint256 deadline</span>
 119 |     | <span class='neutral'>    ) public virtual override ensure(deadline) returns (uint256 amountA, uint256 amountB) {</span>
 120 |     | <span class='neutral'>        address pair = DuoswapV2Library.pairFor(factory, tokenA, tokenB);</span>
 121 |     | <span class='neutral'>        IDuoswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair</span>
 122 |     | <span class='neutral'>        (uint256 amount0, uint256 amount1) = IDuoswapV2Pair(pair).burn(to);</span>
 123 |     | <span class='neutral'>        (address token0, ) = DuoswapV2Library.sortTokens(tokenA, tokenB);</span>
 124 |     | <span class='neutral'>        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);</span>
 125 |     | <span class='neutral'>        require(amountA &gt;= amountAMin, &quot;UniswapV2Router: INSUFFICIENT_A_AMOUNT&quot;);</span>
 126 |     | <span class='neutral'>        require(amountB &gt;= amountBMin, &quot;UniswapV2Router: INSUFFICIENT_B_AMOUNT&quot;);</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    function removeLiquidityWithPermit(</span>
 130 |     | <span class='neutral'>        address tokenA,</span>
 131 |     | <span class='neutral'>        address tokenB,</span>
 132 |     | <span class='neutral'>        uint256 liquidity,</span>
 133 |     | <span class='neutral'>        uint256 amountAMin,</span>
 134 |     | <span class='neutral'>        uint256 amountBMin,</span>
 135 |     | <span class='neutral'>        address to,</span>
 136 |     | <span class='neutral'>        uint256 deadline,</span>
 137 |     | <span class='neutral'>        bool approveMax,</span>
 138 |     | <span class='neutral'>        uint8 v,</span>
 139 |     | <span class='neutral'>        bytes32 r,</span>
 140 |     | <span class='neutral'>        bytes32 s</span>
 141 |     | <span class='neutral'>    ) external virtual override returns (uint256 amountA, uint256 amountB) {</span>
 142 |     | <span class='neutral'>        address pair = DuoswapV2Library.pairFor(factory, tokenA, tokenB);</span>
 143 |     | <span class='neutral'>        uint256 value = approveMax ? type(uint256).max : liquidity;</span>
 144 |     | <span class='neutral'>        IDuoswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);</span>
 145 |     | <span class='neutral'>        (amountA, amountB) = removeLiquidity(</span>
 146 |     | <span class='neutral'>            tokenA,</span>
 147 |     | <span class='neutral'>            tokenB,</span>
 148 |     | <span class='neutral'>            liquidity,</span>
 149 |     | <span class='neutral'>            amountAMin,</span>
 150 |     | <span class='neutral'>            amountBMin,</span>
 151 |     | <span class='neutral'>            to,</span>
 152 |     | <span class='neutral'>            deadline</span>
 153 |     | <span class='neutral'>        );</span>
 154 |     | <span class='neutral'>    }</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='neutral'>    // **** SWAP ****</span>
 157 |     | <span class='neutral'>    // requires the initial amount to have already been sent to the first pair</span>
 158 |     | <span class='neutral'>    function _swap(uint256[] memory amounts, address[] memory path, address _to) internal virtual {</span>
 159 |     | <span class='neutral'>        for (uint256 i; i &lt; path.length - 1; i++) {</span>
 160 |     | <span class='neutral'>            (address input, address output) = (path[i], path[i + 1]);</span>
 161 |     | <span class='neutral'>            (address token0, ) = DuoswapV2Library.sortTokens(input, output);</span>
 162 |     | <span class='neutral'>            uint256 amountOut = amounts[i + 1];</span>
 163 |     | <span class='neutral'>            (uint256 amount0Out, uint256 amount1Out) = input == token0</span>
 164 |     | <span class='neutral'>                ? (uint256(0), amountOut)</span>
 165 |     | <span class='neutral'>                : (amountOut, uint256(0));</span>
 166 |     | <span class='neutral'>            address to = i &lt; path.length - 2</span>
 167 |     | <span class='neutral'>                ? DuoswapV2Library.pairFor(factory, output, path[i + 2])</span>
 168 |     | <span class='neutral'>                : _to;</span>
 169 |     | <span class='neutral'>            IDuoswapV2Pair(DuoswapV2Library.pairFor(factory, input, output)).swap(</span>
 170 |     | <span class='neutral'>                amount0Out,</span>
 171 |     | <span class='neutral'>                amount1Out,</span>
 172 |     | <span class='neutral'>                to,</span>
 173 |     | <span class='neutral'>                new bytes(0)</span>
 174 |     | <span class='neutral'>            );</span>
 175 |     | <span class='neutral'>        }</span>
 176 |     | <span class='neutral'>    }</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='neutral'>    function swapExactTokensForTokens(</span>
 179 |     | <span class='neutral'>        uint256 amountIn,</span>
 180 |     | <span class='neutral'>        uint256 amountOutMin,</span>
 181 |     | <span class='neutral'>        address[] calldata path,</span>
 182 |     | <span class='neutral'>        address to,</span>
 183 |     | <span class='neutral'>        uint256 deadline</span>
 184 |     | <span class='neutral'>    ) external virtual override ensure(deadline) returns (uint256[] memory amounts) {</span>
 185 |     | <span class='neutral'>        amounts = DuoswapV2Library.getAmountsOut(factory, amountIn, path);</span>
 186 |     | <span class='neutral'>        require(</span>
 187 |     | <span class='neutral'>            amounts[amounts.length - 1] &gt;= amountOutMin,</span>
 188 |     | <span class='neutral'>            &quot;UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT&quot;</span>
 189 |     | <span class='neutral'>        );</span>
 190 |     | <span class='neutral'>        IDOS(dos).transferFromERC20(</span>
 191 |     | <span class='neutral'>            path[0],</span>
 192 |     | <span class='neutral'>            to, // changed to userSafe</span>
 193 |     | <span class='neutral'>            IDuoswapV2Pair(DuoswapV2Library.pairFor(factory, path[0], path[1])).dSafe(), // changed to pairSafe</span>
 194 |     | <span class='neutral'>            amounts[0]</span>
 195 |     | <span class='neutral'>        );</span>
 196 |     | <span class='neutral'>        _swap(amounts, path, to);</span>
 197 |     | <span class='neutral'>    }</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='neutral'>    function swapTokensForExactTokens(</span>
 200 |     | <span class='neutral'>        uint256 amountOut,</span>
 201 |     | <span class='neutral'>        uint256 amountInMax,</span>
 202 |     | <span class='neutral'>        address[] calldata path,</span>
 203 |     | <span class='neutral'>        address to,</span>
 204 |     | <span class='neutral'>        uint256 deadline</span>
 205 |     | <span class='neutral'>    ) external virtual override ensure(deadline) returns (uint256[] memory amounts) {</span>
 206 |     | <span class='neutral'>        amounts = DuoswapV2Library.getAmountsIn(factory, amountOut, path);</span>
 207 |     | <span class='neutral'>        require(amounts[0] &lt;= amountInMax, &quot;UniswapV2Router: EXCESSIVE_INPUT_AMOUNT&quot;);</span>
 208 |     | <span class='neutral'>        IDOS(dos).transferFromERC20(</span>
 209 |     | <span class='neutral'>            path[0],</span>
 210 |     | <span class='neutral'>            to, // changed to userSafe</span>
 211 |     | <span class='neutral'>            IDuoswapV2Pair(DuoswapV2Library.pairFor(factory, path[0], path[1])).dSafe(), // changed to pairSafe</span>
 212 |     | <span class='neutral'>            amounts[0]</span>
 213 |     | <span class='neutral'>        );</span>
 214 |     | <span class='neutral'>        _swap(amounts, path, to);</span>
 215 |     | <span class='neutral'>    }</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='neutral'>    // **** SWAP (supporting fee-on-transfer tokens) ****</span>
 218 |     | <span class='neutral'>    // requires the initial amount to have already been sent to the first pair</span>
 219 |     | <span class='neutral'>    function _swapSupportingFeeOnTransferTokens(</span>
 220 |     | <span class='neutral'>        address[] memory path,</span>
 221 |     | <span class='neutral'>        address _to</span>
 222 |     | <span class='neutral'>    ) internal virtual {</span>
 223 |     | <span class='neutral'>        for (uint256 i; i &lt; path.length - 1; i++) {</span>
 224 |     | <span class='neutral'>            (address input, address output) = (path[i], path[i + 1]);</span>
 225 |     | <span class='neutral'>            (address token0, ) = DuoswapV2Library.sortTokens(input, output);</span>
 226 |     | <span class='neutral'>            IDuoswapV2Pair pair = IDuoswapV2Pair(DuoswapV2Library.pairFor(factory, input, output));</span>
 227 |     | <span class='neutral'>            uint256 amountInput;</span>
 228 |     | <span class='neutral'>            uint256 amountOutput;</span>
 229 |     | <span class='neutral'>            {</span>
 230 |     | <span class='neutral'>                // scope to avoid stack too deep errors</span>
 231 |     | <span class='neutral'>                (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();</span>
 232 |     | <span class='neutral'>                (uint256 reserveInput, uint256 reserveOutput) = input == token0</span>
 233 |     | <span class='neutral'>                    ? (reserve0, reserve1)</span>
 234 |     | <span class='neutral'>                    : (reserve1, reserve0);</span>
 235 |     | <span class='neutral'>                amountInput = IERC20(input).balanceOf(address(pair)) - reserveInput;</span>
 236 |     | <span class='neutral'>                amountOutput = DuoswapV2Library.getAmountOut(</span>
 237 |     | <span class='neutral'>                    amountInput,</span>
 238 |     | <span class='neutral'>                    reserveInput,</span>
 239 |     | <span class='neutral'>                    reserveOutput</span>
 240 |     | <span class='neutral'>                );</span>
 241 |     | <span class='neutral'>            }</span>
 242 |     | <span class='neutral'>            (uint256 amount0Out, uint256 amount1Out) = input == token0</span>
 243 |     | <span class='neutral'>                ? (uint256(0), amountOutput)</span>
 244 |     | <span class='neutral'>                : (amountOutput, uint256(0));</span>
 245 |     | <span class='neutral'>            address to = i &lt; path.length - 2</span>
 246 |     | <span class='neutral'>                ? DuoswapV2Library.pairFor(factory, output, path[i + 2])</span>
 247 |     | <span class='neutral'>                : _to;</span>
 248 |     | <span class='neutral'>            pair.swap(amount0Out, amount1Out, to, new bytes(0));</span>
 249 |     | <span class='neutral'>        }</span>
 250 |     | <span class='neutral'>    }</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='neutral'>    function swapExactTokensForTokensSupportingFeeOnTransferTokens(</span>
 253 |     | <span class='neutral'>        uint256 amountIn,</span>
 254 |     | <span class='neutral'>        uint256 amountOutMin,</span>
 255 |     | <span class='neutral'>        address[] calldata path,</span>
 256 |     | <span class='neutral'>        address to,</span>
 257 |     | <span class='neutral'>        uint256 deadline</span>
 258 |     | <span class='neutral'>    ) external virtual override ensure(deadline) {</span>
 259 |     | <span class='neutral'>        TransferHelper.safeTransferFrom(</span>
 260 |     | <span class='neutral'>            path[0],</span>
 261 |     | <span class='neutral'>            msg.sender,</span>
 262 |     | <span class='neutral'>            DuoswapV2Library.pairFor(factory, path[0], path[1]),</span>
 263 |     | <span class='neutral'>            amountIn</span>
 264 |     | <span class='neutral'>        );</span>
 265 |     | <span class='neutral'>        uint256 balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);</span>
 266 |     | <span class='neutral'>        _swapSupportingFeeOnTransferTokens(path, to);</span>
 267 |     | <span class='neutral'>        require(</span>
 268 |     | <span class='neutral'>            IERC20(path[path.length - 1]).balanceOf(to) - balanceBefore &gt;= amountOutMin,</span>
 269 |     | <span class='neutral'>            &quot;UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT&quot;</span>
 270 |     | <span class='neutral'>        );</span>
 271 |     | <span class='neutral'>    }</span>
 272 |     | <span class='neutral'></span>
 273 |     | <span class='neutral'>    // **** LIBRARY FUNCTIONS ****</span>
 274 |     | <span class='neutral'>    function quote(</span>
 275 |     | <span class='neutral'>        uint256 amountA,</span>
 276 |     | <span class='neutral'>        uint256 reserveA,</span>
 277 |     | <span class='neutral'>        uint256 reserveB</span>
 278 |     | <span class='neutral'>    ) public pure virtual override returns (uint256 amountB) {</span>
 279 |     | <span class='neutral'>        return DuoswapV2Library.quote(amountA, reserveA, reserveB);</span>
 280 |     | <span class='neutral'>    }</span>
 281 |     | <span class='neutral'></span>
 282 |     | <span class='neutral'>    function getAmountOut(</span>
 283 |     | <span class='neutral'>        uint256 amountIn,</span>
 284 |     | <span class='neutral'>        uint256 reserveIn,</span>
 285 |     | <span class='neutral'>        uint256 reserveOut</span>
 286 |     | <span class='neutral'>    ) public pure virtual override returns (uint256 amountOut) {</span>
 287 |     | <span class='neutral'>        return DuoswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);</span>
 288 |     | <span class='neutral'>    }</span>
 289 |     | <span class='neutral'></span>
 290 |     | <span class='neutral'>    function getAmountIn(</span>
 291 |     | <span class='neutral'>        uint256 amountOut,</span>
 292 |     | <span class='neutral'>        uint256 reserveIn,</span>
 293 |     | <span class='neutral'>        uint256 reserveOut</span>
 294 |     | <span class='neutral'>    ) public pure virtual override returns (uint256 amountIn) {</span>
 295 |     | <span class='neutral'>        return DuoswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);</span>
 296 |     | <span class='neutral'>    }</span>
 297 |     | <span class='neutral'></span>
 298 |     | <span class='neutral'>    function getAmountsOut(</span>
 299 |     | <span class='neutral'>        uint256 amountIn,</span>
 300 |     | <span class='neutral'>        address[] memory path</span>
 301 |     | <span class='neutral'>    ) public view virtual override returns (uint256[] memory amounts) {</span>
 302 |     | <span class='neutral'>        return DuoswapV2Library.getAmountsOut(factory, amountIn, path);</span>
 303 |     | <span class='neutral'>    }</span>
 304 |     | <span class='neutral'></span>
 305 |     | <span class='neutral'>    function getAmountsIn(</span>
 306 |     | <span class='neutral'>        uint256 amountOut,</span>
 307 |     | <span class='neutral'>        address[] memory path</span>
 308 |     | <span class='neutral'>    ) public view virtual override returns (uint256[] memory amounts) {</span>
 309 |     | <span class='neutral'>        return DuoswapV2Library.getAmountsIn(factory, amountOut, path);</span>
 310 |     | <span class='neutral'>    }</span>
 311 |     | <span class='neutral'>}</span>
 312 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/duoswapV2/interfaces/IDuoswapV2Pair.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>//solhint-disable-next-line compiler-version</span>
  4 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>//solhint-disable func-name-mixedcase</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>import &quot;@uniswap/v2-core/contracts/interfaces/IUniswapV2ERC20.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>interface IDuoswapV2Pair is IUniswapV2ERC20 {</span>
 11 |     | <span class='neutral'>    event Mint(address indexed sender, uint256 amount0, uint256 amount1);</span>
 12 |     | <span class='neutral'>    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);</span>
 13 |     | <span class='unexecuted'>    event Swap(</span>
 14 |     | <span class='neutral'>        address indexed sender,</span>
 15 |     | <span class='neutral'>        uint256 amount0In,</span>
 16 |     | <span class='neutral'>        uint256 amount1In,</span>
 17 |     | <span class='neutral'>        uint256 amount0Out,</span>
 18 |     | <span class='neutral'>        uint256 amount1Out,</span>
 19 |     | <span class='neutral'>        address indexed to</span>
 20 |     | <span class='neutral'>    );</span>
 21 |     | <span class='neutral'>    event Sync(uint112 reserve0, uint112 reserve1);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    function MINIMUM_LIQUIDITY() external pure returns (uint256);</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    function factory() external view returns (address);</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    function token0() external view returns (address);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    function token1() external view returns (address);</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function dSafe() external view returns (address);</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    function getReserves()</span>
 34 |     | <span class='neutral'>        external</span>
 35 |     | <span class='neutral'>        view</span>
 36 |     | <span class='neutral'>        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='neutral'>    function price0CumulativeLast() external view returns (uint256);</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    function price1CumulativeLast() external view returns (uint256);</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    function kLast() external view returns (uint256);</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    function mint(address to) external returns (uint256 liquidity);</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    function burn(address to) external returns (uint256 amount0, uint256 amount1);</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    function skim(address to) external;</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    function sync() external;</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    function initialize(address, address, address) external;</span>
 55 |     | <span class='neutral'>}</span>
 56 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/duoswapV2/interfaces/IDuoswapV2Router.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.7;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;./IDuoswapV2Router01.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>interface IDuoswapV2Router is IDuoswapV2Router01 {</span>
  8 |     | <span class='neutral'>    event TokensApproved(address sender, uint256 amount, bytes data);</span>
  9 |     | <span class='neutral'>    event TokensReceived(address spender, address sender, uint256 amount, bytes data);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function swapExactTokensForTokensSupportingFeeOnTransferTokens(</span>
 12 |     | <span class='neutral'>        uint256 amountIn,</span>
 13 |     | <span class='neutral'>        uint256 amountOutMin,</span>
 14 |     | <span class='neutral'>        address[] calldata path,</span>
 15 |     | <span class='neutral'>        address to,</span>
 16 |     | <span class='neutral'>        uint256 deadline</span>
 17 |     | <span class='neutral'>    ) external;</span>
 18 |     | <span class='neutral'>}</span>
 19 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/duoswapV2/interfaces/IDuoswapV2Router01.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.7;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>//solhint-disable func-name-mixedcase</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IDuoswapV2Router01 {</span>
  7 |     | <span class='neutral'>    function factory() external view returns (address);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>    function WETH() external view returns (address);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function addLiquidity(</span>
 12 |     | <span class='neutral'>        address tokenA,</span>
 13 |     | <span class='neutral'>        address tokenB,</span>
 14 |     | <span class='neutral'>        uint256 amountADesired,</span>
 15 |     | <span class='neutral'>        uint256 amountBDesired,</span>
 16 |     | <span class='neutral'>        uint256 amountAMin,</span>
 17 |     | <span class='neutral'>        uint256 amountBMin,</span>
 18 |     | <span class='neutral'>        address to,</span>
 19 |     | <span class='neutral'>        uint256 deadline</span>
 20 |     | <span class='neutral'>    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    function removeLiquidity(</span>
 23 |     | <span class='neutral'>        address tokenA,</span>
 24 |     | <span class='neutral'>        address tokenB,</span>
 25 |     | <span class='neutral'>        uint256 liquidity,</span>
 26 |     | <span class='neutral'>        uint256 amountAMin,</span>
 27 |     | <span class='neutral'>        uint256 amountBMin,</span>
 28 |     | <span class='neutral'>        address to,</span>
 29 |     | <span class='neutral'>        uint256 deadline</span>
 30 |     | <span class='neutral'>    ) external returns (uint256 amountA, uint256 amountB);</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    function removeLiquidityWithPermit(</span>
 33 |     | <span class='neutral'>        address tokenA,</span>
 34 |     | <span class='neutral'>        address tokenB,</span>
 35 |     | <span class='neutral'>        uint256 liquidity,</span>
 36 |     | <span class='neutral'>        uint256 amountAMin,</span>
 37 |     | <span class='neutral'>        uint256 amountBMin,</span>
 38 |     | <span class='neutral'>        address to,</span>
 39 |     | <span class='neutral'>        uint256 deadline,</span>
 40 |     | <span class='neutral'>        bool approveMax,</span>
 41 |     | <span class='neutral'>        uint8 v,</span>
 42 |     | <span class='neutral'>        bytes32 r,</span>
 43 |     | <span class='neutral'>        bytes32 s</span>
 44 |     | <span class='neutral'>    ) external returns (uint256 amountA, uint256 amountB);</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    function swapExactTokensForTokens(</span>
 47 |     | <span class='neutral'>        uint256 amountIn,</span>
 48 |     | <span class='neutral'>        uint256 amountOutMin,</span>
 49 |     | <span class='neutral'>        address[] calldata path,</span>
 50 |     | <span class='neutral'>        address to,</span>
 51 |     | <span class='neutral'>        uint256 deadline</span>
 52 |     | <span class='neutral'>    ) external returns (uint256[] memory amounts);</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    function swapTokensForExactTokens(</span>
 55 |     | <span class='neutral'>        uint256 amountOut,</span>
 56 |     | <span class='neutral'>        uint256 amountInMax,</span>
 57 |     | <span class='neutral'>        address[] calldata path,</span>
 58 |     | <span class='neutral'>        address to,</span>
 59 |     | <span class='neutral'>        uint256 deadline</span>
 60 |     | <span class='neutral'>    ) external returns (uint256[] memory amounts);</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='neutral'>    function quote(</span>
 63 |     | <span class='neutral'>        uint256 amountA,</span>
 64 |     | <span class='neutral'>        uint256 reserveA,</span>
 65 |     | <span class='neutral'>        uint256 reserveB</span>
 66 |     | <span class='neutral'>    ) external pure returns (uint256 amountB);</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='neutral'>    function getAmountOut(</span>
 69 |     | <span class='neutral'>        uint256 amountIn,</span>
 70 |     | <span class='neutral'>        uint256 reserveIn,</span>
 71 |     | <span class='neutral'>        uint256 reserveOut</span>
 72 |     | <span class='neutral'>    ) external pure returns (uint256 amountOut);</span>
 73 |     | <span class='neutral'></span>
 74 |     | <span class='neutral'>    function getAmountIn(</span>
 75 |     | <span class='neutral'>        uint256 amountOut,</span>
 76 |     | <span class='neutral'>        uint256 reserveIn,</span>
 77 |     | <span class='neutral'>        uint256 reserveOut</span>
 78 |     | <span class='neutral'>    ) external pure returns (uint256 amountIn);</span>
 79 |     | <span class='neutral'></span>
 80 |     | <span class='neutral'>    function getAmountsOut(</span>
 81 |     | <span class='neutral'>        uint256 amountIn,</span>
 82 |     | <span class='neutral'>        address[] calldata path</span>
 83 |     | <span class='neutral'>    ) external view returns (uint256[] memory amounts);</span>
 84 |     | <span class='neutral'></span>
 85 |     | <span class='neutral'>    function getAmountsIn(</span>
 86 |     | <span class='neutral'>        uint256 amountOut,</span>
 87 |     | <span class='neutral'>        address[] calldata path</span>
 88 |     | <span class='neutral'>    ) external view returns (uint256[] memory amounts);</span>
 89 |     | <span class='neutral'>}</span>
 90 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/duoswapV2/libraries/DuoswapV2Library.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.4;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>//solhint-disable reason-string</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='unexecuted'>import {IDuoswapV2Pair} from &quot;../interfaces/IDuoswapV2Pair.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>library DuoswapV2Library {</span>
   9 |     | <span class='unexecuted'>    // returns sorted token addresses, used to handle return values from pairs sorted in this order</span>
  10 |     | <span class='unexecuted'>    function sortTokens(</span>
  11 |     | <span class='neutral'>        address tokenA,</span>
  12 |     | <span class='unexecuted'>        address tokenB</span>
  13 |     | <span class='unexecuted'>    ) internal pure returns (address token0, address token1) {</span>
  14 |     | <span class='unexecuted'>        require(tokenA != tokenB, &quot;UniswapV2Library: IDENTICAL_ADDRESSES&quot;);</span>
  15 |     | <span class='unexecuted'>        (token0, token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);</span>
  16 |     | <span class='unexecuted'>        require(token0 != address(0), &quot;UniswapV2Library: ZERO_ADDRESS&quot;);</span>
  17 |     | <span class='neutral'>    }</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='unexecuted'>    // calculates the CREATE2 address for a pair without making any external calls</span>
  20 |     | <span class='neutral'>    function pairFor(</span>
  21 |     | <span class='unexecuted'>        address factory,</span>
  22 |     | <span class='unexecuted'>        address tokenA,</span>
  23 |     | <span class='neutral'>        address tokenB</span>
  24 |     | <span class='unexecuted'>    ) internal pure returns (address pair) {</span>
  25 |     | <span class='unexecuted'>        (address token0, address token1) = sortTokens(tokenA, tokenB);</span>
  26 |     | <span class='neutral'>        pair = address(</span>
  27 |     | <span class='unexecuted'>            uint160(</span>
  28 |     | <span class='neutral'>                uint256(</span>
  29 |     | <span class='neutral'>                    keccak256(</span>
  30 |     | <span class='neutral'>                        abi.encodePacked(</span>
  31 |     | <span class='neutral'>                            bytes1(0xff),</span>
  32 |     | <span class='neutral'>                            factory,</span>
  33 |     | <span class='neutral'>                            keccak256(abi.encodePacked(token0, token1)),</span>
  34 |     | <span class='neutral'>                            hex&quot;6606d7ddc46633fe75181c4673be2eb17f1a8360674e23ec54231cec1e5077c6&quot; // NOTE: need to replace with actual init code hash every time the pair code is updated</span>
  35 |     | <span class='neutral'>                        )</span>
  36 |     | <span class='neutral'>                    )</span>
  37 |     | <span class='neutral'>                )</span>
  38 |     | <span class='neutral'>            )</span>
  39 |     | <span class='neutral'>        );</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    // fetches and sorts the reserves for a pair</span>
  43 |     | <span class='neutral'>    function getReserves(</span>
  44 |     | <span class='neutral'>        address factory,</span>
  45 |     | <span class='neutral'>        address tokenA,</span>
  46 |     | <span class='neutral'>        address tokenB</span>
  47 |     | <span class='neutral'>    ) internal view returns (uint256 reserveA, uint256 reserveB) {</span>
  48 |     | <span class='neutral'>        (address token0, ) = sortTokens(tokenA, tokenB);</span>
  49 |     | <span class='neutral'>        (uint256 reserve0, uint256 reserve1, ) = IDuoswapV2Pair(pairFor(factory, tokenA, tokenB))</span>
  50 |     | <span class='neutral'>            .getReserves();</span>
  51 |     | <span class='neutral'>        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset</span>
  55 |     | <span class='neutral'>    function quote(</span>
  56 |     | <span class='neutral'>        uint256 amountA,</span>
  57 |     | <span class='neutral'>        uint256 reserveA,</span>
  58 |     | <span class='neutral'>        uint256 reserveB</span>
  59 |     | <span class='neutral'>    ) internal pure returns (uint256 amountB) {</span>
  60 |     | <span class='neutral'>        require(amountA &gt; 0, &quot;UniswapV2Library: INSUFFICIENT_AMOUNT&quot;);</span>
  61 |     | <span class='neutral'>        require(reserveA &gt; 0 &amp;&amp; reserveB &gt; 0, &quot;UniswapV2Library: INSUFFICIENT_LIQUIDITY&quot;);</span>
  62 |     | <span class='neutral'>        amountB = (amountA * reserveB) / reserveA;</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset</span>
  66 |     | <span class='neutral'>    function getAmountOut(</span>
  67 |     | <span class='neutral'>        uint256 amountIn,</span>
  68 |     | <span class='neutral'>        uint256 reserveIn,</span>
  69 |     | <span class='neutral'>        uint256 reserveOut</span>
  70 |     | <span class='neutral'>    ) internal pure returns (uint256 amountOut) {</span>
  71 |     | <span class='neutral'>        require(amountIn &gt; 0, &quot;UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT&quot;);</span>
  72 |     | <span class='neutral'>        require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &quot;UniswapV2Library: INSUFFICIENT_LIQUIDITY&quot;);</span>
  73 |     | <span class='neutral'>        uint256 amountInWithFee = amountIn * 997;</span>
  74 |     | <span class='neutral'>        uint256 numerator = amountInWithFee * reserveOut;</span>
  75 |     | <span class='neutral'>        uint256 denominator = reserveIn * 1000 + amountInWithFee;</span>
  76 |     | <span class='neutral'>        amountOut = numerator / denominator;</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset</span>
  80 |     | <span class='neutral'>    function getAmountIn(</span>
  81 |     | <span class='neutral'>        uint256 amountOut,</span>
  82 |     | <span class='neutral'>        uint256 reserveIn,</span>
  83 |     | <span class='neutral'>        uint256 reserveOut</span>
  84 |     | <span class='neutral'>    ) internal pure returns (uint256 amountIn) {</span>
  85 |     | <span class='neutral'>        require(amountOut &gt; 0, &quot;UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT&quot;);</span>
  86 |     | <span class='neutral'>        require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &quot;UniswapV2Library: INSUFFICIENT_LIQUIDITY&quot;);</span>
  87 |     | <span class='neutral'>        uint256 numerator = reserveIn * amountOut * 1000;</span>
  88 |     | <span class='neutral'>        uint256 denominator = (reserveOut - amountOut) * 997;</span>
  89 |     | <span class='neutral'>        amountIn = numerator / denominator + 1;</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    // performs chained getAmountOut calculations on any number of pairs</span>
  93 |     | <span class='neutral'>    function getAmountsOut(</span>
  94 |     | <span class='neutral'>        address factory,</span>
  95 |     | <span class='neutral'>        uint256 amountIn,</span>
  96 |     | <span class='neutral'>        address[] memory path</span>
  97 |     | <span class='neutral'>    ) internal view returns (uint256[] memory amounts) {</span>
  98 |     | <span class='neutral'>        require(path.length &gt;= 2, &quot;UniswapV2Library: INVALID_PATH&quot;);</span>
  99 |     | <span class='neutral'>        amounts = new uint256[](path.length);</span>
 100 |     | <span class='neutral'>        amounts[0] = amountIn;</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>        for (uint256 i; i &lt; path.length - 1; i++) {</span>
 103 |     | <span class='neutral'>            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i], path[i + 1]);</span>
 104 |     | <span class='neutral'>            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);</span>
 105 |     | <span class='neutral'>        }</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    // performs chained getAmountIn calculations on any number of pairs</span>
 109 |     | <span class='neutral'>    function getAmountsIn(</span>
 110 |     | <span class='neutral'>        address factory,</span>
 111 |     | <span class='neutral'>        uint256 amountOut,</span>
 112 |     | <span class='neutral'>        address[] memory path</span>
 113 |     | <span class='neutral'>    ) internal view returns (uint256[] memory amounts) {</span>
 114 |     | <span class='neutral'>        require(path.length &gt;= 2, &quot;UniswapV2Library: INVALID_PATH&quot;);</span>
 115 |     | <span class='neutral'>        amounts = new uint256[](path.length);</span>
 116 |     | <span class='neutral'>        amounts[amounts.length - 1] = amountOut;</span>
 117 |     | <span class='neutral'>        for (uint256 i = path.length - 1; i &gt; 0; i--) {</span>
 118 |     | <span class='neutral'>            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i]);</span>
 119 |     | <span class='neutral'>            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);</span>
 120 |     | <span class='neutral'>        }</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'>}</span>
 123 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/duoswapV2/libraries/Math.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity &gt;=0.5.16;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>// a library for performing various math operations</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>library Math {</span>
  6 |     | <span class='neutral'>    function min(uint x, uint y) internal pure returns (uint z) {</span>
  7 |     | <span class='neutral'>        z = x &lt; y ? x : y;</span>
  8 |     | <span class='neutral'>    }</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)</span>
 11 |     | <span class='neutral'>    function sqrt(uint y) internal pure returns (uint z) {</span>
 12 |     | <span class='neutral'>        if (y &gt; 3) {</span>
 13 |     | <span class='neutral'>            z = y;</span>
 14 |     | <span class='neutral'>            uint x = y / 2 + 1;</span>
 15 |     | <span class='neutral'>            while (x &lt; z) {</span>
 16 |     | <span class='neutral'>                z = x;</span>
 17 |     | <span class='neutral'>                x = (y / x + x) / 2;</span>
 18 |     | <span class='neutral'>            }</span>
 19 |     | <span class='neutral'>        } else if (y != 0) {</span>
 20 |     | <span class='neutral'>            z = 1;</span>
 21 |     | <span class='neutral'>        }</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'>}</span>
 24 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/duoswapV2/libraries/UQ112x112.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity &gt;=0.5.16;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='unexecuted'>// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>// range: [0, 2**112 - 1]</span>
  6 |     | <span class='neutral'>// resolution: 1 / 2**112</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>library UQ112x112 {</span>
  9 |     | <span class='neutral'>    uint224 constant Q112 = 2 ** 112;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    // encode a uint112 as a UQ112x112</span>
 12 |     | <span class='neutral'>    function encode(uint112 y) internal pure returns (uint224 z) {</span>
 13 |     | <span class='neutral'>        z = uint224(y) * Q112; // never overflows</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    // divide a UQ112x112 by a uint112, returning a UQ112x112</span>
 17 |     | <span class='neutral'>    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {</span>
 18 |     | <span class='neutral'>        z = x / uint224(y);</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'>}</span>
 21 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/external/interfaces/IAnyswapCreate2Deployer.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IAnyswapCreate2Deployer {</span>
  5 |     | <span class='neutral'>    event Deployed(address addr, uint256 salt);</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function deploy(bytes memory code, uint256 salt) external;</span>
  8 |     | <span class='neutral'>}</span>
  9 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/external/interfaces/INonfungiblePositionManager.sol</b>
<code>
   1 |     | <span class='neutral'>// All this file is taken from @uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol</span>
   2 |     | <span class='neutral'>// Commented out the code that is not compatible with owr OpenZeppelin version.</span>
   3 |     | <span class='neutral'>// So the rest may be used to create an interface for a deployed instance of this contract</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   6 |     | <span class='neutral'>pragma solidity &gt;=0.7.5;</span>
   7 |     | <span class='neutral'>pragma abicoder v2;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>//import &#39;@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol&#39;;</span>
  10 |     | <span class='neutral'>//import &#39;@openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol&#39;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>//import &#39;./IPoolInitializer.sol&#39;;</span>
  13 |     | <span class='neutral'>//import &#39;./IERC721Permit.sol&#39;;</span>
  14 |     | <span class='neutral'>//import &#39;./IPeripheryPayments.sol&#39;;</span>
  15 |     | <span class='neutral'>//import &#39;./IPeripheryImmutableState.sol&#39;;</span>
  16 |     | <span class='neutral'>//import &#39;../libraries/PoolAddress.sol&#39;;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>/// @title Non-fungible token for positions</span>
  19 |     | <span class='neutral'>/// @notice Wraps Uniswap V3 positions in a non-fungible token interface which allows for them to be transferred</span>
  20 |     | <span class='neutral'>/// and authorized.</span>
  21 |     | <span class='neutral'>//is</span>
  22 |     | <span class='neutral'>//IPoolInitializer,</span>
  23 |     | <span class='neutral'>//IPeripheryPayments,</span>
  24 |     | <span class='neutral'>//IPeripheryImmutableState,</span>
  25 |     | <span class='neutral'>//IERC721Metadata,</span>
  26 |     | <span class='neutral'>//IERC721Enumerable,</span>
  27 |     | <span class='neutral'>//IERC721Permit</span>
  28 |     | <span class='neutral'>interface INonfungiblePositionManager {</span>
  29 |     | <span class='neutral'>    /// @notice Emitted when liquidity is increased for a position NFT</span>
  30 |     | <span class='neutral'>    /// @dev Also emitted when a token is minted</span>
  31 |     | <span class='neutral'>    /// @param tokenId The ID of the token for which liquidity was increased</span>
  32 |     | <span class='neutral'>    /// @param liquidity The amount by which liquidity for the NFT position was increased</span>
  33 |     | <span class='neutral'>    /// @param amount0 The amount of token0 that was paid for the increase in liquidity</span>
  34 |     | <span class='neutral'>    /// @param amount1 The amount of token1 that was paid for the increase in liquidity</span>
  35 |     | <span class='neutral'>    event IncreaseLiquidity(</span>
  36 |     | <span class='neutral'>        uint256 indexed tokenId,</span>
  37 |     | <span class='neutral'>        uint128 liquidity,</span>
  38 |     | <span class='neutral'>        uint256 amount0,</span>
  39 |     | <span class='neutral'>        uint256 amount1</span>
  40 |     | <span class='neutral'>    );</span>
  41 |     | <span class='neutral'>    /// @notice Emitted when liquidity is decreased for a position NFT</span>
  42 |     | <span class='neutral'>    /// @param tokenId The ID of the token for which liquidity was decreased</span>
  43 |     | <span class='neutral'>    /// @param liquidity The amount by which liquidity for the NFT position was decreased</span>
  44 |     | <span class='neutral'>    /// @param amount0 The amount of token0 that was accounted for the decrease in liquidity</span>
  45 |     | <span class='neutral'>    /// @param amount1 The amount of token1 that was accounted for the decrease in liquidity</span>
  46 |     | <span class='neutral'>    event DecreaseLiquidity(</span>
  47 |     | <span class='neutral'>        uint256 indexed tokenId,</span>
  48 |     | <span class='neutral'>        uint128 liquidity,</span>
  49 |     | <span class='neutral'>        uint256 amount0,</span>
  50 |     | <span class='neutral'>        uint256 amount1</span>
  51 |     | <span class='neutral'>    );</span>
  52 |     | <span class='neutral'>    /// @notice Emitted when tokens are collected for a position NFT</span>
  53 |     | <span class='neutral'>    /// @dev The amounts reported may not be exactly equivalent to the amounts transferred, due to rounding behavior</span>
  54 |     | <span class='neutral'>    /// @param tokenId The ID of the token for which underlying tokens were collected</span>
  55 |     | <span class='neutral'>    /// @param recipient The address of the account that received the collected tokens</span>
  56 |     | <span class='neutral'>    /// @param amount0 The amount of token0 owed to the position that was collected</span>
  57 |     | <span class='neutral'>    /// @param amount1 The amount of token1 owed to the position that was collected</span>
  58 |     | <span class='neutral'>    event Collect(uint256 indexed tokenId, address recipient, uint256 amount0, uint256 amount1);</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    /// @notice Returns the position information associated with a given token ID.</span>
  61 |     | <span class='neutral'>    /// @dev Throws if the token ID is not valid.</span>
  62 |     | <span class='neutral'>    /// @param tokenId The ID of the token that represents the position</span>
  63 |     | <span class='neutral'>    /// @return nonce The nonce for permits</span>
  64 |     | <span class='neutral'>    /// @return operator The address that is approved for spending</span>
  65 |     | <span class='neutral'>    /// @return token0 The address of the token0 for a specific pool</span>
  66 |     | <span class='neutral'>    /// @return token1 The address of the token1 for a specific pool</span>
  67 |     | <span class='neutral'>    /// @return fee The fee associated with the pool</span>
  68 |     | <span class='neutral'>    /// @return tickLower The lower end of the tick range for the position</span>
  69 |     | <span class='neutral'>    /// @return tickUpper The higher end of the tick range for the position</span>
  70 |     | <span class='neutral'>    /// @return liquidity The liquidity of the position</span>
  71 |     | <span class='neutral'>    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position</span>
  72 |     | <span class='neutral'>    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position</span>
  73 |     | <span class='neutral'>    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation</span>
  74 |     | <span class='neutral'>    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation</span>
  75 |     | <span class='neutral'>    function positions(</span>
  76 |     | <span class='neutral'>        uint256 tokenId</span>
  77 |     | <span class='neutral'>    )</span>
  78 |     | <span class='neutral'>        external</span>
  79 |     | <span class='neutral'>        view</span>
  80 |     | <span class='neutral'>        returns (</span>
  81 |     | <span class='neutral'>            uint96 nonce,</span>
  82 |     | <span class='neutral'>            address operator,</span>
  83 |     | <span class='neutral'>            address token0,</span>
  84 |     | <span class='neutral'>            address token1,</span>
  85 |     | <span class='neutral'>            uint24 fee,</span>
  86 |     | <span class='neutral'>            int24 tickLower,</span>
  87 |     | <span class='neutral'>            int24 tickUpper,</span>
  88 |     | <span class='neutral'>            uint128 liquidity,</span>
  89 |     | <span class='neutral'>            uint256 feeGrowthInside0LastX128,</span>
  90 |     | <span class='neutral'>            uint256 feeGrowthInside1LastX128,</span>
  91 |     | <span class='neutral'>            uint128 tokensOwed0,</span>
  92 |     | <span class='neutral'>            uint128 tokensOwed1</span>
  93 |     | <span class='neutral'>        );</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    struct MintParams {</span>
  96 |     | <span class='neutral'>        address token0;</span>
  97 |     | <span class='neutral'>        address token1;</span>
  98 |     | <span class='neutral'>        uint24 fee;</span>
  99 |     | <span class='neutral'>        int24 tickLower;</span>
 100 |     | <span class='neutral'>        int24 tickUpper;</span>
 101 |     | <span class='neutral'>        uint256 amount0Desired;</span>
 102 |     | <span class='neutral'>        uint256 amount1Desired;</span>
 103 |     | <span class='neutral'>        uint256 amount0Min;</span>
 104 |     | <span class='neutral'>        uint256 amount1Min;</span>
 105 |     | <span class='neutral'>        address recipient;</span>
 106 |     | <span class='neutral'>        uint256 deadline;</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    /// @notice Creates a new position wrapped in a NFT</span>
 110 |     | <span class='neutral'>    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized</span>
 111 |     | <span class='neutral'>    /// a method does not exist, i.e. the pool is assumed to be initialized.</span>
 112 |     | <span class='neutral'>    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata</span>
 113 |     | <span class='neutral'>    /// @return tokenId The ID of the token that represents the minted position</span>
 114 |     | <span class='neutral'>    /// @return liquidity The amount of liquidity for this position</span>
 115 |     | <span class='neutral'>    /// @return amount0 The amount of token0</span>
 116 |     | <span class='neutral'>    /// @return amount1 The amount of token1</span>
 117 |     | <span class='neutral'>    function mint(</span>
 118 |     | <span class='neutral'>        MintParams calldata params</span>
 119 |     | <span class='neutral'>    )</span>
 120 |     | <span class='neutral'>        external</span>
 121 |     | <span class='neutral'>        payable</span>
 122 |     | <span class='neutral'>        returns (uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>    struct IncreaseLiquidityParams {</span>
 125 |     | <span class='neutral'>        uint256 tokenId;</span>
 126 |     | <span class='neutral'>        uint256 amount0Desired;</span>
 127 |     | <span class='neutral'>        uint256 amount1Desired;</span>
 128 |     | <span class='neutral'>        uint256 amount0Min;</span>
 129 |     | <span class='neutral'>        uint256 amount1Min;</span>
 130 |     | <span class='neutral'>        uint256 deadline;</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`</span>
 134 |     | <span class='neutral'>    /// @param params tokenId The ID of the token for which liquidity is being increased,</span>
 135 |     | <span class='neutral'>    /// amount0Desired The desired amount of token0 to be spent,</span>
 136 |     | <span class='neutral'>    /// amount1Desired The desired amount of token1 to be spent,</span>
 137 |     | <span class='neutral'>    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,</span>
 138 |     | <span class='neutral'>    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,</span>
 139 |     | <span class='neutral'>    /// deadline The time by which the transaction must be included to effect the change</span>
 140 |     | <span class='neutral'>    /// @return liquidity The new liquidity amount as a result of the increase</span>
 141 |     | <span class='neutral'>    /// @return amount0 The amount of token0 to acheive resulting liquidity</span>
 142 |     | <span class='neutral'>    /// @return amount1 The amount of token1 to acheive resulting liquidity</span>
 143 |     | <span class='neutral'>    function increaseLiquidity(</span>
 144 |     | <span class='neutral'>        IncreaseLiquidityParams calldata params</span>
 145 |     | <span class='neutral'>    ) external payable returns (uint128 liquidity, uint256 amount0, uint256 amount1);</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    struct DecreaseLiquidityParams {</span>
 148 |     | <span class='neutral'>        uint256 tokenId;</span>
 149 |     | <span class='neutral'>        uint128 liquidity;</span>
 150 |     | <span class='neutral'>        uint256 amount0Min;</span>
 151 |     | <span class='neutral'>        uint256 amount1Min;</span>
 152 |     | <span class='neutral'>        uint256 deadline;</span>
 153 |     | <span class='neutral'>    }</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>    /// @notice Decreases the amount of liquidity in a position and accounts it to the position</span>
 156 |     | <span class='neutral'>    /// @param params tokenId The ID of the token for which liquidity is being decreased,</span>
 157 |     | <span class='neutral'>    /// amount The amount by which liquidity will be decreased,</span>
 158 |     | <span class='neutral'>    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,</span>
 159 |     | <span class='neutral'>    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,</span>
 160 |     | <span class='neutral'>    /// deadline The time by which the transaction must be included to effect the change</span>
 161 |     | <span class='neutral'>    /// @return amount0 The amount of token0 accounted to the position&#39;s tokens owed</span>
 162 |     | <span class='neutral'>    /// @return amount1 The amount of token1 accounted to the position&#39;s tokens owed</span>
 163 |     | <span class='neutral'>    function decreaseLiquidity(</span>
 164 |     | <span class='neutral'>        DecreaseLiquidityParams calldata params</span>
 165 |     | <span class='neutral'>    ) external payable returns (uint256 amount0, uint256 amount1);</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    struct CollectParams {</span>
 168 |     | <span class='neutral'>        uint256 tokenId;</span>
 169 |     | <span class='neutral'>        address recipient;</span>
 170 |     | <span class='neutral'>        uint128 amount0Max;</span>
 171 |     | <span class='neutral'>        uint128 amount1Max;</span>
 172 |     | <span class='neutral'>    }</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient</span>
 175 |     | <span class='neutral'>    /// @param params tokenId The ID of the NFT for which tokens are being collected,</span>
 176 |     | <span class='neutral'>    /// recipient The account that should receive the tokens,</span>
 177 |     | <span class='neutral'>    /// amount0Max The maximum amount of token0 to collect,</span>
 178 |     | <span class='neutral'>    /// amount1Max The maximum amount of token1 to collect</span>
 179 |     | <span class='neutral'>    /// @return amount0 The amount of fees collected in token0</span>
 180 |     | <span class='neutral'>    /// @return amount1 The amount of fees collected in token1</span>
 181 |     | <span class='neutral'>    function collect(</span>
 182 |     | <span class='neutral'>        CollectParams calldata params</span>
 183 |     | <span class='neutral'>    ) external payable returns (uint256 amount0, uint256 amount1);</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens</span>
 186 |     | <span class='neutral'>    /// must be collected first.</span>
 187 |     | <span class='neutral'>    /// @param tokenId The ID of the token that is being burned</span>
 188 |     | <span class='neutral'>    function burn(uint256 tokenId) external payable;</span>
 189 |     | <span class='neutral'>}</span>
 190 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/external/interfaces/IPermit2.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>// Minimal Permit2 interface, derived from</span>
  7 |     | <span class='neutral'>// https://github.com/Uniswap/permit2/blob/main/src/interfaces/ISignatureTransfer.sol</span>
  8 |     | <span class='neutral'>interface IPermit2 {</span>
  9 |     | <span class='neutral'>    // Token and amount in a permit message.</span>
 10 |     | <span class='neutral'>    struct TokenPermissions {</span>
 11 |     | <span class='neutral'>        // Token to transfer.</span>
 12 |     | <span class='neutral'>        IERC20 token;</span>
 13 |     | <span class='neutral'>        // Amount to transfer.</span>
 14 |     | <span class='neutral'>        uint256 amount;</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    // The permit2 message.</span>
 18 |     | <span class='neutral'>    struct PermitTransferFrom {</span>
 19 |     | <span class='neutral'>        // Permitted token and amount.</span>
 20 |     | <span class='neutral'>        TokenPermissions permitted;</span>
 21 |     | <span class='neutral'>        // Unique identifier for this permit.</span>
 22 |     | <span class='neutral'>        uint256 nonce;</span>
 23 |     | <span class='neutral'>        // Expiration for this permit.</span>
 24 |     | <span class='neutral'>        uint256 deadline;</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    // Transfer details for permitTransferFrom().</span>
 28 |     | <span class='neutral'>    struct SignatureTransferDetails {</span>
 29 |     | <span class='neutral'>        // Recipient of tokens.</span>
 30 |     | <span class='neutral'>        address to;</span>
 31 |     | <span class='neutral'>        // Amount to transfer.</span>
 32 |     | <span class='neutral'>        uint256 requestedAmount;</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    // Consume a permit2 message and transfer tokens.</span>
 36 |     | <span class='neutral'>    function permitTransferFrom(</span>
 37 |     | <span class='neutral'>        PermitTransferFrom calldata permit,</span>
 38 |     | <span class='neutral'>        SignatureTransferDetails calldata transferDetails,</span>
 39 |     | <span class='neutral'>        address owner,</span>
 40 |     | <span class='neutral'>        bytes calldata signature</span>
 41 |     | <span class='neutral'>    ) external;</span>
 42 |     | <span class='neutral'>}</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>// https://docs.uniswap.org/contracts/permit2/overview</span>
 45 |     | <span class='neutral'>// https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3#code</span>
 46 |     | <span class='neutral'>IPermit2 constant PERMIT2 = IPermit2(0x000000000022D473030F116dDEE9F6B43aC78BA3);</span>
 47 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/external/interfaces/IWETH9.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>interface IERC20WithMetadata is IERC20, IERC20Metadata {}</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>interface IWETH9 is IERC20WithMetadata {</span>
 10 |     | <span class='neutral'>    receive() external payable;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    function deposit() external payable;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    function withdraw(uint256 wad) external;</span>
 15 |     | <span class='neutral'>}</span>
 16 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/governance/GovernanceProxy.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='unexecuted'>import &quot;@openzeppelin/contracts/utils/Address.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../lib/FsUtils.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../lib/ImmutableGovernance.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../lib/AccessControl.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;../tokens/HashNFT.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;../lib/Call.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>// This is a proxy contract representing governance. This allows a fixed</span>
  13 |     | <span class='neutral'>// ethereum address to be the indefinite owner of the system. This works</span>
  14 |     | <span class='neutral'>// nicely with ImmutableGovernance allowing owner to be stored in contract</span>
  15 |     | <span class='neutral'>// code instead of storage. Note that a governance account only has to</span>
  16 |     | <span class='neutral'>// interact with the &quot;execute&quot; method. Proposing new governance or accepting</span>
  17 |     | <span class='neutral'>// governance is done through calls to &quot;execute&quot;, simplifying voting</span>
  18 |     | <span class='neutral'>// contracts that govern this proxy.</span>
  19 |     | <span class='neutral'>contract GovernanceProxy {</span>
  20 |     | <span class='neutral'>    using Address for address;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    // This address controls the proxy and is allowed to execute</span>
  23 |     | <span class='neutral'>    // contract calls from this contracts account.</span>
  24 |     | <span class='neutral'>    address public governance;</span>
  25 |     | <span class='neutral'>    // To avoid losing governance by accidentally transferring governance</span>
  26 |     | <span class='neutral'>    // to a wrong address we use a propose mechanism, where the proposed</span>
  27 |     | <span class='neutral'>    // governance can also execute and by this action finalize the</span>
  28 |     | <span class='neutral'>    // the transfer of governance. This prevents accidentally transferring</span>
  29 |     | <span class='neutral'>    // control to an invalid address.</span>
  30 |     | <span class='neutral'>    address public proposedGovernance;</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    event NewGovernanceProposed(address newGovernance);</span>
  33 |     | <span class='neutral'>    event GovernanceChanged(address oldGovernance, address newGovernance);</span>
  34 |     | <span class='neutral'>    event BatchExecuted(CallWithoutValue[] calls);</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    error OnlyGovernance();</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    constructor(address _governance) {</span>
  39 |     | <span class='neutral'>        governance = FsUtils.nonNull(_governance);</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    /// @notice Execute a batch of contract calls.</span>
  43 |     | <span class='neutral'>    /// @param calls an array of calls.</span>
  44 |     | <span class='neutral'>    function executeBatch(CallWithoutValue[] calldata calls) external {</span>
  45 |     | <span class='neutral'>        if (msg.sender != governance) {</span>
  46 |     | <span class='neutral'>            // If the caller is not governance we only accept if the previous</span>
  47 |     | <span class='neutral'>            // governance has proposed it as the new governance account.</span>
  48 |     | <span class='neutral'>            if (msg.sender != proposedGovernance) revert OnlyGovernance();</span>
  49 |     | <span class='neutral'>            emit GovernanceChanged(governance, msg.sender);</span>
  50 |     | <span class='neutral'>            governance = msg.sender;</span>
  51 |     | <span class='neutral'>            proposedGovernance = address(0);</span>
  52 |     | <span class='neutral'>        }</span>
  53 |     | <span class='neutral'>        // Instead of monitoring each configuration change we opt for a</span>
  54 |     | <span class='neutral'>        // simpler approach where we just emit an event for each batch of</span>
  55 |     | <span class='neutral'>        // privileged calls.</span>
  56 |     | <span class='neutral'>        emit BatchExecuted(calls);</span>
  57 |     | <span class='neutral'>        CallLib.executeBatchWithoutValue(calls);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    /// @notice Propose a new account as governance account. Note that this can</span>
  61 |     | <span class='neutral'>    /// only be called through the execute method above and hence only</span>
  62 |     | <span class='neutral'>    /// by the current governance.</span>
  63 |     | <span class='neutral'>    /// @param newGovernance address of the new governance account (or zero to revoke proposal)</span>
  64 |     | <span class='neutral'>    function proposeGovernance(address newGovernance) external {</span>
  65 |     | <span class='neutral'>        if (msg.sender != address(this)) revert OnlyGovernance();</span>
  66 |     | <span class='neutral'>        emit NewGovernanceProposed(newGovernance);</span>
  67 |     | <span class='neutral'>        proposedGovernance = newGovernance;</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'>}</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>contract Governance is AccessControl, ERC1155Receiver {</span>
  72 |     | <span class='neutral'>    address public voting;</span>
  73 |     | <span class='neutral'>    uint256 public maxSupportedGasCost = 8e6;</span>
  74 |     | <span class='neutral'>    mapping(address =&gt; mapping(bytes4 =&gt; uint256)) public bitmaskByAddressBySelector;</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    event ExecutionFailed(uint256 indexed messageId, string reason);</span>
  77 |     | <span class='neutral'>    event ExecutionSucceeded(uint256 indexed messageId);</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    error AccessDenied(address account, uint8 accessLevel);</span>
  80 |     | <span class='neutral'>    error InvalidCall(address to, bytes callData);</span>
  81 |     | <span class='neutral'>    error CallDenied(address to, bytes callData, uint8 accessLevel);</span>
  82 |     | <span class='neutral'>    error PrivilagedMethod(address to, bytes4 selector);</span>
  83 |     | <span class='neutral'>    error OnlyHashNFT();</span>
  84 |     | <span class='neutral'>    error InsufficientGas();</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    constructor(</span>
  87 |     | <span class='neutral'>        address _governanceProxy,</span>
  88 |     | <span class='neutral'>        address _hashNFT,</span>
  89 |     | <span class='neutral'>        address _voting</span>
  90 |     | <span class='neutral'>    ) AccessControl(_governanceProxy, _hashNFT) {</span>
  91 |     | <span class='neutral'>        voting = FsUtils.nonNull(_voting);</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    function executeBatch(CallWithoutValue[] memory calls) external {</span>
  95 |     | <span class='neutral'>        uint256 tokenId = hashNFT.toTokenId(voting, CallLib.hashCallWithoutValueArray(calls));</span>
  96 |     | <span class='neutral'>        hashNFT.burn(address(this), tokenId, 1); // reverts if tokenId isn&#39;t owned.</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>        // For governance calls we do not want them to revert and be in limbo. Thus if the batch</span>
  99 |     | <span class='neutral'>        // reverts we should still burn the NFT. The only caveat is that we want to prevent</span>
 100 |     | <span class='neutral'>        // sabotage votes by executing with insufficient gas and provoking a spurious revert.</span>
 101 |     | <span class='neutral'>        bool failed = false;</span>
 102 |     | <span class='neutral'>        string memory reason = &quot;&quot;;</span>
 103 |     | <span class='neutral'>        try governanceProxy().executeBatch(calls) {} catch Error(string memory _reason) {</span>
 104 |     | <span class='neutral'>            failed = true;</span>
 105 |     | <span class='neutral'>            reason = _reason;</span>
 106 |     | <span class='neutral'>        } catch {</span>
 107 |     | <span class='neutral'>            failed = true;</span>
 108 |     | <span class='neutral'>        }</span>
 109 |     | <span class='neutral'>        if (failed) {</span>
 110 |     | <span class='neutral'>            // 1/64th of the gas is left in case the execution fails because of OOG. We need to</span>
 111 |     | <span class='neutral'>            // require that this exceeds maxSupportedGasCost / 64 to ensure that in case it</span>
 112 |     | <span class='neutral'>            // reverted because of OOG the execution was given ample gas.</span>
 113 |     | <span class='neutral'>            if (gasleft() &lt; maxSupportedGasCost / 64) revert InsufficientGas();</span>
 114 |     | <span class='neutral'>            emit ExecutionFailed(tokenId, reason);</span>
 115 |     | <span class='neutral'>        } else {</span>
 116 |     | <span class='neutral'>            emit ExecutionSucceeded(tokenId);</span>
 117 |     | <span class='neutral'>        }</span>
 118 |     | <span class='neutral'>    }</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>    function executeBatchWithClearance(</span>
 121 |     | <span class='neutral'>        CallWithoutValue[] memory calls,</span>
 122 |     | <span class='neutral'>        uint8 accessLevel</span>
 123 |     | <span class='neutral'>    ) external {</span>
 124 |     | <span class='neutral'>        if (!hasAccess(msg.sender, accessLevel)) revert AccessDenied(msg.sender, accessLevel);</span>
 125 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; calls.length; i++) {</span>
 126 |     | <span class='neutral'>            if (calls[i].callData.length &lt; 4) revert InvalidCall(calls[i].to, calls[i].callData);</span>
 127 |     | <span class='neutral'>            bytes4 selector = bytes4(calls[i].callData);</span>
 128 |     | <span class='neutral'>            if ((bitmaskByAddressBySelector[calls[i].to][selector] &amp; (1 &lt;&lt; accessLevel)) == 0) {</span>
 129 |     | <span class='neutral'>                revert CallDenied(calls[i].to, calls[i].callData, accessLevel);</span>
 130 |     | <span class='neutral'>            }</span>
 131 |     | <span class='neutral'>        }</span>
 132 |     | <span class='neutral'>        governanceProxy().executeBatch(calls);</span>
 133 |     | <span class='neutral'>    }</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='neutral'>    function transferVoting(address newVoting) external onlyGovernance {</span>
 136 |     | <span class='neutral'>        voting = FsUtils.nonNull(newVoting);</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    function setAccessLevel(</span>
 140 |     | <span class='neutral'>        address addr,</span>
 141 |     | <span class='neutral'>        bytes4 selector,</span>
 142 |     | <span class='neutral'>        uint8 accessLevel,</span>
 143 |     | <span class='neutral'>        bool allowed</span>
 144 |     | <span class='neutral'>    ) external onlyGovernance {</span>
 145 |     | <span class='neutral'>        // We cannot allow setting access level for this contract, since that would enable a designated</span>
 146 |     | <span class='neutral'>        // caller to escalate their access level to include all privilaged functions in the system.</span>
 147 |     | <span class='neutral'>        // By disallowing access levels for this contract we ensure that only the voting system can</span>
 148 |     | <span class='neutral'>        // set access levels for other contracts. The same holds for proposeGovernance on the governance</span>
 149 |     | <span class='neutral'>        // proxy.</span>
 150 |     | <span class='neutral'>        if (</span>
 151 |     | <span class='neutral'>            (addr == address(this) &amp;&amp; selector != this.revokeAccess.selector) ||</span>
 152 |     | <span class='neutral'>            addr == immutableGovernance</span>
 153 |     | <span class='neutral'>        ) {</span>
 154 |     | <span class='neutral'>            revert PrivilagedMethod(addr, selector);</span>
 155 |     | <span class='neutral'>        }</span>
 156 |     | <span class='neutral'>        if (allowed) {</span>
 157 |     | <span class='neutral'>            bitmaskByAddressBySelector[addr][selector] |= 1 &lt;&lt; accessLevel;</span>
 158 |     | <span class='neutral'>        } else {</span>
 159 |     | <span class='neutral'>            bitmaskByAddressBySelector[addr][selector] &amp;= ~(1 &lt;&lt; accessLevel);</span>
 160 |     | <span class='neutral'>        }</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    function setMaxSupportedGasCost(uint256 _maxSupportedGasCost) external onlyGovernance {</span>
 164 |     | <span class='neutral'>        require(_maxSupportedGasCost &gt; 0, &quot;Governance: invalid gas cost&quot;);</span>
 165 |     | <span class='neutral'>        maxSupportedGasCost = _maxSupportedGasCost;</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>    function onERC1155Received(</span>
 169 |     | <span class='neutral'>        address /* operator */,</span>
 170 |     | <span class='neutral'>        address /* from */,</span>
 171 |     | <span class='neutral'>        uint256 /* id */,</span>
 172 |     | <span class='neutral'>        uint256 /* value */,</span>
 173 |     | <span class='neutral'>        bytes calldata /* data */</span>
 174 |     | <span class='neutral'>    ) external view returns (bytes4) {</span>
 175 |     | <span class='neutral'>        if (msg.sender != address(hashNFT)) revert OnlyHashNFT();</span>
 176 |     | <span class='neutral'>        return this.onERC1155Received.selector;</span>
 177 |     | <span class='neutral'>    }</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>    function onERC1155BatchReceived(</span>
 180 |     | <span class='neutral'>        address /* operator */,</span>
 181 |     | <span class='neutral'>        address /* from */,</span>
 182 |     | <span class='neutral'>        uint256[] calldata /* ids */,</span>
 183 |     | <span class='neutral'>        uint256[] calldata /* values */,</span>
 184 |     | <span class='neutral'>        bytes calldata /* data */</span>
 185 |     | <span class='neutral'>    ) external view returns (bytes4) {</span>
 186 |     | <span class='neutral'>        if (msg.sender != address(hashNFT)) revert OnlyHashNFT();</span>
 187 |     | <span class='neutral'>        return this.onERC1155BatchReceived.selector;</span>
 188 |     | <span class='neutral'>    }</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>    function governanceProxy() internal view returns (GovernanceProxy) {</span>
 191 |     | <span class='neutral'>        return GovernanceProxy(immutableGovernance);</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'>}</span>
 194 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/governance/OffchainEntityProxy.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/utils/cryptography/EIP712.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;../lib/Call.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../lib/FsUtils.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>// Signers (EOAs) are the only things that cross EVM chains as they have the same address on all chains.</span>
 10 |     | <span class='neutral'>// To represent an entity cross chains therefore requires a dedicated signer. However this is cumbersome</span>
 11 |     | <span class='unexecuted'>// to manage securely when the offchain entity is distributed (if the signer is hardware who possesses it, or</span>
 12 |     | <span class='unexecuted'>// the security risk of sharing the privare key). Instead, ideally we want a multisig smart contract</span>
 13 |     | <span class='neutral'>// representing the entity but with a fixed address on all chains. We propose a simple proxy contract</span>
 14 |     | <span class='unexecuted'>// that can be deployed to a fixed address on all chains, and can be owned by a multisig wallet. This</span>
 15 |     | <span class='neutral'>// reduces the use of the key to infrequent initial setup for a new chain.</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>// Note: we could deploy this contract with a dedicated deployer key. However this means we must guarantee</span>
 18 |     | <span class='neutral'>// that deployment of this contract is always the first action on the chain for this key. Instead we</span>
 19 |     | <span class='neutral'>// opt for a pattern that only needs the dedicated key to sign offchain.</span>
 20 |     | <span class='neutral'>contract OffchainEntityProxy is Ownable, EIP712 {</span>
 21 |     | <span class='neutral'>    bytes32 constant TAKEOWNERSHIP_TYPEHASH =</span>
 22 |     | <span class='neutral'>        keccak256(&quot;TakeOwnership(address newOwner,uint256 nonce)&quot;);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    bytes32 private immutable entityName;</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    uint256 public nonce;</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>    // Due to offchain signer address being part of the deployment bytecode, the address at which</span>
 29 |     | <span class='neutral'>    // this contract is deployed identifies the offchain signer.</span>
 30 |     | <span class='neutral'>    constructor(</span>
 31 |     | <span class='neutral'>        address offchainSigner,</span>
 32 |     | <span class='neutral'>        string memory _entityName</span>
 33 |     | <span class='neutral'>    ) EIP712(&quot;OffchainEntityProxy&quot;, &quot;1&quot;) {</span>
 34 |     | <span class='neutral'>        _transferOwnership(offchainSigner);</span>
 35 |     | <span class='neutral'>        entityName = FsUtils.encodeToBytes32(bytes(_entityName));</span>
 36 |     | <span class='neutral'>    }</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='neutral'>    // By using signature based ownership transfer, we can ensure that the signer can be</span>
 39 |     | <span class='neutral'>    // purely offchain.</span>
 40 |     | <span class='neutral'>    function takeOwnership(bytes calldata signature) external {</span>
 41 |     | <span class='neutral'>        bytes32 digest = _hashTypedDataV4(</span>
 42 |     | <span class='neutral'>            keccak256(abi.encode(TAKEOWNERSHIP_TYPEHASH, msg.sender, nonce++))</span>
 43 |     | <span class='neutral'>        );</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='neutral'>        address signer = ECDSA.recover(digest, signature);</span>
 46 |     | <span class='neutral'>        require(signer == owner(), &quot;Invalid signature&quot;);</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>        _transferOwnership(msg.sender);</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='neutral'>    // Allow the owner to execute arbitrary calls on behalf of the entity through this proxy</span>
 52 |     | <span class='neutral'>    // contract.</span>
 53 |     | <span class='neutral'>    function executeBatch(Call[] memory calls) external payable onlyOwner {</span>
 54 |     | <span class='neutral'>        CallLib.executeBatch(calls);</span>
 55 |     | <span class='neutral'>    }</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='neutral'>    function name() external view returns (string memory) {</span>
 58 |     | <span class='neutral'>        return string(FsUtils.decodeFromBytes32(entityName));</span>
 59 |     | <span class='neutral'>    }</span>
 60 |     | <span class='neutral'>}</span>
 61 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/governance/TimeLockedCall.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/access/Ownable2Step.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;./GovernanceProxy.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;../lib/ImmutableGovernance.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../tokens/HashNFT.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;../lib/AccessControl.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>contract TimeLockedCall is ImmutableGovernance, Ownable2Step {</span>
 11 |     | <span class='neutral'>    uint256 constant MIN_TIMELOCK = 1 days;</span>
 12 |     | <span class='neutral'>    uint256 constant MAX_TIMELOCK = 3 days;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    HashNFT public immutable hashNFT;</span>
 15 |     | <span class='neutral'>    uint8 public immutable accessLevel;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    uint256 public lockTime;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    event BatchProposed(CallWithoutValue[] calls, uint256 executionTime);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    constructor(</span>
 22 |     | <span class='neutral'>        address governance,</span>
 23 |     | <span class='neutral'>        address hashNFT_,</span>
 24 |     | <span class='neutral'>        uint8 _accessLevel,</span>
 25 |     | <span class='neutral'>        uint256 _lockTime</span>
 26 |     | <span class='neutral'>    ) ImmutableGovernance(governance) {</span>
 27 |     | <span class='neutral'>        require(</span>
 28 |     | <span class='neutral'>            _accessLevel == uint8(AccessControl.AccessLevel.FINANCIAL_RISK),</span>
 29 |     | <span class='neutral'>            &quot;TimeLockedCall: invalid access level&quot;</span>
 30 |     | <span class='neutral'>        );</span>
 31 |     | <span class='neutral'>        accessLevel = _accessLevel;</span>
 32 |     | <span class='neutral'>        hashNFT = HashNFT(FsUtils.nonNull(hashNFT_));</span>
 33 |     | <span class='neutral'>        _setLockTime(_lockTime);</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    function proposeBatch(CallWithoutValue[] calldata calls) external onlyOwner {</span>
 37 |     | <span class='neutral'>        uint256 executionTime = block.timestamp + lockTime;</span>
 38 |     | <span class='neutral'>        emit BatchProposed(calls, block.timestamp + lockTime);</span>
 39 |     | <span class='neutral'>        hashNFT.mint(address(this), calcDigest(calls, executionTime), &quot;&quot;);</span>
 40 |     | <span class='neutral'>    }</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    function executeBatch(CallWithoutValue[] calldata calls, uint256 executionTime) external {</span>
 43 |     | <span class='neutral'>        require(executionTime &lt;= block.timestamp, &quot;TimeLockedCall: not ready&quot;);</span>
 44 |     | <span class='neutral'>        uint256 tokenId = hashNFT.toTokenId(address(this), calcDigest(calls, executionTime));</span>
 45 |     | <span class='neutral'>        hashNFT.burn(address(this), tokenId, 1);</span>
 46 |     | <span class='neutral'>        Governance(GovernanceProxy(immutableGovernance).governance()).executeBatchWithClearance(</span>
 47 |     | <span class='neutral'>            calls,</span>
 48 |     | <span class='neutral'>            accessLevel</span>
 49 |     | <span class='neutral'>        );</span>
 50 |     | <span class='neutral'>    }</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    function setLockTime(uint256 _lockTime) external onlyGovernance {</span>
 53 |     | <span class='neutral'>        _setLockTime(_lockTime);</span>
 54 |     | <span class='neutral'>    }</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='neutral'>    function _setLockTime(uint256 _lockTime) internal {</span>
 57 |     | <span class='neutral'>        require(_lockTime &gt;= MIN_TIMELOCK, &quot;TimeLockedCall: too short&quot;);</span>
 58 |     | <span class='neutral'>        require(_lockTime &lt;= MAX_TIMELOCK, &quot;TimeLockedCall: too long&quot;);</span>
 59 |     | <span class='neutral'>        lockTime = _lockTime;</span>
 60 |     | <span class='neutral'>    }</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='neutral'>    function calcDigest(</span>
 63 |     | <span class='neutral'>        CallWithoutValue[] calldata calls,</span>
 64 |     | <span class='neutral'>        uint256 executionTime</span>
 65 |     | <span class='neutral'>    ) internal pure returns (bytes32) {</span>
 66 |     | <span class='neutral'>        return keccak256(abi.encode(executionTime, calls));</span>
 67 |     | <span class='neutral'>    }</span>
 68 |     | <span class='neutral'>}</span>
 69 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/governance/Voting.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/utils/Address.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/utils/cryptography/EIP712.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/utils/cryptography/ECDSA.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../tokens/HashNFT.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;../lib/Proofs.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;../lib/Call.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;../lib/FsUtils.sol&quot;;</span>
  12 |     | <span class='neutral'>import &quot;../lib/NonceMap.sol&quot;;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>contract Voting is EIP712 {</span>
  15 |     | <span class='neutral'>    using NonceMapLib for NonceMap;</span>
  16 |     | <span class='neutral'>    using Address for address;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    struct Proposal {</span>
  19 |     | <span class='neutral'>        bytes32 digest;</span>
  20 |     | <span class='neutral'>        uint256 deadline;</span>
  21 |     | <span class='neutral'>        bytes32 storageHash;</span>
  22 |     | <span class='neutral'>        uint256 totalSupply;</span>
  23 |     | <span class='neutral'>        uint256 yesVotes;</span>
  24 |     | <span class='neutral'>        uint256 noVotes;</span>
  25 |     | <span class='neutral'>    }</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    struct Vote {</span>
  28 |     | <span class='neutral'>        address voter;</span>
  29 |     | <span class='neutral'>        bool support;</span>
  30 |     | <span class='neutral'>        bytes signature;</span>
  31 |     | <span class='neutral'>        bytes proof;</span>
  32 |     | <span class='neutral'>    }</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    bytes private constant VOTE_TYPESTRING = &quot;Vote(uint256 proposalId,bool support)&quot;;</span>
  35 |     | <span class='unexecuted'>    bytes32 private constant VOTE_TYPEHASH = keccak256(VOTE_TYPESTRING);</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='unexecuted'>    uint256 public constant FRACTION = 10; // 10% must vote for quorum</span>
  38 |     | <span class='neutral'>    uint256 public constant MIN_VOTING_POWER = 100 ether;</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    HashNFT public immutable hashNFT;</span>
  41 |     | <span class='neutral'>    address public immutable governanceToken;</span>
  42 |     | <span class='unexecuted'>    address public immutable governance;</span>
  43 |     | <span class='neutral'>    uint256 public immutable mappingSlot;</span>
  44 |     | <span class='unexecuted'>    uint256 public immutable totalSupplySlot;</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    Proposal[] public proposals;</span>
  47 |     | <span class='unexecuted'>    mapping(address =&gt; NonceMap) private votesByAddress;</span>
  48 |     | <span class='neutral'>    mapping(address =&gt; address) public delegates;</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    event ProposalCreated(</span>
  51 |     | <span class='neutral'>        uint256 proposalId,</span>
  52 |     | <span class='neutral'>        string title,</span>
  53 |     | <span class='neutral'>        string description,</span>
  54 |     | <span class='neutral'>        CallWithoutValue[] calls,</span>
  55 |     | <span class='neutral'>        uint256 deadline,</span>
  56 |     | <span class='neutral'>        bytes32 digest,</span>
  57 |     | <span class='neutral'>        uint256 blockNumber</span>
  58 |     | <span class='neutral'>    );</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    event VoteCasted(address voter, uint256 proposalId, bool support, uint256 votes);</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    modifier requireValidProposal(uint256 proposalId) {</span>
  63 |     | <span class='neutral'>        require(</span>
  64 |     | <span class='neutral'>            proposalId &lt; proposals.length &amp;&amp; proposals[proposalId].deadline &gt; 0,</span>
  65 |     | <span class='neutral'>            &quot;proposal not found&quot;</span>
  66 |     | <span class='neutral'>        );</span>
  67 |     | <span class='neutral'>        require(proposals[proposalId].deadline &gt;= block.timestamp, &quot;voting ended&quot;);</span>
  68 |     | <span class='neutral'>        _;</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    constructor(</span>
  72 |     | <span class='neutral'>        address hashNFT_,</span>
  73 |     | <span class='unexecuted'>        address governanceToken_,</span>
  74 |     | <span class='neutral'>        uint256 mappingSlot_,</span>
  75 |     | <span class='neutral'>        uint256 totalSupplySlot_,</span>
  76 |     | <span class='unexecuted'>        address governance_</span>
  77 |     | <span class='neutral'>    ) EIP712(&quot;Voting&quot;, &quot;1&quot;) {</span>
  78 |     | <span class='neutral'>        hashNFT = HashNFT(FsUtils.nonNull(hashNFT_));</span>
  79 |     | <span class='unexecuted'>        governanceToken = FsUtils.nonNull(governanceToken_);</span>
  80 |     | <span class='neutral'>        mappingSlot = mappingSlot_;</span>
  81 |     | <span class='neutral'>        totalSupplySlot = totalSupplySlot_;</span>
  82 |     | <span class='unexecuted'>        governance = FsUtils.nonNull(governance_);</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='unexecuted'>    function proposeVote(</span>
  86 |     | <span class='neutral'>        string calldata title,</span>
  87 |     | <span class='neutral'>        string calldata description,</span>
  88 |     | <span class='neutral'>        CallWithoutValue[] calldata calls,</span>
  89 |     | <span class='neutral'>        uint256 blockNumber,</span>
  90 |     | <span class='neutral'>        bytes calldata blockHeader,</span>
  91 |     | <span class='neutral'>        bytes calldata stateProof,</span>
  92 |     | <span class='neutral'>        bytes calldata totalSupplyProof,</span>
  93 |     | <span class='neutral'>        address voter,</span>
  94 |     | <span class='neutral'>        bytes calldata proof</span>
  95 |     | <span class='neutral'>    ) external {</span>
  96 |     | <span class='neutral'>        require(msg.sender == voter || delegates[voter] == msg.sender, &quot;not authorized&quot;);</span>
  97 |     | <span class='neutral'>        require(calls.length &gt; 0, &quot;Empty proposal&quot;);</span>
  98 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; calls.length; i++) {</span>
  99 |     | <span class='neutral'>            require(calls[i].to.isContract(), &quot;target not a contract&quot;);</span>
 100 |     | <span class='neutral'>            require(calls[i].callData.length &gt;= 4, &quot;Invalid callData&quot;);</span>
 101 |     | <span class='neutral'>        }</span>
 102 |     | <span class='neutral'>        bytes32 storageHash;</span>
 103 |     | <span class='neutral'>        {</span>
 104 |     | <span class='neutral'>            bytes32 blockHash = getBlockHash(blockNumber);</span>
 105 |     | <span class='neutral'>            require(block.number &lt;= blockNumber + 256, &quot;block too old&quot;);</span>
 106 |     | <span class='neutral'>            require(keccak256(blockHeader) == blockHash, &quot;invalid block header&quot;);</span>
 107 |     | <span class='neutral'>            // RLP of block header 1 list tag + 2 length bytes + 33 bytes of parent hash + 33 bytes of ommers + 21 bytes of coinbase + 1 byte tag</span>
 108 |     | <span class='neutral'>            bytes32 stateHash = bytes32(blockHeader[91:]);</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>            (, , storageHash, ) = TrieLib.proofAccount(governanceToken, stateHash, stateProof);</span>
 111 |     | <span class='neutral'>        }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>        // proof storageHash is correct for blockhash(blockNumber) governanceTokenAddress</span>
 114 |     | <span class='neutral'>        Proposal storage proposal = proposals.push();</span>
 115 |     | <span class='neutral'>        proposal.digest = CallLib.hashCallWithoutValueArray(calls);</span>
 116 |     | <span class='neutral'>        proposal.deadline = block.timestamp + 2 days;</span>
 117 |     | <span class='neutral'>        proposal.storageHash = storageHash;</span>
 118 |     | <span class='neutral'>        proposal.totalSupply = TrieLib.proofStorageAt(</span>
 119 |     | <span class='neutral'>            bytes32(totalSupplySlot),</span>
 120 |     | <span class='neutral'>            storageHash,</span>
 121 |     | <span class='neutral'>            totalSupplyProof</span>
 122 |     | <span class='neutral'>        );</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>        emit ProposalCreated(</span>
 125 |     | <span class='neutral'>            proposals.length - 1,</span>
 126 |     | <span class='neutral'>            title,</span>
 127 |     | <span class='neutral'>            description,</span>
 128 |     | <span class='neutral'>            calls,</span>
 129 |     | <span class='neutral'>            proposal.deadline,</span>
 130 |     | <span class='neutral'>            proposal.digest,</span>
 131 |     | <span class='neutral'>            blockNumber</span>
 132 |     | <span class='neutral'>        );</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>        uint256 amount = _vote(voter, proposals.length - 1, true, proof);</span>
 135 |     | <span class='neutral'>        require(amount &gt;= MIN_VOTING_POWER, &quot;insufficient voting power&quot;);</span>
 136 |     | <span class='neutral'>    }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>    function vote(</span>
 139 |     | <span class='neutral'>        address voter,</span>
 140 |     | <span class='neutral'>        uint256 proposalId,</span>
 141 |     | <span class='neutral'>        bool support,</span>
 142 |     | <span class='neutral'>        bytes calldata proof</span>
 143 |     | <span class='neutral'>    ) external requireValidProposal(proposalId) {</span>
 144 |     | <span class='neutral'>        if (voter == address(0)) {</span>
 145 |     | <span class='neutral'>            voter = msg.sender;</span>
 146 |     | <span class='neutral'>        } else {</span>
 147 |     | <span class='neutral'>            require(voter == msg.sender || msg.sender == delegates[voter], &quot;invalid voter&quot;);</span>
 148 |     | <span class='neutral'>        }</span>
 149 |     | <span class='neutral'>        _vote(voter, proposalId, support, proof);</span>
 150 |     | <span class='neutral'>    }</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>    // Allow multiple offchain votes to be verified in a single transaction</span>
 153 |     | <span class='neutral'>    function voteBatch(</span>
 154 |     | <span class='neutral'>        uint256 proposalId,</span>
 155 |     | <span class='neutral'>        Vote[] calldata votes</span>
 156 |     | <span class='neutral'>    ) external requireValidProposal(proposalId) {</span>
 157 |     | <span class='neutral'>        bytes32 yesVoteDigest = _hashTypedDataV4(</span>
 158 |     | <span class='neutral'>            keccak256(abi.encode(VOTE_TYPEHASH, proposalId, true))</span>
 159 |     | <span class='neutral'>        );</span>
 160 |     | <span class='neutral'>        bytes32 noVoteDigest = _hashTypedDataV4(</span>
 161 |     | <span class='neutral'>            keccak256(abi.encode(VOTE_TYPEHASH, proposalId, false))</span>
 162 |     | <span class='neutral'>        );</span>
 163 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; votes.length; i++) {</span>
 164 |     | <span class='neutral'>            address addr = votes[i].voter;</span>
 165 |     | <span class='neutral'>            if (delegates[addr] != address(0)) {</span>
 166 |     | <span class='neutral'>                addr = delegates[addr];</span>
 167 |     | <span class='neutral'>            }</span>
 168 |     | <span class='neutral'>            require(</span>
 169 |     | <span class='neutral'>                SignatureChecker.isValidSignatureNow(</span>
 170 |     | <span class='neutral'>                    addr,</span>
 171 |     | <span class='neutral'>                    votes[i].support ? yesVoteDigest : noVoteDigest,</span>
 172 |     | <span class='neutral'>                    votes[i].signature</span>
 173 |     | <span class='neutral'>                ),</span>
 174 |     | <span class='neutral'>                &quot;invalid signature&quot;</span>
 175 |     | <span class='neutral'>            );</span>
 176 |     | <span class='neutral'>            _vote(votes[i].voter, proposalId, votes[i].support, votes[i].proof);</span>
 177 |     | <span class='neutral'>        }</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>    function resolve(uint256 proposalId) external {</span>
 181 |     | <span class='neutral'>        Proposal storage proposal = proposals[proposalId];</span>
 182 |     | <span class='neutral'>        require(proposal.deadline &gt; 0, &quot;proposal not found&quot;);</span>
 183 |     | <span class='neutral'>        require(proposal.deadline &lt; block.timestamp, &quot;voting not ended&quot;);</span>
 184 |     | <span class='neutral'>        if (proposal.yesVotes &lt;= proposal.noVotes) {</span>
 185 |     | <span class='neutral'>            delete proposals[proposalId];</span>
 186 |     | <span class='neutral'>            return;</span>
 187 |     | <span class='neutral'>        }</span>
 188 |     | <span class='neutral'>        if (proposal.yesVotes + proposal.noVotes &lt; proposal.totalSupply / FRACTION) {</span>
 189 |     | <span class='neutral'>            delete proposals[proposalId];</span>
 190 |     | <span class='neutral'>            return;</span>
 191 |     | <span class='neutral'>        }</span>
 192 |     | <span class='neutral'>        bytes32 digest = proposal.digest;</span>
 193 |     | <span class='neutral'>        delete proposals[proposalId];</span>
 194 |     | <span class='neutral'>        // Vote passed;</span>
 195 |     | <span class='neutral'>        hashNFT.mint(governance, digest, &quot;&quot;);</span>
 196 |     | <span class='neutral'>    }</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>    function setDelegate(address delegate) external {</span>
 199 |     | <span class='neutral'>        delegates[msg.sender] = delegate;</span>
 200 |     | <span class='neutral'>    }</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>    function hasVoted(address voter, uint256 proposalId) external view returns (bool) {</span>
 203 |     | <span class='neutral'>        return votesByAddress[voter].getNonce(proposalId);</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='neutral'>    function _vote(</span>
 207 |     | <span class='neutral'>        address addr,</span>
 208 |     | <span class='neutral'>        uint256 proposalId,</span>
 209 |     | <span class='neutral'>        bool support,</span>
 210 |     | <span class='neutral'>        bytes calldata proof</span>
 211 |     | <span class='neutral'>    ) internal returns (uint256 amount) {</span>
 212 |     | <span class='neutral'>        votesByAddress[addr].validateAndUseNonce(proposalId);</span>
 213 |     | <span class='neutral'>        // Solidity mapping convention</span>
 214 |     | <span class='neutral'>        bytes32 addressMappingSlot = keccak256(abi.encode(addr, mappingSlot));</span>
 215 |     | <span class='neutral'>        amount = TrieLib.proofStorageAt(</span>
 216 |     | <span class='neutral'>            addressMappingSlot,</span>
 217 |     | <span class='neutral'>            proposals[proposalId].storageHash,</span>
 218 |     | <span class='neutral'>            proof</span>
 219 |     | <span class='neutral'>        );</span>
 220 |     | <span class='neutral'>        require(amount &gt; 0, &quot;no balance&quot;);</span>
 221 |     | <span class='neutral'>        if (support) {</span>
 222 |     | <span class='neutral'>            proposals[proposalId].yesVotes += amount;</span>
 223 |     | <span class='neutral'>        } else {</span>
 224 |     | <span class='neutral'>            proposals[proposalId].noVotes += amount;</span>
 225 |     | <span class='neutral'>        }</span>
 226 |     | <span class='neutral'>        emit VoteCasted(addr, proposalId, support, amount);</span>
 227 |     | <span class='neutral'>    }</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='neutral'>    /// @dev Override this function for testing to return handcrafted blockhashes</span>
 230 |     | <span class='neutral'>    function getBlockHash(uint256 blockNumber) internal view virtual returns (bytes32 blockHash) {</span>
 231 |     | <span class='neutral'>        return blockhash(blockNumber);</span>
 232 |     | <span class='neutral'>    }</span>
 233 |     | <span class='neutral'>}</span>
 234 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/interfaces/IDOS.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.7;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span>
   5 |     | <span class='neutral'>import {Call} from &quot;../lib/Call.sol&quot;;</span>
   6 |     | <span class='neutral'>import {IERC20ValueOracle} from &quot;./IERC20ValueOracle.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>type ERC20Share is int256;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>interface IDOSERC20 is IERC20 {</span>
  11 |     | <span class='neutral'>    function mint(address account, uint256 amount) external;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    function burn(address account, uint256 amount) external;</span>
  14 |     | <span class='neutral'>}</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>interface IDOSConfig {</span>
  17 |     | <span class='neutral'>    struct Config {</span>
  18 |     | <span class='neutral'>        address treasurySafe; // The address of the treasury safe</span>
  19 |     | <span class='neutral'>        uint256 treasuryInterestFraction; // Fraction of interest to send to treasury</span>
  20 |     | <span class='neutral'>        uint256 maxSolvencyCheckGasCost;</span>
  21 |     | <span class='neutral'>        int256 liqFraction; // Fraction for the user</span>
  22 |     | <span class='neutral'>        int256 fractionalReserveLeverage; // Ratio of debt to reserves</span>
  23 |     | <span class='neutral'>    }</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    struct NFTData {</span>
  26 |     | <span class='neutral'>        address erc721;</span>
  27 |     | <span class='neutral'>        uint256 tokenId;</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /// @notice Emitted when the implementation of a dSafe is upgraded</span>
  31 |     | <span class='unexecuted'>    /// @param dSafe The address of the dSafe</span>
  32 |     | <span class='neutral'>    /// @param version The new implementation version</span>
  33 |     | <span class='neutral'>    event DSafeImplementationUpgraded(</span>
  34 |     | <span class='neutral'>        address indexed dSafe,</span>
  35 |     | <span class='neutral'>        string indexed version,</span>
  36 |     | <span class='neutral'>        address implementation</span>
  37 |     | <span class='neutral'>    );</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    event DSafeOwnershipTransferred(address indexed dSafe, address indexed newOwner);</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='unexecuted'>    /// @notice Emitted when a new ERC20 is added to the protocol</span>
  42 |     | <span class='neutral'>    /// @param erc20Idx The index of the ERC20 in the protocol</span>
  43 |     | <span class='neutral'>    /// @param erc20 The address of the ERC20 contract</span>
  44 |     | <span class='neutral'>    /// @param name The name of the ERC20</span>
  45 |     | <span class='neutral'>    /// @param symbol The symbol of the ERC20</span>
  46 |     | <span class='neutral'>    /// @param decimals The decimals of the ERC20</span>
  47 |     | <span class='unexecuted'>    /// @param valueOracle The address of the value oracle for the ERC20</span>
  48 |     | <span class='neutral'>    /// @param baseRate The interest rate at 0% utilization</span>
  49 |     | <span class='neutral'>    /// @param slope1 The interest rate slope at 0% to target utilization</span>
  50 |     | <span class='unexecuted'>    /// @param slope2 The interest rate slope at target utilization to 100% utilization</span>
  51 |     | <span class='neutral'>    /// @param targetUtilization The target utilization for the ERC20</span>
  52 |     | <span class='neutral'>    event ERC20Added(</span>
  53 |     | <span class='neutral'>        uint16 erc20Idx,</span>
  54 |     | <span class='neutral'>        address erc20,</span>
  55 |     | <span class='neutral'>        string name,</span>
  56 |     | <span class='neutral'>        string symbol,</span>
  57 |     | <span class='neutral'>        uint8 decimals,</span>
  58 |     | <span class='neutral'>        address valueOracle,</span>
  59 |     | <span class='neutral'>        uint256 baseRate,</span>
  60 |     | <span class='neutral'>        uint256 slope1,</span>
  61 |     | <span class='neutral'>        uint256 slope2,</span>
  62 |     | <span class='neutral'>        uint256 targetUtilization</span>
  63 |     | <span class='neutral'>    );</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /// @notice Emitted when a new ERC721 is added to the protocol</span>
  66 |     | <span class='neutral'>    /// @param erc721Idx The index of the ERC721 in the protocol</span>
  67 |     | <span class='neutral'>    /// @param erc721Contract The address of the ERC721 contract</span>
  68 |     | <span class='neutral'>    /// @param valueOracleAddress The address of the value oracle for the ERC721</span>
  69 |     | <span class='neutral'>    event ERC721Added(</span>
  70 |     | <span class='neutral'>        uint256 indexed erc721Idx,</span>
  71 |     | <span class='neutral'>        address indexed erc721Contract,</span>
  72 |     | <span class='neutral'>        address valueOracleAddress</span>
  73 |     | <span class='neutral'>    );</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    /// @notice Emitted when the config is set</span>
  76 |     | <span class='neutral'>    /// @param config The new config</span>
  77 |     | <span class='neutral'>    event ConfigSet(Config indexed config);</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    /// @notice Emitted when the version manager address is set</span>
  80 |     | <span class='neutral'>    /// @param versionManager The version manager address</span>
  81 |     | <span class='neutral'>    event VersionManagerSet(address indexed versionManager);</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    /// @notice Emitted when ERC20 Data is set</span>
  84 |     | <span class='neutral'>    /// @param erc20 The address of the erc20 token</span>
  85 |     | <span class='neutral'>    /// @param baseRate The new base interest rate</span>
  86 |     | <span class='neutral'>    /// @param slope1 The new slope1</span>
  87 |     | <span class='neutral'>    /// @param slope2 The new slope2</span>
  88 |     | <span class='neutral'>    /// @param targetUtilization The new target utilization</span>
  89 |     | <span class='neutral'>    event ERC20DataSet(</span>
  90 |     | <span class='neutral'>        address indexed erc20,</span>
  91 |     | <span class='neutral'>        uint256 baseRate,</span>
  92 |     | <span class='neutral'>        uint256 slope1,</span>
  93 |     | <span class='neutral'>        uint256 slope2,</span>
  94 |     | <span class='neutral'>        uint256 targetUtilization</span>
  95 |     | <span class='neutral'>    );</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    /// @notice Emitted when a dSafe is created</span>
  98 |     | <span class='neutral'>    /// @param dSafe The address of the dSafe</span>
  99 |     | <span class='neutral'>    /// @param owner The address of the owner</span>
 100 |     | <span class='neutral'>    event DSafeCreated(address dSafe, address owner);</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    function upgradeDSafeImplementation(string calldata version) external;</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    function transferDSafeOwnership(address newOwner) external;</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    function addERC20Info(</span>
 107 |     | <span class='neutral'>        address erc20Contract,</span>
 108 |     | <span class='neutral'>        string calldata name,</span>
 109 |     | <span class='neutral'>        string calldata symbol,</span>
 110 |     | <span class='neutral'>        uint8 decimals,</span>
 111 |     | <span class='neutral'>        address valueOracle,</span>
 112 |     | <span class='neutral'>        uint256 baseRate,</span>
 113 |     | <span class='neutral'>        uint256 slope1,</span>
 114 |     | <span class='neutral'>        uint256 slope2,</span>
 115 |     | <span class='neutral'>        uint256 targetUtilization</span>
 116 |     | <span class='neutral'>    ) external returns (uint16);</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    function addERC721Info(address nftContract, address valueOracleAddress) external;</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>    function setERC20Data(</span>
 121 |     | <span class='neutral'>        address erc20,</span>
 122 |     | <span class='neutral'>        uint256 baseRate,</span>
 123 |     | <span class='neutral'>        uint256 slope1,</span>
 124 |     | <span class='neutral'>        uint256 slope2,</span>
 125 |     | <span class='neutral'>        uint256 targetUtilization</span>
 126 |     | <span class='neutral'>    ) external;</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='neutral'>    function setConfig(Config calldata _config) external;</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    function setVersionManager(address _versionManager) external;</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>    function createDSafe() external returns (address dSafe);</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    function pause() external;</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>    function unpause() external;</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>    function getDAccountERC20(address dSafe, IERC20 erc20) external view returns (int256);</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    function getDAccountERC721(address dSafe) external view returns (NFTData[] memory);</span>
 141 |     | <span class='neutral'>}</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>interface IDOSCore {</span>
 144 |     | <span class='neutral'>    struct Approval {</span>
 145 |     | <span class='neutral'>        address ercContract; // ERC20/ERC721 contract</span>
 146 |     | <span class='neutral'>        uint256 amountOrTokenId; // amount or tokenId</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /// @notice Emitted when ERC20 tokens are transferred between credit accounts</span>
 150 |     | <span class='neutral'>    /// @param erc20 The address of the ERC20 token</span>
 151 |     | <span class='neutral'>    /// @param from The address of the sender</span>
 152 |     | <span class='neutral'>    /// @param to The address of the receiver</span>
 153 |     | <span class='neutral'>    /// @param value The amount of tokens transferred</span>
 154 |     | <span class='neutral'>    event ERC20Transfer(</span>
 155 |     | <span class='neutral'>        address indexed erc20,</span>
 156 |     | <span class='neutral'>        address indexed from,</span>
 157 |     | <span class='neutral'>        address indexed to,</span>
 158 |     | <span class='neutral'>        int256 value</span>
 159 |     | <span class='neutral'>    );</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>    /// @notice Emitted when erc20 tokens are deposited or withdrawn from a credit account</span>
 162 |     | <span class='neutral'>    /// @param erc20 The address of the ERC20 token</span>
 163 |     | <span class='neutral'>    /// @param to The address of the dSafe</span>
 164 |     | <span class='neutral'>    /// @param amount The amount of tokens deposited or withdrawn</span>
 165 |     | <span class='neutral'>    event ERC20BalanceChanged(address indexed erc20, address indexed to, int256 indexed amount);</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    /// @notice Emitted when a ERC721 is transferred between credit accounts</span>
 168 |     | <span class='neutral'>    /// @param nftId The nftId of the ERC721 token</span>
 169 |     | <span class='neutral'>    /// @param from The address of the sender</span>
 170 |     | <span class='neutral'>    /// @param to The address of the receiver</span>
 171 |     | <span class='neutral'>    event ERC721Transferred(uint256 indexed nftId, address indexed from, address indexed to);</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'>    /// @notice Emitted when an ERC721 token is deposited to a credit account</span>
 174 |     | <span class='neutral'>    /// @param erc721 The address of the ERC721 token</span>
 175 |     | <span class='neutral'>    /// @param to The address of the dSafe</span>
 176 |     | <span class='neutral'>    /// @param tokenId The id of the token deposited</span>
 177 |     | <span class='neutral'>    event ERC721Deposited(address indexed erc721, address indexed to, uint256 indexed tokenId);</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>    /// @notice Emitted when an ERC721 token is withdrawn from a credit account</span>
 180 |     | <span class='neutral'>    /// @param erc721 The address of the ERC721 token</span>
 181 |     | <span class='neutral'>    /// @param from The address of the dSafe</span>
 182 |     | <span class='neutral'>    /// @param tokenId The id of the token withdrawn</span>
 183 |     | <span class='neutral'>    event ERC721Withdrawn(address indexed erc721, address indexed from, uint256 indexed tokenId);</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>    /// @dev Emitted when `owner` approves `spender` to spend `value` tokens on their behalf.</span>
 186 |     | <span class='neutral'>    /// @param erc20 The ERC20 token to approve</span>
 187 |     | <span class='neutral'>    /// @param owner The address of the token owner</span>
 188 |     | <span class='neutral'>    /// @param spender The address of the spender</span>
 189 |     | <span class='neutral'>    /// @param value The amount of tokens to approve</span>
 190 |     | <span class='neutral'>    event ERC20Approval(</span>
 191 |     | <span class='neutral'>        address indexed erc20,</span>
 192 |     | <span class='neutral'>        address indexed owner,</span>
 193 |     | <span class='neutral'>        address indexed spender,</span>
 194 |     | <span class='neutral'>        uint256 value</span>
 195 |     | <span class='neutral'>    );</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='neutral'>    /// @dev Emitted when `owner` enables `approved` to manage the `tokenId` token on collection `collection`.</span>
 198 |     | <span class='neutral'>    /// @param collection The address of the ERC721 collection</span>
 199 |     | <span class='neutral'>    /// @param owner The address of the token owner</span>
 200 |     | <span class='neutral'>    /// @param approved The address of the approved operator</span>
 201 |     | <span class='neutral'>    /// @param tokenId The ID of the approved token</span>
 202 |     | <span class='neutral'>    event ERC721Approval(</span>
 203 |     | <span class='neutral'>        address indexed collection,</span>
 204 |     | <span class='neutral'>        address indexed owner,</span>
 205 |     | <span class='neutral'>        address indexed approved,</span>
 206 |     | <span class='neutral'>        uint256 tokenId</span>
 207 |     | <span class='neutral'>    );</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='neutral'>    /// @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its erc20s.</span>
 210 |     | <span class='neutral'>    /// @param collection The address of the collection</span>
 211 |     | <span class='neutral'>    /// @param owner The address of the owner</span>
 212 |     | <span class='neutral'>    /// @param operator The address of the operator</span>
 213 |     | <span class='neutral'>    /// @param approved True if the operator is approved, false to revoke approval</span>
 214 |     | <span class='neutral'>    event ApprovalForAll(</span>
 215 |     | <span class='neutral'>        address indexed collection,</span>
 216 |     | <span class='neutral'>        address indexed owner,</span>
 217 |     | <span class='neutral'>        address indexed operator,</span>
 218 |     | <span class='neutral'>        bool approved</span>
 219 |     | <span class='neutral'>    );</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='neutral'>    /// @notice Emitted when a dSafe is liquidated</span>
 222 |     | <span class='neutral'>    /// @param dSafe The address of the liquidated dSafe</span>
 223 |     | <span class='neutral'>    /// @param liquidator The address of the liquidator</span>
 224 |     | <span class='neutral'>    event SafeLiquidated(address indexed dSafe, address indexed liquidator);</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>    /// @notice Error thrown if a dSafe accumulates too many assets</span>
 227 |     | <span class='neutral'>    error SolvencyCheckTooExpensive();</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='neutral'>    function liquidate(address dSafe) external;</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='neutral'>    function depositERC20(IERC20 erc20, uint256 amount) external;</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='neutral'>    function withdrawERC20(IERC20 erc20, uint256 amount) external;</span>
 234 |     | <span class='neutral'></span>
 235 |     | <span class='neutral'>    function depositERC20ForSafe(address erc20, address to, uint256 amount) external;</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>    function depositFull(IERC20[] calldata erc20s) external;</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='neutral'>    function withdrawFull(IERC20[] calldata erc20s) external;</span>
 240 |     | <span class='neutral'></span>
 241 |     | <span class='neutral'>    function executeBatch(Call[] memory calls) external;</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='neutral'>    function transferERC20(IERC20 erc20, address to, uint256 amount) external;</span>
 244 |     | <span class='neutral'></span>
 245 |     | <span class='neutral'>    function depositERC721(address nftContract, uint256 tokenId) external;</span>
 246 |     | <span class='neutral'></span>
 247 |     | <span class='neutral'>    function withdrawERC721(address erc721, uint256 tokenId) external;</span>
 248 |     | <span class='neutral'></span>
 249 |     | <span class='neutral'>    function transferERC721(address erc721, uint256 tokenId, address to) external;</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='neutral'>    /// @notice Transfer ERC20 tokens from dSafe to another dSafe</span>
 252 |     | <span class='neutral'>    /// @dev Note: Allowance must be set with approveERC20</span>
 253 |     | <span class='neutral'>    /// @param erc20 The index of the ERC20 token in erc20Infos array</span>
 254 |     | <span class='neutral'>    /// @param from The address of the dSafe to transfer from</span>
 255 |     | <span class='neutral'>    /// @param to The address of the dSafe to transfer to</span>
 256 |     | <span class='neutral'>    /// @param amount The amount of tokens to transfer</span>
 257 |     | <span class='neutral'>    function transferFromERC20(</span>
 258 |     | <span class='neutral'>        address erc20,</span>
 259 |     | <span class='neutral'>        address from,</span>
 260 |     | <span class='neutral'>        address to,</span>
 261 |     | <span class='neutral'>        uint256 amount</span>
 262 |     | <span class='neutral'>    ) external returns (bool);</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='neutral'>    /// @notice Transfer ERC721 tokens from dSafe to another dSafe</span>
 265 |     | <span class='neutral'>    /// @param collection The address of the ERC721 token</span>
 266 |     | <span class='neutral'>    /// @param from The address of the dSafe to transfer from</span>
 267 |     | <span class='neutral'>    /// @param to The address of the dSafe to transfer to</span>
 268 |     | <span class='neutral'>    /// @param tokenId The id of the token to transfer</span>
 269 |     | <span class='neutral'>    function transferFromERC721(</span>
 270 |     | <span class='neutral'>        address collection,</span>
 271 |     | <span class='neutral'>        address from,</span>
 272 |     | <span class='neutral'>        address to,</span>
 273 |     | <span class='neutral'>        uint256 tokenId</span>
 274 |     | <span class='neutral'>    ) external;</span>
 275 |     | <span class='neutral'></span>
 276 |     | <span class='neutral'>    function approveAndCall(</span>
 277 |     | <span class='neutral'>        Approval[] calldata approvals,</span>
 278 |     | <span class='neutral'>        address spender,</span>
 279 |     | <span class='neutral'>        bytes calldata data</span>
 280 |     | <span class='neutral'>    ) external;</span>
 281 |     | <span class='neutral'></span>
 282 |     | <span class='neutral'>    /// @notice Returns the approved address for a token, or zero if no address set</span>
 283 |     | <span class='neutral'>    /// @param collection The address of the ERC721 token</span>
 284 |     | <span class='neutral'>    /// @param tokenId The id of the token to query</span>
 285 |     | <span class='neutral'>    function getApproved(address collection, uint256 tokenId) external view returns (address);</span>
 286 |     | <span class='neutral'></span>
 287 |     | <span class='neutral'>    function getRiskAdjustedPositionValues(</span>
 288 |     | <span class='neutral'>        address dSafeAddress</span>
 289 |     | <span class='neutral'>    ) external view returns (int256 totalValue, int256 collateral, int256 debt);</span>
 290 |     | <span class='neutral'></span>
 291 |     | <span class='neutral'>    /// @notice Returns if the `operator` is allowed to manage all of the erc20s of `owner` on the `collection` contract</span>
 292 |     | <span class='neutral'>    /// @param collection The address of the collection contract</span>
 293 |     | <span class='neutral'>    /// @param _owner The address of the owner</span>
 294 |     | <span class='neutral'>    /// @param spender The address of the spender</span>
 295 |     | <span class='neutral'>    function isApprovedForAll(</span>
 296 |     | <span class='neutral'>        address collection,</span>
 297 |     | <span class='neutral'>        address _owner,</span>
 298 |     | <span class='neutral'>        address spender</span>
 299 |     | <span class='neutral'>    ) external view returns (bool);</span>
 300 |     | <span class='neutral'></span>
 301 |     | <span class='neutral'>    /**</span>
 302 |     | <span class='neutral'>     * @dev Returns the remaining number of tokens that `spender` will be</span>
 303 |     | <span class='neutral'>     * allowed to spend on behalf of `owner` through {transferFrom}. This is</span>
 304 |     | <span class='neutral'>     * zero by default.</span>
 305 |     | <span class='neutral'>     *</span>
 306 |     | <span class='neutral'>     * This value changes when {approve} or {transferFrom} are called.</span>
 307 |     | <span class='neutral'>     */</span>
 308 |     | <span class='neutral'>    function allowance(</span>
 309 |     | <span class='neutral'>        address erc20,</span>
 310 |     | <span class='neutral'>        address _owner,</span>
 311 |     | <span class='neutral'>        address spender</span>
 312 |     | <span class='neutral'>    ) external view returns (uint256);</span>
 313 |     | <span class='neutral'></span>
 314 |     | <span class='neutral'>    function computeInterestRate(uint16 erc20Idx) external view returns (int96);</span>
 315 |     | <span class='neutral'></span>
 316 |     | <span class='neutral'>    function getImplementation(address dSafe) external view returns (address);</span>
 317 |     | <span class='neutral'></span>
 318 |     | <span class='neutral'>    function getDSafeOwner(address dSafe) external view returns (address);</span>
 319 |     | <span class='neutral'>}</span>
 320 |     | <span class='neutral'></span>
 321 |     | <span class='neutral'>interface IDOS is IDOSCore, IDOSConfig {}</span>
 322 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/interfaces/IERC1363-extended.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.7;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {Call} from &quot;../lib/Call.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IERC1363SpenderExtended {</span>
  7 |     | <span class='neutral'>    function onApprovalReceived(</span>
  8 |     | <span class='neutral'>        address owner,</span>
  9 |     | <span class='neutral'>        uint256 value,</span>
 10 |     | <span class='neutral'>        Call calldata call</span>
 11 |     | <span class='neutral'>    ) external returns (bytes4);</span>
 12 |     | <span class='neutral'>}</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>interface IERC1363ReceiverExtended {</span>
 15 |     | <span class='neutral'>    function onTransferReceived(</span>
 16 |     | <span class='neutral'>        address operator,</span>
 17 |     | <span class='neutral'>        address token,</span>
 18 |     | <span class='neutral'>        uint256 value,</span>
 19 |     | <span class='neutral'>        bytes calldata data</span>
 20 |     | <span class='neutral'>    ) external returns (bytes4);</span>
 21 |     | <span class='neutral'>}</span>
 22 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/interfaces/IERC20ValueOracle.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IERC20ValueOracle {</span>
  5 |     | <span class='neutral'>    function calcValue(</span>
  6 |     | <span class='neutral'>        int256 balance</span>
  7 |     | <span class='neutral'>    ) external view returns (int256 value, int256 riskAdjustedValue);</span>
  8 |     | <span class='neutral'>}</span>
  9 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/interfaces/INFTValueOracle.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title NFT Value Oracle Interface</span>
  5 |     | <span class='neutral'>interface INFTValueOracle {</span>
  6 |     | <span class='neutral'>    function calcValue(</span>
  7 |     | <span class='neutral'>        uint256 tokenId</span>
  8 |     | <span class='neutral'>    ) external view returns (int256 value, int256 riskAdjustedValue);</span>
  9 |     | <span class='neutral'>}</span>
 10 | r   | <span class='reverted'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/interfaces/ISafe.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {Call} from &quot;../lib/Call.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface ISafe {</span>
  7 |     | <span class='neutral'>    event TokensApproved(address sender, uint256 amount, bytes data);</span>
  8 |     | <span class='neutral'>    event TokensReceived(address spender, address sender, uint256 amount, bytes data);</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    function executeBatch(Call[] memory calls) external payable;</span>
 11 |     | <span class='neutral'>}</span>
 12 | r   | <span class='reverted'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/interfaces/ITransferReceiver2.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/utils/Address.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>// This address is in flux as long as the bytecode of this contract is not fixed. For now</span>
  9 |     | <span class='neutral'>// we deploy it on local block chain on fixed address, when we go deploy this needs to change</span>
 10 |     | <span class='neutral'>// to the permanent address.</span>
 11 |     | <span class='neutral'>address constant TRANSFER_AND_CALL2 = address(0x4e765952997a33893AfB4457A6A7f381909f3629);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>// Contracts that implement can receive multiple ERC20 transfers in a single transaction,</span>
 14 |     | <span class='neutral'>// with backwards compatibility for legacy ERC20&#39;s not implementing ERC677.</span>
 15 |     | <span class='neutral'>abstract contract ITransferReceiver2 {</span>
 16 |     | <span class='neutral'>    error InvalidSender(address sender);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    struct Transfer {</span>
 19 |     | <span class='neutral'>        address token;</span>
 20 |     | <span class='neutral'>        uint256 amount;</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    /// @dev Called by a token to indicate a transfer into the callee</span>
 24 |     | <span class='neutral'>    /// @param operator The account that initiated the transfer</span>
 25 |     | <span class='neutral'>    /// @param from The account that has sent the token</span>
 26 |     | <span class='neutral'>    /// @param transfers Transfers that have been made</span>
 27 |     | <span class='neutral'>    /// @param data The extra data being passed to the receiving contract</span>
 28 |     | <span class='neutral'>    function onTransferReceived2(</span>
 29 |     | <span class='neutral'>        address operator,</span>
 30 |     | <span class='neutral'>        address from,</span>
 31 |     | <span class='neutral'>        Transfer[] calldata transfers,</span>
 32 |     | <span class='neutral'>        bytes calldata data</span>
 33 |     | <span class='unexecuted'>    ) external virtual returns (bytes4);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    modifier onlyTransferAndCall2() {</span>
 36 |     | <span class='unexecuted'>        if (msg.sender != TRANSFER_AND_CALL2) revert InvalidSender(msg.sender);</span>
 37 |     | <span class='neutral'>        _;</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'>}</span>
 40 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/interfaces/IVersionManager.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @notice version is not registered</span>
  5 |     | <span class='neutral'>error VersionNotRegistered();</span>
  6 |     | <span class='neutral'>/// @notice version name cannot be the empty string</span>
  7 |     | <span class='neutral'>error InvalidVersionName();</span>
  8 |     | <span class='neutral'>/// @notice implementation must be a contract</span>
  9 |     | <span class='neutral'>error InvalidImplementation();</span>
 10 |     | <span class='neutral'>/// @notice version is already registered</span>
 11 |     | <span class='neutral'>error VersionAlreadyRegistered();</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>interface IVersionManager {</span>
 14 |     | <span class='neutral'>    /// @dev Signifies the status of a version</span>
 15 |     | <span class='neutral'>    enum Status {</span>
 16 |     | <span class='neutral'>        BETA,</span>
 17 |     | <span class='neutral'>        RC,</span>
 18 |     | <span class='neutral'>        PRODUCTION,</span>
 19 |     | <span class='neutral'>        DEPRECATED</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    /// @dev Indicated the highest level of bug found in the version</span>
 23 |     | <span class='neutral'>    enum BugLevel {</span>
 24 |     | <span class='neutral'>        NONE,</span>
 25 |     | <span class='neutral'>        LOW,</span>
 26 |     | <span class='neutral'>        MEDIUM,</span>
 27 |     | <span class='neutral'>        HIGH,</span>
 28 |     | <span class='neutral'>        CRITICAL</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    /// @dev A struct to encode version details</span>
 32 |     | <span class='neutral'>    struct Version {</span>
 33 |     | <span class='neutral'>        // the version number string ex. &quot;v1.0&quot;</span>
 34 |     | <span class='neutral'>        string versionName;</span>
 35 |     | <span class='neutral'>        Status status;</span>
 36 |     | <span class='neutral'>        BugLevel bugLevel;</span>
 37 |     | <span class='neutral'>        // the address of the instantiation of the version</span>
 38 |     | <span class='neutral'>        address implementation;</span>
 39 |     | <span class='neutral'>        // the date when this version was registered with the contract</span>
 40 |     | <span class='neutral'>        uint256 dateAdded;</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    event VersionAdded(string versionName, address indexed implementation);</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='neutral'>    event VersionUpdated(string versionName, Status status, BugLevel bugLevel);</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    event VersionRecommended(string versionName);</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='neutral'>    event RecommendedVersionRemoved();</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='neutral'>    function addVersion(Status status, address implementation) external;</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='neutral'>    function updateVersion(string calldata versionName, Status status, BugLevel bugLevel) external;</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='neutral'>    function markRecommendedVersion(string calldata versionName) external;</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='neutral'>    function removeRecommendedVersion() external;</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='neutral'>    function getRecommendedVersion()</span>
 60 |     | <span class='neutral'>        external</span>
 61 |     | <span class='neutral'>        view</span>
 62 |     | <span class='neutral'>        returns (</span>
 63 |     | <span class='neutral'>            string memory versionName,</span>
 64 |     | <span class='neutral'>            Status status,</span>
 65 |     | <span class='neutral'>            BugLevel bugLevel,</span>
 66 |     | <span class='neutral'>            address implementation,</span>
 67 |     | <span class='neutral'>            uint256 dateAdded</span>
 68 |     | <span class='neutral'>        );</span>
 69 |     | <span class='neutral'></span>
 70 |     | <span class='neutral'>    function getVersionCount() external view returns (uint256 count);</span>
 71 |     | <span class='neutral'></span>
 72 |     | <span class='neutral'>    function getVersionAtIndex(uint256 index) external view returns (string memory versionName);</span>
 73 |     | <span class='neutral'></span>
 74 |     | <span class='neutral'>    function getVersionAddress(uint256 index) external view returns (address);</span>
 75 |     | <span class='neutral'></span>
 76 |     | <span class='neutral'>    function getVersionDetails(</span>
 77 |     | <span class='neutral'>        string calldata versionName</span>
 78 |     | <span class='neutral'>    )</span>
 79 |     | <span class='neutral'>        external</span>
 80 |     | <span class='neutral'>        view</span>
 81 |     | <span class='neutral'>        returns (</span>
 82 |     | <span class='neutral'>            string memory versionString,</span>
 83 |     | <span class='neutral'>            Status status,</span>
 84 |     | <span class='neutral'>            BugLevel bugLevel,</span>
 85 |     | <span class='neutral'>            address implementation,</span>
 86 |     | <span class='neutral'>            uint256 dateAdded</span>
 87 |     | <span class='neutral'>        );</span>
 88 |     | <span class='neutral'>}</span>
 89 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/lib/AccessControl.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../tokens/HashNFT.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;../lib/FsUtils.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;./ImmutableGovernance.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/// @title AccessControl</span>
  9 |     | <span class='neutral'>/// @notice Access control based on HashNFT ownership.</span>
 10 |     | <span class='neutral'>/// @dev The owner can grant access rights to an address by minting a HashNFT token</span>
 11 |     | <span class='neutral'>/// to the address with the given access level.</span>
 12 |     | <span class='neutral'>contract AccessControl is ImmutableGovernance {</span>
 13 |     | <span class='neutral'>    enum AccessLevel {</span>
 14 |     | <span class='neutral'>        SECURITY, // Can operate immediately on pausing exchange</span>
 15 |     | <span class='neutral'>        FINANCIAL_RISK // Can set fees, risk factors and interest rates</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    HashNFT internal immutable hashNFT;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    constructor(address owner, address hashNFT_) ImmutableGovernance(owner) {</span>
 21 |     | <span class='neutral'>        hashNFT = HashNFT(FsUtils.nonNull(hashNFT_));</span>
 22 |     | <span class='neutral'>        require(</span>
 23 |     | <span class='neutral'>            hashNFT.supportsInterface(type(IERC1155).interfaceId),</span>
 24 |     | <span class='neutral'>            &quot;AccessControl: not HashNFT&quot;</span>
 25 |     | <span class='neutral'>        );</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>    function mintAccess(</span>
 29 |     | <span class='neutral'>        address to,</span>
 30 |     | <span class='neutral'>        uint256 accessLevel,</span>
 31 |     | <span class='neutral'>        bytes calldata data</span>
 32 |     | <span class='neutral'>    ) external onlyGovernance {</span>
 33 |     | <span class='neutral'>        hashNFT.mint(to, bytes32(accessLevel), data);</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    function revokeAccess(address from, uint256 accessLevel) external onlyGovernance {</span>
 37 |     | <span class='neutral'>        hashNFT.revoke(from, bytes32(accessLevel));</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    function hasAccess(address account, uint256 accessLevel) public view returns (bool) {</span>
 41 |     | <span class='neutral'>        return</span>
 42 |     | <span class='neutral'>            hashNFT.balanceOf(account, hashNFT.toTokenId(address(this), bytes32(accessLevel))) &gt; 0;</span>
 43 |     | <span class='neutral'>    }</span>
 44 |     | <span class='neutral'>}</span>
 45 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/lib/Call.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/utils/Address.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @title A serialized contract method call.</span>
   8 |     | <span class='neutral'> *</span>
   9 |     | <span class='neutral'> * @notice A call to a contract with no native value transferred as part of the call.</span>
  10 |     | <span class='neutral'> *</span>
  11 |     | <span class='neutral'> * We often need to pass calls around, so this is a common representation to use.</span>
  12 |     | <span class='neutral'> */</span>
  13 |     | <span class='neutral'>struct CallWithoutValue {</span>
  14 |     | <span class='neutral'>    address to;</span>
  15 |     | <span class='neutral'>    bytes callData;</span>
  16 |     | <span class='neutral'>}</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>/**</span>
  19 |     | <span class='neutral'> * @title A serialized contract method call, with value.</span>
  20 |     | <span class='neutral'> *</span>
  21 |     | <span class='unexecuted'> * @notice A call to a contract that may also have native value transferred as part of the call.</span>
  22 |     | <span class='neutral'> *</span>
  23 |     | <span class='neutral'> * We often need to pass calls around, so this is a common representation to use.</span>
  24 |     | <span class='neutral'> */</span>
  25 |     | <span class='neutral'>struct Call {</span>
  26 |     | <span class='neutral'>    address to;</span>
  27 |     | <span class='neutral'>    bytes callData;</span>
  28 |     | <span class='neutral'>    uint256 value;</span>
  29 |     | <span class='neutral'>}</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>library CallLib {</span>
  32 |     | <span class='neutral'>    using Address for address;</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='unexecuted'>    bytes internal constant CALL_TYPESTRING = &quot;Call(address to,bytes callData,uint256 value)&quot;;</span>
  35 |     | <span class='unexecuted'>    bytes32 constant CALL_TYPEHASH = keccak256(CALL_TYPESTRING);</span>
  36 |     | <span class='neutral'>    bytes internal constant CALLWITHOUTVALUE_TYPESTRING =</span>
  37 |     | <span class='neutral'>        &quot;CallWithoutValue(address to,bytes callData)&quot;;</span>
  38 |     | <span class='neutral'>    bytes32 constant CALLWITHOUTVALUE_TYPEHASH = keccak256(CALLWITHOUTVALUE_TYPESTRING);</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    /**</span>
  41 |     | <span class='neutral'>     * @notice Execute a call.</span>
  42 |     | <span class='neutral'>     *</span>
  43 |     | <span class='neutral'>     * @param call The call to execute.</span>
  44 |     | <span class='neutral'>     */</span>
  45 |     | <span class='neutral'>    function executeWithoutValue(CallWithoutValue memory call) internal {</span>
  46 |     | <span class='neutral'>        call.to.functionCall(call.callData);</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    /**</span>
  50 |     | <span class='neutral'>     * @notice Execute a call with value.</span>
  51 |     | <span class='neutral'>     *</span>
  52 |     | <span class='neutral'>     * @param call The call to execute.</span>
  53 |     | <span class='neutral'>     */</span>
  54 |     | <span class='neutral'>    function execute(Call memory call) internal {</span>
  55 |     | <span class='neutral'>        call.to.functionCallWithValue(call.callData, call.value);</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    /**</span>
  59 |     | <span class='neutral'>     * @notice Execute a batch of calls.</span>
  60 |     | <span class='neutral'>     *</span>
  61 |     | <span class='neutral'>     * @param calls The calls to execute.</span>
  62 |     | <span class='neutral'>     */</span>
  63 |     | <span class='neutral'>    function executeBatch(Call[] memory calls) internal {</span>
  64 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; calls.length; i++) {</span>
  65 |     | <span class='neutral'>            execute(calls[i]);</span>
  66 |     | <span class='neutral'>        }</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    /**</span>
  70 |     | <span class='neutral'>     * @notice Execute a batch of calls with value.</span>
  71 |     | <span class='neutral'>     *</span>
  72 |     | <span class='neutral'>     * @param calls The calls to execute.</span>
  73 |     | <span class='neutral'>     */</span>
  74 |     | <span class='neutral'>    function executeBatchWithoutValue(CallWithoutValue[] memory calls) internal {</span>
  75 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; calls.length; i++) {</span>
  76 |     | <span class='neutral'>            executeWithoutValue(calls[i]);</span>
  77 |     | <span class='neutral'>        }</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    function hashCall(Call memory call) internal pure returns (bytes32) {</span>
  81 |     | <span class='neutral'>        return keccak256(abi.encode(CALL_TYPEHASH, call.to, keccak256(call.callData), call.value));</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    function hashCallArray(Call[] memory calls) internal pure returns (bytes32) {</span>
  85 |     | <span class='neutral'>        bytes32[] memory hashes = new bytes32[](calls.length);</span>
  86 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; calls.length; i++) {</span>
  87 |     | <span class='neutral'>            hashes[i] = hashCall(calls[i]);</span>
  88 |     | <span class='neutral'>        }</span>
  89 |     | <span class='neutral'>        return keccak256(abi.encodePacked(hashes));</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    function hashCallWithoutValue(CallWithoutValue memory call) internal pure returns (bytes32) {</span>
  93 |     | <span class='neutral'>        return keccak256(abi.encode(CALLWITHOUTVALUE_TYPEHASH, call.to, keccak256(call.callData)));</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    function hashCallWithoutValueArray(</span>
  97 |     | <span class='neutral'>        CallWithoutValue[] memory calls</span>
  98 |     | <span class='neutral'>    ) internal pure returns (bytes32) {</span>
  99 |     | <span class='neutral'>        bytes32[] memory hashes = new bytes32[](calls.length);</span>
 100 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; calls.length; i++) {</span>
 101 |     | <span class='neutral'>            hashes[i] = hashCallWithoutValue(calls[i]);</span>
 102 |     | <span class='neutral'>        }</span>
 103 |     | <span class='neutral'>        return keccak256(abi.encodePacked(hashes));</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'>}</span>
 106 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/lib/FsMath.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./FsUtils.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @title Utility methods basic math operations.</span>
   8 |     | <span class='neutral'> *</span>
   9 |     | <span class='neutral'> * NOTE In order for the fuzzing tests to be isolated, all functions in this library need to be</span>
  10 |     | <span class='neutral'> * `internal`.  Otherwise a contract that uses this library has a dependency on the library.</span>
  11 |     | <span class='neutral'> *</span>
  12 |     | <span class='neutral'> * Our current Echidna setup requires contracts to be deployable in isolation, so make sure to keep</span>
  13 |     | <span class='neutral'> * the functions `internal`, until we update our Echidna tests to support more complex setups.</span>
  14 |     | <span class='neutral'> */</span>
  15 |     | <span class='neutral'>library FsMath {</span>
  16 |     | <span class='neutral'>    /**</span>
  17 |     | <span class='neutral'>     * @notice Size of `FIXED_POINT_SCALE` in bits.</span>
  18 |     | <span class='neutral'>     */</span>
  19 |     | <span class='neutral'>    int256 constant FIXED_POINT_SCALE_BITS = 64;</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    /**</span>
  22 |     | <span class='neutral'>     * @notice Scaling factor used by our fixed-point integer representation.</span>
  23 |     | <span class='neutral'>     *</span>
  24 |     | <span class='neutral'>     * We chose `FIXED_POINT_SCALE` to be a power of 2 to make certain optimizations in the</span>
  25 |     | <span class='neutral'>     * calculation of `e^x` more efficient.  See `exp()` implementation for details.</span>
  26 |     | <span class='neutral'>     *</span>
  27 |     | <span class='neutral'>     * See https://en.wikipedia.org/wiki/Fixed-point_arithmetic</span>
  28 |     | <span class='neutral'>     */</span>
  29 |     | <span class='neutral'>    int256 constant FIXED_POINT_SCALE = int256(1) &lt;&lt; uint256(FIXED_POINT_SCALE_BITS);</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    uint256 constant UINT256_MAX = ~uint256(0);</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    function abs(int256 value) internal pure returns (uint256) {</span>
  34 |     | <span class='neutral'>        if (value &gt;= 0) {</span>
  35 |     | <span class='neutral'>            // slither-disable-next-line safe-cast</span>
  36 |     | <span class='neutral'>            return uint256(value);</span>
  37 |     | <span class='neutral'>        }</span>
  38 |     | <span class='neutral'>        // slither-disable-next-line safe-cast</span>
  39 |     | <span class='neutral'>        return uint256(-value);</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    function sabs(int256 value) internal pure returns (int256) {</span>
  43 |     | <span class='neutral'>        if (value &gt;= 0) {</span>
  44 |     | <span class='neutral'>            return value;</span>
  45 |     | <span class='neutral'>        }</span>
  46 |     | <span class='neutral'>        return -value;</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    function sign(int256 value) internal pure returns (int256) {</span>
  50 |     | <span class='neutral'>        if (value &lt; 0) {</span>
  51 |     | <span class='neutral'>            return -1;</span>
  52 |     | <span class='neutral'>        } else if (value &gt; 0) {</span>
  53 |     | <span class='neutral'>            return 1;</span>
  54 |     | <span class='neutral'>        } else {</span>
  55 |     | <span class='neutral'>            return 0;</span>
  56 |     | <span class='neutral'>        }</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    function min(int256 a, int256 b) internal pure returns (int256) {</span>
  60 |     | <span class='neutral'>        return a &lt; b ? a : b;</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    function max(int256 a, int256 b) internal pure returns (int256) {</span>
  64 |     | <span class='neutral'>        return a &gt; b ? a : b;</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    // Clip val into interval [lower, upper]</span>
  68 |     | <span class='neutral'>    function clip(int256 val, int256 lower, int256 upper) internal pure returns (int256) {</span>
  69 |     | <span class='neutral'>        return min(max(val, lower), upper);</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    function safeCastToSigned(uint256 x) internal pure returns (int256) {</span>
  73 |     | <span class='neutral'>        // slither-disable-next-line safe-cast</span>
  74 |     | <span class='neutral'>        int256 ret = int256(x);</span>
  75 |     | <span class='neutral'>        require(ret &gt;= 0, &quot;Cast overflow&quot;);</span>
  76 |     | <span class='neutral'>        return ret;</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    function safeCastToUnsigned(int256 x) internal pure returns (uint256) {</span>
  80 |     | <span class='neutral'>        require(x &gt;= 0, &quot;Cast underflow&quot;);</span>
  81 |     | <span class='neutral'>        // slither-disable-next-line safe-cast</span>
  82 |     | <span class='neutral'>        return uint256(x);</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    /**</span>
  86 |     | <span class='neutral'>     * @notice Calculate `e^x`.</span>
  87 |     | <span class='neutral'>     *</span>
  88 |     | <span class='neutral'>     * @param x Is a fixed point decimals with the scale of `FIXED_POINT_SCALE`.</span>
  89 |     | <span class='neutral'>     * @return A fixed point decimals with the scale of `FIXED_POINT_SCALE`.</span>
  90 |     | <span class='neutral'>     */</span>
  91 |     | <span class='neutral'>    function exp(int256 x) internal pure returns (int256) {</span>
  92 |     | <span class='neutral'>        /*</span>
  93 |     | <span class='neutral'>         * Making fixed point representation explicit we want to compute</span>
  94 |     | <span class='neutral'>         *</span>
  95 |     | <span class='neutral'>         * result = e^(x / FIXED_POINT_SCALE) * FIXED_POINT_SCALE</span>
  96 |     | <span class='neutral'>         *</span>
  97 |     | <span class='neutral'>         * To efficiently and accurately calculate the above expression we decompose this into 3</span>
  98 |     | <span class='neutral'>         * parts where each part has an efficient and accurate method of calculation.</span>
  99 |     | <span class='neutral'>         *</span>
 100 |     | <span class='neutral'>         * First, we transform the exponentiation into base 2 so we can use shifts:</span>
 101 |     | <span class='neutral'>         *</span>
 102 |     | <span class='neutral'>         *   e^(x / FIXED_POINT_SCALE) * FIXED_POINT_SCALE</span>
 103 |     | <span class='neutral'>         * = 2^(x / FIXED_POINT_SCALE / ln(2)) * FIXED_POINT_SCALE</span>
 104 |     | <span class='neutral'>         * = 2^(x / ln2FixedPoint) * FIXED_POINT_SCALE</span>
 105 |     | <span class='neutral'>         * = 2^integerQuot * 2^(rem / ln2FixedPoint) * FIXED_POINT_SCALE</span>
 106 |     | <span class='neutral'>         */</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>        FsUtils.Assert(FIXED_POINT_SCALE_BITS == 64);</span>
 109 |     | <span class='neutral'>        /*</span>
 110 |     | <span class='neutral'>         * ln(2) * 2^FIXED_POINT_SCALE_BITS = ln(2) * 2^64</span>
 111 |     | <span class='neutral'>         */</span>
 112 |     | <span class='neutral'>        int256 ln2FixedPoint = 12786308645202655659;</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>        int256 shiftLeft = x / ln2FixedPoint;</span>
 115 |     | <span class='neutral'>        int256 remainder = x % ln2FixedPoint;</span>
 116 |     | <span class='neutral'>        if (shiftLeft &lt;= -FIXED_POINT_SCALE_BITS) return 0;</span>
 117 |     | <span class='neutral'>        require(shiftLeft &lt; (256 - FIXED_POINT_SCALE_BITS), &quot;Exponentiation overflows&quot;);</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>        /*</span>
 120 |     | <span class='neutral'>         * At this point we have decomposed exp as a simple bitshift and a fractional power of 2. We</span>
 121 |     | <span class='neutral'>         * could express this as an integer power like</span>
 122 |     | <span class='neutral'>         *</span>
 123 |     | <span class='neutral'>         *      (2^(1/ln2FixedPoint))^remainder</span>
 124 |     | <span class='neutral'>         *</span>
 125 |     | <span class='neutral'>         * but `remainder` is very big, in the order of `10^19` resulting in ~60 (2log) iteration in</span>
 126 |     | <span class='neutral'>         * repeated squaring but more problematic also a lot of precision loss. It turns out that</span>
 127 |     | <span class='neutral'>         * `ln2FixedPoint` as an integer has a smallish factor.</span>
 128 |     | <span class='neutral'>         */</span>
 129 |     | <span class='neutral'>        int256 smallFactor = 4373;</span>
 130 |     | <span class='neutral'>        int256 bigFactor = ln2FixedPoint / smallFactor;</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>        /*</span>
 133 |     | <span class='neutral'>         * Split</span>
 134 |     | <span class='neutral'>         *</span>
 135 |     | <span class='neutral'>         *      2^(remainder/ln2FixedPoint)</span>
 136 |     | <span class='neutral'>         *</span>
 137 |     | <span class='neutral'>         * as</span>
 138 |     | <span class='neutral'>         *</span>
 139 |     | <span class='neutral'>         *      (2^(1/smallFactor)) ^ (remainder/bigFactor)</span>
 140 |     | <span class='neutral'>         */</span>
 141 |     | <span class='neutral'>        int256 integerPower = remainder / bigFactor;</span>
 142 |     | <span class='neutral'>        int256 smallRemainder = remainder % bigFactor;</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>        /*</span>
 145 |     | <span class='neutral'>         * So we can further decompose as follows:</span>
 146 |     | <span class='neutral'>         *</span>
 147 |     | <span class='neutral'>         * (2^(1/smallFactor))^(integerPower) * exp(smallRemainder/fixedPoint)</span>
 148 |     | <span class='neutral'>         *</span>
 149 |     | <span class='neutral'>         * where in the last factor base 2 is replaced with an ordinary e-power using ln2.</span>
 150 |     | <span class='neutral'>         *</span>
 151 |     | <span class='neutral'>         * At this point `0 &lt;= integerPower &lt; smallFactor` and `0 &lt;= smallRemainder &lt; bigFactor`.</span>
 152 |     | <span class='neutral'>         * The first range implies that repeated exponentiation of the first factor won&#39;t loop too</span>
 153 |     | <span class='neutral'>         * much and has rather good precision.  The second range implies that</span>
 154 |     | <span class='neutral'>         * `smallRemainder/FIXED_POINT_SCALE &lt; 1/4373` so that the Taylor expansion rapidly</span>
 155 |     | <span class='neutral'>         * converges.</span>
 156 |     | <span class='neutral'>         */</span>
 157 |     | <span class='neutral'>        int256 taylorApprox = FIXED_POINT_SCALE +</span>
 158 |     | <span class='neutral'>            smallRemainder +</span>
 159 |     | <span class='neutral'>            (smallRemainder * smallRemainder) /</span>
 160 |     | <span class='neutral'>            (2 * FIXED_POINT_SCALE) +</span>
 161 |     | <span class='neutral'>            (smallRemainder * smallRemainder * smallRemainder) /</span>
 162 |     | <span class='neutral'>            (6 * FIXED_POINT_SCALE * FIXED_POINT_SCALE);</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>        int256 twoPowRecipSmallFactor = 18449668226934502855; // 2^(1/smallFactor) in fixed point</span>
 165 |     | <span class='neutral'>        int256 prod;</span>
 166 |     | <span class='neutral'>        if (integerPower &gt;= 0) {</span>
 167 |     | <span class='neutral'>            /*</span>
 168 |     | <span class='neutral'>             * This implies shiftLeft &gt;= 0 we don&#39;t want to lose precision by first dividing and</span>
 169 |     | <span class='neutral'>             * subsequent shifting left.</span>
 170 |     | <span class='neutral'>             */</span>
 171 |     | <span class='neutral'>            prod = pow(twoPowRecipSmallFactor, integerPower) * taylorApprox;</span>
 172 |     | <span class='neutral'>            shiftLeft -= FIXED_POINT_SCALE_BITS;</span>
 173 |     | <span class='neutral'>        } else {</span>
 174 |     | <span class='neutral'>            /*</span>
 175 |     | <span class='neutral'>             * This implies shiftLeft &lt;= 0 so we&#39;re losing precision anyway.</span>
 176 |     | <span class='neutral'>             */</span>
 177 |     | <span class='neutral'>            prod = (FIXED_POINT_SCALE * taylorApprox) / pow(twoPowRecipSmallFactor, -integerPower);</span>
 178 |     | <span class='neutral'>        }</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>        return shiftLeft &gt;= 0 ? (prod &lt;&lt; uint256(shiftLeft)) : (prod &gt;&gt; uint256(-shiftLeft));</span>
 181 |     | <span class='neutral'>    }</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>    /**</span>
 184 |     | <span class='neutral'>     * @notice Calculates `x^n`</span>
 185 |     | <span class='neutral'>     *</span>
 186 |     | <span class='neutral'>     * Note we cannot use solidity `**` as we have to normalize fixed point after every</span>
 187 |     | <span class='neutral'>     * multiplication.</span>
 188 |     | <span class='neutral'>     *</span>
 189 |     | <span class='neutral'>     * @param x  a `FIXED_POINT_SCALE` fixed point decimal, with a scale of `FIXED_POINT_SCALE`.</span>
 190 |     | <span class='neutral'>     * @param n  an integer.</span>
 191 |     | <span class='neutral'>     */</span>
 192 |     | <span class='neutral'>    function pow(int256 x, int256 n) internal pure returns (int256) {</span>
 193 |     | <span class='neutral'>        if (n &gt;= 0) {</span>
 194 |     | <span class='neutral'>            return powInternal(x, n);</span>
 195 |     | <span class='neutral'>        } else {</span>
 196 |     | <span class='neutral'>            return powInternal((FIXED_POINT_SCALE * FIXED_POINT_SCALE) / x, -n);</span>
 197 |     | <span class='neutral'>        }</span>
 198 |     | <span class='neutral'>    }</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>    /**</span>
 201 |     | <span class='neutral'>     * @notice Calculates square root of `x`, in fixed point decimal with a scale of</span>
 202 |     | <span class='neutral'>     * `FIXED_POINT_SCALE`.</span>
 203 |     | <span class='neutral'>     *</span>
 204 |     | <span class='neutral'>     * @param x  a `FIXED_POINT_SCALE` fixed point decimal, with a scale of `FIXED_POINT_SCALE`.</span>
 205 |     | <span class='neutral'>     */</span>
 206 |     | <span class='neutral'>    function sqrt(int256 x) internal pure returns (int256) {</span>
 207 |     | <span class='neutral'>        require(x &gt;= 0, &quot;Square root of negative number&quot;);</span>
 208 |     | <span class='neutral'>        int256 prevRes = 0;</span>
 209 |     | <span class='neutral'>        int256 res = x / 2;</span>
 210 |     | <span class='neutral'>        while (res != prevRes) {</span>
 211 |     | <span class='neutral'>            prevRes = res;</span>
 212 |     | <span class='neutral'>            res = (res + (x &lt;&lt; uint256(FIXED_POINT_SCALE_BITS)) / res) / 2;</span>
 213 |     | <span class='neutral'>        }</span>
 214 |     | <span class='neutral'>        return res;</span>
 215 |     | <span class='neutral'>    }</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='neutral'>    // See https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation</span>
 218 |     | <span class='neutral'>    function bitCount(uint256 x) internal pure returns (uint256) {</span>
 219 |     | <span class='neutral'>        // In this routine we purposefully interpret x as a number in Z mod (2^256) in the</span>
 220 |     | <span class='neutral'>        // multiplication.</span>
 221 |     | <span class='neutral'>        unchecked {</span>
 222 |     | <span class='neutral'>            if (x == UINT256_MAX) return 256;</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='neutral'>            // Count 1&#39;s in 128 2-bit groups</span>
 225 |     | <span class='neutral'>            uint256 mask = UINT256_MAX / 3; // 0x5555...</span>
 226 |     | <span class='neutral'>            // Special case (x &amp; mask) + ((x &gt;&gt; 1) &amp; mask) equals formula below with less</span>
 227 |     | <span class='neutral'>            // instructions.</span>
 228 |     | <span class='neutral'>            x = x - ((x &gt;&gt; 1) &amp; mask);</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='neutral'>            // Count 1&#39;s in 64 4-bit groups</span>
 231 |     | <span class='neutral'>            mask = UINT256_MAX / 5; // 0x3333....</span>
 232 |     | <span class='neutral'>            x = (x &amp; mask) + ((x &gt;&gt; 2) &amp; mask);</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='neutral'>            // Count 1&#39;s in 32 8-bit groups. Note At this point there is no danger of overflowing</span>
 235 |     | <span class='neutral'>            // between count of groups so we can have</span>
 236 |     | <span class='neutral'>            // (x &amp; mask) + ((x &gt;&gt; n) &amp; mask) = (x + (x &gt;&gt; n)) &amp; mask</span>
 237 |     | <span class='neutral'>            // which saves an instruction</span>
 238 |     | <span class='neutral'>            mask = UINT256_MAX / 17; // 0x0F0F...</span>
 239 |     | <span class='neutral'>            x = (x + (x &gt;&gt; 4)) &amp; mask;</span>
 240 |     | <span class='neutral'></span>
 241 |     | <span class='neutral'>            // At this point we have the count of each of the 32 bytes. In 8 bits we can store</span>
 242 |     | <span class='neutral'>            // 0 to 255, so only UINT_MAX would overflow when represented in a single byte, which</span>
 243 |     | <span class='neutral'>            // is case we have excluded. So we can calculate the</span>
 244 |     | <span class='neutral'>            mask = UINT256_MAX / 255;</span>
 245 |     | <span class='neutral'>            x = (x * mask) &gt;&gt; (256 - 8);</span>
 246 |     | <span class='neutral'>        }</span>
 247 |     | <span class='neutral'>        return x;</span>
 248 |     | <span class='neutral'>    }</span>
 249 |     | <span class='neutral'></span>
 250 |     | <span class='neutral'>    /**</span>
 251 |     | <span class='neutral'>     * @notice A helper used by `pow`, that expects that `n` is positive.</span>
 252 |     | <span class='neutral'>     */</span>
 253 |     | <span class='neutral'>    function powInternal(int256 x, int256 n) private pure returns (int256) {</span>
 254 |     | <span class='neutral'>        int256 res = FIXED_POINT_SCALE;</span>
 255 |     | <span class='neutral'>        while (n &gt; 0) {</span>
 256 |     | <span class='neutral'>            if ((n &amp; 1) == 1) {</span>
 257 |     | <span class='neutral'>                res = (res * x) / FIXED_POINT_SCALE;</span>
 258 |     | <span class='neutral'>            }</span>
 259 |     | <span class='neutral'>            x = (x * x) / FIXED_POINT_SCALE;</span>
 260 |     | <span class='neutral'>            n /= 2;</span>
 261 |     | <span class='neutral'>        }</span>
 262 |     | <span class='neutral'>        return res;</span>
 263 |     | <span class='neutral'>    }</span>
 264 |     | <span class='neutral'>}</span>
 265 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/lib/FsUtils.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>// BEGIN STRIP</span>
  5 |     | <span class='neutral'>// Used in `FsUtils.log` which is a debugging tool.</span>
  6 |     | <span class='neutral'>import &quot;hardhat/console.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>// END STRIP</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>library FsUtils {</span>
 11 |     | <span class='neutral'>    // BEGIN STRIP</span>
 12 |     | <span class='neutral'>    // This method is only mean to be used in local testing.  See `preprocess` property in</span>
 13 |     | <span class='neutral'>    // `packages/contracts/hardhat.config.ts`.</span>
 14 |     | <span class='neutral'>    // Slither sees this function is not used, but it is convenient to have it around for debugging</span>
 15 |     | <span class='neutral'>    // purposes.</span>
 16 |     | <span class='neutral'>    // slither-disable-next-line dead-code</span>
 17 |     | <span class='unexecuted'>    function log(string memory s) internal view {</span>
 18 |     | <span class='neutral'>        console.log(s);</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    // This method is only mean to be used in local testing.  See `preprocess` property in</span>
 22 |     | <span class='neutral'>    // `packages/contracts/hardhat.config.ts`.</span>
 23 |     | <span class='neutral'>    // Slither sees this function is not used, but it is convenient to have it around for debugging</span>
 24 |     | <span class='neutral'>    // purposes.</span>
 25 |     | <span class='neutral'>    // slither-disable-next-line dead-code</span>
 26 |     | <span class='neutral'>    function log(string memory s, int256 x) internal view {</span>
 27 |     | <span class='neutral'>        console.log(s);</span>
 28 |     | <span class='neutral'>        console.logInt(x);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function log(string memory s, address x) internal view {</span>
 32 |     | <span class='neutral'>        console.log(s, x);</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    // END STRIP</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    function encodeToBytes32(bytes memory b) internal pure returns (bytes32) {</span>
 38 |     | <span class='neutral'>        require(b.length &lt; 32, &quot;Byte array to long&quot;);</span>
 39 |     | <span class='neutral'>        bytes32 out = bytes32(b);</span>
 40 |     | <span class='neutral'>        out = (out &amp; (~(bytes32(type(uint256).max) &gt;&gt; (8 * b.length)))) | bytes32(b.length);</span>
 41 |     | <span class='neutral'>        return out;</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    function decodeFromBytes32(bytes32 b) internal pure returns (bytes memory) {</span>
 45 |     | <span class='neutral'>        uint256 len = uint256(b) &amp; 0xff;</span>
 46 |     | <span class='neutral'>        bytes memory out = new bytes(len);</span>
 47 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; len; i++) {</span>
 48 |     | <span class='neutral'>            out[i] = b[i];</span>
 49 |     | <span class='neutral'>        }</span>
 50 |     | <span class='neutral'>        return out;</span>
 51 |     | <span class='neutral'>    }</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='neutral'>    function nonNull(address _address) internal pure returns (address) {</span>
 54 |     | <span class='neutral'>        require(_address != address(0), &quot;Zero address&quot;);</span>
 55 |     | <span class='neutral'>        return _address;</span>
 56 |     | <span class='neutral'>    }</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='neutral'>    function revertBytes(bytes memory b) internal pure {</span>
 59 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
 60 |     | <span class='neutral'>            revert(add(b, 0x20), mload(b))</span>
 61 |     | <span class='neutral'>        }</span>
 62 |     | <span class='neutral'>    }</span>
 63 |     | <span class='neutral'></span>
 64 |     | <span class='neutral'>    // assert a condition. Assert should be used to assert an invariant that should be true</span>
 65 |     | <span class='neutral'>    // logically.</span>
 66 |     | <span class='neutral'>    // This is useful for readability and debugability. A failing assert is always a bug.</span>
 67 |     | <span class='neutral'>    //</span>
 68 |     | <span class='neutral'>    // In production builds (non-hardhat, and non-localhost deployments) this method is a noop.</span>
 69 |     | <span class='neutral'>    //</span>
 70 |     | <span class='neutral'>    // Use &quot;require&quot; to enforce requirements on data coming from outside of a contract. Ie.,</span>
 71 |     | <span class='neutral'>    //</span>
 72 |     | <span class='neutral'>    // ```solidity</span>
 73 |     | <span class='neutral'>    // function nonNegativeX(int x) external { require(x &gt;= 0, &quot;non-negative&quot;); }</span>
 74 |     | <span class='neutral'>    // ```</span>
 75 |     | <span class='neutral'>    //</span>
 76 |     | <span class='neutral'>    // But</span>
 77 |     | <span class='neutral'>    // ```solidity</span>
 78 |     | <span class='neutral'>    // function nonNegativeX(int x) private { assert(x &gt;= 0); }</span>
 79 |     | <span class='neutral'>    // ```</span>
 80 |     | <span class='neutral'>    //</span>
 81 |     | <span class='neutral'>    // If a private function has a pre-condition that it should only be called with non-negative</span>
 82 |     | <span class='neutral'>    // values it&#39;s a bug in the contract if it&#39;s called with a negative value.</span>
 83 |     | <span class='neutral'>    // solhint-disable-next-line func-name-mixedcase</span>
 84 |     | <span class='neutral'>    function Assert(bool cond) internal pure {</span>
 85 |     | <span class='neutral'>        // BEGIN STRIP</span>
 86 |     | <span class='neutral'>        assert(cond);</span>
 87 |     | <span class='neutral'>        // END STRIP</span>
 88 |     | <span class='neutral'>    }</span>
 89 |     | <span class='neutral'>}</span>
 90 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/lib/GitCommitHash.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>// Contracts deriving from this contract will have a public pure function</span>
  5 |     | <span class='neutral'>// that returns a gitCommitHash at the moment it was compiled.</span>
  6 |     | <span class='neutral'>contract GitCommitHash {</span>
  7 |     | <span class='neutral'>    // A purely random string that&#39;s being replaced in a prod build by</span>
  8 |     | <span class='neutral'>    // the git hash at build time.</span>
  9 |     | <span class='neutral'>    uint256 public immutable gitCommitHash =</span>
 10 |     | <span class='neutral'>        0xDEADBEEFCAFEBABEBEACBABEBA5EBA11B0A710ADB00BBABEDEFACA7EDEADFA11;</span>
 11 |     | <span class='neutral'>}</span>
 12 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/lib/ImmutableGovernance.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./FsUtils.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/// @title ImmutableGovernance</span>
  7 |     | <span class='neutral'>/// @dev This contract is meant to be inherited by other contracts, to make them ownable.</span>
  8 |     | <span class='neutral'>contract ImmutableGovernance {</span>
  9 |     | <span class='neutral'>    address public immutable immutableGovernance;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    modifier onlyGovernance() {</span>
 12 |     | <span class='neutral'>        require(msg.sender == immutableGovernance, &quot;Only owner&quot;);</span>
 13 |     | <span class='neutral'>        _;</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    constructor(address governance) {</span>
 17 |     | <span class='neutral'>        // slither-disable-next-line missing-zero-check</span>
 18 |     | <span class='neutral'>        immutableGovernance = FsUtils.nonNull(governance);</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'>}</span>
 21 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/lib/ImmutableVersion.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./FsUtils.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;./GitCommitHash.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>/// @title ImmutableVersion</span>
  8 |     | <span class='neutral'>/// @dev This contract is meant to be inherited by other contracts, to version them.</span>
  9 |     | <span class='neutral'>/// @notice Inherits from GitCommitHash to tie the version to the commit hash in the git repo.</span>
 10 |     | <span class='neutral'>contract ImmutableVersion is GitCommitHash {</span>
 11 |     | <span class='neutral'>    bytes32 public immutable immutableVersion;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    constructor(string memory _version) {</span>
 14 |     | <span class='neutral'>        require(bytes(_version).length &gt; 0, &quot;Version is empty&quot;);</span>
 15 |     | <span class='neutral'>        immutableVersion = FsUtils.encodeToBytes32(bytes(_version));</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'>}</span>
 18 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/lib/NonceMap.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/utils/structs/BitMaps.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>struct NonceMap {</span>
  7 |     | <span class='neutral'>    BitMaps.BitMap bitMap;</span>
  8 |     | <span class='neutral'>}</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>library NonceMapLib {</span>
 11 |     | <span class='neutral'>    using BitMaps for BitMaps.BitMap;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function validateAndUseNonce(NonceMap storage self, uint256 nonce) internal {</span>
 14 |     | <span class='neutral'>        require(!self.bitMap.get(nonce), &quot;Nonce already used&quot;);</span>
 15 |     | <span class='neutral'>        self.bitMap.set(nonce);</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    function getNonce(NonceMap storage self, uint256 nonce) internal view returns (bool) {</span>
 19 |     | <span class='neutral'>        return self.bitMap.get(nonce);</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'>}</span>
 22 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/lib/Proofs.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./FsUtils.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>type BytesView is uint256;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>type RLPItem is uint256;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>type RLPIterator is uint256;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>library BytesViewLib {</span>
  13 |     | <span class='neutral'>    uint256 private constant WORD_SIZE = 32;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    error OutOfBounds();</span>
  16 |     | <span class='neutral'>    error InvalidScalarEncoding();</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    function mload(uint256 ptr) internal pure returns (bytes32 res) {</span>
  19 |     | <span class='neutral'>        assembly {</span>
  20 |     | <span class='neutral'>            res := mload(ptr)</span>
  21 |     | <span class='neutral'>        }</span>
  22 |     | <span class='neutral'>    }</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    function mstore(uint256 ptr, bytes32 value) internal pure {</span>
  25 |     | <span class='neutral'>        assembly {</span>
  26 |     | <span class='neutral'>            mstore(ptr, value)</span>
  27 |     | <span class='neutral'>        }</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    function memPtr(bytes memory b) internal pure returns (uint256 res) {</span>
  31 |     | <span class='neutral'>        assembly {</span>
  32 |     | <span class='neutral'>            res := add(b, 0x20)</span>
  33 |     | <span class='neutral'>        }</span>
  34 |     | <span class='unexecuted'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='unexecuted'>    function mCopy(uint256 src, uint256 dest, uint256 len) internal pure {</span>
  37 |     | <span class='neutral'>        unchecked {</span>
  38 |     | <span class='neutral'>            // copy as many word sizes as possible</span>
  39 |     | <span class='unexecuted'>            for (; len &gt;= WORD_SIZE; len -= WORD_SIZE) {</span>
  40 |     | <span class='neutral'>                mstore(dest, mload(src));</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='unexecuted'>                src += WORD_SIZE;</span>
  43 |     | <span class='neutral'>                dest += WORD_SIZE;</span>
  44 |     | <span class='neutral'>            }</span>
  45 |     | <span class='neutral'>            if (len == 0) return;</span>
  46 |     | <span class='unexecuted'>            // left over bytes. Mask is used to remove unwanted bytes from the word</span>
  47 |     | <span class='neutral'>            FsUtils.Assert(len &gt; 0 &amp;&amp; len &lt; WORD_SIZE);</span>
  48 |     | <span class='neutral'>            bytes32 mask = bytes32((1 &lt;&lt; ((WORD_SIZE - len) &lt;&lt; 3)) - 1);</span>
  49 |     | <span class='neutral'>            bytes32 srcpart = mload(src) &amp; ~mask; // zero out src</span>
  50 |     | <span class='neutral'>            bytes32 destpart = mload(dest) &amp; mask; // retrieve the bytes</span>
  51 |     | <span class='neutral'>            mstore(dest, destpart | srcpart);</span>
  52 |     | <span class='neutral'>        }</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    function empty() internal pure returns (BytesView) {</span>
  56 |     | <span class='neutral'>        return BytesView.wrap(0);</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    function wrap(uint256 ptr, uint256 len) internal pure returns (BytesView) {</span>
  60 |     | <span class='neutral'>        return BytesView.wrap((ptr &lt;&lt; 128) | len);</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    function length(BytesView b) internal pure returns (uint256) {</span>
  64 |     | <span class='neutral'>        return BytesView.unwrap(b) &amp; type(uint128).max;</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    function memPtr(BytesView b) private pure returns (uint256) {</span>
  68 |     | <span class='neutral'>        return BytesView.unwrap(b) &gt;&gt; 128;</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    function fromBytes(bytes memory b) internal pure returns (BytesView) {</span>
  72 |     | <span class='neutral'>        return BytesViewLib.wrap(memPtr(b), b.length);</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    function toBytes(BytesView b) internal pure returns (bytes memory res) {</span>
  76 |     | <span class='neutral'>        uint len = length(b);</span>
  77 |     | <span class='neutral'>        res = new bytes(len);</span>
  78 |     | <span class='neutral'>        mCopy(memPtr(b), BytesViewLib.memPtr(res), len);</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    function unsafeLoadUInt8(BytesView b, uint256 offset) internal pure returns (uint256) {</span>
  82 |     | <span class='neutral'>        unchecked {</span>
  83 |     | <span class='neutral'>            return uint256(mload(memPtr(b) + offset)) &gt;&gt; 248;</span>
  84 |     | <span class='neutral'>        }</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>    function loadUInt8(BytesView b, uint256 offset) internal pure returns (uint256) {</span>
  88 |     | <span class='neutral'>        if (offset &gt;= length(b)) revert OutOfBounds();</span>
  89 |     | <span class='neutral'>        return unsafeLoadUInt8(b, offset);</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    function unsafeLoadBytes32(BytesView b, uint256 offset) internal pure returns (bytes32) {</span>
  93 |     | <span class='neutral'>        unchecked {</span>
  94 |     | <span class='neutral'>            return mload(memPtr(b) + offset);</span>
  95 |     | <span class='neutral'>        }</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    function loadBytes32(BytesView b, uint256 offset) internal pure returns (bytes32) {</span>
  99 |     | <span class='neutral'>        if (offset + 32 &gt; length(b)) revert OutOfBounds();</span>
 100 |     | <span class='neutral'>        return unsafeLoadBytes32(b, offset);</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    // Decode scalar value (non-negative integer) as described in yellow paper</span>
 104 |     | <span class='neutral'>    function decodeScalar(BytesView b) internal pure returns (uint256) {</span>
 105 |     | <span class='neutral'>        uint len = length(b);</span>
 106 |     | <span class='neutral'>        if (len == 0) return 0;</span>
 107 |     | <span class='neutral'>        bytes32 data = unsafeLoadBytes32(b, 0);</span>
 108 |     | <span class='neutral'>        if (data[0] == 0) revert InvalidScalarEncoding();</span>
 109 |     | <span class='neutral'>        return uint256(data &gt;&gt; ((WORD_SIZE - len) &lt;&lt; 3)); // reverts if len &gt; 32</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>    function unsafeSlice(</span>
 113 |     | <span class='neutral'>        BytesView b,</span>
 114 |     | <span class='neutral'>        uint256 offset,</span>
 115 |     | <span class='neutral'>        uint256 len</span>
 116 |     | <span class='neutral'>    ) internal pure returns (BytesView) {</span>
 117 |     | <span class='neutral'>        unchecked {</span>
 118 |     | <span class='neutral'>            FsUtils.Assert(offset + len &lt;= length(b));</span>
 119 |     | <span class='neutral'>            return BytesViewLib.wrap(memPtr(b) + offset, len);</span>
 120 |     | <span class='unexecuted'>        }</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>    function slice(BytesView b, uint256 offset, uint256 len) internal pure returns (BytesView) {</span>
 124 |     | <span class='neutral'>        if (offset + len &gt; length(b)) revert OutOfBounds();</span>
 125 |     | <span class='neutral'>        return unsafeSlice(b, offset, len);</span>
 126 |     | <span class='neutral'>    }</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='neutral'>    function unsafeSkip(BytesView b, uint256 offset) internal pure returns (BytesView) {</span>
 129 |     | <span class='neutral'>        unchecked {</span>
 130 |     | <span class='neutral'>            FsUtils.Assert(offset &lt;= length(b));</span>
 131 |     | <span class='neutral'>            return BytesViewLib.wrap(memPtr(b) + offset, length(b) - offset);</span>
 132 |     | <span class='neutral'>        }</span>
 133 |     | <span class='neutral'>    }</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='unexecuted'>    function skip(BytesView b, uint256 offset) internal pure returns (BytesView) {</span>
 136 |     | <span class='unexecuted'>        if (offset &gt; length(b)) revert OutOfBounds();</span>
 137 |     | <span class='neutral'>        return unsafeSkip(b, offset);</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    function keccak(BytesView b) internal pure returns (bytes32 res) {</span>
 141 |     | <span class='neutral'>        uint256 ptr = memPtr(b);</span>
 142 |     | <span class='neutral'>        uint256 len = length(b);</span>
 143 |     | <span class='neutral'>        assembly {</span>
 144 |     | <span class='neutral'>            res := keccak256(ptr, len)</span>
 145 |     | <span class='neutral'>        }</span>
 146 |     | <span class='neutral'>    }</span>
 147 |     | <span class='neutral'>}</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>library RLP {</span>
 150 |     | <span class='neutral'>    using BytesViewLib for BytesView;</span>
 151 |     | <span class='neutral'>    using RLP for RLPItem;</span>
 152 |     | <span class='neutral'>    using RLP for RLPIterator;</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>    error InvalidRLPItem();</span>
 155 |     | <span class='neutral'>    error ItemIsNotList();</span>
 156 |     | <span class='neutral'>    error ItemIsNotBytes();</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>    function isList(RLPItem item) internal pure returns (bool) {</span>
 159 |     | <span class='neutral'>        FsUtils.Assert(buffer(item).length() &gt; 0);</span>
 160 |     | <span class='neutral'>        return buffer(item).unsafeLoadUInt8(0) &gt;= 0xc0;</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    function isBytes(RLPItem item) internal pure returns (bool) {</span>
 164 |     | <span class='neutral'>        return !isList(item);</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    function requireRLPItem(BytesView b) internal pure returns (RLPItem) {</span>
 168 |     | <span class='neutral'>        uint256 len = rlpLen(b);</span>
 169 |     | <span class='neutral'>        if (len != b.length()) revert InvalidRLPItem();</span>
 170 |     | <span class='neutral'>        return asRLPItem(b);</span>
 171 |     | <span class='neutral'>    }</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'>    function requireBytesView(RLPItem item) internal pure returns (BytesView) {</span>
 174 |     | <span class='neutral'>        if (!isBytes(item)) revert ItemIsNotBytes();</span>
 175 |     | <span class='neutral'>        return toBytesView(item);</span>
 176 |     | <span class='neutral'>    }</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='neutral'>    function toBytesView(RLPItem item) internal pure returns (BytesView) {</span>
 179 |     | <span class='neutral'>        unchecked {</span>
 180 |     | <span class='neutral'>            FsUtils.Assert(isBytes(item));</span>
 181 |     | <span class='neutral'>            uint256 tag = buffer(item).unsafeLoadUInt8(0);</span>
 182 |     | <span class='neutral'>            if (tag &lt; 0x80) {</span>
 183 |     | <span class='neutral'>                return buffer(item).unsafeSlice(0, 1);</span>
 184 |     | <span class='neutral'>            } else if (tag &lt; 0xb8) {</span>
 185 |     | <span class='neutral'>                return buffer(item).unsafeSlice(1, tag - 0x80);</span>
 186 |     | <span class='neutral'>            } else {</span>
 187 |     | <span class='neutral'>                uint256 lenLen = tag - 0xb7;</span>
 188 |     | <span class='neutral'>                uint256 len = uint256(buffer(item).unsafeLoadBytes32(1)) &gt;&gt; (8 * (32 - lenLen));</span>
 189 |     | <span class='neutral'>                return buffer(item).unsafeSlice(1 + lenLen, len);</span>
 190 |     | <span class='neutral'>            }</span>
 191 |     | <span class='neutral'>        }</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>    function requireRLPItemIterator(RLPItem item) internal pure returns (RLPIterator) {</span>
 195 |     | <span class='neutral'>        if (!isList(item)) revert ItemIsNotList();</span>
 196 |     | <span class='neutral'>        return toRLPItemIterator(item);</span>
 197 |     | <span class='neutral'>    }</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='neutral'>    function toRLPItemIterator(RLPItem item) internal pure returns (RLPIterator) {</span>
 200 |     | <span class='neutral'>        unchecked {</span>
 201 |     | <span class='neutral'>            FsUtils.Assert(isList(item));</span>
 202 |     | <span class='neutral'>            uint256 len = 0;</span>
 203 |     | <span class='neutral'>            uint256 lenLen = 0;</span>
 204 |     | <span class='neutral'>            uint256 initial = buffer(item).unsafeLoadUInt8(0);</span>
 205 |     | <span class='neutral'>            if (initial &lt; 0xf8) {</span>
 206 |     | <span class='neutral'>                len = initial - 0xc0;</span>
 207 |     | <span class='neutral'>            } else {</span>
 208 |     | <span class='neutral'>                lenLen = initial - 0xf7;</span>
 209 |     | <span class='neutral'>                len = uint256(buffer(item).unsafeLoadBytes32(1)) &gt;&gt; (8 * (32 - lenLen));</span>
 210 |     | <span class='neutral'>            }</span>
 211 |     | <span class='neutral'>            FsUtils.Assert(len + lenLen + 1 == buffer(item).length()); // , &quot;RLP: Invalid length it&quot;);</span>
 212 |     | <span class='neutral'>            BytesView b = buffer(item).unsafeSlice(1 + lenLen, len);</span>
 213 |     | <span class='neutral'>            return RLPIterator.wrap(BytesView.unwrap(b));</span>
 214 |     | <span class='neutral'>        }</span>
 215 |     | <span class='neutral'>    }</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='neutral'>    function unsafeNext(RLPIterator it) internal pure returns (RLPItem item, RLPIterator nextIt) {</span>
 218 |     | <span class='neutral'>        FsUtils.Assert(buffer(it).length() &gt; 0); // &quot;RLP: Iterator out of bounds&quot;);</span>
 219 |     | <span class='neutral'>        uint256 len = rlpLen(buffer(it));</span>
 220 |     | <span class='neutral'>        item = asRLPItem(buffer(it).unsafeSlice(0, len));</span>
 221 |     | <span class='neutral'>        nextIt = asRLPIterator(buffer(it).unsafeSkip(len));</span>
 222 |     | <span class='neutral'>    }</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='neutral'>    function next(RLPIterator it) internal pure returns (RLPItem item, RLPIterator nextIt) {</span>
 225 |     | <span class='neutral'>        FsUtils.Assert(buffer(it).length() &gt; 0); // &quot;RLP: Iterator out of bounds&quot;);</span>
 226 |     | <span class='neutral'>        uint256 len = rlpLen(buffer(it));</span>
 227 |     | <span class='neutral'>        item = asRLPItem(buffer(it).slice(0, len));</span>
 228 |     | <span class='neutral'>        nextIt = asRLPIterator(buffer(it).unsafeSkip(len));</span>
 229 |     | <span class='neutral'>    }</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='neutral'>    function unsafeSkipNext(RLPIterator it) internal pure returns (RLPIterator nextIt) {</span>
 232 |     | <span class='neutral'>        FsUtils.Assert(buffer(it).length() &gt; 0); // &quot;RLP: Iterator out of bounds&quot;);</span>
 233 |     | <span class='neutral'>        uint256 len = rlpLen(buffer(it));</span>
 234 |     | <span class='neutral'>        nextIt = asRLPIterator(buffer(it).unsafeSkip(len));</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>    function hasNext(RLPIterator it) internal pure returns (bool) {</span>
 238 |     | <span class='neutral'>        return buffer(it).length() &gt; 0;</span>
 239 |     | <span class='neutral'>    }</span>
 240 |     | <span class='neutral'></span>
 241 |     | <span class='neutral'>    function length(RLPItem item) internal pure returns (uint256) {</span>
 242 |     | <span class='neutral'>        return buffer(item).length();</span>
 243 |     | <span class='neutral'>    }</span>
 244 |     | <span class='neutral'></span>
 245 |     | <span class='neutral'>    function keccak(RLPItem item) internal pure returns (bytes32 res) {</span>
 246 |     | <span class='neutral'>        return buffer(item).keccak();</span>
 247 |     | <span class='neutral'>    }</span>
 248 |     | <span class='neutral'></span>
 249 |     | <span class='neutral'>    function buffer(RLPItem item) private pure returns (BytesView) {</span>
 250 |     | <span class='neutral'>        return BytesView.wrap(RLPItem.unwrap(item));</span>
 251 |     | <span class='neutral'>    }</span>
 252 |     | <span class='neutral'></span>
 253 |     | <span class='neutral'>    function buffer(RLPIterator it) private pure returns (BytesView) {</span>
 254 |     | <span class='neutral'>        return BytesView.wrap(RLPIterator.unwrap(it));</span>
 255 |     | <span class='neutral'>    }</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='neutral'>    function rlpLen(BytesView b) private pure returns (uint256) {</span>
 258 |     | <span class='neutral'>        unchecked {</span>
 259 |     | <span class='neutral'>            FsUtils.Assert(b.length() &gt; 0); // &quot;RLP: Empty buffer&quot;);</span>
 260 |     | <span class='neutral'>            uint256 len = 0;</span>
 261 |     | <span class='neutral'>            uint256 lenLen = 0;</span>
 262 |     | <span class='neutral'>            uint256 initial = b.unsafeLoadUInt8(0);</span>
 263 |     | <span class='neutral'>            if (initial &lt; 0x80) {</span>
 264 |     | <span class='neutral'>                return 1;</span>
 265 |     | <span class='neutral'>                // nothing</span>
 266 |     | <span class='neutral'>            } else if (initial &lt; 0xb8) {</span>
 267 |     | <span class='neutral'>                return 1 + initial - 0x80;</span>
 268 |     | <span class='neutral'>            } else if (initial &lt; 0xc0) {</span>
 269 |     | <span class='neutral'>                lenLen = initial - 0xb7;</span>
 270 |     | <span class='neutral'>                // Continue below</span>
 271 |     | <span class='neutral'>            } else if (initial &lt; 0xf8) {</span>
 272 |     | <span class='neutral'>                return 1 + initial - 0xc0;</span>
 273 |     | <span class='neutral'>            } else {</span>
 274 |     | <span class='neutral'>                lenLen = initial - 0xf7;</span>
 275 |     | <span class='neutral'>                // Continue below</span>
 276 |     | <span class='neutral'>            }</span>
 277 |     | <span class='neutral'>            len = uint256(b.unsafeLoadBytes32(1)) &gt;&gt; (8 * (32 - lenLen));</span>
 278 |     | <span class='neutral'>            return len + lenLen + 1;</span>
 279 |     | <span class='neutral'>        }</span>
 280 |     | <span class='neutral'>    }</span>
 281 |     | <span class='neutral'></span>
 282 |     | <span class='neutral'>    function asRLPItem(BytesView b) private pure returns (RLPItem) {</span>
 283 |     | <span class='neutral'>        return RLPItem.wrap(BytesView.unwrap(b));</span>
 284 |     | <span class='neutral'>    }</span>
 285 |     | <span class='neutral'></span>
 286 |     | <span class='neutral'>    function asRLPIterator(BytesView b) private pure returns (RLPIterator) {</span>
 287 |     | <span class='neutral'>        return RLPIterator.wrap(BytesView.unwrap(b));</span>
 288 |     | <span class='neutral'>    }</span>
 289 |     | <span class='neutral'>}</span>
 290 |     | <span class='neutral'></span>
 291 |     | <span class='neutral'>library TrieLib {</span>
 292 |     | <span class='neutral'>    using BytesViewLib for BytesView;</span>
 293 |     | <span class='neutral'>    using RLP for RLPItem;</span>
 294 |     | <span class='neutral'>    using RLP for RLPIterator;</span>
 295 |     | <span class='neutral'></span>
 296 |     | <span class='neutral'>    // RLP(&quot;&quot;) = &quot;0x80&quot;</span>
 297 |     | <span class='neutral'>    bytes32 private constant EMPTY_TRIE_HASH =</span>
 298 |     | <span class='neutral'>        0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421;</span>
 299 |     | <span class='neutral'></span>
 300 |     | <span class='neutral'>    error KeyTooLong();</span>
 301 |     | <span class='neutral'>    error ProofTooLong();</span>
 302 |     | <span class='neutral'>    error IncompleteProof();</span>
 303 |     | <span class='neutral'>    error InvalidProof();</span>
 304 |     | <span class='neutral'></span>
 305 |     | <span class='neutral'>    /// @dev Verify a proof of a key in a Merkle Patricia Trie, revert if the proof is invalid.</span>
 306 |     | <span class='neutral'>    /// @param key The key to verify.</span>
 307 |     | <span class='neutral'>    /// @param root The root hash of the trie. This is assumed to be from a trusted source (e.g. a block header)</span>
 308 |     | <span class='neutral'>    ///        and therefore represents a structurally valid tree.</span>
 309 |     | <span class='neutral'>    /// @param proof The proof of the key. Untrusted data.</span>
 310 |     | <span class='neutral'>    /// @return The value of the key if the key exists or empty if key doesn&#39;t exist.</span>
 311 |     | <span class='neutral'>    /// @notice The stored value is encoded as RLP and thus never empty, so empty means the key doesn&#39;t exist.</span>
 312 |     | <span class='neutral'>    ///         This is reasonably optimized for gas, it&#39;s around 25k gas per proof depending on the depth.</span>
 313 |     | <span class='neutral'>    function verify(</span>
 314 |     | <span class='neutral'>        bytes32 key,</span>
 315 |     | <span class='neutral'>        uint256 keyLength,</span>
 316 |     | <span class='neutral'>        bytes32 root,</span>
 317 |     | <span class='neutral'>        bytes memory proof</span>
 318 |     | <span class='neutral'>    ) internal pure returns (BytesView) {</span>
 319 |     | <span class='neutral'>        unchecked {</span>
 320 |     | <span class='neutral'>            if (keyLength &gt; 32) revert KeyTooLong();</span>
 321 |     | <span class='neutral'>            uint256 nibblesLeft = keyLength * 2;</span>
 322 |     | <span class='neutral'>            RLPItem rlpListItem = RLP.requireRLPItem(BytesViewLib.fromBytes(proof));</span>
 323 |     | <span class='neutral'>            RLPIterator listIt = rlpListItem.requireRLPItemIterator();</span>
 324 |     | <span class='neutral'>            RLPItem child0;</span>
 325 |     | <span class='neutral'>            RLPItem child1;</span>
 326 |     | <span class='neutral'>            BytesView res = BytesViewLib.empty();</span>
 327 |     | <span class='neutral'>            while (listIt.hasNext()) {</span>
 328 |     | <span class='neutral'>                if (root == EMPTY_TRIE_HASH) revert ProofTooLong();</span>
 329 |     | <span class='neutral'>                RLPItem rlpItem;</span>
 330 |     | <span class='neutral'>                (rlpItem, listIt) = listIt.next();</span>
 331 |     | <span class='neutral'>                if (rlpItem.keccak() != root) revert InvalidProof();</span>
 332 |     | <span class='neutral'>                // Because it passed this cryptographic check, we know that the rlpItem is a well-formed</span>
 333 |     | <span class='neutral'>                // RLP encoded MPT node.</span>
 334 |     | <span class='neutral'></span>
 335 |     | <span class='neutral'>                RLPIterator childIt = rlpItem.toRLPItemIterator();</span>
 336 |     | <span class='neutral'>                FsUtils.Assert(childIt.hasNext());</span>
 337 |     | <span class='neutral'>                (child0, childIt) = childIt.unsafeNext();</span>
 338 |     | <span class='neutral'>                FsUtils.Assert(childIt.hasNext());</span>
 339 |     | <span class='neutral'>                (child1, childIt) = childIt.unsafeNext();</span>
 340 |     | <span class='neutral'></span>
 341 |     | <span class='neutral'>                RLPItem nextRoot;</span>
 342 |     | <span class='neutral'>                root = EMPTY_TRIE_HASH; // sentinel indicating end of proof</span>
 343 |     | <span class='neutral'>                if (childIt.hasNext()) {</span>
 344 |     | <span class='neutral'>                    // Branch node</span>
 345 |     | <span class='neutral'>                    uint nibble = nibblesLeft == 0 ? 16 : uint256(key) &gt;&gt; 252;</span>
 346 |     | <span class='neutral'></span>
 347 |     | <span class='neutral'>                    if (nibble &lt; 2) {</span>
 348 |     | <span class='neutral'>                        nextRoot = nibble == 0 ? child0 : child1;</span>
 349 |     | <span class='neutral'>                    } else {</span>
 350 |     | <span class='neutral'>                        for (uint i = 2; i &lt; nibble; i++) {</span>
 351 |     | <span class='neutral'>                            FsUtils.Assert(childIt.hasNext());</span>
 352 |     | <span class='neutral'>                            childIt = childIt.unsafeSkipNext();</span>
 353 |     | <span class='neutral'>                        }</span>
 354 |     | <span class='neutral'>                        FsUtils.Assert(childIt.hasNext());</span>
 355 |     | <span class='neutral'>                        (nextRoot, childIt) = childIt.unsafeNext();</span>
 356 |     | <span class='neutral'>                    }</span>
 357 |     | <span class='neutral'></span>
 358 |     | <span class='neutral'>                    if (nibblesLeft == 0) {</span>
 359 |     | <span class='neutral'>                        res = nextRoot.toBytesView();</span>
 360 |     | <span class='neutral'>                        continue;</span>
 361 |     | <span class='neutral'>                    }</span>
 362 |     | <span class='neutral'>                    key &lt;&lt;= 4;</span>
 363 |     | <span class='neutral'>                    nibblesLeft -= 1;</span>
 364 |     | <span class='neutral'>                } else {</span>
 365 |     | <span class='neutral'>                    // Extension or leaf nodes</span>
 366 |     | <span class='neutral'>                    BytesView partialKey = child0.toBytesView();</span>
 367 |     | <span class='neutral'>                    FsUtils.Assert(partialKey.length() &gt; 0 &amp;&amp; partialKey.length() &lt;= 33);</span>
 368 |     | <span class='neutral'>                    uint256 tag = partialKey.unsafeLoadUInt8(0);</span>
 369 |     | <span class='neutral'>                    bytes32 partialKeyBytes = partialKey.unsafeLoadBytes32(1);</span>
 370 |     | <span class='neutral'>                    uint partialKeyLength = 2 * partialKey.length() - 2;</span>
 371 |     | <span class='neutral'>                    // Two most significant bits must be zero for a valid hex-prefix string</span>
 372 |     | <span class='neutral'>                    FsUtils.Assert(tag &lt; 64);</span>
 373 |     | <span class='neutral'>                    if ((tag &amp; 16) != 0) {</span>
 374 |     | <span class='neutral'>                        // Odd number of nibbles, low order nibble of tag is first nibble of key</span>
 375 |     | <span class='neutral'>                        partialKeyBytes = (partialKeyBytes &gt;&gt; 4) | bytes32(tag &lt;&lt; 252);</span>
 376 |     | <span class='neutral'>                        partialKeyLength += 1;</span>
 377 |     | <span class='neutral'>                    } else {</span>
 378 |     | <span class='neutral'>                        // Even number of nibbles, low order nibble of tag is zero</span>
 379 |     | <span class='neutral'>                        FsUtils.Assert(tag &amp; 0xF == 0);</span>
 380 |     | <span class='neutral'>                    }</span>
 381 |     | <span class='neutral'>                    // For a valid MPT, the partial key must be at least one nibble and will</span>
 382 |     | <span class='neutral'>                    // never be more then 32 bytes.</span>
 383 |     | <span class='neutral'>                    FsUtils.Assert(partialKeyLength &gt; 0 &amp;&amp; partialKeyLength &lt;= 64);</span>
 384 |     | <span class='neutral'>                    // The partialKey must be a prefix of key</span>
 385 |     | <span class='neutral'>                    if (</span>
 386 |     | <span class='neutral'>                        partialKeyLength &gt; nibblesLeft ||</span>
 387 |     | <span class='neutral'>                        (partialKeyBytes ^ key) &gt;&gt; (256 - 4 * partialKeyLength) != 0</span>
 388 |     | <span class='neutral'>                    ) {</span>
 389 |     | <span class='neutral'>                        // The partial key is not a prefix of the key, so the key doesn&#39;t exist</span>
 390 |     | <span class='neutral'>                        continue;</span>
 391 |     | <span class='neutral'>                    }</span>
 392 |     | <span class='neutral'>                    nibblesLeft -= partialKeyLength;</span>
 393 |     | <span class='neutral'>                    key &lt;&lt;= 4 * partialKeyLength;</span>
 394 |     | <span class='neutral'></span>
 395 |     | <span class='neutral'>                    if ((tag &amp; 32) != 0) {</span>
 396 |     | <span class='neutral'>                        // Leaf node</span>
 397 |     | <span class='neutral'>                        if (nibblesLeft == 0) {</span>
 398 |     | <span class='neutral'>                            res = child1.toBytesView();</span>
 399 |     | <span class='neutral'>                        }</span>
 400 |     | <span class='neutral'>                        continue;</span>
 401 |     | <span class='neutral'>                    }</span>
 402 |     | <span class='neutral'>                    nextRoot = child1;</span>
 403 |     | <span class='neutral'>                }</span>
 404 |     | <span class='neutral'>                // Proof continue with child node</span>
 405 |     | <span class='neutral'>                if (nextRoot.isBytes()) {</span>
 406 |     | <span class='neutral'>                    BytesView childBytes = nextRoot.toBytesView();</span>
 407 |     | <span class='neutral'>                    if (childBytes.length() == 0) {</span>
 408 |     | <span class='neutral'>                        continue;</span>
 409 |     | <span class='neutral'>                    }</span>
 410 |     | <span class='neutral'>                    FsUtils.Assert(childBytes.length() == 32); // Invalid child hash</span>
 411 |     | <span class='neutral'>                    root = childBytes.unsafeLoadBytes32(0);</span>
 412 |     | <span class='neutral'>                } else {</span>
 413 |     | <span class='neutral'>                    FsUtils.Assert(nextRoot.isList());</span>
 414 |     | <span class='neutral'>                    // The next node is embedded directly in this node</span>
 415 |     | <span class='neutral'>                    // as it&#39;s RLP length is less than 32 bytes.</span>
 416 |     | <span class='neutral'>                    FsUtils.Assert(nextRoot.length() &lt; 32); // &quot;IP: child node too long&quot;;</span>
 417 |     | <span class='neutral'>                    root = nextRoot.keccak();</span>
 418 |     | <span class='neutral'>                }</span>
 419 |     | <span class='neutral'>            }</span>
 420 |     | <span class='neutral'>            if (root != EMPTY_TRIE_HASH) revert IncompleteProof();</span>
 421 |     | <span class='neutral'>            return res;</span>
 422 |     | <span class='neutral'>        }</span>
 423 |     | <span class='neutral'>    }</span>
 424 |     | <span class='neutral'></span>
 425 |     | <span class='neutral'>    function proofAccount(</span>
 426 |     | <span class='neutral'>        address account,</span>
 427 |     | <span class='neutral'>        bytes32 stateRoot,</span>
 428 |     | <span class='neutral'>        bytes memory proof</span>
 429 |     | <span class='neutral'>    )</span>
 430 |     | <span class='neutral'>        internal</span>
 431 |     | <span class='neutral'>        pure</span>
 432 |     | <span class='neutral'>        returns (uint256 nonce, uint256 balance, bytes32 storageHash, bytes32 codeHash)</span>
 433 |     | <span class='neutral'>    {</span>
 434 |     | <span class='neutral'>        BytesView accountRLP = verify(keccak256(abi.encodePacked(account)), 32, stateRoot, proof);</span>
 435 |     | <span class='neutral'>        if (accountRLP.length() == 0) {</span>
 436 |     | <span class='neutral'>            return (0, 0, bytes32(0), bytes32(0));</span>
 437 |     | <span class='neutral'>        }</span>
 438 |     | <span class='neutral'>        RLPItem item = RLP.requireRLPItem(accountRLP);</span>
 439 |     | <span class='neutral'>        RLPIterator it = item.requireRLPItemIterator();</span>
 440 |     | <span class='neutral'>        FsUtils.Assert(it.hasNext());</span>
 441 |     | <span class='neutral'>        (item, it) = it.next();</span>
 442 |     | <span class='neutral'>        nonce = item.requireBytesView().decodeScalar();</span>
 443 |     | <span class='neutral'>        FsUtils.Assert(it.hasNext());</span>
 444 |     | <span class='neutral'>        (item, it) = it.next();</span>
 445 |     | <span class='neutral'>        balance = item.requireBytesView().decodeScalar();</span>
 446 |     | <span class='neutral'>        FsUtils.Assert(it.hasNext());</span>
 447 |     | <span class='neutral'>        (item, it) = it.next();</span>
 448 |     | <span class='neutral'>        storageHash = item.requireBytesView().unsafeLoadBytes32(0);</span>
 449 |     | <span class='neutral'>        FsUtils.Assert(it.hasNext());</span>
 450 |     | <span class='neutral'>        (item, it) = it.next();</span>
 451 |     | <span class='neutral'>        codeHash = item.requireBytesView().unsafeLoadBytes32(0);</span>
 452 |     | <span class='neutral'>    }</span>
 453 |     | <span class='neutral'></span>
 454 |     | <span class='neutral'>    function proofStorageAt(</span>
 455 |     | <span class='neutral'>        bytes32 slot,</span>
 456 |     | <span class='neutral'>        bytes32 storageHash,</span>
 457 |     | <span class='neutral'>        bytes memory proof</span>
 458 |     | <span class='neutral'>    ) internal pure returns (uint256) {</span>
 459 |     | <span class='neutral'>        BytesView valueRLP = verify(keccak256(abi.encodePacked(slot)), 32, storageHash, proof);</span>
 460 |     | <span class='neutral'>        if (valueRLP.length() == 0) {</span>
 461 |     | <span class='neutral'>            return 0;</span>
 462 |     | <span class='neutral'>        }</span>
 463 |     | <span class='neutral'>        RLPItem item = RLP.requireRLPItem(valueRLP);</span>
 464 |     | <span class='neutral'>        BytesView storedAmount = item.requireBytesView();</span>
 465 |     | <span class='neutral'>        return storedAmount.decodeScalar();</span>
 466 |     | <span class='neutral'>    }</span>
 467 |     | <span class='neutral'>}</span>
 468 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/oracles/ERC20ChainlinkValueOracle.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/utils/Strings.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;../lib/FsUtils.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../interfaces/IERC20ValueOracle.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>import {ImmutableGovernance} from &quot;../lib/ImmutableGovernance.sol&quot;;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>contract ERC20ChainlinkValueOracle is ImmutableGovernance, IERC20ValueOracle {</span>
 12 |     | <span class='neutral'>    AggregatorV3Interface priceOracle;</span>
 13 |     | <span class='neutral'>    int256 immutable base;</span>
 14 |     | <span class='neutral'>    int256 collateralFactor = 1 ether;</span>
 15 |     | <span class='neutral'>    int256 borrowFactor = 1 ether;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    modifier checkDecimals(string memory label, uint8 decimals) {</span>
 18 |     | <span class='unexecuted'>        if (decimals &lt; 3 || 18 &lt; decimals) {</span>
 19 |     | <span class='neutral'>            // prettier-ignore</span>
 20 |     | <span class='neutral'>            revert(string.concat(</span>
 21 |     | <span class='neutral'>                &quot;Invalid &quot;, label, &quot;: must be within [3, 18] range while provided is &quot;,</span>
 22 |     | <span class='neutral'>                Strings.toString(decimals)</span>
 23 |     | <span class='neutral'>            ));</span>
 24 |     | <span class='neutral'>        }</span>
 25 |     | <span class='neutral'>        _;</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>    constructor(</span>
 29 |     | <span class='neutral'>        address chainlink,</span>
 30 |     | <span class='neutral'>        uint8 baseDecimals,</span>
 31 |     | <span class='neutral'>        uint8 tokenDecimals,</span>
 32 |     | <span class='neutral'>        int256 _collateralFactor,</span>
 33 |     | <span class='neutral'>        int256 _borrowFactor,</span>
 34 |     | <span class='neutral'>        address _owner</span>
 35 |     | <span class='neutral'>    )</span>
 36 |     | <span class='neutral'>        ImmutableGovernance(_owner)</span>
 37 |     | <span class='neutral'>        checkDecimals(&quot;baseDecimals&quot;, baseDecimals)</span>
 38 |     | <span class='neutral'>        checkDecimals(&quot;tokenDecimals&quot;, tokenDecimals)</span>
 39 |     | <span class='neutral'>    {</span>
 40 |     | <span class='neutral'>        priceOracle = AggregatorV3Interface(FsUtils.nonNull(chainlink));</span>
 41 |     | <span class='neutral'>        base = int256(10) ** (tokenDecimals + priceOracle.decimals() - baseDecimals);</span>
 42 |     | <span class='neutral'>        collateralFactor = _collateralFactor;</span>
 43 |     | <span class='neutral'>        borrowFactor = _borrowFactor;</span>
 44 |     | <span class='neutral'>    }</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    function setRiskFactors(</span>
 47 |     | <span class='neutral'>        int256 _collateralFactor,</span>
 48 |     | <span class='neutral'>        int256 _borrowFactor</span>
 49 |     | <span class='neutral'>    ) external onlyGovernance {</span>
 50 |     | <span class='neutral'>        collateralFactor = _collateralFactor;</span>
 51 |     | <span class='unexecuted'>        borrowFactor = _borrowFactor;</span>
 52 |     | <span class='neutral'>    }</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    function calcValue(</span>
 55 |     | <span class='neutral'>        int256 balance</span>
 56 |     | <span class='unexecuted'>    ) external view override returns (int256 value, int256 riskAdjustedValue) {</span>
 57 |     | <span class='neutral'>        (, int256 price, , , ) = priceOracle.latestRoundData();</span>
 58 |     | <span class='neutral'>        value = (balance * price) / base;</span>
 59 |     | <span class='neutral'>        if (balance &gt;= 0) {</span>
 60 |     | <span class='unexecuted'>            riskAdjustedValue = (value * collateralFactor) / 1 ether;</span>
 61 |     | <span class='neutral'>        } else {</span>
 62 |     | <span class='neutral'>            riskAdjustedValue = (value * 1 ether) / borrowFactor;</span>
 63 |     | <span class='neutral'>        }</span>
 64 |     | <span class='neutral'>        return (value, riskAdjustedValue);</span>
 65 |     | <span class='neutral'>    }</span>
 66 |     | <span class='unexecuted'>}</span>
 67 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/oracles/UniV2Oracle.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import {ImmutableGovernance} from &quot;../lib/ImmutableGovernance.sol&quot;;</span>
  7 |     | <span class='neutral'>import {IERC20ValueOracle} from &quot;../interfaces/IERC20ValueOracle.sol&quot;;</span>
  8 |     | <span class='neutral'>import {FsMath} from &quot;../lib/FsMath.sol&quot;;</span>
  9 |     | <span class='neutral'>import {IDOS} from &quot;../interfaces/IDOS.sol&quot;;</span>
 10 |     | <span class='neutral'>import {IDuoswapV2Pair} from &quot;../duoswapV2/interfaces/IDuoswapV2Pair.sol&quot;;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>contract UniV2Oracle is ImmutableGovernance, IERC20ValueOracle {</span>
 13 |     | <span class='neutral'>    IDOS public immutable dos;</span>
 14 |     | <span class='neutral'>    IDuoswapV2Pair public immutable pair;</span>
 15 |     | <span class='neutral'>    // address public immutable dSafe;</span>
 16 |     | <span class='neutral'>    // address public immutable token0;</span>
 17 |     | <span class='neutral'>    // address public immutable token1;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    mapping(address =&gt; IERC20ValueOracle) public erc20ValueOracle;</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    constructor(address _dos, address _pair, address _owner) ImmutableGovernance(_owner) {</span>
 22 |     | <span class='neutral'>        if (_dos == address(0) || _pair == address(0) || _owner == address(0)) {</span>
 23 |     | <span class='neutral'>            revert(&quot;Zero address&quot;);</span>
 24 |     | <span class='neutral'>        }</span>
 25 |     | <span class='neutral'>        dos = IDOS(_dos);</span>
 26 |     | <span class='neutral'>        pair = IDuoswapV2Pair(_pair);</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>        // dSafe = IUniswapV2Pair(_pair).dSafe();</span>
 29 |     | <span class='neutral'>        // token0 = IUniswapV2Pair(_pair).token0();</span>
 30 |     | <span class='neutral'>        // token1 = IUniswapV2Pair(_pair).token1();</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    /// @notice Set the oracle for an underlying token</span>
 34 |     | <span class='neutral'>    /// @param erc20 The underlying token</span>
 35 |     | <span class='neutral'>    /// @param oracle The oracle for the underlying token</span>
 36 |     | <span class='neutral'>    function setERC20ValueOracle(address erc20, address oracle) external onlyGovernance {</span>
 37 |     | <span class='neutral'>        erc20ValueOracle[erc20] = IERC20ValueOracle(oracle);</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    /// @notice Calculate the value of a uniswap pair token</span>
 41 |     | <span class='neutral'>    /// @param amount The amount of the token</span>
 42 |     | <span class='neutral'>    /// @return value The value of the uniswap pair token</span>
 43 |     | <span class='neutral'>    /// @return riskAdjustedValue The risk adjusted value of the uniswap pair token</span>
 44 |     | <span class='neutral'>    function calcValue(</span>
 45 |     | <span class='neutral'>        int256 amount</span>
 46 |     | <span class='neutral'>    ) external view override returns (int256 value, int256 riskAdjustedValue) {</span>
 47 |     | <span class='neutral'>        uint256 totalSupply = pair.totalSupply();</span>
 48 |     | <span class='neutral'>        if (totalSupply == 0) {</span>
 49 |     | <span class='neutral'>            return (0, 0);</span>
 50 |     | <span class='neutral'>        }</span>
 51 |     | <span class='neutral'>        address dSafe = pair.dSafe();</span>
 52 |     | <span class='neutral'>        address token0 = pair.token0();</span>
 53 |     | <span class='neutral'>        address token1 = pair.token1();</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='neutral'>        uint256 balance0 = uint256(IDOS(dos).getDAccountERC20(dSafe, IERC20(token0)));</span>
 56 |     | <span class='neutral'>        uint256 balance1 = uint256(IDOS(dos).getDAccountERC20(dSafe, IERC20(token1)));</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='neutral'>        (int256 price0, int256 adjustedPrice0) = erc20ValueOracle[token0].calcValue(</span>
 59 |     | <span class='neutral'>            FsMath.safeCastToSigned(balance0)</span>
 60 |     | <span class='neutral'>        );</span>
 61 |     | <span class='neutral'>        (int256 price1, int256 adjustedPrice1) = erc20ValueOracle[token1].calcValue(</span>
 62 |     | <span class='neutral'>            FsMath.safeCastToSigned(balance1)</span>
 63 |     | <span class='neutral'>        );</span>
 64 |     | <span class='neutral'></span>
 65 |     | <span class='neutral'>        value = ((price0 + price1) * amount) / FsMath.safeCastToSigned(totalSupply);</span>
 66 |     | <span class='neutral'>        riskAdjustedValue =</span>
 67 |     | <span class='neutral'>            ((adjustedPrice0 + adjustedPrice1) * amount) /</span>
 68 |     | <span class='neutral'>            FsMath.safeCastToSigned(totalSupply);</span>
 69 |     | <span class='neutral'>        return (value, riskAdjustedValue);</span>
 70 |     | <span class='neutral'>    }</span>
 71 |     | <span class='neutral'>}</span>
 72 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/oracles/UniV3Oracle.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;../lib/ImmutableGovernance.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;../interfaces/IERC20ValueOracle.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../interfaces/INFTValueOracle.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../lib/FsMath.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../lib/FsUtils.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;../external/interfaces/INonfungiblePositionManager.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol&quot;;</span>
  12 |     | <span class='neutral'>import &quot;@uniswap/v3-core/contracts/libraries/FixedPoint96.sol&quot;;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>// TickMath lib is inconsistent with solidity compiler version</span>
  15 |     | <span class='neutral'>library TickMath {</span>
  16 |     | <span class='neutral'>    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128</span>
  17 |     | <span class='neutral'>    int24 internal constant MIN_TICK = -887272;</span>
  18 |     | <span class='neutral'>    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128</span>
  19 |     | <span class='neutral'>    int24 internal constant MAX_TICK = -MIN_TICK;</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)</span>
  22 |     | <span class='neutral'>    uint160 internal constant MIN_SQRT_RATIO = 4295128739;</span>
  23 |     | <span class='neutral'>    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)</span>
  24 |     | <span class='neutral'>    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    /// @notice Calculates sqrt(1.0001^tick) * 2^96</span>
  27 |     | <span class='neutral'>    /// @dev Throws if |tick| &gt; max tick</span>
  28 |     | <span class='neutral'>    /// @param tick The input tick for the above formula</span>
  29 |     | <span class='neutral'>    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two erc20s (token1/token0)</span>
  30 |     | <span class='neutral'>    /// at the given tick</span>
  31 |     | <span class='neutral'>    function getSqrtRatioAtTick(int24 tick) internal pure returns (int256 sqrtPriceX96) {</span>
  32 |     | <span class='neutral'>        uint256 absTick = tick &lt; 0 ? uint256(-int256(tick)) : uint256(int256(tick));</span>
  33 |     | <span class='neutral'>        require(absTick &lt;= uint256(uint24(MAX_TICK)), &quot;T&quot;);</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>        uint256 ratio = absTick &amp; 0x1 != 0</span>
  36 |     | <span class='neutral'>            ? 0xfffcb933bd6fad37aa2d162d1a594001</span>
  37 |     | <span class='neutral'>            : 0x100000000000000000000000000000000;</span>
  38 |     | <span class='neutral'>        if (absTick &amp; 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) &gt;&gt; 128;</span>
  39 |     | <span class='neutral'>        if (absTick &amp; 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) &gt;&gt; 128;</span>
  40 |     | <span class='neutral'>        if (absTick &amp; 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) &gt;&gt; 128;</span>
  41 |     | <span class='neutral'>        if (absTick &amp; 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) &gt;&gt; 128;</span>
  42 |     | <span class='neutral'>        if (absTick &amp; 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) &gt;&gt; 128;</span>
  43 |     | <span class='neutral'>        if (absTick &amp; 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) &gt;&gt; 128;</span>
  44 |     | <span class='neutral'>        if (absTick &amp; 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) &gt;&gt; 128;</span>
  45 |     | <span class='neutral'>        if (absTick &amp; 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) &gt;&gt; 128;</span>
  46 |     | <span class='neutral'>        if (absTick &amp; 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) &gt;&gt; 128;</span>
  47 |     | <span class='neutral'>        if (absTick &amp; 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) &gt;&gt; 128;</span>
  48 |     | <span class='neutral'>        if (absTick &amp; 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) &gt;&gt; 128;</span>
  49 |     | <span class='neutral'>        if (absTick &amp; 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) &gt;&gt; 128;</span>
  50 |     | <span class='neutral'>        if (absTick &amp; 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) &gt;&gt; 128;</span>
  51 |     | <span class='neutral'>        if (absTick &amp; 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) &gt;&gt; 128;</span>
  52 |     | <span class='neutral'>        if (absTick &amp; 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) &gt;&gt; 128;</span>
  53 |     | <span class='neutral'>        if (absTick &amp; 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) &gt;&gt; 128;</span>
  54 |     | <span class='neutral'>        if (absTick &amp; 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) &gt;&gt; 128;</span>
  55 |     | <span class='neutral'>        if (absTick &amp; 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) &gt;&gt; 128;</span>
  56 |     | <span class='neutral'>        if (absTick &amp; 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) &gt;&gt; 128;</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>        if (tick &gt; 0) ratio = type(uint256).max / ratio;</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>        // this divides by 1&lt;&lt;32 rounding up to go from a Q128.128 to a Q128.96.</span>
  61 |     | <span class='neutral'>        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint</span>
  62 |     | <span class='neutral'>        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent</span>
  63 |     | <span class='neutral'>        sqrtPriceX96 = int256((ratio &gt;&gt; 32) + (ratio % (1 &lt;&lt; 32) == 0 ? 0 : 1));</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'>}</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>contract UniV3Oracle is ImmutableGovernance, INFTValueOracle {</span>
  68 |     | <span class='neutral'>    INonfungiblePositionManager public immutable manager;</span>
  69 |     | <span class='neutral'>    IUniswapV3Factory public immutable factory;</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    int256 collateralFactor = 1 ether;</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>    mapping(address =&gt; IERC20ValueOracle) public erc20ValueOracle;</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    int256 constant Q96 = int256(FixedPoint96.Q96);</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    constructor(address _factory, address _manager, address _owner) ImmutableGovernance(_owner) {</span>
  78 |     | <span class='neutral'>        manager = INonfungiblePositionManager(_manager);</span>
  79 |     | <span class='neutral'>        factory = IUniswapV3Factory(_factory);</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    function setERC20ValueOracle(address token, address oracle) external onlyGovernance {</span>
  83 |     | <span class='neutral'>        erc20ValueOracle[token] = IERC20ValueOracle(oracle);</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    function setCollateralFactor(int256 _collateralFactor) external onlyGovernance {</span>
  87 |     | <span class='neutral'>        collateralFactor = _collateralFactor;</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    function calcValue(uint256 tokenId) external view override returns (int256, int256) {</span>
  91 |     | <span class='neutral'>        address token0;</span>
  92 |     | <span class='neutral'>        address token1;</span>
  93 |     | <span class='neutral'>        int256 liquidity;</span>
  94 |     | <span class='neutral'>        int256 sqrtPrice;</span>
  95 |     | <span class='neutral'>        int256 baseX;</span>
  96 |     | <span class='neutral'>        int256 baseY;</span>
  97 |     | <span class='neutral'>        {</span>
  98 |     | <span class='neutral'>            (</span>
  99 |     | <span class='neutral'>                ,</span>
 100 |     | <span class='neutral'>                ,</span>
 101 |     | <span class='neutral'>                address token0Tmp,</span>
 102 |     | <span class='neutral'>                address token1Tmp,</span>
 103 |     | <span class='neutral'>                uint24 fee,</span>
 104 |     | <span class='neutral'>                int24 tickLower,</span>
 105 |     | <span class='neutral'>                int24 tickUpper,</span>
 106 |     | <span class='neutral'>                uint128 liquidityUnsigned,</span>
 107 |     | <span class='neutral'>                ,</span>
 108 |     | <span class='neutral'>                ,</span>
 109 |     | <span class='neutral'>                ,</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>            ) = manager.positions(tokenId);</span>
 112 |     | <span class='neutral'>            liquidity = int256(uint256(liquidityUnsigned));</span>
 113 |     | <span class='neutral'>            IUniswapV3Pool pool = IUniswapV3Pool(factory.getPool(token0Tmp, token1Tmp, fee));</span>
 114 |     | <span class='neutral'>            (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();</span>
 115 |     | <span class='neutral'>            sqrtPrice = int256(uint256(sqrtPriceX96));</span>
 116 |     | <span class='neutral'>            token0 = token0Tmp;</span>
 117 |     | <span class='neutral'>            token1 = token1Tmp;</span>
 118 |     | <span class='neutral'>            int256 lowerSqrtPrice = TickMath.getSqrtRatioAtTick(tickLower);</span>
 119 |     | <span class='neutral'>            int256 upperSqrtPrice = TickMath.getSqrtRatioAtTick(tickUpper);</span>
 120 |     | <span class='neutral'>            // Clamp the price into the range</span>
 121 |     | <span class='neutral'>            sqrtPrice = FsMath.clip(sqrtPrice, lowerSqrtPrice, upperSqrtPrice);</span>
 122 |     | <span class='neutral'>            baseX = (liquidity * Q96) / upperSqrtPrice;</span>
 123 |     | <span class='neutral'>            baseY = (lowerSqrtPrice * liquidity) / Q96;</span>
 124 |     | <span class='neutral'>        }</span>
 125 |     | <span class='neutral'>        // X token0 amount, Y token1 amount</span>
 126 |     | <span class='neutral'>        // L = sqrt(X * Y)  p = Y / X</span>
 127 |     | <span class='neutral'>        // Thus sqrt(p) * L = Y and sqrt(p) / L = X</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>        int256 amountY = (sqrtPrice * liquidity) / Q96 - baseY;</span>
 130 |     | <span class='neutral'>        int256 amountX = (liquidity * Q96) / sqrtPrice - baseX;</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>        int256 value = 0;</span>
 133 |     | <span class='neutral'>        int256 riskAdjustedValue;</span>
 134 |     | <span class='neutral'>        {</span>
 135 |     | <span class='neutral'>            IERC20ValueOracle valueOracle = erc20ValueOracle[token0];</span>
 136 |     | <span class='neutral'>            if (address(valueOracle) != address(0)) {</span>
 137 |     | <span class='neutral'>                (int256 assetValue, int256 adjustedAssetValue) = valueOracle.calcValue(amountX);</span>
 138 |     | <span class='neutral'>                value += assetValue;</span>
 139 |     | <span class='neutral'>                riskAdjustedValue += adjustedAssetValue;</span>
 140 |     | <span class='neutral'>            }</span>
 141 |     | <span class='neutral'>        }</span>
 142 |     | <span class='neutral'>        {</span>
 143 |     | <span class='neutral'>            IERC20ValueOracle valueOracle = erc20ValueOracle[token1];</span>
 144 |     | <span class='neutral'>            if (address(valueOracle) != address(0)) {</span>
 145 |     | <span class='neutral'>                (int256 assetValue, int256 adjustedAssetValue) = valueOracle.calcValue(amountY);</span>
 146 |     | <span class='neutral'>                value += assetValue;</span>
 147 |     | <span class='neutral'>                riskAdjustedValue += adjustedAssetValue;</span>
 148 |     | <span class='neutral'>            }</span>
 149 |     | <span class='neutral'>        }</span>
 150 |     | <span class='neutral'>        riskAdjustedValue = (riskAdjustedValue * collateralFactor) / 1 ether;</span>
 151 |     | <span class='neutral'>        return (value, riskAdjustedValue);</span>
 152 |     | <span class='neutral'>    }</span>
 153 |     | <span class='neutral'>}</span>
 154 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/testing/Echidna.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../dos/DOS.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;../dos/DSafeProxy.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;../dos/VersionManager.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../interfaces/IVersionManager.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;../lib/FsMath.sol&quot;;</span>
  9 |     | <span class='neutral'>import &quot;../lib/FsUtils.sol&quot;;</span>
 10 |     | <span class='neutral'>import &quot;../lib/ImmutableVersion.sol&quot;;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>// echidna-test . --config echidna.yaml --contract Echidna</span>
 13 |     | <span class='neutral'>contract Echidna {</span>
 14 |     | <span class='neutral'>  constructor() public {</span>
 15 |     | <span class='neutral'>    initDos();</span>
 16 |     | <span class='neutral'>  }</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>  function testExp(int256 xa, int256 xb) public {</span>
 19 |     | <span class='neutral'>    int256 x = xa*FsMath.FIXED_POINT_SCALE+xb;</span>
 20 |     | <span class='neutral'>    int256 result = FsMath.exp(x);</span>
 21 |     | <span class='neutral'>    int256 epsilon = int256(1)&lt;&lt;uint256(10); // 2^10, far less than FIXED_POINT_SCALE</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    if (x &gt;= 0)</span>
 24 |     | <span class='neutral'>      assert(result &gt;= FsMath.FIXED_POINT_SCALE);</span>
 25 |     | <span class='neutral'>    if (x &gt;= epsilon)</span>
 26 |     | <span class='neutral'>      assert(result &gt; FsMath.FIXED_POINT_SCALE);</span>
 27 |     | <span class='neutral'>    if (x &lt;= 0)</span>
 28 |     | <span class='neutral'>      assert(result &lt;= FsMath.FIXED_POINT_SCALE);</span>
 29 |     | <span class='neutral'>    if (x &lt;= -epsilon)</span>
 30 |     | <span class='neutral'>      assert(result &lt; FsMath.FIXED_POINT_SCALE);</span>
 31 |     | <span class='neutral'>  }</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>  function testPow(int256 xa, int256 xb, int256 n) public {</span>
 34 |     | <span class='neutral'>    int256 x = xa*FsMath.FIXED_POINT_SCALE+xb;</span>
 35 |     | <span class='neutral'>    int256 result = FsMath.pow(x,n);</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    int256 signExpected = FsMath.sign(x);</span>
 38 |     | <span class='neutral'>    if (n % 2 == 0 &amp;&amp; signExpected == -1) // when n is even, x^n is positive</span>
 39 |     | <span class='neutral'>      signExpected = 1;</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    if (n == 0) // x^0 = 1</span>
 42 |     | <span class='neutral'>      assert(result == FsMath.FIXED_POINT_SCALE);</span>
 43 |     | <span class='neutral'>    else if (n &lt; 0 || (x &gt; -FsMath.FIXED_POINT_SCALE &amp;&amp; x &lt; FsMath.FIXED_POINT_SCALE)) // if n is negative or |x| &lt; 1, x^n can round to 0</span>
 44 |     | <span class='neutral'>      assert(FsMath.sign(result) == signExpected || result == 0);</span>
 45 |     | <span class='neutral'>    else</span>
 46 |     | <span class='neutral'>      assert(FsMath.sign(result) == signExpected);</span>
 47 |     | <span class='neutral'>  }</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='neutral'>  function testSqrt(int256 xa, int256 xb) public {</span>
 50 |     | <span class='neutral'>    int256 x = xa*FsMath.FIXED_POINT_SCALE+xb;</span>
 51 |     | <span class='neutral'>    require(x &gt;= 0, &quot;Must be positive&quot;);</span>
 52 |     | <span class='neutral'>    require(x &lt;= 100*FsMath.FIXED_POINT_SCALE, &quot;Too big&quot;);</span>
 53 |     | <span class='neutral'>    int256 result = FsMath.sqrt(x);</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='neutral'>    assert(result &gt;= 0);</span>
 56 |     | <span class='neutral'>    if (x &gt;= FsMath.FIXED_POINT_SCALE)</span>
 57 |     | <span class='neutral'>      assert(result &lt;= x);</span>
 58 |     | <span class='neutral'>    else</span>
 59 |     | <span class='neutral'>      assert(result &gt;= x);</span>
 60 |     | <span class='neutral'>  }</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='neutral'>  VersionManager public versionManager;</span>
 63 |     | <span class='neutral'>  DOSConfig public dosConfig;</span>
 64 |     | <span class='neutral'>  DOS public dos;</span>
 65 |     | <span class='neutral'>  DSafeLogic public dSafeLogic;</span>
 66 |     | <span class='neutral'>  DSafeProxy public proxy1_1;</span>
 67 |     | <span class='neutral'>  DSafeProxy public proxy1_2;</span>
 68 |     | <span class='neutral'>  DSafeProxy public proxy2_1;</span>
 69 |     | <span class='neutral'>  DSafeProxy public proxy2_2;</span>
 70 |     | <span class='neutral'>  DSafeProxy public proxy3_1;</span>
 71 |     | <span class='neutral'>  DSafeProxy public proxy3_2;</span>
 72 |     | <span class='neutral'>  function initDos() internal {</span>
 73 |     | <span class='neutral'>    versionManager = new VersionManager(address(this));</span>
 74 |     | <span class='neutral'>    dosConfig = new DOSConfig(address(this));</span>
 75 |     | <span class='neutral'>    dos = new DOS(address(dosConfig), address(versionManager));</span>
 76 |     | <span class='neutral'>    dSafeLogic = new DSafeLogic(address(dos));</span>
 77 |     | <span class='neutral'></span>
 78 |     | <span class='neutral'>    dosConfig.setVersionManager(address(versionManager));</span>
 79 |     | <span class='neutral'></span>
 80 |     | <span class='neutral'>    versionManager.addVersion(IVersionManager.Status.PRODUCTION, address(dSafeLogic));</span>
 81 |     | <span class='neutral'>    string memory versionName = string(FsUtils.decodeFromBytes32(dSafeLogic.immutableVersion()));</span>
 82 |     | <span class='neutral'>    versionManager.markRecommendedVersion(versionName);</span>
 83 |     | <span class='neutral'></span>
 84 |     | <span class='neutral'>    proxy1_1 = DSafeProxy(payable(dosConfig._createDSafe(address(0x10000))));</span>
 85 |     | <span class='neutral'>    proxy1_2 = DSafeProxy(payable(dosConfig._createDSafe(address(0x10000))));</span>
 86 |     | <span class='neutral'>    proxy2_1 = DSafeProxy(payable(dosConfig._createDSafe(address(0x20000))));</span>
 87 |     | <span class='neutral'>    proxy2_2 = DSafeProxy(payable(dosConfig._createDSafe(address(0x20000))));</span>
 88 |     | <span class='neutral'>    proxy3_1 = DSafeProxy(payable(dosConfig._createDSafe(address(0x30000))));</span>
 89 |     | <span class='neutral'>    proxy3_2 = DSafeProxy(payable(dosConfig._createDSafe(address(0x30000))));</span>
 90 |     | <span class='neutral'>  }</span>
 91 |     | <span class='neutral'>}</span>
 92 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/testing/Echidna2.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../dos/DOS.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;../dos/DSafeProxy.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;../dos/VersionManager.sol&quot;;</span>
  7 |     | <span class='unexecuted'>import &quot;../interfaces/IVersionManager.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;../lib/FsMath.sol&quot;;</span>
  9 |     | <span class='neutral'>import &quot;../lib/FsUtils.sol&quot;;</span>
 10 |     | <span class='neutral'>import &quot;../lib/ImmutableVersion.sol&quot;;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>contract Echidna2 {</span>
 13 |     | <span class='neutral'>  // SETUP STUFF, I THINK I DID THIS PART RIGHT:</span>
 14 |     | <span class='neutral'>  VersionManager public versionManager;</span>
 15 |     | <span class='neutral'>  DOSConfig public dosConfig;</span>
 16 |     | <span class='neutral'>  DOS public dos;</span>
 17 |     | <span class='neutral'>  DSafeLogic public dSafeLogic;</span>
 18 |     | <span class='neutral'>  DSafeProxy public proxy1;</span>
 19 |     | <span class='neutral'>  constructor() public {</span>
 20 |     | <span class='neutral'>    versionManager = new VersionManager(address(this));</span>
 21 |     | <span class='neutral'>    dosConfig = new DOSConfig(address(this));</span>
 22 |     | <span class='neutral'>    dos = new DOS(address(dosConfig), address(versionManager));</span>
 23 |     | <span class='neutral'>    dSafeLogic = new DSafeLogic(address(dos));</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    IDOSConfig(address(dos)).setConfig(</span>
 26 |     | <span class='neutral'>            IDOSConfig.Config({</span>
 27 |     | <span class='neutral'>                treasurySafe: address(0),</span>
 28 |     | <span class='neutral'>                treasuryInterestFraction: 0,</span>
 29 |     | <span class='neutral'>                maxSolvencyCheckGasCost: 10_000_000,</span>
 30 |     | <span class='neutral'>                liqFraction: 8e17,</span>
 31 |     | <span class='neutral'>                fractionalReserveLeverage: 10</span>
 32 |     | <span class='neutral'>            })</span>
 33 |     | <span class='neutral'>        );</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    //dosConfig.setVersionManager(address(versionManager));</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='unexecuted'>    versionManager.addVersion(IVersionManager.Status.PRODUCTION, address(dSafeLogic));</span>
 38 |     | <span class='neutral'>    //string memory versionName = string(FsUtils.decodeFromBytes32(dSafeLogic.immutableVersion()));</span>
 39 |     | <span class='neutral'>    versionManager.markRecommendedVersion(&quot;1.0.0&quot;);</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    // pretty sure everything up here is good</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='unexecuted'>    proxy1 = DSafeProxy(payable(IDOSConfig(address(dos)).createDSafe()));</span>
 44 |     | <span class='neutral'>  }</span>
 45 |     | <span class='neutral'>  function ensureProxyNonzero() public { // fails in assert mode, meaning proxy1 is nonzero</span>
 46 |     | <span class='neutral'>    if (address(proxy1) != address(0))</span>
 47 |     | <span class='neutral'>      assert(false);</span>
 48 |     | <span class='neutral'>  }</span>
 49 |     | <span class='neutral'>  // ONE OF THESE TWO SHOULD WORK:</span>
 50 |     | <span class='neutral'>  function tryToCall1() public { // passes in assert mode, meaning the call isn&#39;t working</span>
 51 |     | <span class='neutral'>    DSafeProxy(payable(address(proxy1))).executeBatch(new Call[](0));</span>
 52 |     | <span class='neutral'>  }</span>
 53 |     | <span class='neutral'>  function tryToCall2() public { // passes in assert mode, meaning the call isn&#39;t working</span>
 54 |     | <span class='neutral'>    DSafeLogic(payable(address(proxy1))).executeBatch(new Call[](0));</span>
 55 |     | <span class='neutral'>  }</span>
 56 |     | <span class='unexecuted'>}</span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/testing/MockERC20Oracle.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../interfaces/IERC20ValueOracle.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;../lib/ImmutableGovernance.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>contract MockERC20Oracle is IERC20ValueOracle, ImmutableGovernance {</span>
  8 |     | <span class='neutral'>    int256 public price;</span>
  9 |     | <span class='neutral'>    int256 collateralFactor = 1 ether;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    constructor(address owner) ImmutableGovernance(owner) {}</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function setPrice(</span>
 14 |     | <span class='neutral'>        int256 _price,</span>
 15 |     | <span class='neutral'>        uint256 baseDecimals,</span>
 16 |     | <span class='neutral'>        uint256 decimals</span>
 17 |     | <span class='neutral'>    ) external onlyGovernance {</span>
 18 |     | <span class='neutral'>        price = (_price * (int256(10) ** (18 + baseDecimals - decimals))) / 1 ether;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function setCollateralFactor(int256 _collateralFactor) external onlyGovernance {</span>
 22 |     | <span class='neutral'>        collateralFactor = _collateralFactor;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='unexecuted'>    function calcValue(</span>
 26 |     | <span class='neutral'>        int256 amount</span>
 27 |     | <span class='neutral'>    ) external view override returns (int256 value, int256 riskAdjustedValue) {</span>
 28 |     | <span class='neutral'>        value = (amount * price) / 1 ether;</span>
 29 |     | <span class='neutral'>        riskAdjustedValue = (value * collateralFactor) / 1 ether;</span>
 30 |     | <span class='neutral'>        return (value, riskAdjustedValue);</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'>}</span>
 33 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/testing/MockNFTOracle.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../interfaces/INFTValueOracle.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/utils/Strings.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>contract MockNFTOracle is INFTValueOracle {</span>
  8 |     | <span class='neutral'>    mapping(uint256 =&gt; int256) prices;</span>
  9 |     | <span class='neutral'>    int256 collateralFactor = 1 ether;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function setPrice(uint256 tokenId, int256 price) external {</span>
 12 |     | <span class='neutral'>        require(</span>
 13 |     | <span class='neutral'>            price != -1,</span>
 14 |     | <span class='unexecuted'>            &quot;Please, don&#39;t use -1 as NFT price - it&#39;s a reserved value used for early error detection&quot;</span>
 15 |     | <span class='neutral'>        );</span>
 16 |     | <span class='neutral'>        prices[tokenId] = price + 1;</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    function setCollateralFactor(int256 _collateralFactor) external {</span>
 20 |     | <span class='neutral'>        collateralFactor = _collateralFactor;</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    function calcValue(uint256 tokenId) external view override returns (int256, int256) {</span>
 24 |     | <span class='neutral'>        require(</span>
 25 |     | <span class='neutral'>            prices[tokenId] &gt; 0,</span>
 26 |     | <span class='neutral'>            string.concat(</span>
 27 |     | <span class='neutral'>                &quot;Price for the NFT with tokenId &quot;,</span>
 28 |     | <span class='neutral'>                Strings.toString(tokenId),</span>
 29 |     | <span class='neutral'>                &quot; is not set&quot;</span>
 30 |     | <span class='neutral'>            )</span>
 31 |     | <span class='neutral'>        );</span>
 32 |     | <span class='neutral'>        int256 value = prices[tokenId] - 1;</span>
 33 |     | <span class='unexecuted'>        int256 riskAdjustedValue = (value * collateralFactor) / 1 ether;</span>
 34 |     | <span class='neutral'>        return (value, riskAdjustedValue);</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'>}</span>
 37 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/testing/TestERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.7;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>contract TestERC20 is ERC20 {</span>
  7 |     | <span class='unexecuted'>    uint8 private immutable _decimals;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    constructor(string memory name, string memory symbol, uint8 deci) ERC20(name, symbol) {</span>
 10 |     | <span class='neutral'>        _decimals = deci;</span>
 11 |     | <span class='neutral'>    }</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function mint(address to, uint256 amount) external {</span>
 14 |     | <span class='neutral'>        _mint(to, amount);</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    function decimals() public view virtual override returns (uint8) {</span>
 18 |     | <span class='neutral'>        return _decimals;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'>}</span>
 21 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/testing/TestFsMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../lib/FsMath.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>contract TestFsMath {</span>
  7 |     | <span class='neutral'>    function abs(int256 value) external pure returns (uint256) {</span>
  8 |     | <span class='neutral'>        return FsMath.abs(value);</span>
  9 |     | <span class='neutral'>    }</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function sabs(int256 value) external pure returns (int256) {</span>
 12 |     | <span class='neutral'>        return FsMath.sabs(value);</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    function sign(int256 value) external pure returns (int256) {</span>
 16 |     | <span class='neutral'>        return FsMath.sign(value);</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    function min(int256 a, int256 b) external pure returns (int256) {</span>
 20 |     | <span class='neutral'>        return FsMath.min(a, b);</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>    function max(int256 a, int256 b) external pure returns (int256) {</span>
 24 |     | <span class='unexecuted'>        return FsMath.max(a, b);</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>    // Clip val into interval [lower, upper]</span>
 28 |     | <span class='unexecuted'>    function clip(int256 val, int256 lower, int256 upper) external pure returns (int256) {</span>
 29 |     | <span class='neutral'>        return FsMath.clip(val, lower, upper);</span>
 30 |     | <span class='unexecuted'>    }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='unexecuted'>    function safeCastToSigned(uint256 x) external pure returns (int256) {</span>
 33 |     | <span class='unexecuted'>        return FsMath.safeCastToSigned(x);</span>
 34 |     | <span class='unexecuted'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='unexecuted'>    function safeCastToUnsigned(int256 x) external pure returns (uint256) {</span>
 37 |     | <span class='neutral'>        return FsMath.safeCastToUnsigned(x);</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    function exp(int256 x) external pure returns (int256) {</span>
 41 |     | <span class='neutral'>        return FsMath.exp(x);</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    function sqrt(int256 x) external pure returns (int256) {</span>
 45 |     | <span class='neutral'>        return FsMath.sqrt(x);</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    function bitCount(uint256 x) external pure returns (uint256) {</span>
 49 |     | <span class='neutral'>        return FsMath.bitCount(x);</span>
 50 |     | <span class='neutral'>    }</span>
 51 |     | <span class='neutral'>}</span>
 52 | *r  | <span class='executed'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/testing/TestNFT.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC721/ERC721.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/utils/Counters.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>contract TestNFT is ERC721 {</span>
  8 |     | <span class='neutral'>    using Counters for Counters.Counter;</span>
  9 |     | <span class='neutral'>    Counters.Counter private tokenIdCounter;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    event Mint(uint256 tokenId);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    constructor(</span>
 14 |     | <span class='neutral'>        string memory name,</span>
 15 |     | <span class='neutral'>        string memory symbol,</span>
 16 |     | <span class='neutral'>        uint256 initTokenId</span>
 17 |     | <span class='neutral'>    ) ERC721(name, symbol) {</span>
 18 |     | <span class='neutral'>        tokenIdCounter._value = initTokenId;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function mint(address to) public returns (uint256) {</span>
 22 |     | <span class='neutral'>        uint256 tokenId = tokenIdCounter.current();</span>
 23 |     | <span class='neutral'>        tokenIdCounter.increment();</span>
 24 |     | <span class='neutral'>        _mint(to, tokenId);</span>
 25 |     | <span class='neutral'>        emit Mint(tokenId);</span>
 26 |     | <span class='neutral'>        return tokenId;</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'>}</span>
 29 | r   | <span class='reverted'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/testing/TestTrie.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../lib/Proofs.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>contract TestTrie {</span>
  7 |     | <span class='neutral'>    function verify(</span>
  8 |     | <span class='neutral'>        bytes calldata key,</span>
  9 |     | <span class='neutral'>        bytes32 root,</span>
 10 |     | <span class='neutral'>        bytes calldata proof</span>
 11 |     | <span class='neutral'>    ) external pure returns (bytes memory) {</span>
 12 |     | <span class='neutral'>        return BytesViewLib.toBytes(TrieLib.verify(bytes32(key), key.length, root, proof));</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'>}</span>
 15 | *r  | <span class='executed'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/testing/VotingTest.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../governance/Voting.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>contract VotingTest is Voting {</span>
  7 |     | <span class='neutral'>    bytes32 public mockBlockHash;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    constructor(</span>
 10 |     | <span class='neutral'>        address hashNFT_,</span>
 11 |     | <span class='neutral'>        address governanceToken_,</span>
 12 |     | <span class='neutral'>        uint256 mappingSlot_,</span>
 13 |     | <span class='neutral'>        uint256 totalSupplySlot_,</span>
 14 |     | <span class='neutral'>        address governance_</span>
 15 |     | <span class='neutral'>    ) Voting(hashNFT_, governanceToken_, mappingSlot_, totalSupplySlot_, governance_) {}</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function setMockBlockHash(bytes32 blockHash) external {</span>
 18 |     | <span class='neutral'>        mockBlockHash = blockHash;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function getBlockHash(uint256) internal view override returns (bytes32) {</span>
 22 |     | <span class='neutral'>        return mockBlockHash;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/testing/external/WETH9.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.7;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/utils/Address.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>contract WETH9 is ERC20 {</span>
  8 |     | <span class='neutral'>    constructor() ERC20(&quot;Wrapped ETH&quot;, &quot;WETH&quot;) {}</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    function deposit() external payable {</span>
 11 |     | <span class='neutral'>        _mint(msg.sender, msg.value);</span>
 12 |     | <span class='neutral'>    }</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    function withdraw(uint256 amount) external {</span>
 15 |     | <span class='neutral'>        _burn(msg.sender, amount);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>        Address.sendValue(payable(msg.sender), amount);</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    function mint(address to, uint256 amount) external {</span>
 21 |     | <span class='neutral'>        _mint(to, amount);</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'>}</span>
 24 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/tokens/HashNFT.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Burnable.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='unexecuted'>/// @title HashNFT a NFT for cryptographic proof of ownership.</span>
  7 |     | <span class='neutral'>/// @notice A generic ownerless contract that allows fine grained access control,</span>
  8 |     | <span class='neutral'>/// voting and other use cases build on top of.</span>
  9 |     | <span class='neutral'>/// @dev The 256 bit tokenId of ERC1155 is used to store cryptographic hash of the</span>
 10 |     | <span class='neutral'>/// an arbitrary digest and minter address. The cryptographic security of the hash</span>
 11 |     | <span class='neutral'>/// provides the guarantees of the contract.</span>
 12 |     | <span class='neutral'>/// 1) Each token id is associated with only one minter and digest.</span>
 13 |     | <span class='neutral'>/// 2) Ownership of a token id implies the minter has granted (directly or indirectly)</span>
 14 |     | <span class='neutral'>///    the ownership to the owner. (The minter can revoke the token at any time.</span>
 15 |     | <span class='neutral'>/// 3) A minter (and only the minter) can revoke tokens it issued itself.</span>
 16 |     | <span class='neutral'>/// 4) Everyone can burn tokens they own.</span>
 17 |     | <span class='neutral'>contract HashNFT is ERC1155Burnable {</span>
 18 |     | <span class='neutral'>    bytes constant HASHNFT_TYPESTRING = &quot;HashNFT(address minter,bytes32 digest)&quot;;</span>
 19 |     | <span class='neutral'>    bytes32 constant HASHNFT_TYPEHASH = keccak256(HASHNFT_TYPESTRING);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    event Minted(uint256 indexed tokenId, address indexed minter, bytes32 indexed digest);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    constructor(string memory uri) ERC1155(uri) {}</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    function mint(</span>
 26 |     | <span class='neutral'>        address to,</span>
 27 |     | <span class='neutral'>        bytes32 digest,</span>
 28 |     | <span class='neutral'>        bytes calldata data</span>
 29 |     | <span class='neutral'>    ) external returns (uint256 tokenId) {</span>
 30 |     | <span class='neutral'>        tokenId = toTokenId(msg.sender, digest);</span>
 31 |     | <span class='neutral'>        _mint(to, tokenId, 1, data);</span>
 32 |     | <span class='neutral'>        emit Minted(tokenId, msg.sender, digest);</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    // The minter can revoke tokens it minted.</span>
 36 |     | <span class='neutral'>    function revoke(address from, bytes32 digest) external {</span>
 37 |     | <span class='neutral'>        uint256 tokenId = toTokenId(msg.sender, digest);</span>
 38 |     | <span class='neutral'>        _burn(from, tokenId, 1);</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    // Crypto secure hash function, to ensure only valid digest are recognized</span>
 42 |     | <span class='neutral'>    function toTokenId(address minter, bytes32 digest) public pure returns (uint256) {</span>
 43 |     | <span class='neutral'>        return uint256(keccak256(abi.encode(HASHNFT_TYPEHASH, minter, digest)));</span>
 44 |     | <span class='neutral'>    }</span>
 45 |     | <span class='neutral'>}</span>
 46 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/contracts/utils/TypeChainGeneration.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol&quot;;</span>
  7 |     | <span class='neutral'>// These unfortunately don&#39;t compile due to conflict with our version of openzeppelin</span>
  8 |     | <span class='unexecuted'>// import &quot;@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol&quot;;</span>
  9 |     | <span class='neutral'>// import &quot;@uniswap/v3-periphery/contracts/interfaces/INonfungibleTokenPositionDescriptor.sol&quot;;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>// Just here so solidity compiles and typechain generates the types</span>
 12 | *r  | <span class='executed'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/lib/forge-std/lib/ds-test/src/test.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>// This program is free software: you can redistribute it and/or modify</span>
   4 |     | <span class='unexecuted'>// it under the terms of the GNU General Public License as published by</span>
   5 |     | <span class='neutral'>// the Free Software Foundation, either version 3 of the License, or</span>
   6 |     | <span class='neutral'>// (at your option) any later version.</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>// This program is distributed in the hope that it will be useful,</span>
   9 |     | <span class='neutral'>// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
  10 |     | <span class='neutral'>// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
  11 |     | <span class='neutral'>// GNU General Public License for more details.</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>// You should have received a copy of the GNU General Public License</span>
  14 |     | <span class='neutral'>// along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>contract DSTest {</span>
  19 |     | <span class='neutral'>    event log                    (string);</span>
  20 |     | <span class='neutral'>    event logs                   (bytes);</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    event log_address            (address);</span>
  23 |     | <span class='neutral'>    event log_bytes32            (bytes32);</span>
  24 |     | <span class='neutral'>    event log_int                (int);</span>
  25 |     | <span class='neutral'>    event log_uint               (uint);</span>
  26 |     | <span class='neutral'>    event log_bytes              (bytes);</span>
  27 |     | <span class='neutral'>    event log_string             (string);</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    event log_named_address      (string key, address val);</span>
  30 |     | <span class='neutral'>    event log_named_bytes32      (string key, bytes32 val);</span>
  31 |     | <span class='neutral'>    event log_named_decimal_int  (string key, int val, uint decimals);</span>
  32 |     | <span class='neutral'>    event log_named_decimal_uint (string key, uint val, uint decimals);</span>
  33 |     | <span class='unexecuted'>    event log_named_int          (string key, int val);</span>
  34 |     | <span class='unexecuted'>    event log_named_uint         (string key, uint val);</span>
  35 |     | <span class='unexecuted'>    event log_named_bytes        (string key, bytes val);</span>
  36 |     | <span class='neutral'>    event log_named_string       (string key, string val);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    bool public IS_TEST = true;</span>
  39 |     | <span class='neutral'>    bool private _failed;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    address constant HEVM_ADDRESS =</span>
  42 |     | <span class='neutral'>        address(bytes20(uint160(uint256(keccak256(&#39;hevm cheat code&#39;)))));</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    modifier mayRevert() { _; }</span>
  45 |     | <span class='neutral'>    modifier testopts(string memory) { _; }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    function failed() public returns (bool) {</span>
  48 |     | <span class='neutral'>        if (_failed) {</span>
  49 |     | <span class='neutral'>            return _failed;</span>
  50 |     | <span class='neutral'>        } else {</span>
  51 |     | <span class='neutral'>            bool globalFailed = false;</span>
  52 |     | <span class='neutral'>            if (hasHEVMContext()) {</span>
  53 |     | <span class='neutral'>                (, bytes memory retdata) = HEVM_ADDRESS.call(</span>
  54 |     | <span class='neutral'>                    abi.encodePacked(</span>
  55 |     | <span class='neutral'>                        bytes4(keccak256(&quot;load(address,bytes32)&quot;)),</span>
  56 |     | <span class='neutral'>                        abi.encode(HEVM_ADDRESS, bytes32(&quot;failed&quot;))</span>
  57 |     | <span class='neutral'>                    )</span>
  58 |     | <span class='neutral'>                );</span>
  59 |     | <span class='neutral'>                globalFailed = abi.decode(retdata, (bool));</span>
  60 |     | <span class='neutral'>            }</span>
  61 |     | <span class='neutral'>            return globalFailed;</span>
  62 |     | <span class='neutral'>        }</span>
  63 |     | <span class='neutral'>    } </span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    function fail() internal {</span>
  66 |     | <span class='neutral'>        if (hasHEVMContext()) {</span>
  67 |     | <span class='neutral'>            (bool status, ) = HEVM_ADDRESS.call(</span>
  68 |     | <span class='neutral'>                abi.encodePacked(</span>
  69 |     | <span class='neutral'>                    bytes4(keccak256(&quot;store(address,bytes32,bytes32)&quot;)),</span>
  70 |     | <span class='neutral'>                    abi.encode(HEVM_ADDRESS, bytes32(&quot;failed&quot;), bytes32(uint256(0x01)))</span>
  71 |     | <span class='neutral'>                )</span>
  72 |     | <span class='neutral'>            );</span>
  73 |     | <span class='neutral'>            status; // Silence compiler warnings</span>
  74 |     | <span class='neutral'>        }</span>
  75 |     | <span class='neutral'>        _failed = true;</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    function hasHEVMContext() internal view returns (bool) {</span>
  79 |     | <span class='neutral'>        uint256 hevmCodeSize = 0;</span>
  80 |     | <span class='neutral'>        assembly {</span>
  81 |     | <span class='neutral'>            hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)</span>
  82 |     | <span class='neutral'>        }</span>
  83 |     | <span class='neutral'>        return hevmCodeSize &gt; 0;</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    modifier logs_gas() {</span>
  87 |     | <span class='neutral'>        uint startGas = gasleft();</span>
  88 |     | <span class='neutral'>        _;</span>
  89 |     | <span class='neutral'>        uint endGas = gasleft();</span>
  90 |     | <span class='neutral'>        emit log_named_uint(&quot;gas&quot;, startGas - endGas);</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    function assertTrue(bool condition) internal {</span>
  94 |     | <span class='neutral'>        if (!condition) {</span>
  95 |     | <span class='neutral'>            emit log(&quot;Error: Assertion Failed&quot;);</span>
  96 |     | <span class='neutral'>            fail();</span>
  97 |     | <span class='neutral'>        }</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    function assertTrue(bool condition, string memory err) internal {</span>
 101 |     | <span class='neutral'>        if (!condition) {</span>
 102 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 103 |     | <span class='neutral'>            assertTrue(condition);</span>
 104 |     | <span class='neutral'>        }</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    function assertEq(address a, address b) internal {</span>
 108 |     | <span class='neutral'>        if (a != b) {</span>
 109 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [address]&quot;);</span>
 110 |     | <span class='neutral'>            emit log_named_address(&quot;  Expected&quot;, b);</span>
 111 |     | <span class='neutral'>            emit log_named_address(&quot;    Actual&quot;, a);</span>
 112 |     | <span class='neutral'>            fail();</span>
 113 |     | <span class='neutral'>        }</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'>    function assertEq(address a, address b, string memory err) internal {</span>
 116 |     | <span class='neutral'>        if (a != b) {</span>
 117 |     | <span class='neutral'>            emit log_named_string (&quot;Error&quot;, err);</span>
 118 |     | <span class='neutral'>            assertEq(a, b);</span>
 119 |     | <span class='neutral'>        }</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    function assertEq(bytes32 a, bytes32 b) internal {</span>
 123 |     | <span class='neutral'>        if (a != b) {</span>
 124 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [bytes32]&quot;);</span>
 125 |     | <span class='neutral'>            emit log_named_bytes32(&quot;  Expected&quot;, b);</span>
 126 |     | <span class='neutral'>            emit log_named_bytes32(&quot;    Actual&quot;, a);</span>
 127 |     | <span class='neutral'>            fail();</span>
 128 |     | <span class='neutral'>        }</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'>    function assertEq(bytes32 a, bytes32 b, string memory err) internal {</span>
 131 |     | <span class='neutral'>        if (a != b) {</span>
 132 |     | <span class='neutral'>            emit log_named_string (&quot;Error&quot;, err);</span>
 133 |     | <span class='neutral'>            assertEq(a, b);</span>
 134 |     | <span class='neutral'>        }</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'>    function assertEq32(bytes32 a, bytes32 b) internal {</span>
 137 |     | <span class='neutral'>        assertEq(a, b);</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'>    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {</span>
 140 |     | <span class='neutral'>        assertEq(a, b, err);</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    function assertEq(int a, int b) internal {</span>
 144 |     | <span class='neutral'>        if (a != b) {</span>
 145 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [int]&quot;);</span>
 146 |     | <span class='neutral'>            emit log_named_int(&quot;  Expected&quot;, b);</span>
 147 |     | <span class='neutral'>            emit log_named_int(&quot;    Actual&quot;, a);</span>
 148 |     | <span class='neutral'>            fail();</span>
 149 |     | <span class='neutral'>        }</span>
 150 |     | <span class='neutral'>    }</span>
 151 |     | <span class='neutral'>    function assertEq(int a, int b, string memory err) internal {</span>
 152 |     | <span class='neutral'>        if (a != b) {</span>
 153 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 154 |     | <span class='neutral'>            assertEq(a, b);</span>
 155 |     | <span class='neutral'>        }</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'>    function assertEq(uint a, uint b) internal {</span>
 158 |     | <span class='neutral'>        if (a != b) {</span>
 159 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [uint]&quot;);</span>
 160 |     | <span class='neutral'>            emit log_named_uint(&quot;  Expected&quot;, b);</span>
 161 |     | <span class='neutral'>            emit log_named_uint(&quot;    Actual&quot;, a);</span>
 162 |     | <span class='neutral'>            fail();</span>
 163 |     | <span class='neutral'>        }</span>
 164 |     | <span class='neutral'>    }</span>
 165 |     | <span class='neutral'>    function assertEq(uint a, uint b, string memory err) internal {</span>
 166 |     | <span class='neutral'>        if (a != b) {</span>
 167 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 168 |     | <span class='neutral'>            assertEq(a, b);</span>
 169 |     | <span class='neutral'>        }</span>
 170 |     | <span class='neutral'>    }</span>
 171 |     | <span class='neutral'>    function assertEqDecimal(int a, int b, uint decimals) internal {</span>
 172 |     | <span class='neutral'>        if (a != b) {</span>
 173 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [decimal int]&quot;);</span>
 174 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Expected&quot;, b, decimals);</span>
 175 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;    Actual&quot;, a, decimals);</span>
 176 |     | <span class='neutral'>            fail();</span>
 177 |     | <span class='neutral'>        }</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'>    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {</span>
 180 |     | <span class='neutral'>        if (a != b) {</span>
 181 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 182 |     | <span class='neutral'>            assertEqDecimal(a, b, decimals);</span>
 183 |     | <span class='neutral'>        }</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'>    function assertEqDecimal(uint a, uint b, uint decimals) internal {</span>
 186 |     | <span class='neutral'>        if (a != b) {</span>
 187 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [decimal uint]&quot;);</span>
 188 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Expected&quot;, b, decimals);</span>
 189 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;    Actual&quot;, a, decimals);</span>
 190 |     | <span class='neutral'>            fail();</span>
 191 |     | <span class='neutral'>        }</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'>    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {</span>
 194 |     | <span class='neutral'>        if (a != b) {</span>
 195 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 196 |     | <span class='neutral'>            assertEqDecimal(a, b, decimals);</span>
 197 |     | <span class='neutral'>        }</span>
 198 |     | <span class='neutral'>    }</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>    function assertGt(uint a, uint b) internal {</span>
 201 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 202 |     | <span class='neutral'>            emit log(&quot;Error: a &gt; b not satisfied [uint]&quot;);</span>
 203 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value a&quot;, a);</span>
 204 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value b&quot;, b);</span>
 205 |     | <span class='neutral'>            fail();</span>
 206 |     | <span class='neutral'>        }</span>
 207 |     | <span class='neutral'>    }</span>
 208 |     | <span class='neutral'>    function assertGt(uint a, uint b, string memory err) internal {</span>
 209 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 210 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 211 |     | <span class='neutral'>            assertGt(a, b);</span>
 212 |     | <span class='neutral'>        }</span>
 213 |     | <span class='neutral'>    }</span>
 214 |     | <span class='neutral'>    function assertGt(int a, int b) internal {</span>
 215 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 216 |     | <span class='neutral'>            emit log(&quot;Error: a &gt; b not satisfied [int]&quot;);</span>
 217 |     | <span class='neutral'>            emit log_named_int(&quot;  Value a&quot;, a);</span>
 218 |     | <span class='neutral'>            emit log_named_int(&quot;  Value b&quot;, b);</span>
 219 |     | <span class='neutral'>            fail();</span>
 220 |     | <span class='neutral'>        }</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'>    function assertGt(int a, int b, string memory err) internal {</span>
 223 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 224 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 225 |     | <span class='neutral'>            assertGt(a, b);</span>
 226 |     | <span class='neutral'>        }</span>
 227 |     | <span class='neutral'>    }</span>
 228 |     | <span class='neutral'>    function assertGtDecimal(int a, int b, uint decimals) internal {</span>
 229 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 230 |     | <span class='neutral'>            emit log(&quot;Error: a &gt; b not satisfied [decimal int]&quot;);</span>
 231 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value a&quot;, a, decimals);</span>
 232 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value b&quot;, b, decimals);</span>
 233 |     | <span class='neutral'>            fail();</span>
 234 |     | <span class='neutral'>        }</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'>    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {</span>
 237 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 238 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 239 |     | <span class='neutral'>            assertGtDecimal(a, b, decimals);</span>
 240 |     | <span class='neutral'>        }</span>
 241 |     | <span class='neutral'>    }</span>
 242 |     | <span class='neutral'>    function assertGtDecimal(uint a, uint b, uint decimals) internal {</span>
 243 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 244 |     | <span class='neutral'>            emit log(&quot;Error: a &gt; b not satisfied [decimal uint]&quot;);</span>
 245 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value a&quot;, a, decimals);</span>
 246 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value b&quot;, b, decimals);</span>
 247 |     | <span class='neutral'>            fail();</span>
 248 |     | <span class='neutral'>        }</span>
 249 |     | <span class='neutral'>    }</span>
 250 |     | <span class='neutral'>    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {</span>
 251 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 252 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 253 |     | <span class='neutral'>            assertGtDecimal(a, b, decimals);</span>
 254 |     | <span class='neutral'>        }</span>
 255 |     | <span class='neutral'>    }</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='neutral'>    function assertGe(uint a, uint b) internal {</span>
 258 |     | <span class='neutral'>        if (a &lt; b) {</span>
 259 |     | <span class='neutral'>            emit log(&quot;Error: a &gt;= b not satisfied [uint]&quot;);</span>
 260 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value a&quot;, a);</span>
 261 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value b&quot;, b);</span>
 262 |     | <span class='neutral'>            fail();</span>
 263 |     | <span class='neutral'>        }</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'>    function assertGe(uint a, uint b, string memory err) internal {</span>
 266 |     | <span class='neutral'>        if (a &lt; b) {</span>
 267 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 268 |     | <span class='neutral'>            assertGe(a, b);</span>
 269 |     | <span class='neutral'>        }</span>
 270 |     | <span class='neutral'>    }</span>
 271 |     | <span class='neutral'>    function assertGe(int a, int b) internal {</span>
 272 |     | <span class='neutral'>        if (a &lt; b) {</span>
 273 |     | <span class='neutral'>            emit log(&quot;Error: a &gt;= b not satisfied [int]&quot;);</span>
 274 |     | <span class='neutral'>            emit log_named_int(&quot;  Value a&quot;, a);</span>
 275 |     | <span class='neutral'>            emit log_named_int(&quot;  Value b&quot;, b);</span>
 276 |     | <span class='neutral'>            fail();</span>
 277 |     | <span class='neutral'>        }</span>
 278 |     | <span class='neutral'>    }</span>
 279 |     | <span class='neutral'>    function assertGe(int a, int b, string memory err) internal {</span>
 280 |     | <span class='neutral'>        if (a &lt; b) {</span>
 281 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 282 |     | <span class='neutral'>            assertGe(a, b);</span>
 283 |     | <span class='neutral'>        }</span>
 284 |     | <span class='neutral'>    }</span>
 285 |     | <span class='neutral'>    function assertGeDecimal(int a, int b, uint decimals) internal {</span>
 286 |     | <span class='neutral'>        if (a &lt; b) {</span>
 287 |     | <span class='neutral'>            emit log(&quot;Error: a &gt;= b not satisfied [decimal int]&quot;);</span>
 288 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value a&quot;, a, decimals);</span>
 289 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value b&quot;, b, decimals);</span>
 290 |     | <span class='neutral'>            fail();</span>
 291 |     | <span class='neutral'>        }</span>
 292 |     | <span class='neutral'>    }</span>
 293 |     | <span class='neutral'>    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {</span>
 294 |     | <span class='neutral'>        if (a &lt; b) {</span>
 295 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 296 |     | <span class='neutral'>            assertGeDecimal(a, b, decimals);</span>
 297 |     | <span class='neutral'>        }</span>
 298 |     | <span class='neutral'>    }</span>
 299 |     | <span class='neutral'>    function assertGeDecimal(uint a, uint b, uint decimals) internal {</span>
 300 |     | <span class='neutral'>        if (a &lt; b) {</span>
 301 |     | <span class='neutral'>            emit log(&quot;Error: a &gt;= b not satisfied [decimal uint]&quot;);</span>
 302 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value a&quot;, a, decimals);</span>
 303 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value b&quot;, b, decimals);</span>
 304 |     | <span class='neutral'>            fail();</span>
 305 |     | <span class='neutral'>        }</span>
 306 |     | <span class='neutral'>    }</span>
 307 |     | <span class='neutral'>    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {</span>
 308 |     | <span class='neutral'>        if (a &lt; b) {</span>
 309 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 310 |     | <span class='neutral'>            assertGeDecimal(a, b, decimals);</span>
 311 |     | <span class='neutral'>        }</span>
 312 |     | <span class='neutral'>    }</span>
 313 |     | <span class='neutral'></span>
 314 |     | <span class='neutral'>    function assertLt(uint a, uint b) internal {</span>
 315 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 316 |     | <span class='neutral'>            emit log(&quot;Error: a &lt; b not satisfied [uint]&quot;);</span>
 317 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value a&quot;, a);</span>
 318 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value b&quot;, b);</span>
 319 |     | <span class='neutral'>            fail();</span>
 320 |     | <span class='neutral'>        }</span>
 321 |     | <span class='neutral'>    }</span>
 322 |     | <span class='neutral'>    function assertLt(uint a, uint b, string memory err) internal {</span>
 323 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 324 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 325 |     | <span class='neutral'>            assertLt(a, b);</span>
 326 |     | <span class='neutral'>        }</span>
 327 |     | <span class='neutral'>    }</span>
 328 |     | <span class='neutral'>    function assertLt(int a, int b) internal {</span>
 329 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 330 |     | <span class='neutral'>            emit log(&quot;Error: a &lt; b not satisfied [int]&quot;);</span>
 331 |     | <span class='neutral'>            emit log_named_int(&quot;  Value a&quot;, a);</span>
 332 |     | <span class='neutral'>            emit log_named_int(&quot;  Value b&quot;, b);</span>
 333 |     | <span class='neutral'>            fail();</span>
 334 |     | <span class='neutral'>        }</span>
 335 |     | <span class='neutral'>    }</span>
 336 |     | <span class='neutral'>    function assertLt(int a, int b, string memory err) internal {</span>
 337 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 338 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 339 |     | <span class='neutral'>            assertLt(a, b);</span>
 340 |     | <span class='neutral'>        }</span>
 341 |     | <span class='neutral'>    }</span>
 342 |     | <span class='neutral'>    function assertLtDecimal(int a, int b, uint decimals) internal {</span>
 343 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 344 |     | <span class='neutral'>            emit log(&quot;Error: a &lt; b not satisfied [decimal int]&quot;);</span>
 345 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value a&quot;, a, decimals);</span>
 346 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value b&quot;, b, decimals);</span>
 347 |     | <span class='neutral'>            fail();</span>
 348 |     | <span class='neutral'>        }</span>
 349 |     | <span class='neutral'>    }</span>
 350 |     | <span class='neutral'>    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {</span>
 351 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 352 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 353 |     | <span class='neutral'>            assertLtDecimal(a, b, decimals);</span>
 354 |     | <span class='neutral'>        }</span>
 355 |     | <span class='neutral'>    }</span>
 356 |     | <span class='neutral'>    function assertLtDecimal(uint a, uint b, uint decimals) internal {</span>
 357 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 358 |     | <span class='neutral'>            emit log(&quot;Error: a &lt; b not satisfied [decimal uint]&quot;);</span>
 359 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value a&quot;, a, decimals);</span>
 360 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value b&quot;, b, decimals);</span>
 361 |     | <span class='neutral'>            fail();</span>
 362 |     | <span class='neutral'>        }</span>
 363 |     | <span class='neutral'>    }</span>
 364 |     | <span class='neutral'>    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {</span>
 365 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 366 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 367 |     | <span class='neutral'>            assertLtDecimal(a, b, decimals);</span>
 368 |     | <span class='neutral'>        }</span>
 369 |     | <span class='neutral'>    }</span>
 370 |     | <span class='neutral'></span>
 371 |     | <span class='neutral'>    function assertLe(uint a, uint b) internal {</span>
 372 |     | <span class='neutral'>        if (a &gt; b) {</span>
 373 |     | <span class='neutral'>            emit log(&quot;Error: a &lt;= b not satisfied [uint]&quot;);</span>
 374 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value a&quot;, a);</span>
 375 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value b&quot;, b);</span>
 376 |     | <span class='neutral'>            fail();</span>
 377 |     | <span class='neutral'>        }</span>
 378 |     | <span class='neutral'>    }</span>
 379 |     | <span class='neutral'>    function assertLe(uint a, uint b, string memory err) internal {</span>
 380 |     | <span class='neutral'>        if (a &gt; b) {</span>
 381 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 382 |     | <span class='neutral'>            assertLe(a, b);</span>
 383 |     | <span class='neutral'>        }</span>
 384 |     | <span class='neutral'>    }</span>
 385 |     | <span class='neutral'>    function assertLe(int a, int b) internal {</span>
 386 |     | <span class='neutral'>        if (a &gt; b) {</span>
 387 |     | <span class='neutral'>            emit log(&quot;Error: a &lt;= b not satisfied [int]&quot;);</span>
 388 |     | <span class='neutral'>            emit log_named_int(&quot;  Value a&quot;, a);</span>
 389 |     | <span class='neutral'>            emit log_named_int(&quot;  Value b&quot;, b);</span>
 390 |     | <span class='neutral'>            fail();</span>
 391 |     | <span class='neutral'>        }</span>
 392 |     | <span class='neutral'>    }</span>
 393 |     | <span class='neutral'>    function assertLe(int a, int b, string memory err) internal {</span>
 394 |     | <span class='neutral'>        if (a &gt; b) {</span>
 395 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 396 |     | <span class='neutral'>            assertLe(a, b);</span>
 397 |     | <span class='neutral'>        }</span>
 398 |     | <span class='neutral'>    }</span>
 399 |     | <span class='neutral'>    function assertLeDecimal(int a, int b, uint decimals) internal {</span>
 400 |     | <span class='neutral'>        if (a &gt; b) {</span>
 401 |     | <span class='neutral'>            emit log(&quot;Error: a &lt;= b not satisfied [decimal int]&quot;);</span>
 402 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value a&quot;, a, decimals);</span>
 403 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value b&quot;, b, decimals);</span>
 404 |     | <span class='neutral'>            fail();</span>
 405 |     | <span class='neutral'>        }</span>
 406 |     | <span class='neutral'>    }</span>
 407 |     | <span class='neutral'>    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {</span>
 408 |     | <span class='neutral'>        if (a &gt; b) {</span>
 409 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 410 |     | <span class='neutral'>            assertLeDecimal(a, b, decimals);</span>
 411 |     | <span class='neutral'>        }</span>
 412 |     | <span class='neutral'>    }</span>
 413 |     | <span class='neutral'>    function assertLeDecimal(uint a, uint b, uint decimals) internal {</span>
 414 |     | <span class='neutral'>        if (a &gt; b) {</span>
 415 |     | <span class='neutral'>            emit log(&quot;Error: a &lt;= b not satisfied [decimal uint]&quot;);</span>
 416 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value a&quot;, a, decimals);</span>
 417 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value b&quot;, b, decimals);</span>
 418 |     | <span class='neutral'>            fail();</span>
 419 |     | <span class='neutral'>        }</span>
 420 |     | <span class='neutral'>    }</span>
 421 |     | <span class='neutral'>    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {</span>
 422 |     | <span class='neutral'>        if (a &gt; b) {</span>
 423 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 424 |     | <span class='neutral'>            assertGeDecimal(a, b, decimals);</span>
 425 |     | <span class='neutral'>        }</span>
 426 |     | <span class='neutral'>    }</span>
 427 |     | <span class='neutral'></span>
 428 |     | <span class='neutral'>    function assertEq(string memory a, string memory b) internal {</span>
 429 |     | <span class='neutral'>        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {</span>
 430 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [string]&quot;);</span>
 431 |     | <span class='neutral'>            emit log_named_string(&quot;  Expected&quot;, b);</span>
 432 |     | <span class='neutral'>            emit log_named_string(&quot;    Actual&quot;, a);</span>
 433 |     | <span class='neutral'>            fail();</span>
 434 |     | <span class='neutral'>        }</span>
 435 |     | <span class='neutral'>    }</span>
 436 |     | <span class='neutral'>    function assertEq(string memory a, string memory b, string memory err) internal {</span>
 437 |     | <span class='neutral'>        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {</span>
 438 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 439 |     | <span class='neutral'>            assertEq(a, b);</span>
 440 |     | <span class='neutral'>        }</span>
 441 |     | <span class='neutral'>    }</span>
 442 |     | <span class='neutral'></span>
 443 |     | <span class='neutral'>    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {</span>
 444 |     | <span class='neutral'>        ok = true;</span>
 445 |     | <span class='neutral'>        if (a.length == b.length) {</span>
 446 |     | <span class='neutral'>            for (uint i = 0; i &lt; a.length; i++) {</span>
 447 |     | <span class='neutral'>                if (a[i] != b[i]) {</span>
 448 |     | <span class='neutral'>                    ok = false;</span>
 449 |     | <span class='neutral'>                }</span>
 450 |     | <span class='neutral'>            }</span>
 451 |     | <span class='neutral'>        } else {</span>
 452 |     | <span class='neutral'>            ok = false;</span>
 453 |     | <span class='neutral'>        }</span>
 454 |     | <span class='neutral'>    }</span>
 455 |     | <span class='neutral'>    function assertEq0(bytes memory a, bytes memory b) internal {</span>
 456 |     | <span class='neutral'>        if (!checkEq0(a, b)) {</span>
 457 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [bytes]&quot;);</span>
 458 |     | <span class='neutral'>            emit log_named_bytes(&quot;  Expected&quot;, b);</span>
 459 |     | <span class='neutral'>            emit log_named_bytes(&quot;    Actual&quot;, a);</span>
 460 |     | <span class='neutral'>            fail();</span>
 461 |     | <span class='neutral'>        }</span>
 462 |     | <span class='neutral'>    }</span>
 463 |     | <span class='neutral'>    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {</span>
 464 |     | <span class='neutral'>        if (!checkEq0(a, b)) {</span>
 465 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 466 |     | <span class='neutral'>            assertEq0(a, b);</span>
 467 |     | <span class='neutral'>        }</span>
 468 |     | <span class='neutral'>    }</span>
 469 |     | <span class='neutral'>}</span>
 470 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/lib/forge-std/src/Common.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {StdStorage, Vm} from &quot;./Components.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>abstract contract CommonBase {</span>
  7 |     | <span class='neutral'>    address internal constant VM_ADDRESS = address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;))));</span>
  8 |     | <span class='neutral'>    uint256 internal constant UINT256_MAX =</span>
  9 |     | <span class='neutral'>        115792089237316195423570985008687907853269984665640564039457584007913129639935;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    StdStorage internal stdstore;</span>
 12 |     | <span class='neutral'>    Vm internal constant vm = Vm(VM_ADDRESS);</span>
 13 |     | <span class='neutral'>}</span>
 14 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/lib/forge-std/src/Components.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./console.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;./console2.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;./StdAssertions.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;./StdCheats.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;./StdError.sol&quot;;</span>
  9 |     | <span class='neutral'>import &quot;./StdJson.sol&quot;;</span>
 10 |     | <span class='neutral'>import &quot;./StdMath.sol&quot;;</span>
 11 |     | <span class='neutral'>import &quot;./StdStorage.sol&quot;;</span>
 12 |     | <span class='neutral'>import &quot;./StdUtils.sol&quot;;</span>
 13 |     | <span class='neutral'>import &quot;./Vm.sol&quot;;</span>
 14 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/lib/forge-std/src/Script.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {CommonBase} from &quot;./Common.sol&quot;;</span>
  5 |     | <span class='neutral'>// forgefmt: disable-next-line</span>
  6 |     | <span class='neutral'>import {console, console2, StdCheatsSafe, stdJson, stdMath, StdStorage, stdStorageSafe, StdUtils, VmSafe} from &quot;./Components.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>abstract contract ScriptBase is CommonBase {</span>
  9 |     | <span class='neutral'>    VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);</span>
 10 |     | <span class='neutral'>}</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>abstract contract Script is ScriptBase, StdCheatsSafe, StdUtils {</span>
 13 |     | <span class='neutral'>    bool public IS_SCRIPT = true;</span>
 14 |     | <span class='neutral'>}</span>
 15 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/lib/forge-std/src/StdAssertions.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;ds-test/test.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;./StdMath.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>abstract contract StdAssertions is DSTest {</span>
   8 |     | <span class='neutral'>    event log_array(uint256[] val);</span>
   9 |     | <span class='neutral'>    event log_array(int256[] val);</span>
  10 |     | <span class='neutral'>    event log_array(address[] val);</span>
  11 |     | <span class='neutral'>    event log_named_array(string key, uint256[] val);</span>
  12 |     | <span class='neutral'>    event log_named_array(string key, int256[] val);</span>
  13 |     | <span class='neutral'>    event log_named_array(string key, address[] val);</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    function fail(string memory err) internal virtual {</span>
  16 |     | <span class='neutral'>        emit log_named_string(&quot;Error&quot;, err);</span>
  17 |     | <span class='neutral'>        fail();</span>
  18 |     | <span class='neutral'>    }</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    function assertFalse(bool data) internal virtual {</span>
  21 |     | <span class='neutral'>        assertTrue(!data);</span>
  22 |     | <span class='neutral'>    }</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    function assertFalse(bool data, string memory err) internal virtual {</span>
  25 |     | <span class='neutral'>        assertTrue(!data, err);</span>
  26 |     | <span class='neutral'>    }</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    function assertEq(bool a, bool b) internal virtual {</span>
  29 |     | <span class='neutral'>        if (a != b) {</span>
  30 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [bool]&quot;);</span>
  31 |     | <span class='neutral'>            emit log_named_string(&quot;  Expected&quot;, b ? &quot;true&quot; : &quot;false&quot;);</span>
  32 |     | <span class='neutral'>            emit log_named_string(&quot;    Actual&quot;, a ? &quot;true&quot; : &quot;false&quot;);</span>
  33 |     | <span class='neutral'>            fail();</span>
  34 |     | <span class='neutral'>        }</span>
  35 |     | <span class='neutral'>    }</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    function assertEq(bool a, bool b, string memory err) internal virtual {</span>
  38 |     | <span class='neutral'>        if (a != b) {</span>
  39 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
  40 |     | <span class='neutral'>            assertEq(a, b);</span>
  41 |     | <span class='neutral'>        }</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    function assertEq(bytes memory a, bytes memory b) internal virtual {</span>
  45 |     | <span class='neutral'>        assertEq0(a, b);</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    function assertEq(bytes memory a, bytes memory b, string memory err) internal virtual {</span>
  49 |     | <span class='neutral'>        assertEq0(a, b, err);</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    function assertEq(uint256[] memory a, uint256[] memory b) internal virtual {</span>
  53 |     | <span class='neutral'>        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {</span>
  54 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [uint[]]&quot;);</span>
  55 |     | <span class='neutral'>            emit log_named_array(&quot;  Expected&quot;, b);</span>
  56 |     | <span class='neutral'>            emit log_named_array(&quot;    Actual&quot;, a);</span>
  57 |     | <span class='neutral'>            fail();</span>
  58 |     | <span class='neutral'>        }</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    function assertEq(int256[] memory a, int256[] memory b) internal virtual {</span>
  62 |     | <span class='neutral'>        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {</span>
  63 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [int[]]&quot;);</span>
  64 |     | <span class='neutral'>            emit log_named_array(&quot;  Expected&quot;, b);</span>
  65 |     | <span class='neutral'>            emit log_named_array(&quot;    Actual&quot;, a);</span>
  66 |     | <span class='neutral'>            fail();</span>
  67 |     | <span class='neutral'>        }</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    function assertEq(address[] memory a, address[] memory b) internal virtual {</span>
  71 |     | <span class='neutral'>        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {</span>
  72 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [address[]]&quot;);</span>
  73 |     | <span class='neutral'>            emit log_named_array(&quot;  Expected&quot;, b);</span>
  74 |     | <span class='neutral'>            emit log_named_array(&quot;    Actual&quot;, a);</span>
  75 |     | <span class='neutral'>            fail();</span>
  76 |     | <span class='neutral'>        }</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal virtual {</span>
  80 |     | <span class='neutral'>        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {</span>
  81 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
  82 |     | <span class='neutral'>            assertEq(a, b);</span>
  83 |     | <span class='neutral'>        }</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    function assertEq(int256[] memory a, int256[] memory b, string memory err) internal virtual {</span>
  87 |     | <span class='neutral'>        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {</span>
  88 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
  89 |     | <span class='neutral'>            assertEq(a, b);</span>
  90 |     | <span class='neutral'>        }</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    function assertEq(address[] memory a, address[] memory b, string memory err) internal virtual {</span>
  94 |     | <span class='neutral'>        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {</span>
  95 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
  96 |     | <span class='neutral'>            assertEq(a, b);</span>
  97 |     | <span class='neutral'>        }</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    // Legacy helper</span>
 101 |     | <span class='neutral'>    function assertEqUint(uint256 a, uint256 b) internal virtual {</span>
 102 |     | <span class='neutral'>        assertEq(uint256(a), uint256(b));</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta) internal virtual {</span>
 106 |     | <span class='neutral'>        uint256 delta = stdMath.delta(a, b);</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>        if (delta &gt; maxDelta) {</span>
 109 |     | <span class='neutral'>            emit log(&quot;Error: a ~= b not satisfied [uint]&quot;);</span>
 110 |     | <span class='neutral'>            emit log_named_uint(&quot;  Expected&quot;, b);</span>
 111 |     | <span class='neutral'>            emit log_named_uint(&quot;    Actual&quot;, a);</span>
 112 |     | <span class='neutral'>            emit log_named_uint(&quot; Max Delta&quot;, maxDelta);</span>
 113 |     | <span class='neutral'>            emit log_named_uint(&quot;     Delta&quot;, delta);</span>
 114 |     | <span class='neutral'>            fail();</span>
 115 |     | <span class='neutral'>        }</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta, string memory err) internal virtual {</span>
 119 |     | <span class='neutral'>        uint256 delta = stdMath.delta(a, b);</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>        if (delta &gt; maxDelta) {</span>
 122 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 123 |     | <span class='neutral'>            assertApproxEqAbs(a, b, maxDelta);</span>
 124 |     | <span class='neutral'>        }</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta) internal virtual {</span>
 128 |     | <span class='neutral'>        uint256 delta = stdMath.delta(a, b);</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>        if (delta &gt; maxDelta) {</span>
 131 |     | <span class='neutral'>            emit log(&quot;Error: a ~= b not satisfied [int]&quot;);</span>
 132 |     | <span class='neutral'>            emit log_named_int(&quot;  Expected&quot;, b);</span>
 133 |     | <span class='neutral'>            emit log_named_int(&quot;    Actual&quot;, a);</span>
 134 |     | <span class='neutral'>            emit log_named_uint(&quot; Max Delta&quot;, maxDelta);</span>
 135 |     | <span class='neutral'>            emit log_named_uint(&quot;     Delta&quot;, delta);</span>
 136 |     | <span class='neutral'>            fail();</span>
 137 |     | <span class='neutral'>        }</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta, string memory err) internal virtual {</span>
 141 |     | <span class='neutral'>        uint256 delta = stdMath.delta(a, b);</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>        if (delta &gt; maxDelta) {</span>
 144 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 145 |     | <span class='neutral'>            assertApproxEqAbs(a, b, maxDelta);</span>
 146 |     | <span class='neutral'>        }</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    function assertApproxEqRel(</span>
 150 |     | <span class='neutral'>        uint256 a,</span>
 151 |     | <span class='neutral'>        uint256 b,</span>
 152 |     | <span class='neutral'>        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%</span>
 153 |     | <span class='neutral'>    ) internal virtual {</span>
 154 |     | <span class='neutral'>        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='neutral'>        uint256 percentDelta = stdMath.percentDelta(a, b);</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>        if (percentDelta &gt; maxPercentDelta) {</span>
 159 |     | <span class='neutral'>            emit log(&quot;Error: a ~= b not satisfied [uint]&quot;);</span>
 160 |     | <span class='neutral'>            emit log_named_uint(&quot;    Expected&quot;, b);</span>
 161 |     | <span class='neutral'>            emit log_named_uint(&quot;      Actual&quot;, a);</span>
 162 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot; Max % Delta&quot;, maxPercentDelta, 18);</span>
 163 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;     % Delta&quot;, percentDelta, 18);</span>
 164 |     | <span class='neutral'>            fail();</span>
 165 |     | <span class='neutral'>        }</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>    function assertApproxEqRel(</span>
 169 |     | <span class='neutral'>        uint256 a,</span>
 170 |     | <span class='neutral'>        uint256 b,</span>
 171 |     | <span class='neutral'>        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%</span>
 172 |     | <span class='neutral'>        string memory err</span>
 173 |     | <span class='neutral'>    ) internal virtual {</span>
 174 |     | <span class='neutral'>        if (b == 0) return assertEq(a, b, err); // If the expected is 0, actual must be too.</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>        uint256 percentDelta = stdMath.percentDelta(a, b);</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='neutral'>        if (percentDelta &gt; maxPercentDelta) {</span>
 179 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 180 |     | <span class='neutral'>            assertApproxEqRel(a, b, maxPercentDelta);</span>
 181 |     | <span class='neutral'>        }</span>
 182 |     | <span class='neutral'>    }</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta) internal virtual {</span>
 185 |     | <span class='neutral'>        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>        uint256 percentDelta = stdMath.percentDelta(a, b);</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>        if (percentDelta &gt; maxPercentDelta) {</span>
 190 |     | <span class='neutral'>            emit log(&quot;Error: a ~= b not satisfied [int]&quot;);</span>
 191 |     | <span class='neutral'>            emit log_named_int(&quot;    Expected&quot;, b);</span>
 192 |     | <span class='neutral'>            emit log_named_int(&quot;      Actual&quot;, a);</span>
 193 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot; Max % Delta&quot;, maxPercentDelta, 18);</span>
 194 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;     % Delta&quot;, percentDelta, 18);</span>
 195 |     | <span class='neutral'>            fail();</span>
 196 |     | <span class='neutral'>        }</span>
 197 |     | <span class='neutral'>    }</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='neutral'>    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta, string memory err) internal virtual {</span>
 200 |     | <span class='neutral'>        if (b == 0) return assertEq(a, b, err); // If the expected is 0, actual must be too.</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>        uint256 percentDelta = stdMath.percentDelta(a, b);</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='neutral'>        if (percentDelta &gt; maxPercentDelta) {</span>
 205 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 206 |     | <span class='neutral'>            assertApproxEqRel(a, b, maxPercentDelta);</span>
 207 |     | <span class='neutral'>        }</span>
 208 |     | <span class='neutral'>    }</span>
 209 |     | <span class='neutral'>}</span>
 210 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/lib/forge-std/src/StdCheats.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;./StdStorage.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./Vm.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>abstract contract StdCheatsSafe {</span>
  10 |     | <span class='neutral'>    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    /// @dev To hide constructor warnings across solc versions due to different constructor visibility requirements and</span>
  13 |     | <span class='neutral'>    /// syntaxes, we put the constructor in a private method and assign an unused return value to a variable. This</span>
  14 |     | <span class='neutral'>    /// forces the method to run during construction, but without declaring an explicit constructor.</span>
  15 |     | <span class='neutral'>    uint256 private CONSTRUCTOR = _constructor();</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    struct Chain {</span>
  18 |     | <span class='neutral'>        // The chain name, using underscores as the separator to match `foundry.toml` conventions.</span>
  19 |     | <span class='neutral'>        string name;</span>
  20 |     | <span class='neutral'>        // The chain&#39;s Chain ID.</span>
  21 |     | <span class='neutral'>        uint256 chainId;</span>
  22 |     | <span class='neutral'>        // A default RPC endpoint for this chain.</span>
  23 |     | <span class='neutral'>        // NOTE: This default RPC URL is included for convenience to facilitate quick tests and</span>
  24 |     | <span class='neutral'>        // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy</span>
  25 |     | <span class='neutral'>        // usage as you will be throttled and this is a disservice to others who need this endpoint.</span>
  26 |     | <span class='neutral'>        string rpcUrl;</span>
  27 |     | <span class='neutral'>    }</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    // Maps from a chain&#39;s name (matching what&#39;s in the `foundry.toml` file) to chain data.</span>
  30 |     | <span class='neutral'>    mapping(string =&gt; Chain) internal stdChains;</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    // Data structures to parse Transaction objects from the broadcast artifact</span>
  33 |     | <span class='neutral'>    // that conform to EIP1559. The Raw structs is what is parsed from the JSON</span>
  34 |     | <span class='neutral'>    // and then converted to the one that is used by the user for better UX.</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    struct RawTx1559 {</span>
  37 |     | <span class='neutral'>        string[] arguments;</span>
  38 |     | <span class='neutral'>        address contractAddress;</span>
  39 |     | <span class='neutral'>        string contractName;</span>
  40 |     | <span class='neutral'>        // json value name = function</span>
  41 |     | <span class='neutral'>        string functionSig;</span>
  42 |     | <span class='neutral'>        bytes32 hash;</span>
  43 |     | <span class='neutral'>        // json value name = tx</span>
  44 |     | <span class='neutral'>        RawTx1559Detail txDetail;</span>
  45 |     | <span class='neutral'>        // json value name = type</span>
  46 |     | <span class='neutral'>        string opcode;</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    struct RawTx1559Detail {</span>
  50 |     | <span class='neutral'>        AccessList[] accessList;</span>
  51 |     | <span class='neutral'>        bytes data;</span>
  52 |     | <span class='neutral'>        address from;</span>
  53 |     | <span class='neutral'>        bytes gas;</span>
  54 |     | <span class='neutral'>        bytes nonce;</span>
  55 |     | <span class='neutral'>        address to;</span>
  56 |     | <span class='neutral'>        bytes txType;</span>
  57 |     | <span class='neutral'>        bytes value;</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    struct Tx1559 {</span>
  61 |     | <span class='neutral'>        string[] arguments;</span>
  62 |     | <span class='neutral'>        address contractAddress;</span>
  63 |     | <span class='neutral'>        string contractName;</span>
  64 |     | <span class='neutral'>        string functionSig;</span>
  65 |     | <span class='neutral'>        bytes32 hash;</span>
  66 |     | <span class='neutral'>        Tx1559Detail txDetail;</span>
  67 |     | <span class='neutral'>        string opcode;</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    struct Tx1559Detail {</span>
  71 |     | <span class='neutral'>        AccessList[] accessList;</span>
  72 |     | <span class='neutral'>        bytes data;</span>
  73 |     | <span class='neutral'>        address from;</span>
  74 |     | <span class='neutral'>        uint256 gas;</span>
  75 |     | <span class='neutral'>        uint256 nonce;</span>
  76 |     | <span class='neutral'>        address to;</span>
  77 |     | <span class='neutral'>        uint256 txType;</span>
  78 |     | <span class='neutral'>        uint256 value;</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    // Data structures to parse Transaction objects from the broadcast artifact</span>
  82 |     | <span class='neutral'>    // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON</span>
  83 |     | <span class='neutral'>    // and then converted to the one that is used by the user for better UX.</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    struct TxLegacy {</span>
  86 |     | <span class='neutral'>        string[] arguments;</span>
  87 |     | <span class='neutral'>        address contractAddress;</span>
  88 |     | <span class='neutral'>        string contractName;</span>
  89 |     | <span class='neutral'>        string functionSig;</span>
  90 |     | <span class='neutral'>        string hash;</span>
  91 |     | <span class='neutral'>        string opcode;</span>
  92 |     | <span class='neutral'>        TxDetailLegacy transaction;</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    struct TxDetailLegacy {</span>
  96 |     | <span class='neutral'>        AccessList[] accessList;</span>
  97 |     | <span class='neutral'>        uint256 chainId;</span>
  98 |     | <span class='neutral'>        bytes data;</span>
  99 |     | <span class='neutral'>        address from;</span>
 100 |     | <span class='neutral'>        uint256 gas;</span>
 101 |     | <span class='neutral'>        uint256 gasPrice;</span>
 102 |     | <span class='neutral'>        bytes32 hash;</span>
 103 |     | <span class='neutral'>        uint256 nonce;</span>
 104 |     | <span class='neutral'>        bytes1 opcode;</span>
 105 |     | <span class='neutral'>        bytes32 r;</span>
 106 |     | <span class='neutral'>        bytes32 s;</span>
 107 |     | <span class='neutral'>        uint256 txType;</span>
 108 |     | <span class='neutral'>        address to;</span>
 109 |     | <span class='neutral'>        uint8 v;</span>
 110 |     | <span class='neutral'>        uint256 value;</span>
 111 |     | <span class='neutral'>    }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>    struct AccessList {</span>
 114 |     | <span class='neutral'>        address accessAddress;</span>
 115 |     | <span class='neutral'>        bytes32[] storageKeys;</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    // Data structures to parse Receipt objects from the broadcast artifact.</span>
 119 |     | <span class='neutral'>    // The Raw structs is what is parsed from the JSON</span>
 120 |     | <span class='neutral'>    // and then converted to the one that is used by the user for better UX.</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    struct RawReceipt {</span>
 123 |     | <span class='neutral'>        bytes32 blockHash;</span>
 124 |     | <span class='neutral'>        bytes blockNumber;</span>
 125 |     | <span class='neutral'>        address contractAddress;</span>
 126 |     | <span class='neutral'>        bytes cumulativeGasUsed;</span>
 127 |     | <span class='neutral'>        bytes effectiveGasPrice;</span>
 128 |     | <span class='neutral'>        address from;</span>
 129 |     | <span class='neutral'>        bytes gasUsed;</span>
 130 |     | <span class='neutral'>        RawReceiptLog[] logs;</span>
 131 |     | <span class='neutral'>        bytes logsBloom;</span>
 132 |     | <span class='neutral'>        bytes status;</span>
 133 |     | <span class='neutral'>        address to;</span>
 134 |     | <span class='neutral'>        bytes32 transactionHash;</span>
 135 |     | <span class='neutral'>        bytes transactionIndex;</span>
 136 |     | <span class='neutral'>    }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>    struct Receipt {</span>
 139 |     | <span class='neutral'>        bytes32 blockHash;</span>
 140 |     | <span class='neutral'>        uint256 blockNumber;</span>
 141 |     | <span class='neutral'>        address contractAddress;</span>
 142 |     | <span class='neutral'>        uint256 cumulativeGasUsed;</span>
 143 |     | <span class='neutral'>        uint256 effectiveGasPrice;</span>
 144 |     | <span class='neutral'>        address from;</span>
 145 |     | <span class='neutral'>        uint256 gasUsed;</span>
 146 |     | <span class='neutral'>        ReceiptLog[] logs;</span>
 147 |     | <span class='neutral'>        bytes logsBloom;</span>
 148 |     | <span class='neutral'>        uint256 status;</span>
 149 |     | <span class='neutral'>        address to;</span>
 150 |     | <span class='neutral'>        bytes32 transactionHash;</span>
 151 |     | <span class='neutral'>        uint256 transactionIndex;</span>
 152 |     | <span class='neutral'>    }</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>    // Data structures to parse the entire broadcast artifact, assuming the</span>
 155 |     | <span class='neutral'>    // transactions conform to EIP1559.</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>    struct EIP1559ScriptArtifact {</span>
 158 |     | <span class='neutral'>        string[] libraries;</span>
 159 |     | <span class='neutral'>        string path;</span>
 160 |     | <span class='neutral'>        string[] pending;</span>
 161 |     | <span class='neutral'>        Receipt[] receipts;</span>
 162 |     | <span class='neutral'>        uint256 timestamp;</span>
 163 |     | <span class='neutral'>        Tx1559[] transactions;</span>
 164 |     | <span class='neutral'>        TxReturn[] txReturns;</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    struct RawEIP1559ScriptArtifact {</span>
 168 |     | <span class='neutral'>        string[] libraries;</span>
 169 |     | <span class='neutral'>        string path;</span>
 170 |     | <span class='neutral'>        string[] pending;</span>
 171 |     | <span class='neutral'>        RawReceipt[] receipts;</span>
 172 |     | <span class='neutral'>        TxReturn[] txReturns;</span>
 173 |     | <span class='neutral'>        uint256 timestamp;</span>
 174 |     | <span class='neutral'>        RawTx1559[] transactions;</span>
 175 |     | <span class='neutral'>    }</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='neutral'>    struct RawReceiptLog {</span>
 178 |     | <span class='neutral'>        // json value = address</span>
 179 |     | <span class='neutral'>        address logAddress;</span>
 180 |     | <span class='neutral'>        bytes32 blockHash;</span>
 181 |     | <span class='neutral'>        bytes blockNumber;</span>
 182 |     | <span class='neutral'>        bytes data;</span>
 183 |     | <span class='neutral'>        bytes logIndex;</span>
 184 |     | <span class='neutral'>        bool removed;</span>
 185 |     | <span class='neutral'>        bytes32[] topics;</span>
 186 |     | <span class='neutral'>        bytes32 transactionHash;</span>
 187 |     | <span class='neutral'>        bytes transactionIndex;</span>
 188 |     | <span class='neutral'>        bytes transactionLogIndex;</span>
 189 |     | <span class='neutral'>    }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>    struct ReceiptLog {</span>
 192 |     | <span class='neutral'>        // json value = address</span>
 193 |     | <span class='neutral'>        address logAddress;</span>
 194 |     | <span class='neutral'>        bytes32 blockHash;</span>
 195 |     | <span class='neutral'>        uint256 blockNumber;</span>
 196 |     | <span class='neutral'>        bytes data;</span>
 197 |     | <span class='neutral'>        uint256 logIndex;</span>
 198 |     | <span class='neutral'>        bytes32[] topics;</span>
 199 |     | <span class='neutral'>        uint256 transactionIndex;</span>
 200 |     | <span class='neutral'>        uint256 transactionLogIndex;</span>
 201 |     | <span class='neutral'>        bool removed;</span>
 202 |     | <span class='neutral'>    }</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='neutral'>    struct TxReturn {</span>
 205 |     | <span class='neutral'>        string internalType;</span>
 206 |     | <span class='neutral'>        string value;</span>
 207 |     | <span class='neutral'>    }</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='neutral'>    function _constructor() private returns (uint256) {</span>
 210 |     | <span class='neutral'>        // Initialize `stdChains` with the defaults.</span>
 211 |     | <span class='neutral'>        stdChains[&quot;anvil&quot;] = Chain(&quot;Anvil&quot;, 31337, &quot;http://127.0.0.1:8545&quot;);</span>
 212 |     | <span class='neutral'>        stdChains[&quot;hardhat&quot;] = Chain(&quot;Hardhat&quot;, 31337, &quot;http://127.0.0.1:8545&quot;);</span>
 213 |     | <span class='neutral'>        stdChains[&quot;mainnet&quot;] = Chain(&quot;Mainnet&quot;, 1, &quot;https://mainnet.infura.io/v3/6770454bc6ea42c58aac12978531b93f&quot;);</span>
 214 |     | <span class='neutral'>        stdChains[&quot;goerli&quot;] = Chain(&quot;Goerli&quot;, 5, &quot;https://goerli.infura.io/v3/6770454bc6ea42c58aac12978531b93f&quot;);</span>
 215 |     | <span class='neutral'>        stdChains[&quot;sepolia&quot;] = Chain(&quot;Sepolia&quot;, 11155111, &quot;https://rpc.sepolia.dev&quot;);</span>
 216 |     | <span class='neutral'>        stdChains[&quot;optimism&quot;] = Chain(&quot;Optimism&quot;, 10, &quot;https://mainnet.optimism.io&quot;);</span>
 217 |     | <span class='neutral'>        stdChains[&quot;optimism_goerli&quot;] = Chain(&quot;Optimism Goerli&quot;, 420, &quot;https://goerli.optimism.io&quot;);</span>
 218 |     | <span class='neutral'>        stdChains[&quot;arbitrum_one&quot;] = Chain(&quot;Arbitrum One&quot;, 42161, &quot;https://arb1.arbitrum.io/rpc&quot;);</span>
 219 |     | <span class='neutral'>        stdChains[&quot;arbitrum_one_goerli&quot;] = Chain(&quot;Arbitrum One Goerli&quot;, 421613, &quot;https://goerli-rollup.arbitrum.io/rpc&quot;);</span>
 220 |     | <span class='neutral'>        stdChains[&quot;arbitrum_nova&quot;] = Chain(&quot;Arbitrum Nova&quot;, 42170, &quot;https://nova.arbitrum.io/rpc&quot;);</span>
 221 |     | <span class='neutral'>        stdChains[&quot;polygon&quot;] = Chain(&quot;Polygon&quot;, 137, &quot;https://polygon-rpc.com&quot;);</span>
 222 |     | <span class='neutral'>        stdChains[&quot;polygon_mumbai&quot;] = Chain(&quot;Polygon Mumbai&quot;, 80001, &quot;https://rpc-mumbai.matic.today&quot;);</span>
 223 |     | <span class='neutral'>        stdChains[&quot;avalanche&quot;] = Chain(&quot;Avalanche&quot;, 43114, &quot;https://api.avax.network/ext/bc/C/rpc&quot;);</span>
 224 |     | <span class='neutral'>        stdChains[&quot;avalanche_fuji&quot;] = Chain(&quot;Avalanche Fuji&quot;, 43113, &quot;https://api.avax-test.network/ext/bc/C/rpc&quot;);</span>
 225 |     | <span class='neutral'>        stdChains[&quot;bnb_smart_chain&quot;] = Chain(&quot;BNB Smart Chain&quot;, 56, &quot;https://bsc-dataseed1.binance.org&quot;);</span>
 226 |     | <span class='neutral'>        stdChains[&quot;bnb_smart_chain_testnet&quot;] = Chain(&quot;BNB Smart Chain Testnet&quot;, 97, &quot;https://data-seed-prebsc-1-s1.binance.org:8545&quot;);// forgefmt: disable-line</span>
 227 |     | <span class='neutral'>        stdChains[&quot;gnosis_chain&quot;] = Chain(&quot;Gnosis Chain&quot;, 100, &quot;https://rpc.gnosischain.com&quot;);</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='neutral'>        // Loop over RPC URLs in the config file to replace the default RPC URLs</span>
 230 |     | <span class='neutral'>        Vm.Rpc[] memory rpcs = vm.rpcUrlStructs();</span>
 231 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; rpcs.length; i++) {</span>
 232 |     | <span class='neutral'>            stdChains[rpcs[i].name].rpcUrl = rpcs[i].url;</span>
 233 |     | <span class='neutral'>        }</span>
 234 |     | <span class='neutral'>        return 0;</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>    function assumeNoPrecompiles(address addr) internal view virtual {</span>
 238 |     | <span class='neutral'>        // Assembly required since `block.chainid` was introduced in 0.8.0.</span>
 239 |     | <span class='neutral'>        uint256 chainId;</span>
 240 |     | <span class='neutral'>        assembly {</span>
 241 |     | <span class='neutral'>            chainId := chainid()</span>
 242 |     | <span class='neutral'>        }</span>
 243 |     | <span class='neutral'>        assumeNoPrecompiles(addr, chainId);</span>
 244 |     | <span class='neutral'>    }</span>
 245 |     | <span class='neutral'></span>
 246 |     | <span class='neutral'>    function assumeNoPrecompiles(address addr, uint256 chainId) internal view virtual {</span>
 247 |     | <span class='neutral'>        // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific</span>
 248 |     | <span class='neutral'>        // address), but the same rationale for excluding them applies so we include those too.</span>
 249 |     | <span class='neutral'></span>
 250 |     | <span class='neutral'>        // These should be present on all EVM-compatible chains.</span>
 251 |     | <span class='neutral'>        vm.assume(addr &lt; address(0x1) || addr &gt; address(0x9));</span>
 252 |     | <span class='neutral'></span>
 253 |     | <span class='neutral'>        // forgefmt: disable-start</span>
 254 |     | <span class='neutral'>        if (chainId == stdChains[&quot;optimism&quot;].chainId || chainId == stdChains[&quot;optimism_goerli&quot;].chainId) {</span>
 255 |     | <span class='neutral'>            // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21</span>
 256 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x4200000000000000000000000000000000000000) || addr &gt; address(0x4200000000000000000000000000000000000800));</span>
 257 |     | <span class='neutral'>        } else if (chainId == stdChains[&quot;arbitrum_one&quot;].chainId || chainId == stdChains[&quot;arbitrum_one_goerli&quot;].chainId) {</span>
 258 |     | <span class='neutral'>            // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains</span>
 259 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x0000000000000000000000000000000000000064) || addr &gt; address(0x0000000000000000000000000000000000000068));</span>
 260 |     | <span class='neutral'>        } else if (chainId == stdChains[&quot;avalanche&quot;].chainId || chainId == stdChains[&quot;avalanche_fuji&quot;].chainId) {</span>
 261 |     | <span class='neutral'>            // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59</span>
 262 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x0100000000000000000000000000000000000000) || addr &gt; address(0x01000000000000000000000000000000000000ff));</span>
 263 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x0200000000000000000000000000000000000000) || addr &gt; address(0x02000000000000000000000000000000000000FF));</span>
 264 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x0300000000000000000000000000000000000000) || addr &gt; address(0x03000000000000000000000000000000000000Ff));</span>
 265 |     | <span class='neutral'>        }</span>
 266 |     | <span class='neutral'>        // forgefmt: disable-end</span>
 267 |     | <span class='neutral'>    }</span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='neutral'>    function readEIP1559ScriptArtifact(string memory path)</span>
 270 |     | <span class='neutral'>        internal</span>
 271 |     | <span class='neutral'>        view</span>
 272 |     | <span class='neutral'>        virtual</span>
 273 |     | <span class='neutral'>        returns (EIP1559ScriptArtifact memory)</span>
 274 |     | <span class='neutral'>    {</span>
 275 |     | <span class='neutral'>        string memory data = vm.readFile(path);</span>
 276 |     | <span class='neutral'>        bytes memory parsedData = vm.parseJson(data);</span>
 277 |     | <span class='neutral'>        RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));</span>
 278 |     | <span class='neutral'>        EIP1559ScriptArtifact memory artifact;</span>
 279 |     | <span class='neutral'>        artifact.libraries = rawArtifact.libraries;</span>
 280 |     | <span class='neutral'>        artifact.path = rawArtifact.path;</span>
 281 |     | <span class='neutral'>        artifact.timestamp = rawArtifact.timestamp;</span>
 282 |     | <span class='neutral'>        artifact.pending = rawArtifact.pending;</span>
 283 |     | <span class='neutral'>        artifact.txReturns = rawArtifact.txReturns;</span>
 284 |     | <span class='neutral'>        artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);</span>
 285 |     | <span class='neutral'>        artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);</span>
 286 |     | <span class='neutral'>        return artifact;</span>
 287 |     | <span class='neutral'>    }</span>
 288 |     | <span class='neutral'></span>
 289 |     | <span class='neutral'>    function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {</span>
 290 |     | <span class='neutral'>        Tx1559[] memory txs = new Tx1559[](rawTxs.length);</span>
 291 |     | <span class='neutral'>        for (uint256 i; i &lt; rawTxs.length; i++) {</span>
 292 |     | <span class='neutral'>            txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);</span>
 293 |     | <span class='neutral'>        }</span>
 294 |     | <span class='neutral'>        return txs;</span>
 295 |     | <span class='neutral'>    }</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='neutral'>    function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {</span>
 298 |     | <span class='neutral'>        Tx1559 memory transaction;</span>
 299 |     | <span class='neutral'>        transaction.arguments = rawTx.arguments;</span>
 300 |     | <span class='neutral'>        transaction.contractName = rawTx.contractName;</span>
 301 |     | <span class='neutral'>        transaction.functionSig = rawTx.functionSig;</span>
 302 |     | <span class='neutral'>        transaction.hash = rawTx.hash;</span>
 303 |     | <span class='neutral'>        transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);</span>
 304 |     | <span class='neutral'>        transaction.opcode = rawTx.opcode;</span>
 305 |     | <span class='neutral'>        return transaction;</span>
 306 |     | <span class='neutral'>    }</span>
 307 |     | <span class='neutral'></span>
 308 |     | <span class='neutral'>    function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)</span>
 309 |     | <span class='neutral'>        internal</span>
 310 |     | <span class='neutral'>        pure</span>
 311 |     | <span class='neutral'>        virtual</span>
 312 |     | <span class='neutral'>        returns (Tx1559Detail memory)</span>
 313 |     | <span class='neutral'>    {</span>
 314 |     | <span class='neutral'>        Tx1559Detail memory txDetail;</span>
 315 |     | <span class='neutral'>        txDetail.data = rawDetail.data;</span>
 316 |     | <span class='neutral'>        txDetail.from = rawDetail.from;</span>
 317 |     | <span class='neutral'>        txDetail.to = rawDetail.to;</span>
 318 |     | <span class='neutral'>        txDetail.nonce = _bytesToUint(rawDetail.nonce);</span>
 319 |     | <span class='neutral'>        txDetail.txType = _bytesToUint(rawDetail.txType);</span>
 320 |     | <span class='neutral'>        txDetail.value = _bytesToUint(rawDetail.value);</span>
 321 |     | <span class='neutral'>        txDetail.gas = _bytesToUint(rawDetail.gas);</span>
 322 |     | <span class='neutral'>        txDetail.accessList = rawDetail.accessList;</span>
 323 |     | <span class='neutral'>        return txDetail;</span>
 324 |     | <span class='neutral'>    }</span>
 325 |     | <span class='neutral'></span>
 326 |     | <span class='neutral'>    function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {</span>
 327 |     | <span class='neutral'>        string memory deployData = vm.readFile(path);</span>
 328 |     | <span class='neutral'>        bytes memory parsedDeployData = vm.parseJson(deployData, &quot;.transactions&quot;);</span>
 329 |     | <span class='neutral'>        RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));</span>
 330 |     | <span class='neutral'>        return rawToConvertedEIPTx1559s(rawTxs);</span>
 331 |     | <span class='neutral'>    }</span>
 332 |     | <span class='neutral'></span>
 333 |     | <span class='neutral'>    function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {</span>
 334 |     | <span class='neutral'>        string memory deployData = vm.readFile(path);</span>
 335 |     | <span class='neutral'>        string memory key = string(abi.encodePacked(&quot;.transactions[&quot;, vm.toString(index), &quot;]&quot;));</span>
 336 |     | <span class='neutral'>        bytes memory parsedDeployData = vm.parseJson(deployData, key);</span>
 337 |     | <span class='neutral'>        RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));</span>
 338 |     | <span class='neutral'>        return rawToConvertedEIPTx1559(rawTx);</span>
 339 |     | <span class='neutral'>    }</span>
 340 |     | <span class='neutral'></span>
 341 |     | <span class='neutral'>    // Analogous to readTransactions, but for receipts.</span>
 342 |     | <span class='neutral'>    function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {</span>
 343 |     | <span class='neutral'>        string memory deployData = vm.readFile(path);</span>
 344 |     | <span class='neutral'>        bytes memory parsedDeployData = vm.parseJson(deployData, &quot;.receipts&quot;);</span>
 345 |     | <span class='neutral'>        RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));</span>
 346 |     | <span class='neutral'>        return rawToConvertedReceipts(rawReceipts);</span>
 347 |     | <span class='neutral'>    }</span>
 348 |     | <span class='neutral'></span>
 349 |     | <span class='neutral'>    function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {</span>
 350 |     | <span class='neutral'>        string memory deployData = vm.readFile(path);</span>
 351 |     | <span class='neutral'>        string memory key = string(abi.encodePacked(&quot;.receipts[&quot;, vm.toString(index), &quot;]&quot;));</span>
 352 |     | <span class='neutral'>        bytes memory parsedDeployData = vm.parseJson(deployData, key);</span>
 353 |     | <span class='neutral'>        RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));</span>
 354 |     | <span class='neutral'>        return rawToConvertedReceipt(rawReceipt);</span>
 355 |     | <span class='neutral'>    }</span>
 356 |     | <span class='neutral'></span>
 357 |     | <span class='neutral'>    function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {</span>
 358 |     | <span class='neutral'>        Receipt[] memory receipts = new Receipt[](rawReceipts.length);</span>
 359 |     | <span class='neutral'>        for (uint256 i; i &lt; rawReceipts.length; i++) {</span>
 360 |     | <span class='neutral'>            receipts[i] = rawToConvertedReceipt(rawReceipts[i]);</span>
 361 |     | <span class='neutral'>        }</span>
 362 |     | <span class='neutral'>        return receipts;</span>
 363 |     | <span class='neutral'>    }</span>
 364 |     | <span class='neutral'></span>
 365 |     | <span class='neutral'>    function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {</span>
 366 |     | <span class='neutral'>        Receipt memory receipt;</span>
 367 |     | <span class='neutral'>        receipt.blockHash = rawReceipt.blockHash;</span>
 368 |     | <span class='neutral'>        receipt.to = rawReceipt.to;</span>
 369 |     | <span class='neutral'>        receipt.from = rawReceipt.from;</span>
 370 |     | <span class='neutral'>        receipt.contractAddress = rawReceipt.contractAddress;</span>
 371 |     | <span class='neutral'>        receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);</span>
 372 |     | <span class='neutral'>        receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);</span>
 373 |     | <span class='neutral'>        receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);</span>
 374 |     | <span class='neutral'>        receipt.status = _bytesToUint(rawReceipt.status);</span>
 375 |     | <span class='neutral'>        receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);</span>
 376 |     | <span class='neutral'>        receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);</span>
 377 |     | <span class='neutral'>        receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);</span>
 378 |     | <span class='neutral'>        receipt.logsBloom = rawReceipt.logsBloom;</span>
 379 |     | <span class='neutral'>        receipt.transactionHash = rawReceipt.transactionHash;</span>
 380 |     | <span class='neutral'>        return receipt;</span>
 381 |     | <span class='neutral'>    }</span>
 382 |     | <span class='neutral'></span>
 383 |     | <span class='neutral'>    function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)</span>
 384 |     | <span class='neutral'>        internal</span>
 385 |     | <span class='neutral'>        pure</span>
 386 |     | <span class='neutral'>        virtual</span>
 387 |     | <span class='neutral'>        returns (ReceiptLog[] memory)</span>
 388 |     | <span class='neutral'>    {</span>
 389 |     | <span class='neutral'>        ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);</span>
 390 |     | <span class='neutral'>        for (uint256 i; i &lt; rawLogs.length; i++) {</span>
 391 |     | <span class='neutral'>            logs[i].logAddress = rawLogs[i].logAddress;</span>
 392 |     | <span class='neutral'>            logs[i].blockHash = rawLogs[i].blockHash;</span>
 393 |     | <span class='neutral'>            logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);</span>
 394 |     | <span class='neutral'>            logs[i].data = rawLogs[i].data;</span>
 395 |     | <span class='neutral'>            logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);</span>
 396 |     | <span class='neutral'>            logs[i].topics = rawLogs[i].topics;</span>
 397 |     | <span class='neutral'>            logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);</span>
 398 |     | <span class='neutral'>            logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);</span>
 399 |     | <span class='neutral'>            logs[i].removed = rawLogs[i].removed;</span>
 400 |     | <span class='neutral'>        }</span>
 401 |     | <span class='neutral'>        return logs;</span>
 402 |     | <span class='neutral'>    }</span>
 403 |     | <span class='neutral'></span>
 404 |     | <span class='neutral'>    // Deploy a contract by fetching the contract bytecode from</span>
 405 |     | <span class='neutral'>    // the artifacts directory</span>
 406 |     | <span class='neutral'>    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`</span>
 407 |     | <span class='neutral'>    function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {</span>
 408 |     | <span class='neutral'>        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);</span>
 409 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 410 |     | <span class='neutral'>        assembly {</span>
 411 |     | <span class='neutral'>            addr := create(0, add(bytecode, 0x20), mload(bytecode))</span>
 412 |     | <span class='neutral'>        }</span>
 413 |     | <span class='neutral'></span>
 414 |     | <span class='neutral'>        require(addr != address(0), &quot;StdCheats deployCode(string,bytes): Deployment failed.&quot;);</span>
 415 |     | <span class='neutral'>    }</span>
 416 |     | <span class='neutral'></span>
 417 |     | <span class='neutral'>    function deployCode(string memory what) internal virtual returns (address addr) {</span>
 418 |     | <span class='neutral'>        bytes memory bytecode = vm.getCode(what);</span>
 419 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 420 |     | <span class='neutral'>        assembly {</span>
 421 |     | <span class='neutral'>            addr := create(0, add(bytecode, 0x20), mload(bytecode))</span>
 422 |     | <span class='neutral'>        }</span>
 423 |     | <span class='neutral'></span>
 424 |     | <span class='neutral'>        require(addr != address(0), &quot;StdCheats deployCode(string): Deployment failed.&quot;);</span>
 425 |     | <span class='neutral'>    }</span>
 426 |     | <span class='neutral'></span>
 427 |     | <span class='neutral'>    /// @dev deploy contract with value on construction</span>
 428 |     | <span class='neutral'>    function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {</span>
 429 |     | <span class='neutral'>        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);</span>
 430 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 431 |     | <span class='neutral'>        assembly {</span>
 432 |     | <span class='neutral'>            addr := create(val, add(bytecode, 0x20), mload(bytecode))</span>
 433 |     | <span class='neutral'>        }</span>
 434 |     | <span class='neutral'></span>
 435 |     | <span class='neutral'>        require(addr != address(0), &quot;StdCheats deployCode(string,bytes,uint256): Deployment failed.&quot;);</span>
 436 |     | <span class='neutral'>    }</span>
 437 |     | <span class='neutral'></span>
 438 |     | <span class='neutral'>    function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {</span>
 439 |     | <span class='neutral'>        bytes memory bytecode = vm.getCode(what);</span>
 440 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 441 |     | <span class='neutral'>        assembly {</span>
 442 |     | <span class='neutral'>            addr := create(val, add(bytecode, 0x20), mload(bytecode))</span>
 443 |     | <span class='neutral'>        }</span>
 444 |     | <span class='neutral'></span>
 445 |     | <span class='neutral'>        require(addr != address(0), &quot;StdCheats deployCode(string,uint256): Deployment failed.&quot;);</span>
 446 |     | <span class='neutral'>    }</span>
 447 |     | <span class='neutral'></span>
 448 |     | <span class='neutral'>    // creates a labeled address and the corresponding private key</span>
 449 |     | <span class='neutral'>    function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {</span>
 450 |     | <span class='neutral'>        privateKey = uint256(keccak256(abi.encodePacked(name)));</span>
 451 |     | <span class='neutral'>        addr = vm.addr(privateKey);</span>
 452 |     | <span class='neutral'>        vm.label(addr, name);</span>
 453 |     | <span class='neutral'>    }</span>
 454 |     | <span class='neutral'></span>
 455 |     | <span class='neutral'>    // creates a labeled address</span>
 456 |     | <span class='neutral'>    function makeAddr(string memory name) internal virtual returns (address addr) {</span>
 457 |     | <span class='neutral'>        (addr,) = makeAddrAndKey(name);</span>
 458 |     | <span class='neutral'>    }</span>
 459 |     | <span class='neutral'></span>
 460 |     | <span class='neutral'>    function deriveRememberKey(string memory mnemonic, uint32 index)</span>
 461 |     | <span class='neutral'>        internal</span>
 462 |     | <span class='neutral'>        virtual</span>
 463 |     | <span class='neutral'>        returns (address who, uint256 privateKey)</span>
 464 |     | <span class='neutral'>    {</span>
 465 |     | <span class='neutral'>        privateKey = vm.deriveKey(mnemonic, index);</span>
 466 |     | <span class='neutral'>        who = vm.rememberKey(privateKey);</span>
 467 |     | <span class='neutral'>    }</span>
 468 |     | <span class='neutral'></span>
 469 |     | <span class='neutral'>    function _bytesToUint(bytes memory b) private pure returns (uint256) {</span>
 470 |     | <span class='neutral'>        require(b.length &lt;= 32, &quot;StdCheats _bytesToUint(bytes): Bytes length exceeds 32.&quot;);</span>
 471 |     | <span class='neutral'>        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));</span>
 472 |     | <span class='neutral'>    }</span>
 473 |     | <span class='neutral'>}</span>
 474 |     | <span class='neutral'></span>
 475 |     | <span class='neutral'>// Wrappers around cheatcodes to avoid footguns</span>
 476 |     | <span class='neutral'>abstract contract StdCheats is StdCheatsSafe {</span>
 477 |     | <span class='neutral'>    using stdStorage for StdStorage;</span>
 478 |     | <span class='neutral'></span>
 479 |     | <span class='neutral'>    StdStorage private stdstore;</span>
 480 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
 481 |     | <span class='neutral'></span>
 482 |     | <span class='neutral'>    // Skip forward or rewind time by the specified number of seconds</span>
 483 |     | <span class='neutral'>    function skip(uint256 time) internal virtual {</span>
 484 |     | <span class='neutral'>        vm.warp(block.timestamp + time);</span>
 485 |     | <span class='neutral'>    }</span>
 486 |     | <span class='neutral'></span>
 487 |     | <span class='neutral'>    function rewind(uint256 time) internal virtual {</span>
 488 |     | <span class='neutral'>        vm.warp(block.timestamp - time);</span>
 489 |     | <span class='neutral'>    }</span>
 490 |     | <span class='neutral'></span>
 491 |     | <span class='neutral'>    // Setup a prank from an address that has some ether</span>
 492 |     | <span class='neutral'>    function hoax(address who) internal virtual {</span>
 493 |     | <span class='neutral'>        vm.deal(who, 1 &lt;&lt; 128);</span>
 494 |     | <span class='neutral'>        vm.prank(who);</span>
 495 |     | <span class='neutral'>    }</span>
 496 |     | <span class='neutral'></span>
 497 |     | <span class='neutral'>    function hoax(address who, uint256 give) internal virtual {</span>
 498 |     | <span class='neutral'>        vm.deal(who, give);</span>
 499 |     | <span class='neutral'>        vm.prank(who);</span>
 500 |     | <span class='neutral'>    }</span>
 501 |     | <span class='neutral'></span>
 502 |     | <span class='neutral'>    function hoax(address who, address origin) internal virtual {</span>
 503 |     | <span class='neutral'>        vm.deal(who, 1 &lt;&lt; 128);</span>
 504 |     | <span class='neutral'>        vm.prank(who, origin);</span>
 505 |     | <span class='neutral'>    }</span>
 506 |     | <span class='neutral'></span>
 507 |     | <span class='neutral'>    function hoax(address who, address origin, uint256 give) internal virtual {</span>
 508 |     | <span class='neutral'>        vm.deal(who, give);</span>
 509 |     | <span class='neutral'>        vm.prank(who, origin);</span>
 510 |     | <span class='neutral'>    }</span>
 511 |     | <span class='neutral'></span>
 512 |     | <span class='neutral'>    // Start perpetual prank from an address that has some ether</span>
 513 |     | <span class='neutral'>    function startHoax(address who) internal virtual {</span>
 514 |     | <span class='neutral'>        vm.deal(who, 1 &lt;&lt; 128);</span>
 515 |     | <span class='neutral'>        vm.startPrank(who);</span>
 516 |     | <span class='neutral'>    }</span>
 517 |     | <span class='neutral'></span>
 518 |     | <span class='neutral'>    function startHoax(address who, uint256 give) internal virtual {</span>
 519 |     | <span class='neutral'>        vm.deal(who, give);</span>
 520 |     | <span class='neutral'>        vm.startPrank(who);</span>
 521 |     | <span class='neutral'>    }</span>
 522 |     | <span class='neutral'></span>
 523 |     | <span class='neutral'>    // Start perpetual prank from an address that has some ether</span>
 524 |     | <span class='neutral'>    // tx.origin is set to the origin parameter</span>
 525 |     | <span class='neutral'>    function startHoax(address who, address origin) internal virtual {</span>
 526 |     | <span class='neutral'>        vm.deal(who, 1 &lt;&lt; 128);</span>
 527 |     | <span class='neutral'>        vm.startPrank(who, origin);</span>
 528 |     | <span class='neutral'>    }</span>
 529 |     | <span class='neutral'></span>
 530 |     | <span class='neutral'>    function startHoax(address who, address origin, uint256 give) internal virtual {</span>
 531 |     | <span class='neutral'>        vm.deal(who, give);</span>
 532 |     | <span class='neutral'>        vm.startPrank(who, origin);</span>
 533 |     | <span class='neutral'>    }</span>
 534 |     | <span class='neutral'></span>
 535 |     | <span class='neutral'>    function changePrank(address who) internal virtual {</span>
 536 |     | <span class='neutral'>        vm.stopPrank();</span>
 537 |     | <span class='neutral'>        vm.startPrank(who);</span>
 538 |     | <span class='neutral'>    }</span>
 539 |     | <span class='neutral'></span>
 540 |     | <span class='neutral'>    // The same as Vm&#39;s `deal`</span>
 541 |     | <span class='neutral'>    // Use the alternative signature for ERC20 tokens</span>
 542 |     | <span class='neutral'>    function deal(address to, uint256 give) internal virtual {</span>
 543 |     | <span class='neutral'>        vm.deal(to, give);</span>
 544 |     | <span class='neutral'>    }</span>
 545 |     | <span class='neutral'></span>
 546 |     | <span class='neutral'>    // Set the balance of an account for any ERC20 token</span>
 547 |     | <span class='neutral'>    // Use the alternative signature to update `totalSupply`</span>
 548 |     | <span class='neutral'>    function deal(address token, address to, uint256 give) internal virtual {</span>
 549 |     | <span class='neutral'>        deal(token, to, give, false);</span>
 550 |     | <span class='neutral'>    }</span>
 551 |     | <span class='neutral'></span>
 552 |     | <span class='neutral'>    function deal(address token, address to, uint256 give, bool adjust) internal virtual {</span>
 553 |     | <span class='neutral'>        // get current balance</span>
 554 |     | <span class='neutral'>        (, bytes memory balData) = token.call(abi.encodeWithSelector(0x70a08231, to));</span>
 555 |     | <span class='neutral'>        uint256 prevBal = abi.decode(balData, (uint256));</span>
 556 |     | <span class='neutral'></span>
 557 |     | <span class='neutral'>        // update balance</span>
 558 |     | <span class='neutral'>        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);</span>
 559 |     | <span class='neutral'></span>
 560 |     | <span class='neutral'>        // update total supply</span>
 561 |     | <span class='neutral'>        if (adjust) {</span>
 562 |     | <span class='neutral'>            (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0x18160ddd));</span>
 563 |     | <span class='neutral'>            uint256 totSup = abi.decode(totSupData, (uint256));</span>
 564 |     | <span class='neutral'>            if (give &lt; prevBal) {</span>
 565 |     | <span class='neutral'>                totSup -= (prevBal - give);</span>
 566 |     | <span class='neutral'>            } else {</span>
 567 |     | <span class='neutral'>                totSup += (give - prevBal);</span>
 568 |     | <span class='neutral'>            }</span>
 569 |     | <span class='neutral'>            stdstore.target(token).sig(0x18160ddd).checked_write(totSup);</span>
 570 |     | <span class='neutral'>        }</span>
 571 |     | <span class='neutral'>    }</span>
 572 |     | <span class='neutral'>}</span>
 573 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/lib/forge-std/src/StdError.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// Panics work for versions &gt;=0.8.0, but we lowered the pragma to make this compatible with Test</span>
  3 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>library stdError {</span>
  6 |     | <span class='neutral'>    bytes public constant assertionError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x01);</span>
  7 |     | <span class='neutral'>    bytes public constant arithmeticError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x11);</span>
  8 |     | <span class='neutral'>    bytes public constant divisionError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x12);</span>
  9 |     | <span class='neutral'>    bytes public constant enumConversionError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x21);</span>
 10 |     | <span class='neutral'>    bytes public constant encodeStorageError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x22);</span>
 11 |     | <span class='neutral'>    bytes public constant popError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x31);</span>
 12 |     | <span class='neutral'>    bytes public constant indexOOBError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x32);</span>
 13 |     | <span class='neutral'>    bytes public constant memOverflowError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x41);</span>
 14 |     | <span class='neutral'>    bytes public constant zeroVarError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x51);</span>
 15 |     | <span class='neutral'>}</span>
 16 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/lib/forge-std/src/StdJson.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.0 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;./Vm.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>// Helpers for parsing and writing JSON files</span>
   9 |     | <span class='neutral'>// To parse:</span>
  10 |     | <span class='neutral'>// ```</span>
  11 |     | <span class='neutral'>// using stdJson for string;</span>
  12 |     | <span class='neutral'>// string memory json = vm.readFile(&quot;some_peth&quot;);</span>
  13 |     | <span class='neutral'>// json.parseUint(&quot;&lt;json_path&gt;&quot;);</span>
  14 |     | <span class='neutral'>// ```</span>
  15 |     | <span class='neutral'>// To write:</span>
  16 |     | <span class='neutral'>// ```</span>
  17 |     | <span class='neutral'>// using stdJson for string;</span>
  18 |     | <span class='neutral'>// string memory json = &quot;deploymentArtifact&quot;;</span>
  19 |     | <span class='neutral'>// Contract contract = new Contract();</span>
  20 |     | <span class='neutral'>// json.serialize(&quot;contractAddress&quot;, address(contract));</span>
  21 |     | <span class='neutral'>// json = json.serialize(&quot;deploymentTimes&quot;, uint(1));</span>
  22 |     | <span class='neutral'>// // store the stringified JSON to the &#39;json&#39; variable we have been using as a key</span>
  23 |     | <span class='neutral'>// // as we won&#39;t need it any longer</span>
  24 |     | <span class='neutral'>// string memory json2 = &quot;finalArtifact&quot;;</span>
  25 |     | <span class='neutral'>// string memory final = json2.serialize(&quot;depArtifact&quot;, json);</span>
  26 |     | <span class='neutral'>// final.write(&quot;&lt;some_path&gt;&quot;);</span>
  27 |     | <span class='neutral'>// ```</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>library stdJson {</span>
  30 |     | <span class='neutral'>    VmSafe private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {</span>
  33 |     | <span class='neutral'>        return vm.parseJson(json, key);</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    function readUint(string memory json, string memory key) internal pure returns (uint256) {</span>
  37 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (uint256));</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    function readUintArray(string memory json, string memory key) internal pure returns (uint256[] memory) {</span>
  41 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (uint256[]));</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    function readInt(string memory json, string memory key) internal pure returns (int256) {</span>
  45 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (int256));</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    function readIntArray(string memory json, string memory key) internal pure returns (int256[] memory) {</span>
  49 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (int256[]));</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    function readBytes32(string memory json, string memory key) internal pure returns (bytes32) {</span>
  53 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (bytes32));</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    function readBytes32Array(string memory json, string memory key) internal pure returns (bytes32[] memory) {</span>
  57 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (bytes32[]));</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    function readString(string memory json, string memory key) internal pure returns (string memory) {</span>
  61 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (string));</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    function readStringArray(string memory json, string memory key) internal pure returns (string[] memory) {</span>
  65 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (string[]));</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    function readAddress(string memory json, string memory key) internal pure returns (address) {</span>
  69 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (address));</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    function readAddressArray(string memory json, string memory key) internal pure returns (address[] memory) {</span>
  73 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (address[]));</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    function readBool(string memory json, string memory key) internal pure returns (bool) {</span>
  77 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (bool));</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    function readBoolArray(string memory json, string memory key) internal pure returns (bool[] memory) {</span>
  81 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (bool[]));</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    function readBytes(string memory json, string memory key) internal pure returns (bytes memory) {</span>
  85 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (bytes));</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    function readBytesArray(string memory json, string memory key) internal pure returns (bytes[] memory) {</span>
  89 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (bytes[]));</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {</span>
  93 |     | <span class='neutral'>        return vm.serializeBool(jsonKey, key, value);</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bool[] memory value)</span>
  97 |     | <span class='neutral'>        internal</span>
  98 |     | <span class='neutral'>        returns (string memory)</span>
  99 |     | <span class='neutral'>    {</span>
 100 |     | <span class='neutral'>        return vm.serializeBool(jsonKey, key, value);</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {</span>
 104 |     | <span class='neutral'>        return vm.serializeUint(jsonKey, key, value);</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, uint256[] memory value)</span>
 108 |     | <span class='neutral'>        internal</span>
 109 |     | <span class='neutral'>        returns (string memory)</span>
 110 |     | <span class='neutral'>    {</span>
 111 |     | <span class='neutral'>        return vm.serializeUint(jsonKey, key, value);</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {</span>
 115 |     | <span class='neutral'>        return vm.serializeInt(jsonKey, key, value);</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, int256[] memory value)</span>
 119 |     | <span class='neutral'>        internal</span>
 120 |     | <span class='neutral'>        returns (string memory)</span>
 121 |     | <span class='neutral'>    {</span>
 122 |     | <span class='neutral'>        return vm.serializeInt(jsonKey, key, value);</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {</span>
 126 |     | <span class='neutral'>        return vm.serializeAddress(jsonKey, key, value);</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, address[] memory value)</span>
 130 |     | <span class='neutral'>        internal</span>
 131 |     | <span class='neutral'>        returns (string memory)</span>
 132 |     | <span class='neutral'>    {</span>
 133 |     | <span class='neutral'>        return vm.serializeAddress(jsonKey, key, value);</span>
 134 |     | <span class='neutral'>    }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {</span>
 137 |     | <span class='neutral'>        return vm.serializeBytes32(jsonKey, key, value);</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)</span>
 141 |     | <span class='neutral'>        internal</span>
 142 |     | <span class='neutral'>        returns (string memory)</span>
 143 |     | <span class='neutral'>    {</span>
 144 |     | <span class='neutral'>        return vm.serializeBytes32(jsonKey, key, value);</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {</span>
 148 |     | <span class='neutral'>        return vm.serializeBytes(jsonKey, key, value);</span>
 149 |     | <span class='neutral'>    }</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes[] memory value)</span>
 152 |     | <span class='neutral'>        internal</span>
 153 |     | <span class='neutral'>        returns (string memory)</span>
 154 |     | <span class='neutral'>    {</span>
 155 |     | <span class='neutral'>        return vm.serializeBytes(jsonKey, key, value);</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, string memory value)</span>
 159 |     | <span class='neutral'>        internal</span>
 160 |     | <span class='neutral'>        returns (string memory)</span>
 161 |     | <span class='neutral'>    {</span>
 162 |     | <span class='neutral'>        return vm.serializeString(jsonKey, key, value);</span>
 163 |     | <span class='neutral'>    }</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, string[] memory value)</span>
 166 |     | <span class='neutral'>        internal</span>
 167 |     | <span class='neutral'>        returns (string memory)</span>
 168 |     | <span class='neutral'>    {</span>
 169 |     | <span class='neutral'>        return vm.serializeString(jsonKey, key, value);</span>
 170 |     | <span class='neutral'>    }</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='neutral'>    function write(string memory jsonKey, string memory path) internal {</span>
 173 |     | <span class='neutral'>        vm.writeJson(jsonKey, path);</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    function write(string memory jsonKey, string memory path, string memory valueKey) internal {</span>
 177 |     | <span class='neutral'>        vm.writeJson(jsonKey, path, valueKey);</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'>}</span>
 180 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/lib/forge-std/src/StdMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>library stdMath {</span>
  5 |     | <span class='neutral'>    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function abs(int256 a) internal pure returns (uint256) {</span>
  8 |     | <span class='neutral'>        // Required or it will fail when `a = type(int256).min`</span>
  9 |     | <span class='neutral'>        if (a == INT256_MIN) {</span>
 10 |     | <span class='neutral'>            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span>
 11 |     | <span class='neutral'>        }</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>        return uint256(a &gt; 0 ? a : -a);</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    function delta(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 17 |     | <span class='neutral'>        return a &gt; b ? a - b : b - a;</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    function delta(int256 a, int256 b) internal pure returns (uint256) {</span>
 21 |     | <span class='neutral'>        // a and b are of the same sign</span>
 22 |     | <span class='neutral'>        // this works thanks to two&#39;s complement, the left-most bit is the sign bit</span>
 23 |     | <span class='neutral'>        if ((a ^ b) &gt; -1) {</span>
 24 |     | <span class='neutral'>            return delta(abs(a), abs(b));</span>
 25 |     | <span class='neutral'>        }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>        // a and b are of opposite signs</span>
 28 |     | <span class='neutral'>        return abs(a) + abs(b);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 32 |     | <span class='neutral'>        uint256 absDelta = delta(a, b);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>        return absDelta * 1e18 / b;</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {</span>
 38 |     | <span class='neutral'>        uint256 absDelta = delta(a, b);</span>
 39 |     | <span class='neutral'>        uint256 absB = abs(b);</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>        return absDelta * 1e18 / absB;</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'>}</span>
 44 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/lib/forge-std/src/StdStorage.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./Vm.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>struct StdStorage {</span>
   7 |     | <span class='neutral'>    mapping(address =&gt; mapping(bytes4 =&gt; mapping(bytes32 =&gt; uint256))) slots;</span>
   8 |     | <span class='neutral'>    mapping(address =&gt; mapping(bytes4 =&gt; mapping(bytes32 =&gt; bool))) finds;</span>
   9 |     | <span class='neutral'>    bytes32[] _keys;</span>
  10 |     | <span class='neutral'>    bytes4 _sig;</span>
  11 |     | <span class='neutral'>    uint256 _depth;</span>
  12 |     | <span class='neutral'>    address _target;</span>
  13 |     | <span class='neutral'>    bytes32 _set;</span>
  14 |     | <span class='neutral'>}</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>library stdStorageSafe {</span>
  17 |     | <span class='neutral'>    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);</span>
  18 |     | <span class='neutral'>    event WARNING_UninitedSlot(address who, uint256 slot);</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    function sigs(string memory sigStr) internal pure returns (bytes4) {</span>
  23 |     | <span class='neutral'>        return bytes4(keccak256(bytes(sigStr)));</span>
  24 |     | <span class='neutral'>    }</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against</span>
  27 |     | <span class='neutral'>    // slot complexity:</span>
  28 |     | <span class='neutral'>    //  if flat, will be bytes32(uint256(uint));</span>
  29 |     | <span class='neutral'>    //  if map, will be keccak256(abi.encode(key, uint(slot)));</span>
  30 |     | <span class='neutral'>    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));</span>
  31 |     | <span class='neutral'>    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);</span>
  32 |     | <span class='neutral'>    function find(StdStorage storage self) internal returns (uint256) {</span>
  33 |     | <span class='neutral'>        address who = self._target;</span>
  34 |     | <span class='neutral'>        bytes4 fsig = self._sig;</span>
  35 |     | <span class='neutral'>        uint256 field_depth = self._depth;</span>
  36 |     | <span class='neutral'>        bytes32[] memory ins = self._keys;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>        // calldata to test against</span>
  39 |     | <span class='neutral'>        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {</span>
  40 |     | <span class='neutral'>            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];</span>
  41 |     | <span class='neutral'>        }</span>
  42 |     | <span class='neutral'>        bytes memory cald = abi.encodePacked(fsig, flatten(ins));</span>
  43 |     | <span class='neutral'>        vm.record();</span>
  44 |     | <span class='neutral'>        bytes32 fdat;</span>
  45 |     | <span class='neutral'>        {</span>
  46 |     | <span class='neutral'>            (, bytes memory rdat) = who.staticcall(cald);</span>
  47 |     | <span class='neutral'>            fdat = bytesToBytes32(rdat, 32 * field_depth);</span>
  48 |     | <span class='neutral'>        }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>        (bytes32[] memory reads,) = vm.accesses(address(who));</span>
  51 |     | <span class='neutral'>        if (reads.length == 1) {</span>
  52 |     | <span class='neutral'>            bytes32 curr = vm.load(who, reads[0]);</span>
  53 |     | <span class='neutral'>            if (curr == bytes32(0)) {</span>
  54 |     | <span class='neutral'>                emit WARNING_UninitedSlot(who, uint256(reads[0]));</span>
  55 |     | <span class='neutral'>            }</span>
  56 |     | <span class='neutral'>            if (fdat != curr) {</span>
  57 |     | <span class='neutral'>                require(</span>
  58 |     | <span class='neutral'>                    false,</span>
  59 |     | <span class='neutral'>                    &quot;stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn&#39;t supported.&quot;</span>
  60 |     | <span class='neutral'>                );</span>
  61 |     | <span class='neutral'>            }</span>
  62 |     | <span class='neutral'>            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));</span>
  63 |     | <span class='neutral'>            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);</span>
  64 |     | <span class='neutral'>            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;</span>
  65 |     | <span class='neutral'>        } else if (reads.length &gt; 1) {</span>
  66 |     | <span class='neutral'>            for (uint256 i = 0; i &lt; reads.length; i++) {</span>
  67 |     | <span class='neutral'>                bytes32 prev = vm.load(who, reads[i]);</span>
  68 |     | <span class='neutral'>                if (prev == bytes32(0)) {</span>
  69 |     | <span class='neutral'>                    emit WARNING_UninitedSlot(who, uint256(reads[i]));</span>
  70 |     | <span class='neutral'>                }</span>
  71 |     | <span class='neutral'>                // store</span>
  72 |     | <span class='neutral'>                vm.store(who, reads[i], bytes32(hex&quot;1337&quot;));</span>
  73 |     | <span class='neutral'>                bool success;</span>
  74 |     | <span class='neutral'>                bytes memory rdat;</span>
  75 |     | <span class='neutral'>                {</span>
  76 |     | <span class='neutral'>                    (success, rdat) = who.staticcall(cald);</span>
  77 |     | <span class='neutral'>                    fdat = bytesToBytes32(rdat, 32 * field_depth);</span>
  78 |     | <span class='neutral'>                }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>                if (success &amp;&amp; fdat == bytes32(hex&quot;1337&quot;)) {</span>
  81 |     | <span class='neutral'>                    // we found which of the slots is the actual one</span>
  82 |     | <span class='neutral'>                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));</span>
  83 |     | <span class='neutral'>                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);</span>
  84 |     | <span class='neutral'>                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;</span>
  85 |     | <span class='neutral'>                    vm.store(who, reads[i], prev);</span>
  86 |     | <span class='neutral'>                    break;</span>
  87 |     | <span class='neutral'>                }</span>
  88 |     | <span class='neutral'>                vm.store(who, reads[i], prev);</span>
  89 |     | <span class='neutral'>            }</span>
  90 |     | <span class='neutral'>        } else {</span>
  91 |     | <span class='neutral'>            require(false, &quot;stdStorage find(StdStorage): No storage use detected for target.&quot;);</span>
  92 |     | <span class='neutral'>        }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>        require(</span>
  95 |     | <span class='neutral'>            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))],</span>
  96 |     | <span class='neutral'>            &quot;stdStorage find(StdStorage): Slot(s) not found.&quot;</span>
  97 |     | <span class='neutral'>        );</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>        delete self._target;</span>
 100 |     | <span class='neutral'>        delete self._sig;</span>
 101 |     | <span class='neutral'>        delete self._keys;</span>
 102 |     | <span class='neutral'>        delete self._depth;</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {</span>
 108 |     | <span class='neutral'>        self._target = _target;</span>
 109 |     | <span class='neutral'>        return self;</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {</span>
 113 |     | <span class='neutral'>        self._sig = _sig;</span>
 114 |     | <span class='neutral'>        return self;</span>
 115 |     | <span class='neutral'>    }</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {</span>
 118 |     | <span class='neutral'>        self._sig = sigs(_sig);</span>
 119 |     | <span class='neutral'>        return self;</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {</span>
 123 |     | <span class='neutral'>        self._keys.push(bytes32(uint256(uint160(who))));</span>
 124 |     | <span class='neutral'>        return self;</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {</span>
 128 |     | <span class='neutral'>        self._keys.push(bytes32(amt));</span>
 129 |     | <span class='neutral'>        return self;</span>
 130 |     | <span class='neutral'>    }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {</span>
 133 |     | <span class='neutral'>        self._keys.push(key);</span>
 134 |     | <span class='neutral'>        return self;</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {</span>
 138 |     | <span class='neutral'>        self._depth = _depth;</span>
 139 |     | <span class='neutral'>        return self;</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    function read(StdStorage storage self) private returns (bytes memory) {</span>
 143 |     | <span class='neutral'>        address t = self._target;</span>
 144 |     | <span class='neutral'>        uint256 s = find(self);</span>
 145 |     | <span class='neutral'>        return abi.encode(vm.load(t, bytes32(s)));</span>
 146 |     | <span class='neutral'>    }</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>    function read_bytes32(StdStorage storage self) internal returns (bytes32) {</span>
 149 |     | <span class='neutral'>        return abi.decode(read(self), (bytes32));</span>
 150 |     | <span class='neutral'>    }</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>    function read_bool(StdStorage storage self) internal returns (bool) {</span>
 153 |     | <span class='neutral'>        int256 v = read_int(self);</span>
 154 |     | <span class='neutral'>        if (v == 0) return false;</span>
 155 |     | <span class='neutral'>        if (v == 1) return true;</span>
 156 |     | <span class='neutral'>        revert(&quot;stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.&quot;);</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    function read_address(StdStorage storage self) internal returns (address) {</span>
 160 |     | <span class='neutral'>        return abi.decode(read(self), (address));</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    function read_uint(StdStorage storage self) internal returns (uint256) {</span>
 164 |     | <span class='neutral'>        return abi.decode(read(self), (uint256));</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    function read_int(StdStorage storage self) internal returns (int256) {</span>
 168 |     | <span class='neutral'>        return abi.decode(read(self), (int256));</span>
 169 |     | <span class='neutral'>    }</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {</span>
 172 |     | <span class='neutral'>        bytes32 out;</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>        uint256 max = b.length &gt; 32 ? 32 : b.length;</span>
 175 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; max; i++) {</span>
 176 |     | <span class='neutral'>            out |= bytes32(b[offset + i] &amp; 0xFF) &gt;&gt; (i * 8);</span>
 177 |     | <span class='neutral'>        }</span>
 178 |     | <span class='neutral'>        return out;</span>
 179 |     | <span class='neutral'>    }</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='neutral'>    function flatten(bytes32[] memory b) private pure returns (bytes memory) {</span>
 182 |     | <span class='neutral'>        bytes memory result = new bytes(b.length * 32);</span>
 183 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; b.length; i++) {</span>
 184 |     | <span class='neutral'>            bytes32 k = b[i];</span>
 185 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 186 |     | <span class='neutral'>            assembly {</span>
 187 |     | <span class='neutral'>                mstore(add(result, add(32, mul(32, i))), k)</span>
 188 |     | <span class='neutral'>            }</span>
 189 |     | <span class='neutral'>        }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>        return result;</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'>}</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>library stdStorage {</span>
 196 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>    function sigs(string memory sigStr) internal pure returns (bytes4) {</span>
 199 |     | <span class='neutral'>        return stdStorageSafe.sigs(sigStr);</span>
 200 |     | <span class='neutral'>    }</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>    function find(StdStorage storage self) internal returns (uint256) {</span>
 203 |     | <span class='neutral'>        return stdStorageSafe.find(self);</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='neutral'>    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {</span>
 207 |     | <span class='neutral'>        return stdStorageSafe.target(self, _target);</span>
 208 |     | <span class='neutral'>    }</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='neutral'>    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {</span>
 211 |     | <span class='neutral'>        return stdStorageSafe.sig(self, _sig);</span>
 212 |     | <span class='neutral'>    }</span>
 213 |     | <span class='neutral'></span>
 214 |     | <span class='neutral'>    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {</span>
 215 |     | <span class='neutral'>        return stdStorageSafe.sig(self, _sig);</span>
 216 |     | <span class='neutral'>    }</span>
 217 |     | <span class='neutral'></span>
 218 |     | <span class='neutral'>    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {</span>
 219 |     | <span class='neutral'>        return stdStorageSafe.with_key(self, who);</span>
 220 |     | <span class='neutral'>    }</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {</span>
 223 |     | <span class='neutral'>        return stdStorageSafe.with_key(self, amt);</span>
 224 |     | <span class='neutral'>    }</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {</span>
 227 |     | <span class='neutral'>        return stdStorageSafe.with_key(self, key);</span>
 228 |     | <span class='neutral'>    }</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='neutral'>    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {</span>
 231 |     | <span class='neutral'>        return stdStorageSafe.depth(self, _depth);</span>
 232 |     | <span class='neutral'>    }</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='neutral'>    function checked_write(StdStorage storage self, address who) internal {</span>
 235 |     | <span class='neutral'>        checked_write(self, bytes32(uint256(uint160(who))));</span>
 236 |     | <span class='neutral'>    }</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='neutral'>    function checked_write(StdStorage storage self, uint256 amt) internal {</span>
 239 |     | <span class='neutral'>        checked_write(self, bytes32(amt));</span>
 240 |     | <span class='neutral'>    }</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>    function checked_write(StdStorage storage self, bool write) internal {</span>
 243 |     | <span class='neutral'>        bytes32 t;</span>
 244 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 245 |     | <span class='neutral'>        assembly {</span>
 246 |     | <span class='neutral'>            t := write</span>
 247 |     | <span class='neutral'>        }</span>
 248 |     | <span class='neutral'>        checked_write(self, t);</span>
 249 |     | <span class='neutral'>    }</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='neutral'>    function checked_write(StdStorage storage self, bytes32 set) internal {</span>
 252 |     | <span class='neutral'>        address who = self._target;</span>
 253 |     | <span class='neutral'>        bytes4 fsig = self._sig;</span>
 254 |     | <span class='neutral'>        uint256 field_depth = self._depth;</span>
 255 |     | <span class='neutral'>        bytes32[] memory ins = self._keys;</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='neutral'>        bytes memory cald = abi.encodePacked(fsig, flatten(ins));</span>
 258 |     | <span class='neutral'>        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {</span>
 259 |     | <span class='neutral'>            find(self);</span>
 260 |     | <span class='neutral'>        }</span>
 261 |     | <span class='neutral'>        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);</span>
 262 |     | <span class='neutral'></span>
 263 |     | <span class='neutral'>        bytes32 fdat;</span>
 264 |     | <span class='neutral'>        {</span>
 265 |     | <span class='neutral'>            (, bytes memory rdat) = who.staticcall(cald);</span>
 266 |     | <span class='neutral'>            fdat = bytesToBytes32(rdat, 32 * field_depth);</span>
 267 |     | <span class='neutral'>        }</span>
 268 |     | <span class='neutral'>        bytes32 curr = vm.load(who, slot);</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='neutral'>        if (fdat != curr) {</span>
 271 |     | <span class='neutral'>            require(</span>
 272 |     | <span class='neutral'>                false,</span>
 273 |     | <span class='neutral'>                &quot;stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn&#39;t supported.&quot;</span>
 274 |     | <span class='neutral'>            );</span>
 275 |     | <span class='neutral'>        }</span>
 276 |     | <span class='neutral'>        vm.store(who, slot, set);</span>
 277 |     | <span class='neutral'>        delete self._target;</span>
 278 |     | <span class='neutral'>        delete self._sig;</span>
 279 |     | <span class='neutral'>        delete self._keys;</span>
 280 |     | <span class='neutral'>        delete self._depth;</span>
 281 |     | <span class='neutral'>    }</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='neutral'>    function read_bytes32(StdStorage storage self) internal returns (bytes32) {</span>
 284 |     | <span class='neutral'>        return stdStorageSafe.read_bytes32(self);</span>
 285 |     | <span class='neutral'>    }</span>
 286 |     | <span class='neutral'></span>
 287 |     | <span class='neutral'>    function read_bool(StdStorage storage self) internal returns (bool) {</span>
 288 |     | <span class='neutral'>        return stdStorageSafe.read_bool(self);</span>
 289 |     | <span class='neutral'>    }</span>
 290 |     | <span class='neutral'></span>
 291 |     | <span class='neutral'>    function read_address(StdStorage storage self) internal returns (address) {</span>
 292 |     | <span class='neutral'>        return stdStorageSafe.read_address(self);</span>
 293 |     | <span class='neutral'>    }</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='neutral'>    function read_uint(StdStorage storage self) internal returns (uint256) {</span>
 296 |     | <span class='neutral'>        return stdStorageSafe.read_uint(self);</span>
 297 |     | <span class='neutral'>    }</span>
 298 |     | <span class='neutral'></span>
 299 |     | <span class='neutral'>    function read_int(StdStorage storage self) internal returns (int256) {</span>
 300 |     | <span class='neutral'>        return stdStorageSafe.read_int(self);</span>
 301 |     | <span class='neutral'>    }</span>
 302 |     | <span class='neutral'></span>
 303 |     | <span class='neutral'>    // Private function so needs to be copied over</span>
 304 |     | <span class='neutral'>    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {</span>
 305 |     | <span class='neutral'>        bytes32 out;</span>
 306 |     | <span class='neutral'></span>
 307 |     | <span class='neutral'>        uint256 max = b.length &gt; 32 ? 32 : b.length;</span>
 308 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; max; i++) {</span>
 309 |     | <span class='neutral'>            out |= bytes32(b[offset + i] &amp; 0xFF) &gt;&gt; (i * 8);</span>
 310 |     | <span class='neutral'>        }</span>
 311 |     | <span class='neutral'>        return out;</span>
 312 |     | <span class='neutral'>    }</span>
 313 |     | <span class='neutral'></span>
 314 |     | <span class='neutral'>    // Private function so needs to be copied over</span>
 315 |     | <span class='neutral'>    function flatten(bytes32[] memory b) private pure returns (bytes memory) {</span>
 316 |     | <span class='neutral'>        bytes memory result = new bytes(b.length * 32);</span>
 317 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; b.length; i++) {</span>
 318 |     | <span class='neutral'>            bytes32 k = b[i];</span>
 319 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 320 |     | <span class='neutral'>            assembly {</span>
 321 |     | <span class='neutral'>                mstore(add(result, add(32, mul(32, i))), k)</span>
 322 |     | <span class='neutral'>            }</span>
 323 |     | <span class='neutral'>        }</span>
 324 |     | <span class='neutral'></span>
 325 |     | <span class='neutral'>        return result;</span>
 326 |     | <span class='neutral'>    }</span>
 327 |     | <span class='neutral'>}</span>
 328 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/lib/forge-std/src/StdUtils.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./console2.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>abstract contract StdUtils {</span>
  7 |     | <span class='neutral'>    uint256 private constant UINT256_MAX =</span>
  8 |     | <span class='neutral'>        115792089237316195423570985008687907853269984665640564039457584007913129639935;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {</span>
 11 |     | <span class='neutral'>        require(min &lt;= max, &quot;StdUtils bound(uint256,uint256,uint256): Max is less than min.&quot;);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>        // If x is between min and max, return x directly. This is to ensure that dictionary values</span>
 14 |     | <span class='neutral'>        // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188</span>
 15 |     | <span class='neutral'>        if (x &gt;= min &amp;&amp; x &lt;= max) return x;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>        uint256 size = max - min + 1;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>        // If the value is 0, 1, 2, 3, warp that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.</span>
 20 |     | <span class='neutral'>        // This helps ensure coverage of the min/max values.</span>
 21 |     | <span class='neutral'>        if (x &lt;= 3 &amp;&amp; size &gt; x) return min + x;</span>
 22 |     | <span class='neutral'>        if (x &gt;= UINT256_MAX - 3 &amp;&amp; size &gt; UINT256_MAX - x) return max - (UINT256_MAX - x);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>        // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.</span>
 25 |     | <span class='neutral'>        if (x &gt; max) {</span>
 26 |     | <span class='neutral'>            uint256 diff = x - max;</span>
 27 |     | <span class='neutral'>            uint256 rem = diff % size;</span>
 28 |     | <span class='neutral'>            if (rem == 0) return max;</span>
 29 |     | <span class='neutral'>            result = min + rem - 1;</span>
 30 |     | <span class='neutral'>        } else if (x &lt; min) {</span>
 31 |     | <span class='neutral'>            uint256 diff = min - x;</span>
 32 |     | <span class='neutral'>            uint256 rem = diff % size;</span>
 33 |     | <span class='neutral'>            if (rem == 0) return min;</span>
 34 |     | <span class='neutral'>            result = max - rem + 1;</span>
 35 |     | <span class='neutral'>        }</span>
 36 |     | <span class='neutral'>    }</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='neutral'>    function bound(uint256 x, uint256 min, uint256 max) internal view virtual returns (uint256 result) {</span>
 39 |     | <span class='neutral'>        result = _bound(x, min, max);</span>
 40 |     | <span class='neutral'>        console2.log(&quot;Bound Result&quot;, result);</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce</span>
 44 |     | <span class='neutral'>    /// @notice adapated from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)</span>
 45 |     | <span class='neutral'>    function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {</span>
 46 |     | <span class='neutral'>        // forgefmt: disable-start</span>
 47 |     | <span class='neutral'>        // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.</span>
 48 |     | <span class='neutral'>        // A one byte integer uses its own value as its length prefix, there is no additional &quot;0x80 + length&quot; prefix that comes before it.</span>
 49 |     | <span class='neutral'>        if (nonce == 0x00)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80))));</span>
 50 |     | <span class='neutral'>        if (nonce &lt;= 0x7f)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce))));</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>        // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.</span>
 53 |     | <span class='neutral'>        if (nonce &lt;= 2**8 - 1)  return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))));</span>
 54 |     | <span class='neutral'>        if (nonce &lt;= 2**16 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))));</span>
 55 |     | <span class='neutral'>        if (nonce &lt;= 2**24 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))));</span>
 56 |     | <span class='neutral'>        // forgefmt: disable-end</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='neutral'>        // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp</span>
 59 |     | <span class='neutral'>        // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)</span>
 60 |     | <span class='neutral'>        // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)</span>
 61 |     | <span class='neutral'>        // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)</span>
 62 |     | <span class='neutral'>        // We assume nobody can have a nonce large enough to require more than 32 bytes.</span>
 63 |     | <span class='neutral'>        return addressFromLast20Bytes(</span>
 64 |     | <span class='neutral'>            keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce)))</span>
 65 |     | <span class='neutral'>        );</span>
 66 |     | <span class='neutral'>    }</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='neutral'>    function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)</span>
 69 |     | <span class='neutral'>        internal</span>
 70 |     | <span class='neutral'>        pure</span>
 71 |     | <span class='neutral'>        virtual</span>
 72 |     | <span class='neutral'>        returns (address)</span>
 73 |     | <span class='neutral'>    {</span>
 74 |     | <span class='neutral'>        return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, initcodeHash)));</span>
 75 |     | <span class='neutral'>    }</span>
 76 |     | <span class='neutral'></span>
 77 |     | <span class='neutral'>    function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {</span>
 78 |     | <span class='neutral'>        require(b.length &lt;= 32, &quot;StdUtils bytesToUint(bytes): Bytes length exceeds 32.&quot;);</span>
 79 |     | <span class='neutral'>        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));</span>
 80 |     | <span class='neutral'>    }</span>
 81 |     | <span class='neutral'></span>
 82 |     | <span class='neutral'>    function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {</span>
 83 |     | <span class='neutral'>        return address(uint160(uint256(bytesValue)));</span>
 84 |     | <span class='neutral'>    }</span>
 85 |     | <span class='neutral'>}</span>
 86 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/lib/forge-std/src/Test.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {CommonBase} from &quot;./Common.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;ds-test/test.sol&quot;;</span>
  6 |     | <span class='neutral'>// forgefmt: disable-next-line</span>
  7 |     | <span class='neutral'>import {console, console2, StdAssertions, StdCheats, stdError, stdJson, stdMath, StdStorage, stdStorage, StdUtils, Vm} from &quot;./Components.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>abstract contract TestBase is CommonBase {}</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>abstract contract Test is TestBase, DSTest, StdAssertions, StdCheats, StdUtils {}</span>
 12 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/lib/forge-std/src/Vm.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>// Cheatcodes are marked as view/pure/none using the following rules:</span>
   7 |     | <span class='neutral'>// 0. A call&#39;s observable behaviour includes its return value, logs, reverts and state writes.</span>
   8 |     | <span class='neutral'>// 1. If you can influence a later call&#39;s observable behaviour, you&#39;re neither `view` nor `pure` (you are modifying some state be it the EVM, interpreter, filesystem, etc),</span>
   9 |     | <span class='neutral'>// 2. Otherwise if you can be influenced by an earlier call, or if reading some state, you&#39;re `view`,</span>
  10 |     | <span class='neutral'>// 3. Otherwise you&#39;re `pure`.</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>interface VmSafe {</span>
  13 |     | <span class='neutral'>    struct Log {</span>
  14 |     | <span class='neutral'>        bytes32[] topics;</span>
  15 |     | <span class='neutral'>        bytes data;</span>
  16 |     | <span class='neutral'>        address emitter;</span>
  17 |     | <span class='neutral'>    }</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    struct Rpc {</span>
  20 |     | <span class='neutral'>        string name;</span>
  21 |     | <span class='neutral'>        string url;</span>
  22 |     | <span class='neutral'>    }</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    // Loads a storage slot from an address (who, slot)</span>
  25 |     | <span class='neutral'>    function load(address, bytes32) external view returns (bytes32);</span>
  26 |     | <span class='neutral'>    // Signs data, (privateKey, digest) =&gt; (v, r, s)</span>
  27 |     | <span class='neutral'>    function sign(uint256, bytes32) external pure returns (uint8, bytes32, bytes32);</span>
  28 |     | <span class='neutral'>    // Gets the address for a given private key, (privateKey) =&gt; (address)</span>
  29 |     | <span class='neutral'>    function addr(uint256) external pure returns (address);</span>
  30 |     | <span class='neutral'>    // Gets the nonce of an account</span>
  31 |     | <span class='neutral'>    function getNonce(address) external view returns (uint64);</span>
  32 |     | <span class='neutral'>    // Performs a foreign function call via the terminal, (stringInputs) =&gt; (result)</span>
  33 |     | <span class='neutral'>    function ffi(string[] calldata) external returns (bytes memory);</span>
  34 |     | <span class='neutral'>    // Sets environment variables, (name, value)</span>
  35 |     | <span class='neutral'>    function setEnv(string calldata, string calldata) external;</span>
  36 |     | <span class='neutral'>    // Reads environment variables, (name) =&gt; (value)</span>
  37 |     | <span class='neutral'>    function envBool(string calldata) external view returns (bool);</span>
  38 |     | <span class='neutral'>    function envUint(string calldata) external view returns (uint256);</span>
  39 |     | <span class='neutral'>    function envInt(string calldata) external view returns (int256);</span>
  40 |     | <span class='neutral'>    function envAddress(string calldata) external view returns (address);</span>
  41 |     | <span class='neutral'>    function envBytes32(string calldata) external view returns (bytes32);</span>
  42 |     | <span class='neutral'>    function envString(string calldata) external view returns (string memory);</span>
  43 |     | <span class='neutral'>    function envBytes(string calldata) external view returns (bytes memory);</span>
  44 |     | <span class='neutral'>    // Reads environment variables as arrays, (name, delim) =&gt; (value[])</span>
  45 |     | <span class='neutral'>    function envBool(string calldata, string calldata) external view returns (bool[] memory);</span>
  46 |     | <span class='neutral'>    function envUint(string calldata, string calldata) external view returns (uint256[] memory);</span>
  47 |     | <span class='neutral'>    function envInt(string calldata, string calldata) external view returns (int256[] memory);</span>
  48 |     | <span class='neutral'>    function envAddress(string calldata, string calldata) external view returns (address[] memory);</span>
  49 |     | <span class='neutral'>    function envBytes32(string calldata, string calldata) external view returns (bytes32[] memory);</span>
  50 |     | <span class='neutral'>    function envString(string calldata, string calldata) external view returns (string[] memory);</span>
  51 |     | <span class='neutral'>    function envBytes(string calldata, string calldata) external view returns (bytes[] memory);</span>
  52 |     | <span class='neutral'>    // Records all storage reads and writes</span>
  53 |     | <span class='neutral'>    function record() external;</span>
  54 |     | <span class='neutral'>    // Gets all accessed reads and write slot from a recording session, for a given address</span>
  55 |     | <span class='neutral'>    function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);</span>
  56 |     | <span class='neutral'>    // Gets the _creation_ bytecode from an artifact file. Takes in the relative path to the json file</span>
  57 |     | <span class='neutral'>    function getCode(string calldata) external view returns (bytes memory);</span>
  58 |     | <span class='neutral'>    // Gets the _deployed_ bytecode from an artifact file. Takes in the relative path to the json file</span>
  59 |     | <span class='neutral'>    function getDeployedCode(string calldata) external view returns (bytes memory);</span>
  60 |     | <span class='neutral'>    // Labels an address in call traces</span>
  61 |     | <span class='neutral'>    function label(address, string calldata) external;</span>
  62 |     | <span class='neutral'>    // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain</span>
  63 |     | <span class='neutral'>    function broadcast() external;</span>
  64 |     | <span class='neutral'>    // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain</span>
  65 |     | <span class='neutral'>    function broadcast(address) external;</span>
  66 |     | <span class='neutral'>    // Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain</span>
  67 |     | <span class='neutral'>    function broadcast(uint256) external;</span>
  68 |     | <span class='neutral'>    // Using the address that calls the test contract, has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain</span>
  69 |     | <span class='neutral'>    function startBroadcast() external;</span>
  70 |     | <span class='neutral'>    // Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain</span>
  71 |     | <span class='neutral'>    function startBroadcast(address) external;</span>
  72 |     | <span class='neutral'>    // Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain</span>
  73 |     | <span class='neutral'>    function startBroadcast(uint256) external;</span>
  74 |     | <span class='neutral'>    // Stops collecting onchain transactions</span>
  75 |     | <span class='neutral'>    function stopBroadcast() external;</span>
  76 |     | <span class='neutral'>    // Reads the entire content of file to string, (path) =&gt; (data)</span>
  77 |     | <span class='neutral'>    function readFile(string calldata) external view returns (string memory);</span>
  78 |     | <span class='neutral'>    // Reads the entire content of file as binary. Path is relative to the project root. (path) =&gt; (data)</span>
  79 |     | <span class='neutral'>    function readFileBinary(string calldata) external view returns (bytes memory);</span>
  80 |     | <span class='neutral'>    // Get the path of the current project root</span>
  81 |     | <span class='neutral'>    function projectRoot() external view returns (string memory);</span>
  82 |     | <span class='neutral'>    // Reads next line of file to string, (path) =&gt; (line)</span>
  83 |     | <span class='neutral'>    function readLine(string calldata) external view returns (string memory);</span>
  84 |     | <span class='neutral'>    // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.</span>
  85 |     | <span class='neutral'>    // (path, data) =&gt; ()</span>
  86 |     | <span class='neutral'>    function writeFile(string calldata, string calldata) external;</span>
  87 |     | <span class='neutral'>    // Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.</span>
  88 |     | <span class='neutral'>    // Path is relative to the project root. (path, data) =&gt; ()</span>
  89 |     | <span class='neutral'>    function writeFileBinary(string calldata, bytes calldata) external;</span>
  90 |     | <span class='neutral'>    // Writes line to file, creating a file if it does not exist.</span>
  91 |     | <span class='neutral'>    // (path, data) =&gt; ()</span>
  92 |     | <span class='neutral'>    function writeLine(string calldata, string calldata) external;</span>
  93 |     | <span class='neutral'>    // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.</span>
  94 |     | <span class='neutral'>    // (path) =&gt; ()</span>
  95 |     | <span class='neutral'>    function closeFile(string calldata) external;</span>
  96 |     | <span class='neutral'>    // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:</span>
  97 |     | <span class='neutral'>    // - Path points to a directory.</span>
  98 |     | <span class='neutral'>    // - The file doesn&#39;t exist.</span>
  99 |     | <span class='neutral'>    // - The user lacks permissions to remove the file.</span>
 100 |     | <span class='neutral'>    // (path) =&gt; ()</span>
 101 |     | <span class='neutral'>    function removeFile(string calldata) external;</span>
 102 |     | <span class='neutral'>    // Convert values to a string, (value) =&gt; (stringified value)</span>
 103 |     | <span class='neutral'>    function toString(address) external pure returns (string memory);</span>
 104 |     | <span class='neutral'>    function toString(bytes calldata) external pure returns (string memory);</span>
 105 |     | <span class='neutral'>    function toString(bytes32) external pure returns (string memory);</span>
 106 |     | <span class='neutral'>    function toString(bool) external pure returns (string memory);</span>
 107 |     | <span class='neutral'>    function toString(uint256) external pure returns (string memory);</span>
 108 |     | <span class='neutral'>    function toString(int256) external pure returns (string memory);</span>
 109 |     | <span class='neutral'>    // Convert values from a string, (string) =&gt; (parsed value)</span>
 110 |     | <span class='neutral'>    function parseBytes(string calldata) external pure returns (bytes memory);</span>
 111 |     | <span class='neutral'>    function parseAddress(string calldata) external pure returns (address);</span>
 112 |     | <span class='neutral'>    function parseUint(string calldata) external pure returns (uint256);</span>
 113 |     | <span class='neutral'>    function parseInt(string calldata) external pure returns (int256);</span>
 114 |     | <span class='neutral'>    function parseBytes32(string calldata) external pure returns (bytes32);</span>
 115 |     | <span class='neutral'>    function parseBool(string calldata) external pure returns (bool);</span>
 116 |     | <span class='neutral'>    // Record all the transaction logs</span>
 117 |     | <span class='neutral'>    function recordLogs() external;</span>
 118 |     | <span class='neutral'>    // Gets all the recorded logs, () =&gt; (logs)</span>
 119 |     | <span class='neutral'>    function getRecordedLogs() external returns (Log[] memory);</span>
 120 |     | <span class='neutral'>    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44&#39;/60&#39;/0&#39;/0/{index}</span>
 121 |     | <span class='neutral'>    function deriveKey(string calldata, uint32) external pure returns (uint256);</span>
 122 |     | <span class='neutral'>    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}</span>
 123 |     | <span class='neutral'>    function deriveKey(string calldata, string calldata, uint32) external pure returns (uint256);</span>
 124 |     | <span class='neutral'>    // Adds a private key to the local forge wallet and returns the address</span>
 125 |     | <span class='neutral'>    function rememberKey(uint256) external returns (address);</span>
 126 |     | <span class='neutral'>    //</span>
 127 |     | <span class='neutral'>    // parseJson</span>
 128 |     | <span class='neutral'>    //</span>
 129 |     | <span class='neutral'>    // ----</span>
 130 |     | <span class='neutral'>    // In case the returned value is a JSON object, it&#39;s encoded as a ABI-encoded tuple. As JSON objects</span>
 131 |     | <span class='neutral'>    // don&#39;t have the notion of ordered, but tuples do, they JSON object is encoded with it&#39;s fields ordered in</span>
 132 |     | <span class='neutral'>    // ALPHABETICAL ordser. That means that in order to succesfully decode the tuple, we need to define a tuple that</span>
 133 |     | <span class='neutral'>    // encodes the fields in the same order, which is alphabetical. In the case of Solidity structs, they are encoded</span>
 134 |     | <span class='neutral'>    // as tuples, with the attributes in the order in which they are defined.</span>
 135 |     | <span class='neutral'>    // For example: json = { &#39;a&#39;: 1, &#39;b&#39;: 0xa4tb......3xs}</span>
 136 |     | <span class='neutral'>    // a: uint256</span>
 137 |     | <span class='neutral'>    // b: address</span>
 138 |     | <span class='neutral'>    // To decode that json, we need to define a struct or a tuple as follows:</span>
 139 |     | <span class='neutral'>    // struct json = { uint256 a; address b; }</span>
 140 |     | <span class='neutral'>    // If we defined a json struct with the opposite order, meaning placing the address b first, it would try to</span>
 141 |     | <span class='neutral'>    // decode the tuple in that order, and thus fail.</span>
 142 |     | <span class='neutral'>    // ----</span>
 143 |     | <span class='neutral'>    // Given a string of JSON, return it as ABI-encoded, (stringified json, key) =&gt; (ABI-encoded data)</span>
 144 |     | <span class='neutral'>    function parseJson(string calldata, string calldata) external pure returns (bytes memory);</span>
 145 |     | <span class='neutral'>    function parseJson(string calldata) external pure returns (bytes memory);</span>
 146 |     | <span class='neutral'>    //</span>
 147 |     | <span class='neutral'>    // writeJson</span>
 148 |     | <span class='neutral'>    //</span>
 149 |     | <span class='neutral'>    // ----</span>
 150 |     | <span class='neutral'>    // Let&#39;s assume we want to write the following JSON to a file:</span>
 151 |     | <span class='neutral'>    //</span>
 152 |     | <span class='neutral'>    // { &quot;boolean&quot;: true, &quot;number&quot;: 342, &quot;object&quot;: { &quot;title&quot;: &quot;finally json serialization&quot; } }</span>
 153 |     | <span class='neutral'>    //</span>
 154 |     | <span class='neutral'>    // ```</span>
 155 |     | <span class='neutral'>    //  string memory json1 = &quot;some key&quot;;</span>
 156 |     | <span class='neutral'>    //  vm.serializeBool(json1, &quot;boolean&quot;, true);</span>
 157 |     | <span class='neutral'>    //  vm.serializeBool(json1, &quot;number&quot;, uint256(342));</span>
 158 |     | <span class='neutral'>    //  json2 = &quot;some other key&quot;;</span>
 159 |     | <span class='neutral'>    //  string memory output = vm.serializeString(json2, &quot;title&quot;, &quot;finally json serialization&quot;);</span>
 160 |     | <span class='neutral'>    //  string memory finalJson = vm.serialize(json1, &quot;object&quot;, output);</span>
 161 |     | <span class='neutral'>    //  vm.writeJson(finalJson, &quot;./output/example.json&quot;);</span>
 162 |     | <span class='neutral'>    // ```</span>
 163 |     | <span class='neutral'>    //  The critical insight is that every invocation of serialization will return the stringified version of the JSON</span>
 164 |     | <span class='neutral'>    // up to that point. That means we can construct arbitrary JSON objects and then use the return stringified version</span>
 165 |     | <span class='neutral'>    // to serialize them as values to another JSON object.</span>
 166 |     | <span class='neutral'>    //</span>
 167 |     | <span class='neutral'>    //  json1 and json2 are simply keys used by the backend to keep track of the objects. So vm.serializeJson(json1,..)</span>
 168 |     | <span class='neutral'>    //  will find the object in-memory that is keyed by &quot;some key&quot;.   // writeJson</span>
 169 |     | <span class='neutral'>    // ----</span>
 170 |     | <span class='neutral'>    // Serialize a key and value to a JSON object stored in-memory that can be latery written to a file</span>
 171 |     | <span class='neutral'>    // It returns the stringified version of the specific JSON file up to that moment.</span>
 172 |     | <span class='neutral'>    // (object_key, value_key, value) =&gt; (stringified JSON)</span>
 173 |     | <span class='neutral'>    function serializeBool(string calldata, string calldata, bool) external returns (string memory);</span>
 174 |     | <span class='neutral'>    function serializeUint(string calldata, string calldata, uint256) external returns (string memory);</span>
 175 |     | <span class='neutral'>    function serializeInt(string calldata, string calldata, int256) external returns (string memory);</span>
 176 |     | <span class='neutral'>    function serializeAddress(string calldata, string calldata, address) external returns (string memory);</span>
 177 |     | <span class='neutral'>    function serializeBytes32(string calldata, string calldata, bytes32) external returns (string memory);</span>
 178 |     | <span class='neutral'>    function serializeString(string calldata, string calldata, string calldata) external returns (string memory);</span>
 179 |     | <span class='neutral'>    function serializeBytes(string calldata, string calldata, bytes calldata) external returns (string memory);</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='neutral'>    function serializeBool(string calldata, string calldata, bool[] calldata) external returns (string memory);</span>
 182 |     | <span class='neutral'>    function serializeUint(string calldata, string calldata, uint256[] calldata) external returns (string memory);</span>
 183 |     | <span class='neutral'>    function serializeInt(string calldata, string calldata, int256[] calldata) external returns (string memory);</span>
 184 |     | <span class='neutral'>    function serializeAddress(string calldata, string calldata, address[] calldata) external returns (string memory);</span>
 185 |     | <span class='neutral'>    function serializeBytes32(string calldata, string calldata, bytes32[] calldata) external returns (string memory);</span>
 186 |     | <span class='neutral'>    function serializeString(string calldata, string calldata, string[] calldata) external returns (string memory);</span>
 187 |     | <span class='neutral'>    function serializeBytes(string calldata, string calldata, bytes[] calldata) external returns (string memory);</span>
 188 |     | <span class='neutral'>    // Write a serialized JSON object to a file. If the file exists, it will be overwritten.</span>
 189 |     | <span class='neutral'>    // (stringified_json, path)</span>
 190 |     | <span class='neutral'>    function writeJson(string calldata, string calldata) external;</span>
 191 |     | <span class='neutral'>    // Write a serialized JSON object to an **existing** JSON file, replacing a value with key = &lt;value_key&gt;</span>
 192 |     | <span class='neutral'>    // This is useful to replace a specific value of a JSON file, without having to parse the entire thing</span>
 193 |     | <span class='neutral'>    // (stringified_json, path, value_key)</span>
 194 |     | <span class='neutral'>    function writeJson(string calldata, string calldata, string calldata) external;</span>
 195 |     | <span class='neutral'>    // Returns the RPC url for the given alias</span>
 196 |     | <span class='neutral'>    function rpcUrl(string calldata) external view returns (string memory);</span>
 197 |     | <span class='neutral'>    // Returns all rpc urls and their aliases `[alias, url][]`</span>
 198 |     | <span class='neutral'>    function rpcUrls() external view returns (string[2][] memory);</span>
 199 |     | <span class='neutral'>    // Returns all rpc urls and their aliases as structs.</span>
 200 |     | <span class='neutral'>    function rpcUrlStructs() external view returns (Rpc[] memory);</span>
 201 |     | <span class='neutral'>    // If the condition is false, discard this run&#39;s fuzz inputs and generate new ones.</span>
 202 |     | <span class='neutral'>    function assume(bool) external pure;</span>
 203 |     | <span class='neutral'>}</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='neutral'>interface Vm is VmSafe {</span>
 206 |     | <span class='neutral'>    // Sets block.timestamp (newTimestamp)</span>
 207 |     | <span class='neutral'>    function warp(uint256) external;</span>
 208 |     | <span class='neutral'>    // Sets block.height (newHeight)</span>
 209 |     | <span class='neutral'>    function roll(uint256) external;</span>
 210 |     | <span class='neutral'>    // Sets block.basefee (newBasefee)</span>
 211 |     | <span class='neutral'>    function fee(uint256) external;</span>
 212 |     | <span class='neutral'>    // Sets block.difficulty (newDifficulty)</span>
 213 |     | <span class='neutral'>    function difficulty(uint256) external;</span>
 214 |     | <span class='neutral'>    // Sets block.chainid</span>
 215 |     | <span class='neutral'>    function chainId(uint256) external;</span>
 216 |     | <span class='neutral'>    // Stores a value to an address&#39; storage slot, (who, slot, value)</span>
 217 |     | <span class='neutral'>    function store(address, bytes32, bytes32) external;</span>
 218 |     | <span class='neutral'>    // Sets the nonce of an account; must be higher than the current nonce of the account</span>
 219 |     | <span class='neutral'>    function setNonce(address, uint64) external;</span>
 220 |     | <span class='neutral'>    // Sets the *next* call&#39;s msg.sender to be the input address</span>
 221 |     | <span class='neutral'>    function prank(address) external;</span>
 222 |     | <span class='neutral'>    // Sets all subsequent calls&#39; msg.sender to be the input address until `stopPrank` is called</span>
 223 |     | <span class='neutral'>    function startPrank(address) external;</span>
 224 |     | <span class='neutral'>    // Sets the *next* call&#39;s msg.sender to be the input address, and the tx.origin to be the second input</span>
 225 |     | <span class='neutral'>    function prank(address, address) external;</span>
 226 |     | <span class='neutral'>    // Sets all subsequent calls&#39; msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input</span>
 227 |     | <span class='neutral'>    function startPrank(address, address) external;</span>
 228 |     | <span class='neutral'>    // Resets subsequent calls&#39; msg.sender to be `address(this)`</span>
 229 |     | <span class='neutral'>    function stopPrank() external;</span>
 230 |     | <span class='neutral'>    // Sets an address&#39; balance, (who, newBalance)</span>
 231 |     | <span class='neutral'>    function deal(address, uint256) external;</span>
 232 |     | <span class='neutral'>    // Sets an address&#39; code, (who, newCode)</span>
 233 |     | <span class='neutral'>    function etch(address, bytes calldata) external;</span>
 234 |     | <span class='neutral'>    // Expects an error on next call</span>
 235 |     | <span class='neutral'>    function expectRevert(bytes calldata) external;</span>
 236 |     | <span class='neutral'>    function expectRevert(bytes4) external;</span>
 237 |     | <span class='neutral'>    function expectRevert() external;</span>
 238 |     | <span class='neutral'>    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).</span>
 239 |     | <span class='neutral'>    // Call this function, then emit an event, then call a function. Internally after the call, we check if</span>
 240 |     | <span class='neutral'>    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans)</span>
 241 |     | <span class='neutral'>    function expectEmit(bool, bool, bool, bool) external;</span>
 242 |     | <span class='neutral'>    function expectEmit(bool, bool, bool, bool, address) external;</span>
 243 |     | <span class='neutral'>    // Mocks a call to an address, returning specified data.</span>
 244 |     | <span class='neutral'>    // Calldata can either be strict or a partial match, e.g. if you only</span>
 245 |     | <span class='neutral'>    // pass a Solidity selector to the expected calldata, then the entire Solidity</span>
 246 |     | <span class='neutral'>    // function will be mocked.</span>
 247 |     | <span class='neutral'>    function mockCall(address, bytes calldata, bytes calldata) external;</span>
 248 |     | <span class='neutral'>    // Mocks a call to an address with a specific msg.value, returning specified data.</span>
 249 |     | <span class='neutral'>    // Calldata match takes precedence over msg.value in case of ambiguity.</span>
 250 |     | <span class='neutral'>    function mockCall(address, uint256, bytes calldata, bytes calldata) external;</span>
 251 |     | <span class='neutral'>    // Clears all mocked calls</span>
 252 |     | <span class='neutral'>    function clearMockedCalls() external;</span>
 253 |     | <span class='neutral'>    // Expects a call to an address with the specified calldata.</span>
 254 |     | <span class='neutral'>    // Calldata can either be a strict or a partial match</span>
 255 |     | <span class='neutral'>    function expectCall(address, bytes calldata) external;</span>
 256 |     | <span class='neutral'>    // Expects a call to an address with the specified msg.value and calldata</span>
 257 |     | <span class='neutral'>    function expectCall(address, uint256, bytes calldata) external;</span>
 258 |     | <span class='neutral'>    // Sets block.coinbase (who)</span>
 259 |     | <span class='neutral'>    function coinbase(address) external;</span>
 260 |     | <span class='neutral'>    // Snapshot the current state of the evm.</span>
 261 |     | <span class='neutral'>    // Returns the id of the snapshot that was created.</span>
 262 |     | <span class='neutral'>    // To revert a snapshot use `revertTo`</span>
 263 |     | <span class='neutral'>    function snapshot() external returns (uint256);</span>
 264 |     | <span class='neutral'>    // Revert the state of the evm to a previous snapshot</span>
 265 |     | <span class='neutral'>    // Takes the snapshot id to revert to.</span>
 266 |     | <span class='neutral'>    // This deletes the snapshot and all snapshots taken after the given snapshot id.</span>
 267 |     | <span class='neutral'>    function revertTo(uint256) external returns (bool);</span>
 268 |     | <span class='neutral'>    // Creates a new fork with the given endpoint and block and returns the identifier of the fork</span>
 269 |     | <span class='neutral'>    function createFork(string calldata, uint256) external returns (uint256);</span>
 270 |     | <span class='neutral'>    // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork</span>
 271 |     | <span class='neutral'>    function createFork(string calldata) external returns (uint256);</span>
 272 |     | <span class='neutral'>    // Creates a new fork with the given endpoint and at the block the given transaction was mined in, and replays all transaction mined in the block before the transaction</span>
 273 |     | <span class='neutral'>    function createFork(string calldata, bytes32) external returns (uint256);</span>
 274 |     | <span class='neutral'>    // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork</span>
 275 |     | <span class='neutral'>    function createSelectFork(string calldata, uint256) external returns (uint256);</span>
 276 |     | <span class='neutral'>    // Creates _and_ also selects new fork with the given endpoint and at the block the given transaction was mined in, and replays all transaction mined in the block before the transaction</span>
 277 |     | <span class='neutral'>    function createSelectFork(string calldata, bytes32) external returns (uint256);</span>
 278 |     | <span class='neutral'>    // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork</span>
 279 |     | <span class='neutral'>    function createSelectFork(string calldata) external returns (uint256);</span>
 280 |     | <span class='neutral'>    // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.</span>
 281 |     | <span class='neutral'>    function selectFork(uint256) external;</span>
 282 |     | <span class='neutral'>    /// Returns the currently active fork</span>
 283 |     | <span class='neutral'>    /// Reverts if no fork is currently active</span>
 284 |     | <span class='neutral'>    function activeFork() external view returns (uint256);</span>
 285 |     | <span class='neutral'>    // Updates the currently active fork to given block number</span>
 286 |     | <span class='neutral'>    // This is similar to `roll` but for the currently active fork</span>
 287 |     | <span class='neutral'>    function rollFork(uint256) external;</span>
 288 |     | <span class='neutral'>    // Updates the currently active fork to given transaction</span>
 289 |     | <span class='neutral'>    // this will `rollFork` with the number of the block the transaction was mined in and replays all transaction mined before it in the block</span>
 290 |     | <span class='neutral'>    function rollFork(bytes32) external;</span>
 291 |     | <span class='neutral'>    // Updates the given fork to given block number</span>
 292 |     | <span class='neutral'>    function rollFork(uint256 forkId, uint256 blockNumber) external;</span>
 293 |     | <span class='neutral'>    // Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block</span>
 294 |     | <span class='neutral'>    function rollFork(uint256 forkId, bytes32 transaction) external;</span>
 295 |     | <span class='neutral'>    // Marks that the account(s) should use persistent storage across fork swaps in a multifork setup</span>
 296 |     | <span class='neutral'>    // Meaning, changes made to the state of this account will be kept when switching forks</span>
 297 |     | <span class='neutral'>    function makePersistent(address) external;</span>
 298 |     | <span class='neutral'>    function makePersistent(address, address) external;</span>
 299 |     | <span class='neutral'>    function makePersistent(address, address, address) external;</span>
 300 |     | <span class='neutral'>    function makePersistent(address[] calldata) external;</span>
 301 |     | <span class='neutral'>    // Revokes persistent status from the address, previously added via `makePersistent`</span>
 302 |     | <span class='neutral'>    function revokePersistent(address) external;</span>
 303 |     | <span class='neutral'>    function revokePersistent(address[] calldata) external;</span>
 304 |     | <span class='neutral'>    // Returns true if the account is marked as persistent</span>
 305 |     | <span class='neutral'>    function isPersistent(address) external view returns (bool);</span>
 306 |     | <span class='neutral'>    // In forking mode, explicitly grant the given address cheatcode access</span>
 307 |     | <span class='neutral'>    function allowCheatcodes(address) external;</span>
 308 |     | <span class='neutral'>    // Fetches the given transaction from the active fork and executes it on the current state</span>
 309 |     | <span class='neutral'>    function transact(bytes32 txHash) external;</span>
 310 |     | <span class='neutral'>    // Fetches the given transaction from the given fork and executes it on the current state</span>
 311 |     | <span class='neutral'>    function transact(uint256 forkId, bytes32 txHash) external;</span>
 312 |     | <span class='neutral'>}</span>
 313 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/lib/forge-std/src/console.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
    2 |     | <span class='neutral'>pragma solidity &gt;=0.4.22 &lt;0.9.0;</span>
    3 |     | <span class='neutral'></span>
    4 |     | <span class='neutral'>library console {</span>
    5 |     | <span class='neutral'>    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);</span>
    6 |     | <span class='neutral'></span>
    7 |     | <span class='neutral'>    function _sendLogPayload(bytes memory payload) private view {</span>
    8 |     | <span class='unexecuted'>        uint256 payloadLength = payload.length;</span>
    9 |     | <span class='neutral'>        address consoleAddress = CONSOLE_ADDRESS;</span>
   10 |     | <span class='unexecuted'>        /// @solidity memory-safe-assembly</span>
   11 |     | <span class='neutral'>        assembly {</span>
   12 |     | <span class='neutral'>            let payloadStart := add(payload, 32)</span>
   13 |     | <span class='neutral'>            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)</span>
   14 |     | <span class='neutral'>        }</span>
   15 |     | <span class='neutral'>    }</span>
   16 |     | <span class='neutral'></span>
   17 |     | <span class='neutral'>    function log() internal view {</span>
   18 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log()&quot;));</span>
   19 |     | <span class='neutral'>    }</span>
   20 |     | <span class='neutral'></span>
   21 |     | <span class='neutral'>    function logInt(int p0) internal view {</span>
   22 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(int)&quot;, p0));</span>
   23 |     | <span class='neutral'>    }</span>
   24 |     | <span class='neutral'></span>
   25 |     | <span class='neutral'>    function logUint(uint p0) internal view {</span>
   26 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint)&quot;, p0));</span>
   27 |     | <span class='neutral'>    }</span>
   28 |     | <span class='neutral'></span>
   29 |     | <span class='neutral'>    function logString(string memory p0) internal view {</span>
   30 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
   31 |     | <span class='neutral'>    }</span>
   32 |     | <span class='neutral'></span>
   33 |     | <span class='neutral'>    function logBool(bool p0) internal view {</span>
   34 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
   35 |     | <span class='neutral'>    }</span>
   36 |     | <span class='neutral'></span>
   37 |     | <span class='neutral'>    function logAddress(address p0) internal view {</span>
   38 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
   39 |     | <span class='neutral'>    }</span>
   40 |     | <span class='neutral'></span>
   41 |     | <span class='neutral'>    function logBytes(bytes memory p0) internal view {</span>
   42 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes)&quot;, p0));</span>
   43 |     | <span class='neutral'>    }</span>
   44 |     | <span class='neutral'></span>
   45 |     | <span class='neutral'>    function logBytes1(bytes1 p0) internal view {</span>
   46 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes1)&quot;, p0));</span>
   47 |     | <span class='neutral'>    }</span>
   48 |     | <span class='neutral'></span>
   49 |     | <span class='neutral'>    function logBytes2(bytes2 p0) internal view {</span>
   50 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes2)&quot;, p0));</span>
   51 |     | <span class='neutral'>    }</span>
   52 |     | <span class='neutral'></span>
   53 |     | <span class='neutral'>    function logBytes3(bytes3 p0) internal view {</span>
   54 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes3)&quot;, p0));</span>
   55 |     | <span class='neutral'>    }</span>
   56 |     | <span class='neutral'></span>
   57 |     | <span class='neutral'>    function logBytes4(bytes4 p0) internal view {</span>
   58 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes4)&quot;, p0));</span>
   59 |     | <span class='neutral'>    }</span>
   60 |     | <span class='neutral'></span>
   61 |     | <span class='neutral'>    function logBytes5(bytes5 p0) internal view {</span>
   62 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes5)&quot;, p0));</span>
   63 |     | <span class='neutral'>    }</span>
   64 |     | <span class='neutral'></span>
   65 |     | <span class='neutral'>    function logBytes6(bytes6 p0) internal view {</span>
   66 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes6)&quot;, p0));</span>
   67 |     | <span class='neutral'>    }</span>
   68 |     | <span class='neutral'></span>
   69 |     | <span class='neutral'>    function logBytes7(bytes7 p0) internal view {</span>
   70 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes7)&quot;, p0));</span>
   71 |     | <span class='neutral'>    }</span>
   72 |     | <span class='neutral'></span>
   73 |     | <span class='neutral'>    function logBytes8(bytes8 p0) internal view {</span>
   74 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes8)&quot;, p0));</span>
   75 |     | <span class='neutral'>    }</span>
   76 |     | <span class='neutral'></span>
   77 |     | <span class='neutral'>    function logBytes9(bytes9 p0) internal view {</span>
   78 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes9)&quot;, p0));</span>
   79 |     | <span class='neutral'>    }</span>
   80 |     | <span class='neutral'></span>
   81 |     | <span class='neutral'>    function logBytes10(bytes10 p0) internal view {</span>
   82 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes10)&quot;, p0));</span>
   83 |     | <span class='neutral'>    }</span>
   84 |     | <span class='neutral'></span>
   85 |     | <span class='neutral'>    function logBytes11(bytes11 p0) internal view {</span>
   86 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes11)&quot;, p0));</span>
   87 |     | <span class='neutral'>    }</span>
   88 |     | <span class='neutral'></span>
   89 |     | <span class='neutral'>    function logBytes12(bytes12 p0) internal view {</span>
   90 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes12)&quot;, p0));</span>
   91 |     | <span class='neutral'>    }</span>
   92 |     | <span class='neutral'></span>
   93 |     | <span class='neutral'>    function logBytes13(bytes13 p0) internal view {</span>
   94 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes13)&quot;, p0));</span>
   95 |     | <span class='neutral'>    }</span>
   96 |     | <span class='neutral'></span>
   97 |     | <span class='neutral'>    function logBytes14(bytes14 p0) internal view {</span>
   98 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes14)&quot;, p0));</span>
   99 |     | <span class='neutral'>    }</span>
  100 |     | <span class='neutral'></span>
  101 |     | <span class='neutral'>    function logBytes15(bytes15 p0) internal view {</span>
  102 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes15)&quot;, p0));</span>
  103 |     | <span class='neutral'>    }</span>
  104 |     | <span class='neutral'></span>
  105 |     | <span class='neutral'>    function logBytes16(bytes16 p0) internal view {</span>
  106 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes16)&quot;, p0));</span>
  107 |     | <span class='neutral'>    }</span>
  108 |     | <span class='neutral'></span>
  109 |     | <span class='neutral'>    function logBytes17(bytes17 p0) internal view {</span>
  110 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes17)&quot;, p0));</span>
  111 |     | <span class='neutral'>    }</span>
  112 |     | <span class='neutral'></span>
  113 |     | <span class='neutral'>    function logBytes18(bytes18 p0) internal view {</span>
  114 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes18)&quot;, p0));</span>
  115 |     | <span class='neutral'>    }</span>
  116 |     | <span class='neutral'></span>
  117 |     | <span class='neutral'>    function logBytes19(bytes19 p0) internal view {</span>
  118 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes19)&quot;, p0));</span>
  119 |     | <span class='neutral'>    }</span>
  120 |     | <span class='neutral'></span>
  121 |     | <span class='neutral'>    function logBytes20(bytes20 p0) internal view {</span>
  122 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes20)&quot;, p0));</span>
  123 |     | <span class='neutral'>    }</span>
  124 |     | <span class='neutral'></span>
  125 |     | <span class='neutral'>    function logBytes21(bytes21 p0) internal view {</span>
  126 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes21)&quot;, p0));</span>
  127 |     | <span class='neutral'>    }</span>
  128 |     | <span class='neutral'></span>
  129 |     | <span class='neutral'>    function logBytes22(bytes22 p0) internal view {</span>
  130 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes22)&quot;, p0));</span>
  131 |     | <span class='neutral'>    }</span>
  132 |     | <span class='neutral'></span>
  133 |     | <span class='neutral'>    function logBytes23(bytes23 p0) internal view {</span>
  134 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes23)&quot;, p0));</span>
  135 |     | <span class='neutral'>    }</span>
  136 |     | <span class='neutral'></span>
  137 |     | <span class='neutral'>    function logBytes24(bytes24 p0) internal view {</span>
  138 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes24)&quot;, p0));</span>
  139 |     | <span class='neutral'>    }</span>
  140 |     | <span class='neutral'></span>
  141 |     | <span class='neutral'>    function logBytes25(bytes25 p0) internal view {</span>
  142 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes25)&quot;, p0));</span>
  143 |     | <span class='neutral'>    }</span>
  144 |     | <span class='neutral'></span>
  145 |     | <span class='neutral'>    function logBytes26(bytes26 p0) internal view {</span>
  146 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes26)&quot;, p0));</span>
  147 |     | <span class='neutral'>    }</span>
  148 |     | <span class='neutral'></span>
  149 |     | <span class='neutral'>    function logBytes27(bytes27 p0) internal view {</span>
  150 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes27)&quot;, p0));</span>
  151 |     | <span class='neutral'>    }</span>
  152 |     | <span class='neutral'></span>
  153 |     | <span class='neutral'>    function logBytes28(bytes28 p0) internal view {</span>
  154 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes28)&quot;, p0));</span>
  155 |     | <span class='neutral'>    }</span>
  156 |     | <span class='neutral'></span>
  157 |     | <span class='neutral'>    function logBytes29(bytes29 p0) internal view {</span>
  158 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes29)&quot;, p0));</span>
  159 |     | <span class='neutral'>    }</span>
  160 |     | <span class='neutral'></span>
  161 |     | <span class='neutral'>    function logBytes30(bytes30 p0) internal view {</span>
  162 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes30)&quot;, p0));</span>
  163 |     | <span class='neutral'>    }</span>
  164 |     | <span class='neutral'></span>
  165 |     | <span class='neutral'>    function logBytes31(bytes31 p0) internal view {</span>
  166 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes31)&quot;, p0));</span>
  167 |     | <span class='neutral'>    }</span>
  168 |     | <span class='neutral'></span>
  169 |     | <span class='neutral'>    function logBytes32(bytes32 p0) internal view {</span>
  170 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes32)&quot;, p0));</span>
  171 |     | <span class='neutral'>    }</span>
  172 |     | <span class='neutral'></span>
  173 |     | <span class='neutral'>    function log(uint p0) internal view {</span>
  174 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint)&quot;, p0));</span>
  175 |     | <span class='neutral'>    }</span>
  176 |     | <span class='neutral'></span>
  177 |     | <span class='neutral'>    function log(string memory p0) internal view {</span>
  178 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
  179 |     | <span class='neutral'>    }</span>
  180 |     | <span class='neutral'></span>
  181 |     | <span class='neutral'>    function log(bool p0) internal view {</span>
  182 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
  183 |     | <span class='neutral'>    }</span>
  184 |     | <span class='neutral'></span>
  185 |     | <span class='neutral'>    function log(address p0) internal view {</span>
  186 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
  187 |     | <span class='neutral'>    }</span>
  188 |     | <span class='neutral'></span>
  189 |     | <span class='neutral'>    function log(uint p0, uint p1) internal view {</span>
  190 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint)&quot;, p0, p1));</span>
  191 |     | <span class='neutral'>    }</span>
  192 |     | <span class='neutral'></span>
  193 |     | <span class='neutral'>    function log(uint p0, string memory p1) internal view {</span>
  194 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string)&quot;, p0, p1));</span>
  195 |     | <span class='neutral'>    }</span>
  196 |     | <span class='neutral'></span>
  197 |     | <span class='neutral'>    function log(uint p0, bool p1) internal view {</span>
  198 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool)&quot;, p0, p1));</span>
  199 |     | <span class='neutral'>    }</span>
  200 |     | <span class='neutral'></span>
  201 |     | <span class='neutral'>    function log(uint p0, address p1) internal view {</span>
  202 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address)&quot;, p0, p1));</span>
  203 |     | <span class='neutral'>    }</span>
  204 |     | <span class='neutral'></span>
  205 |     | <span class='neutral'>    function log(string memory p0, uint p1) internal view {</span>
  206 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint)&quot;, p0, p1));</span>
  207 |     | <span class='neutral'>    }</span>
  208 |     | <span class='neutral'></span>
  209 |     | <span class='neutral'>    function log(string memory p0, string memory p1) internal view {</span>
  210 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string)&quot;, p0, p1));</span>
  211 |     | <span class='neutral'>    }</span>
  212 |     | <span class='neutral'></span>
  213 |     | <span class='neutral'>    function log(string memory p0, bool p1) internal view {</span>
  214 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool)&quot;, p0, p1));</span>
  215 |     | <span class='neutral'>    }</span>
  216 |     | <span class='neutral'></span>
  217 |     | <span class='neutral'>    function log(string memory p0, address p1) internal view {</span>
  218 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address)&quot;, p0, p1));</span>
  219 |     | <span class='neutral'>    }</span>
  220 |     | <span class='neutral'></span>
  221 |     | <span class='neutral'>    function log(bool p0, uint p1) internal view {</span>
  222 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint)&quot;, p0, p1));</span>
  223 |     | <span class='neutral'>    }</span>
  224 |     | <span class='neutral'></span>
  225 |     | <span class='neutral'>    function log(bool p0, string memory p1) internal view {</span>
  226 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string)&quot;, p0, p1));</span>
  227 |     | <span class='neutral'>    }</span>
  228 |     | <span class='neutral'></span>
  229 |     | <span class='neutral'>    function log(bool p0, bool p1) internal view {</span>
  230 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool)&quot;, p0, p1));</span>
  231 |     | <span class='neutral'>    }</span>
  232 |     | <span class='neutral'></span>
  233 |     | <span class='neutral'>    function log(bool p0, address p1) internal view {</span>
  234 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address)&quot;, p0, p1));</span>
  235 |     | <span class='neutral'>    }</span>
  236 |     | <span class='neutral'></span>
  237 |     | <span class='neutral'>    function log(address p0, uint p1) internal view {</span>
  238 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint)&quot;, p0, p1));</span>
  239 |     | <span class='neutral'>    }</span>
  240 |     | <span class='neutral'></span>
  241 |     | <span class='neutral'>    function log(address p0, string memory p1) internal view {</span>
  242 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string)&quot;, p0, p1));</span>
  243 |     | <span class='neutral'>    }</span>
  244 |     | <span class='neutral'></span>
  245 |     | <span class='neutral'>    function log(address p0, bool p1) internal view {</span>
  246 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool)&quot;, p0, p1));</span>
  247 |     | <span class='neutral'>    }</span>
  248 |     | <span class='neutral'></span>
  249 |     | <span class='neutral'>    function log(address p0, address p1) internal view {</span>
  250 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address)&quot;, p0, p1));</span>
  251 |     | <span class='neutral'>    }</span>
  252 |     | <span class='neutral'></span>
  253 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2) internal view {</span>
  254 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint)&quot;, p0, p1, p2));</span>
  255 |     | <span class='neutral'>    }</span>
  256 |     | <span class='neutral'></span>
  257 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2) internal view {</span>
  258 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string)&quot;, p0, p1, p2));</span>
  259 |     | <span class='neutral'>    }</span>
  260 |     | <span class='neutral'></span>
  261 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2) internal view {</span>
  262 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool)&quot;, p0, p1, p2));</span>
  263 |     | <span class='neutral'>    }</span>
  264 |     | <span class='neutral'></span>
  265 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2) internal view {</span>
  266 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address)&quot;, p0, p1, p2));</span>
  267 |     | <span class='neutral'>    }</span>
  268 |     | <span class='neutral'></span>
  269 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2) internal view {</span>
  270 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint)&quot;, p0, p1, p2));</span>
  271 |     | <span class='neutral'>    }</span>
  272 |     | <span class='neutral'></span>
  273 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2) internal view {</span>
  274 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string)&quot;, p0, p1, p2));</span>
  275 |     | <span class='neutral'>    }</span>
  276 |     | <span class='neutral'></span>
  277 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2) internal view {</span>
  278 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool)&quot;, p0, p1, p2));</span>
  279 |     | <span class='neutral'>    }</span>
  280 |     | <span class='neutral'></span>
  281 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2) internal view {</span>
  282 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address)&quot;, p0, p1, p2));</span>
  283 |     | <span class='neutral'>    }</span>
  284 |     | <span class='neutral'></span>
  285 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2) internal view {</span>
  286 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint)&quot;, p0, p1, p2));</span>
  287 |     | <span class='neutral'>    }</span>
  288 |     | <span class='neutral'></span>
  289 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2) internal view {</span>
  290 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string)&quot;, p0, p1, p2));</span>
  291 |     | <span class='neutral'>    }</span>
  292 |     | <span class='neutral'></span>
  293 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2) internal view {</span>
  294 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool)&quot;, p0, p1, p2));</span>
  295 |     | <span class='neutral'>    }</span>
  296 |     | <span class='neutral'></span>
  297 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2) internal view {</span>
  298 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address)&quot;, p0, p1, p2));</span>
  299 |     | <span class='neutral'>    }</span>
  300 |     | <span class='neutral'></span>
  301 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2) internal view {</span>
  302 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint)&quot;, p0, p1, p2));</span>
  303 |     | <span class='neutral'>    }</span>
  304 |     | <span class='neutral'></span>
  305 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2) internal view {</span>
  306 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string)&quot;, p0, p1, p2));</span>
  307 |     | <span class='neutral'>    }</span>
  308 |     | <span class='neutral'></span>
  309 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2) internal view {</span>
  310 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool)&quot;, p0, p1, p2));</span>
  311 |     | <span class='neutral'>    }</span>
  312 |     | <span class='neutral'></span>
  313 |     | <span class='neutral'>    function log(uint p0, address p1, address p2) internal view {</span>
  314 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address)&quot;, p0, p1, p2));</span>
  315 |     | <span class='neutral'>    }</span>
  316 |     | <span class='neutral'></span>
  317 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2) internal view {</span>
  318 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint)&quot;, p0, p1, p2));</span>
  319 |     | <span class='neutral'>    }</span>
  320 |     | <span class='neutral'></span>
  321 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2) internal view {</span>
  322 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string)&quot;, p0, p1, p2));</span>
  323 |     | <span class='neutral'>    }</span>
  324 |     | <span class='neutral'></span>
  325 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2) internal view {</span>
  326 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool)&quot;, p0, p1, p2));</span>
  327 |     | <span class='neutral'>    }</span>
  328 |     | <span class='neutral'></span>
  329 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2) internal view {</span>
  330 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address)&quot;, p0, p1, p2));</span>
  331 |     | <span class='neutral'>    }</span>
  332 |     | <span class='neutral'></span>
  333 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2) internal view {</span>
  334 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint)&quot;, p0, p1, p2));</span>
  335 |     | <span class='neutral'>    }</span>
  336 |     | <span class='neutral'></span>
  337 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2) internal view {</span>
  338 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string)&quot;, p0, p1, p2));</span>
  339 |     | <span class='neutral'>    }</span>
  340 |     | <span class='neutral'></span>
  341 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2) internal view {</span>
  342 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool)&quot;, p0, p1, p2));</span>
  343 |     | <span class='neutral'>    }</span>
  344 |     | <span class='neutral'></span>
  345 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2) internal view {</span>
  346 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address)&quot;, p0, p1, p2));</span>
  347 |     | <span class='neutral'>    }</span>
  348 |     | <span class='neutral'></span>
  349 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2) internal view {</span>
  350 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint)&quot;, p0, p1, p2));</span>
  351 |     | <span class='neutral'>    }</span>
  352 |     | <span class='neutral'></span>
  353 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2) internal view {</span>
  354 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string)&quot;, p0, p1, p2));</span>
  355 |     | <span class='neutral'>    }</span>
  356 |     | <span class='neutral'></span>
  357 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2) internal view {</span>
  358 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool)&quot;, p0, p1, p2));</span>
  359 |     | <span class='neutral'>    }</span>
  360 |     | <span class='neutral'></span>
  361 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2) internal view {</span>
  362 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address)&quot;, p0, p1, p2));</span>
  363 |     | <span class='neutral'>    }</span>
  364 |     | <span class='neutral'></span>
  365 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2) internal view {</span>
  366 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint)&quot;, p0, p1, p2));</span>
  367 |     | <span class='neutral'>    }</span>
  368 |     | <span class='neutral'></span>
  369 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2) internal view {</span>
  370 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string)&quot;, p0, p1, p2));</span>
  371 |     | <span class='neutral'>    }</span>
  372 |     | <span class='neutral'></span>
  373 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2) internal view {</span>
  374 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool)&quot;, p0, p1, p2));</span>
  375 |     | <span class='neutral'>    }</span>
  376 |     | <span class='neutral'></span>
  377 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2) internal view {</span>
  378 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address)&quot;, p0, p1, p2));</span>
  379 |     | <span class='neutral'>    }</span>
  380 |     | <span class='neutral'></span>
  381 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2) internal view {</span>
  382 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint)&quot;, p0, p1, p2));</span>
  383 |     | <span class='neutral'>    }</span>
  384 |     | <span class='neutral'></span>
  385 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2) internal view {</span>
  386 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string)&quot;, p0, p1, p2));</span>
  387 |     | <span class='neutral'>    }</span>
  388 |     | <span class='neutral'></span>
  389 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2) internal view {</span>
  390 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool)&quot;, p0, p1, p2));</span>
  391 |     | <span class='neutral'>    }</span>
  392 |     | <span class='neutral'></span>
  393 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2) internal view {</span>
  394 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address)&quot;, p0, p1, p2));</span>
  395 |     | <span class='neutral'>    }</span>
  396 |     | <span class='neutral'></span>
  397 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2) internal view {</span>
  398 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint)&quot;, p0, p1, p2));</span>
  399 |     | <span class='neutral'>    }</span>
  400 |     | <span class='neutral'></span>
  401 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2) internal view {</span>
  402 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string)&quot;, p0, p1, p2));</span>
  403 |     | <span class='neutral'>    }</span>
  404 |     | <span class='neutral'></span>
  405 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2) internal view {</span>
  406 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool)&quot;, p0, p1, p2));</span>
  407 |     | <span class='neutral'>    }</span>
  408 |     | <span class='neutral'></span>
  409 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2) internal view {</span>
  410 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address)&quot;, p0, p1, p2));</span>
  411 |     | <span class='neutral'>    }</span>
  412 |     | <span class='neutral'></span>
  413 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2) internal view {</span>
  414 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint)&quot;, p0, p1, p2));</span>
  415 |     | <span class='neutral'>    }</span>
  416 |     | <span class='neutral'></span>
  417 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2) internal view {</span>
  418 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string)&quot;, p0, p1, p2));</span>
  419 |     | <span class='neutral'>    }</span>
  420 |     | <span class='neutral'></span>
  421 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2) internal view {</span>
  422 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool)&quot;, p0, p1, p2));</span>
  423 |     | <span class='neutral'>    }</span>
  424 |     | <span class='neutral'></span>
  425 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2) internal view {</span>
  426 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address)&quot;, p0, p1, p2));</span>
  427 |     | <span class='neutral'>    }</span>
  428 |     | <span class='neutral'></span>
  429 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2) internal view {</span>
  430 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint)&quot;, p0, p1, p2));</span>
  431 |     | <span class='neutral'>    }</span>
  432 |     | <span class='neutral'></span>
  433 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2) internal view {</span>
  434 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string)&quot;, p0, p1, p2));</span>
  435 |     | <span class='neutral'>    }</span>
  436 |     | <span class='neutral'></span>
  437 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2) internal view {</span>
  438 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool)&quot;, p0, p1, p2));</span>
  439 |     | <span class='neutral'>    }</span>
  440 |     | <span class='neutral'></span>
  441 |     | <span class='neutral'>    function log(bool p0, address p1, address p2) internal view {</span>
  442 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address)&quot;, p0, p1, p2));</span>
  443 |     | <span class='neutral'>    }</span>
  444 |     | <span class='neutral'></span>
  445 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2) internal view {</span>
  446 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint)&quot;, p0, p1, p2));</span>
  447 |     | <span class='neutral'>    }</span>
  448 |     | <span class='neutral'></span>
  449 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2) internal view {</span>
  450 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string)&quot;, p0, p1, p2));</span>
  451 |     | <span class='neutral'>    }</span>
  452 |     | <span class='neutral'></span>
  453 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2) internal view {</span>
  454 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool)&quot;, p0, p1, p2));</span>
  455 |     | <span class='neutral'>    }</span>
  456 |     | <span class='neutral'></span>
  457 |     | <span class='neutral'>    function log(address p0, uint p1, address p2) internal view {</span>
  458 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address)&quot;, p0, p1, p2));</span>
  459 |     | <span class='neutral'>    }</span>
  460 |     | <span class='neutral'></span>
  461 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2) internal view {</span>
  462 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint)&quot;, p0, p1, p2));</span>
  463 |     | <span class='neutral'>    }</span>
  464 |     | <span class='neutral'></span>
  465 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2) internal view {</span>
  466 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string)&quot;, p0, p1, p2));</span>
  467 |     | <span class='neutral'>    }</span>
  468 |     | <span class='neutral'></span>
  469 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2) internal view {</span>
  470 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool)&quot;, p0, p1, p2));</span>
  471 |     | <span class='neutral'>    }</span>
  472 |     | <span class='neutral'></span>
  473 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2) internal view {</span>
  474 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address)&quot;, p0, p1, p2));</span>
  475 |     | <span class='neutral'>    }</span>
  476 |     | <span class='neutral'></span>
  477 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2) internal view {</span>
  478 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint)&quot;, p0, p1, p2));</span>
  479 |     | <span class='neutral'>    }</span>
  480 |     | <span class='neutral'></span>
  481 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2) internal view {</span>
  482 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string)&quot;, p0, p1, p2));</span>
  483 |     | <span class='neutral'>    }</span>
  484 |     | <span class='neutral'></span>
  485 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2) internal view {</span>
  486 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool)&quot;, p0, p1, p2));</span>
  487 |     | <span class='neutral'>    }</span>
  488 |     | <span class='neutral'></span>
  489 |     | <span class='neutral'>    function log(address p0, bool p1, address p2) internal view {</span>
  490 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address)&quot;, p0, p1, p2));</span>
  491 |     | <span class='neutral'>    }</span>
  492 |     | <span class='neutral'></span>
  493 |     | <span class='neutral'>    function log(address p0, address p1, uint p2) internal view {</span>
  494 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint)&quot;, p0, p1, p2));</span>
  495 |     | <span class='neutral'>    }</span>
  496 |     | <span class='neutral'></span>
  497 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2) internal view {</span>
  498 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string)&quot;, p0, p1, p2));</span>
  499 |     | <span class='neutral'>    }</span>
  500 |     | <span class='neutral'></span>
  501 |     | <span class='neutral'>    function log(address p0, address p1, bool p2) internal view {</span>
  502 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool)&quot;, p0, p1, p2));</span>
  503 |     | <span class='neutral'>    }</span>
  504 |     | <span class='neutral'></span>
  505 |     | <span class='neutral'>    function log(address p0, address p1, address p2) internal view {</span>
  506 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address)&quot;, p0, p1, p2));</span>
  507 |     | <span class='neutral'>    }</span>
  508 |     | <span class='neutral'></span>
  509 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2, uint p3) internal view {</span>
  510 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint,uint)&quot;, p0, p1, p2, p3));</span>
  511 |     | <span class='neutral'>    }</span>
  512 |     | <span class='neutral'></span>
  513 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2, string memory p3) internal view {</span>
  514 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint,string)&quot;, p0, p1, p2, p3));</span>
  515 |     | <span class='neutral'>    }</span>
  516 |     | <span class='neutral'></span>
  517 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2, bool p3) internal view {</span>
  518 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint,bool)&quot;, p0, p1, p2, p3));</span>
  519 |     | <span class='neutral'>    }</span>
  520 |     | <span class='neutral'></span>
  521 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2, address p3) internal view {</span>
  522 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint,address)&quot;, p0, p1, p2, p3));</span>
  523 |     | <span class='neutral'>    }</span>
  524 |     | <span class='neutral'></span>
  525 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2, uint p3) internal view {</span>
  526 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string,uint)&quot;, p0, p1, p2, p3));</span>
  527 |     | <span class='neutral'>    }</span>
  528 |     | <span class='neutral'></span>
  529 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {</span>
  530 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string,string)&quot;, p0, p1, p2, p3));</span>
  531 |     | <span class='neutral'>    }</span>
  532 |     | <span class='neutral'></span>
  533 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2, bool p3) internal view {</span>
  534 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string,bool)&quot;, p0, p1, p2, p3));</span>
  535 |     | <span class='neutral'>    }</span>
  536 |     | <span class='neutral'></span>
  537 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2, address p3) internal view {</span>
  538 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string,address)&quot;, p0, p1, p2, p3));</span>
  539 |     | <span class='neutral'>    }</span>
  540 |     | <span class='neutral'></span>
  541 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2, uint p3) internal view {</span>
  542 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool,uint)&quot;, p0, p1, p2, p3));</span>
  543 |     | <span class='neutral'>    }</span>
  544 |     | <span class='neutral'></span>
  545 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2, string memory p3) internal view {</span>
  546 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool,string)&quot;, p0, p1, p2, p3));</span>
  547 |     | <span class='neutral'>    }</span>
  548 |     | <span class='neutral'></span>
  549 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2, bool p3) internal view {</span>
  550 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool,bool)&quot;, p0, p1, p2, p3));</span>
  551 |     | <span class='neutral'>    }</span>
  552 |     | <span class='neutral'></span>
  553 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2, address p3) internal view {</span>
  554 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool,address)&quot;, p0, p1, p2, p3));</span>
  555 |     | <span class='neutral'>    }</span>
  556 |     | <span class='neutral'></span>
  557 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2, uint p3) internal view {</span>
  558 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address,uint)&quot;, p0, p1, p2, p3));</span>
  559 |     | <span class='neutral'>    }</span>
  560 |     | <span class='neutral'></span>
  561 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2, string memory p3) internal view {</span>
  562 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address,string)&quot;, p0, p1, p2, p3));</span>
  563 |     | <span class='neutral'>    }</span>
  564 |     | <span class='neutral'></span>
  565 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2, bool p3) internal view {</span>
  566 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address,bool)&quot;, p0, p1, p2, p3));</span>
  567 |     | <span class='neutral'>    }</span>
  568 |     | <span class='neutral'></span>
  569 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2, address p3) internal view {</span>
  570 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address,address)&quot;, p0, p1, p2, p3));</span>
  571 |     | <span class='neutral'>    }</span>
  572 |     | <span class='neutral'></span>
  573 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2, uint p3) internal view {</span>
  574 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint,uint)&quot;, p0, p1, p2, p3));</span>
  575 |     | <span class='neutral'>    }</span>
  576 |     | <span class='neutral'></span>
  577 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {</span>
  578 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint,string)&quot;, p0, p1, p2, p3));</span>
  579 |     | <span class='neutral'>    }</span>
  580 |     | <span class='neutral'></span>
  581 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2, bool p3) internal view {</span>
  582 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint,bool)&quot;, p0, p1, p2, p3));</span>
  583 |     | <span class='neutral'>    }</span>
  584 |     | <span class='neutral'></span>
  585 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2, address p3) internal view {</span>
  586 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint,address)&quot;, p0, p1, p2, p3));</span>
  587 |     | <span class='neutral'>    }</span>
  588 |     | <span class='neutral'></span>
  589 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {</span>
  590 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string,uint)&quot;, p0, p1, p2, p3));</span>
  591 |     | <span class='neutral'>    }</span>
  592 |     | <span class='neutral'></span>
  593 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {</span>
  594 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string,string)&quot;, p0, p1, p2, p3));</span>
  595 |     | <span class='neutral'>    }</span>
  596 |     | <span class='neutral'></span>
  597 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {</span>
  598 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  599 |     | <span class='neutral'>    }</span>
  600 |     | <span class='neutral'></span>
  601 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2, address p3) internal view {</span>
  602 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string,address)&quot;, p0, p1, p2, p3));</span>
  603 |     | <span class='neutral'>    }</span>
  604 |     | <span class='neutral'></span>
  605 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2, uint p3) internal view {</span>
  606 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool,uint)&quot;, p0, p1, p2, p3));</span>
  607 |     | <span class='neutral'>    }</span>
  608 |     | <span class='neutral'></span>
  609 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {</span>
  610 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  611 |     | <span class='neutral'>    }</span>
  612 |     | <span class='neutral'></span>
  613 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2, bool p3) internal view {</span>
  614 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  615 |     | <span class='neutral'>    }</span>
  616 |     | <span class='neutral'></span>
  617 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2, address p3) internal view {</span>
  618 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  619 |     | <span class='neutral'>    }</span>
  620 |     | <span class='neutral'></span>
  621 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2, uint p3) internal view {</span>
  622 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address,uint)&quot;, p0, p1, p2, p3));</span>
  623 |     | <span class='neutral'>    }</span>
  624 |     | <span class='neutral'></span>
  625 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2, string memory p3) internal view {</span>
  626 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address,string)&quot;, p0, p1, p2, p3));</span>
  627 |     | <span class='neutral'>    }</span>
  628 |     | <span class='neutral'></span>
  629 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2, bool p3) internal view {</span>
  630 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  631 |     | <span class='neutral'>    }</span>
  632 |     | <span class='neutral'></span>
  633 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2, address p3) internal view {</span>
  634 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address,address)&quot;, p0, p1, p2, p3));</span>
  635 |     | <span class='neutral'>    }</span>
  636 |     | <span class='neutral'></span>
  637 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2, uint p3) internal view {</span>
  638 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint,uint)&quot;, p0, p1, p2, p3));</span>
  639 |     | <span class='neutral'>    }</span>
  640 |     | <span class='neutral'></span>
  641 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2, string memory p3) internal view {</span>
  642 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint,string)&quot;, p0, p1, p2, p3));</span>
  643 |     | <span class='neutral'>    }</span>
  644 |     | <span class='neutral'></span>
  645 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2, bool p3) internal view {</span>
  646 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint,bool)&quot;, p0, p1, p2, p3));</span>
  647 |     | <span class='neutral'>    }</span>
  648 |     | <span class='neutral'></span>
  649 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2, address p3) internal view {</span>
  650 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint,address)&quot;, p0, p1, p2, p3));</span>
  651 |     | <span class='neutral'>    }</span>
  652 |     | <span class='neutral'></span>
  653 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2, uint p3) internal view {</span>
  654 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string,uint)&quot;, p0, p1, p2, p3));</span>
  655 |     | <span class='neutral'>    }</span>
  656 |     | <span class='neutral'></span>
  657 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {</span>
  658 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  659 |     | <span class='neutral'>    }</span>
  660 |     | <span class='neutral'></span>
  661 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2, bool p3) internal view {</span>
  662 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  663 |     | <span class='neutral'>    }</span>
  664 |     | <span class='neutral'></span>
  665 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2, address p3) internal view {</span>
  666 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  667 |     | <span class='neutral'>    }</span>
  668 |     | <span class='neutral'></span>
  669 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2, uint p3) internal view {</span>
  670 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool,uint)&quot;, p0, p1, p2, p3));</span>
  671 |     | <span class='neutral'>    }</span>
  672 |     | <span class='neutral'></span>
  673 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2, string memory p3) internal view {</span>
  674 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  675 |     | <span class='neutral'>    }</span>
  676 |     | <span class='neutral'></span>
  677 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2, bool p3) internal view {</span>
  678 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  679 |     | <span class='neutral'>    }</span>
  680 |     | <span class='neutral'></span>
  681 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2, address p3) internal view {</span>
  682 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  683 |     | <span class='neutral'>    }</span>
  684 |     | <span class='neutral'></span>
  685 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2, uint p3) internal view {</span>
  686 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address,uint)&quot;, p0, p1, p2, p3));</span>
  687 |     | <span class='neutral'>    }</span>
  688 |     | <span class='neutral'></span>
  689 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2, string memory p3) internal view {</span>
  690 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  691 |     | <span class='neutral'>    }</span>
  692 |     | <span class='neutral'></span>
  693 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2, bool p3) internal view {</span>
  694 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  695 |     | <span class='neutral'>    }</span>
  696 |     | <span class='neutral'></span>
  697 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2, address p3) internal view {</span>
  698 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  699 |     | <span class='neutral'>    }</span>
  700 |     | <span class='neutral'></span>
  701 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2, uint p3) internal view {</span>
  702 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint,uint)&quot;, p0, p1, p2, p3));</span>
  703 |     | <span class='neutral'>    }</span>
  704 |     | <span class='neutral'></span>
  705 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2, string memory p3) internal view {</span>
  706 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint,string)&quot;, p0, p1, p2, p3));</span>
  707 |     | <span class='neutral'>    }</span>
  708 |     | <span class='neutral'></span>
  709 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2, bool p3) internal view {</span>
  710 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint,bool)&quot;, p0, p1, p2, p3));</span>
  711 |     | <span class='neutral'>    }</span>
  712 |     | <span class='neutral'></span>
  713 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2, address p3) internal view {</span>
  714 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint,address)&quot;, p0, p1, p2, p3));</span>
  715 |     | <span class='neutral'>    }</span>
  716 |     | <span class='neutral'></span>
  717 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2, uint p3) internal view {</span>
  718 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string,uint)&quot;, p0, p1, p2, p3));</span>
  719 |     | <span class='neutral'>    }</span>
  720 |     | <span class='neutral'></span>
  721 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2, string memory p3) internal view {</span>
  722 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string,string)&quot;, p0, p1, p2, p3));</span>
  723 |     | <span class='neutral'>    }</span>
  724 |     | <span class='neutral'></span>
  725 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2, bool p3) internal view {</span>
  726 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string,bool)&quot;, p0, p1, p2, p3));</span>
  727 |     | <span class='neutral'>    }</span>
  728 |     | <span class='neutral'></span>
  729 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2, address p3) internal view {</span>
  730 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string,address)&quot;, p0, p1, p2, p3));</span>
  731 |     | <span class='neutral'>    }</span>
  732 |     | <span class='neutral'></span>
  733 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2, uint p3) internal view {</span>
  734 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool,uint)&quot;, p0, p1, p2, p3));</span>
  735 |     | <span class='neutral'>    }</span>
  736 |     | <span class='neutral'></span>
  737 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2, string memory p3) internal view {</span>
  738 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool,string)&quot;, p0, p1, p2, p3));</span>
  739 |     | <span class='neutral'>    }</span>
  740 |     | <span class='neutral'></span>
  741 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2, bool p3) internal view {</span>
  742 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
  743 |     | <span class='neutral'>    }</span>
  744 |     | <span class='neutral'></span>
  745 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2, address p3) internal view {</span>
  746 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool,address)&quot;, p0, p1, p2, p3));</span>
  747 |     | <span class='neutral'>    }</span>
  748 |     | <span class='neutral'></span>
  749 |     | <span class='neutral'>    function log(uint p0, address p1, address p2, uint p3) internal view {</span>
  750 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address,uint)&quot;, p0, p1, p2, p3));</span>
  751 |     | <span class='neutral'>    }</span>
  752 |     | <span class='neutral'></span>
  753 |     | <span class='neutral'>    function log(uint p0, address p1, address p2, string memory p3) internal view {</span>
  754 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address,string)&quot;, p0, p1, p2, p3));</span>
  755 |     | <span class='neutral'>    }</span>
  756 |     | <span class='neutral'></span>
  757 |     | <span class='neutral'>    function log(uint p0, address p1, address p2, bool p3) internal view {</span>
  758 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address,bool)&quot;, p0, p1, p2, p3));</span>
  759 |     | <span class='neutral'>    }</span>
  760 |     | <span class='neutral'></span>
  761 |     | <span class='neutral'>    function log(uint p0, address p1, address p2, address p3) internal view {</span>
  762 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address,address)&quot;, p0, p1, p2, p3));</span>
  763 |     | <span class='neutral'>    }</span>
  764 |     | <span class='neutral'></span>
  765 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2, uint p3) internal view {</span>
  766 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint,uint)&quot;, p0, p1, p2, p3));</span>
  767 |     | <span class='neutral'>    }</span>
  768 |     | <span class='neutral'></span>
  769 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {</span>
  770 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint,string)&quot;, p0, p1, p2, p3));</span>
  771 |     | <span class='neutral'>    }</span>
  772 |     | <span class='neutral'></span>
  773 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2, bool p3) internal view {</span>
  774 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint,bool)&quot;, p0, p1, p2, p3));</span>
  775 |     | <span class='neutral'>    }</span>
  776 |     | <span class='neutral'></span>
  777 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2, address p3) internal view {</span>
  778 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint,address)&quot;, p0, p1, p2, p3));</span>
  779 |     | <span class='neutral'>    }</span>
  780 |     | <span class='neutral'></span>
  781 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {</span>
  782 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string,uint)&quot;, p0, p1, p2, p3));</span>
  783 |     | <span class='neutral'>    }</span>
  784 |     | <span class='neutral'></span>
  785 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {</span>
  786 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string,string)&quot;, p0, p1, p2, p3));</span>
  787 |     | <span class='neutral'>    }</span>
  788 |     | <span class='neutral'></span>
  789 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {</span>
  790 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string,bool)&quot;, p0, p1, p2, p3));</span>
  791 |     | <span class='neutral'>    }</span>
  792 |     | <span class='neutral'></span>
  793 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2, address p3) internal view {</span>
  794 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string,address)&quot;, p0, p1, p2, p3));</span>
  795 |     | <span class='neutral'>    }</span>
  796 |     | <span class='neutral'></span>
  797 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2, uint p3) internal view {</span>
  798 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool,uint)&quot;, p0, p1, p2, p3));</span>
  799 |     | <span class='neutral'>    }</span>
  800 |     | <span class='neutral'></span>
  801 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {</span>
  802 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool,string)&quot;, p0, p1, p2, p3));</span>
  803 |     | <span class='neutral'>    }</span>
  804 |     | <span class='neutral'></span>
  805 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2, bool p3) internal view {</span>
  806 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool,bool)&quot;, p0, p1, p2, p3));</span>
  807 |     | <span class='neutral'>    }</span>
  808 |     | <span class='neutral'></span>
  809 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2, address p3) internal view {</span>
  810 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool,address)&quot;, p0, p1, p2, p3));</span>
  811 |     | <span class='neutral'>    }</span>
  812 |     | <span class='neutral'></span>
  813 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2, uint p3) internal view {</span>
  814 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address,uint)&quot;, p0, p1, p2, p3));</span>
  815 |     | <span class='neutral'>    }</span>
  816 |     | <span class='neutral'></span>
  817 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2, string memory p3) internal view {</span>
  818 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address,string)&quot;, p0, p1, p2, p3));</span>
  819 |     | <span class='neutral'>    }</span>
  820 |     | <span class='neutral'></span>
  821 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2, bool p3) internal view {</span>
  822 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address,bool)&quot;, p0, p1, p2, p3));</span>
  823 |     | <span class='neutral'>    }</span>
  824 |     | <span class='neutral'></span>
  825 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2, address p3) internal view {</span>
  826 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address,address)&quot;, p0, p1, p2, p3));</span>
  827 |     | <span class='neutral'>    }</span>
  828 |     | <span class='neutral'></span>
  829 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {</span>
  830 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint,uint)&quot;, p0, p1, p2, p3));</span>
  831 |     | <span class='neutral'>    }</span>
  832 |     | <span class='neutral'></span>
  833 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {</span>
  834 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint,string)&quot;, p0, p1, p2, p3));</span>
  835 |     | <span class='neutral'>    }</span>
  836 |     | <span class='neutral'></span>
  837 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {</span>
  838 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint,bool)&quot;, p0, p1, p2, p3));</span>
  839 |     | <span class='neutral'>    }</span>
  840 |     | <span class='neutral'></span>
  841 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2, address p3) internal view {</span>
  842 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint,address)&quot;, p0, p1, p2, p3));</span>
  843 |     | <span class='neutral'>    }</span>
  844 |     | <span class='neutral'></span>
  845 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {</span>
  846 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,uint)&quot;, p0, p1, p2, p3));</span>
  847 |     | <span class='neutral'>    }</span>
  848 |     | <span class='neutral'></span>
  849 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {</span>
  850 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,string)&quot;, p0, p1, p2, p3));</span>
  851 |     | <span class='neutral'>    }</span>
  852 |     | <span class='neutral'></span>
  853 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {</span>
  854 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  855 |     | <span class='neutral'>    }</span>
  856 |     | <span class='neutral'></span>
  857 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {</span>
  858 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,address)&quot;, p0, p1, p2, p3));</span>
  859 |     | <span class='neutral'>    }</span>
  860 |     | <span class='neutral'></span>
  861 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {</span>
  862 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,uint)&quot;, p0, p1, p2, p3));</span>
  863 |     | <span class='neutral'>    }</span>
  864 |     | <span class='neutral'></span>
  865 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {</span>
  866 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  867 |     | <span class='neutral'>    }</span>
  868 |     | <span class='neutral'></span>
  869 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {</span>
  870 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  871 |     | <span class='neutral'>    }</span>
  872 |     | <span class='neutral'></span>
  873 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, address p3) internal view {</span>
  874 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  875 |     | <span class='neutral'>    }</span>
  876 |     | <span class='neutral'></span>
  877 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, uint p3) internal view {</span>
  878 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,uint)&quot;, p0, p1, p2, p3));</span>
  879 |     | <span class='neutral'>    }</span>
  880 |     | <span class='neutral'></span>
  881 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {</span>
  882 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,string)&quot;, p0, p1, p2, p3));</span>
  883 |     | <span class='neutral'>    }</span>
  884 |     | <span class='neutral'></span>
  885 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, bool p3) internal view {</span>
  886 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  887 |     | <span class='neutral'>    }</span>
  888 |     | <span class='neutral'></span>
  889 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, address p3) internal view {</span>
  890 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,address)&quot;, p0, p1, p2, p3));</span>
  891 |     | <span class='neutral'>    }</span>
  892 |     | <span class='neutral'></span>
  893 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2, uint p3) internal view {</span>
  894 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint,uint)&quot;, p0, p1, p2, p3));</span>
  895 |     | <span class='neutral'>    }</span>
  896 |     | <span class='neutral'></span>
  897 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {</span>
  898 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint,string)&quot;, p0, p1, p2, p3));</span>
  899 |     | <span class='neutral'>    }</span>
  900 |     | <span class='neutral'></span>
  901 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2, bool p3) internal view {</span>
  902 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint,bool)&quot;, p0, p1, p2, p3));</span>
  903 |     | <span class='neutral'>    }</span>
  904 |     | <span class='neutral'></span>
  905 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2, address p3) internal view {</span>
  906 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint,address)&quot;, p0, p1, p2, p3));</span>
  907 |     | <span class='neutral'>    }</span>
  908 |     | <span class='neutral'></span>
  909 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {</span>
  910 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,uint)&quot;, p0, p1, p2, p3));</span>
  911 |     | <span class='neutral'>    }</span>
  912 |     | <span class='neutral'></span>
  913 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {</span>
  914 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  915 |     | <span class='neutral'>    }</span>
  916 |     | <span class='neutral'></span>
  917 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {</span>
  918 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  919 |     | <span class='neutral'>    }</span>
  920 |     | <span class='neutral'></span>
  921 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, address p3) internal view {</span>
  922 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  923 |     | <span class='neutral'>    }</span>
  924 |     | <span class='neutral'></span>
  925 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, uint p3) internal view {</span>
  926 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,uint)&quot;, p0, p1, p2, p3));</span>
  927 |     | <span class='neutral'>    }</span>
  928 |     | <span class='neutral'></span>
  929 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {</span>
  930 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  931 |     | <span class='neutral'>    }</span>
  932 |     | <span class='neutral'></span>
  933 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, bool p3) internal view {</span>
  934 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  935 |     | <span class='neutral'>    }</span>
  936 |     | <span class='neutral'></span>
  937 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, address p3) internal view {</span>
  938 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  939 |     | <span class='neutral'>    }</span>
  940 |     | <span class='neutral'></span>
  941 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, uint p3) internal view {</span>
  942 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,uint)&quot;, p0, p1, p2, p3));</span>
  943 |     | <span class='neutral'>    }</span>
  944 |     | <span class='neutral'></span>
  945 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, string memory p3) internal view {</span>
  946 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  947 |     | <span class='neutral'>    }</span>
  948 |     | <span class='neutral'></span>
  949 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, bool p3) internal view {</span>
  950 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  951 |     | <span class='neutral'>    }</span>
  952 |     | <span class='neutral'></span>
  953 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, address p3) internal view {</span>
  954 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  955 |     | <span class='neutral'>    }</span>
  956 |     | <span class='neutral'></span>
  957 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2, uint p3) internal view {</span>
  958 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint,uint)&quot;, p0, p1, p2, p3));</span>
  959 |     | <span class='neutral'>    }</span>
  960 |     | <span class='neutral'></span>
  961 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2, string memory p3) internal view {</span>
  962 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint,string)&quot;, p0, p1, p2, p3));</span>
  963 |     | <span class='neutral'>    }</span>
  964 |     | <span class='neutral'></span>
  965 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2, bool p3) internal view {</span>
  966 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint,bool)&quot;, p0, p1, p2, p3));</span>
  967 |     | <span class='neutral'>    }</span>
  968 |     | <span class='neutral'></span>
  969 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2, address p3) internal view {</span>
  970 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint,address)&quot;, p0, p1, p2, p3));</span>
  971 |     | <span class='neutral'>    }</span>
  972 |     | <span class='neutral'></span>
  973 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, uint p3) internal view {</span>
  974 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,uint)&quot;, p0, p1, p2, p3));</span>
  975 |     | <span class='neutral'>    }</span>
  976 |     | <span class='neutral'></span>
  977 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {</span>
  978 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,string)&quot;, p0, p1, p2, p3));</span>
  979 |     | <span class='neutral'>    }</span>
  980 |     | <span class='neutral'></span>
  981 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, bool p3) internal view {</span>
  982 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,bool)&quot;, p0, p1, p2, p3));</span>
  983 |     | <span class='neutral'>    }</span>
  984 |     | <span class='neutral'></span>
  985 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, address p3) internal view {</span>
  986 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,address)&quot;, p0, p1, p2, p3));</span>
  987 |     | <span class='neutral'>    }</span>
  988 |     | <span class='neutral'></span>
  989 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, uint p3) internal view {</span>
  990 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,uint)&quot;, p0, p1, p2, p3));</span>
  991 |     | <span class='neutral'>    }</span>
  992 |     | <span class='neutral'></span>
  993 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, string memory p3) internal view {</span>
  994 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,string)&quot;, p0, p1, p2, p3));</span>
  995 |     | <span class='neutral'>    }</span>
  996 |     | <span class='neutral'></span>
  997 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, bool p3) internal view {</span>
  998 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
  999 |     | <span class='neutral'>    }</span>
 1000 |     | <span class='neutral'></span>
 1001 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, address p3) internal view {</span>
 1002 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1003 |     | <span class='neutral'>    }</span>
 1004 |     | <span class='neutral'></span>
 1005 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, uint p3) internal view {</span>
 1006 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,uint)&quot;, p0, p1, p2, p3));</span>
 1007 |     | <span class='neutral'>    }</span>
 1008 |     | <span class='neutral'></span>
 1009 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, string memory p3) internal view {</span>
 1010 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1011 |     | <span class='neutral'>    }</span>
 1012 |     | <span class='neutral'></span>
 1013 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, bool p3) internal view {</span>
 1014 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1015 |     | <span class='neutral'>    }</span>
 1016 |     | <span class='neutral'></span>
 1017 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, address p3) internal view {</span>
 1018 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1019 |     | <span class='neutral'>    }</span>
 1020 |     | <span class='neutral'></span>
 1021 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2, uint p3) internal view {</span>
 1022 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1023 |     | <span class='neutral'>    }</span>
 1024 |     | <span class='neutral'></span>
 1025 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2, string memory p3) internal view {</span>
 1026 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint,string)&quot;, p0, p1, p2, p3));</span>
 1027 |     | <span class='neutral'>    }</span>
 1028 |     | <span class='neutral'></span>
 1029 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2, bool p3) internal view {</span>
 1030 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1031 |     | <span class='neutral'>    }</span>
 1032 |     | <span class='neutral'></span>
 1033 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2, address p3) internal view {</span>
 1034 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint,address)&quot;, p0, p1, p2, p3));</span>
 1035 |     | <span class='neutral'>    }</span>
 1036 |     | <span class='neutral'></span>
 1037 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2, uint p3) internal view {</span>
 1038 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string,uint)&quot;, p0, p1, p2, p3));</span>
 1039 |     | <span class='neutral'>    }</span>
 1040 |     | <span class='neutral'></span>
 1041 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {</span>
 1042 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string,string)&quot;, p0, p1, p2, p3));</span>
 1043 |     | <span class='neutral'>    }</span>
 1044 |     | <span class='neutral'></span>
 1045 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2, bool p3) internal view {</span>
 1046 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string,bool)&quot;, p0, p1, p2, p3));</span>
 1047 |     | <span class='neutral'>    }</span>
 1048 |     | <span class='neutral'></span>
 1049 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2, address p3) internal view {</span>
 1050 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string,address)&quot;, p0, p1, p2, p3));</span>
 1051 |     | <span class='neutral'>    }</span>
 1052 |     | <span class='neutral'></span>
 1053 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2, uint p3) internal view {</span>
 1054 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1055 |     | <span class='neutral'>    }</span>
 1056 |     | <span class='neutral'></span>
 1057 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2, string memory p3) internal view {</span>
 1058 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool,string)&quot;, p0, p1, p2, p3));</span>
 1059 |     | <span class='neutral'>    }</span>
 1060 |     | <span class='neutral'></span>
 1061 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2, bool p3) internal view {</span>
 1062 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1063 |     | <span class='neutral'>    }</span>
 1064 |     | <span class='neutral'></span>
 1065 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2, address p3) internal view {</span>
 1066 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool,address)&quot;, p0, p1, p2, p3));</span>
 1067 |     | <span class='neutral'>    }</span>
 1068 |     | <span class='neutral'></span>
 1069 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2, uint p3) internal view {</span>
 1070 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address,uint)&quot;, p0, p1, p2, p3));</span>
 1071 |     | <span class='neutral'>    }</span>
 1072 |     | <span class='neutral'></span>
 1073 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2, string memory p3) internal view {</span>
 1074 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address,string)&quot;, p0, p1, p2, p3));</span>
 1075 |     | <span class='neutral'>    }</span>
 1076 |     | <span class='neutral'></span>
 1077 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2, bool p3) internal view {</span>
 1078 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address,bool)&quot;, p0, p1, p2, p3));</span>
 1079 |     | <span class='neutral'>    }</span>
 1080 |     | <span class='neutral'></span>
 1081 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2, address p3) internal view {</span>
 1082 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address,address)&quot;, p0, p1, p2, p3));</span>
 1083 |     | <span class='neutral'>    }</span>
 1084 |     | <span class='neutral'></span>
 1085 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2, uint p3) internal view {</span>
 1086 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1087 |     | <span class='neutral'>    }</span>
 1088 |     | <span class='neutral'></span>
 1089 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {</span>
 1090 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint,string)&quot;, p0, p1, p2, p3));</span>
 1091 |     | <span class='neutral'>    }</span>
 1092 |     | <span class='neutral'></span>
 1093 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2, bool p3) internal view {</span>
 1094 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1095 |     | <span class='neutral'>    }</span>
 1096 |     | <span class='neutral'></span>
 1097 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2, address p3) internal view {</span>
 1098 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint,address)&quot;, p0, p1, p2, p3));</span>
 1099 |     | <span class='neutral'>    }</span>
 1100 |     | <span class='neutral'></span>
 1101 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {</span>
 1102 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,uint)&quot;, p0, p1, p2, p3));</span>
 1103 |     | <span class='neutral'>    }</span>
 1104 |     | <span class='neutral'></span>
 1105 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {</span>
 1106 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1107 |     | <span class='neutral'>    }</span>
 1108 |     | <span class='neutral'></span>
 1109 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {</span>
 1110 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1111 |     | <span class='neutral'>    }</span>
 1112 |     | <span class='neutral'></span>
 1113 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, address p3) internal view {</span>
 1114 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1115 |     | <span class='neutral'>    }</span>
 1116 |     | <span class='neutral'></span>
 1117 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, uint p3) internal view {</span>
 1118 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1119 |     | <span class='neutral'>    }</span>
 1120 |     | <span class='neutral'></span>
 1121 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {</span>
 1122 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1123 |     | <span class='neutral'>    }</span>
 1124 |     | <span class='neutral'></span>
 1125 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, bool p3) internal view {</span>
 1126 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1127 |     | <span class='neutral'>    }</span>
 1128 |     | <span class='neutral'></span>
 1129 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, address p3) internal view {</span>
 1130 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1131 |     | <span class='neutral'>    }</span>
 1132 |     | <span class='neutral'></span>
 1133 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, uint p3) internal view {</span>
 1134 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,uint)&quot;, p0, p1, p2, p3));</span>
 1135 |     | <span class='neutral'>    }</span>
 1136 |     | <span class='neutral'></span>
 1137 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, string memory p3) internal view {</span>
 1138 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1139 |     | <span class='neutral'>    }</span>
 1140 |     | <span class='neutral'></span>
 1141 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, bool p3) internal view {</span>
 1142 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1143 |     | <span class='neutral'>    }</span>
 1144 |     | <span class='neutral'></span>
 1145 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, address p3) internal view {</span>
 1146 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1147 |     | <span class='neutral'>    }</span>
 1148 |     | <span class='neutral'></span>
 1149 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2, uint p3) internal view {</span>
 1150 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1151 |     | <span class='neutral'>    }</span>
 1152 |     | <span class='neutral'></span>
 1153 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2, string memory p3) internal view {</span>
 1154 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint,string)&quot;, p0, p1, p2, p3));</span>
 1155 |     | <span class='neutral'>    }</span>
 1156 |     | <span class='neutral'></span>
 1157 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2, bool p3) internal view {</span>
 1158 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1159 |     | <span class='neutral'>    }</span>
 1160 |     | <span class='neutral'></span>
 1161 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2, address p3) internal view {</span>
 1162 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint,address)&quot;, p0, p1, p2, p3));</span>
 1163 |     | <span class='neutral'>    }</span>
 1164 |     | <span class='neutral'></span>
 1165 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, uint p3) internal view {</span>
 1166 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,uint)&quot;, p0, p1, p2, p3));</span>
 1167 |     | <span class='neutral'>    }</span>
 1168 |     | <span class='neutral'></span>
 1169 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {</span>
 1170 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1171 |     | <span class='neutral'>    }</span>
 1172 |     | <span class='neutral'></span>
 1173 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, bool p3) internal view {</span>
 1174 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1175 |     | <span class='neutral'>    }</span>
 1176 |     | <span class='neutral'></span>
 1177 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, address p3) internal view {</span>
 1178 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1179 |     | <span class='neutral'>    }</span>
 1180 |     | <span class='neutral'></span>
 1181 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, uint p3) internal view {</span>
 1182 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1183 |     | <span class='neutral'>    }</span>
 1184 |     | <span class='neutral'></span>
 1185 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, string memory p3) internal view {</span>
 1186 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1187 |     | <span class='neutral'>    }</span>
 1188 |     | <span class='neutral'></span>
 1189 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, bool p3) internal view {</span>
 1190 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1191 |     | <span class='neutral'>    }</span>
 1192 |     | <span class='neutral'></span>
 1193 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, address p3) internal view {</span>
 1194 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1195 |     | <span class='neutral'>    }</span>
 1196 |     | <span class='neutral'></span>
 1197 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, uint p3) internal view {</span>
 1198 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,uint)&quot;, p0, p1, p2, p3));</span>
 1199 |     | <span class='neutral'>    }</span>
 1200 |     | <span class='neutral'></span>
 1201 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, string memory p3) internal view {</span>
 1202 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1203 |     | <span class='neutral'>    }</span>
 1204 |     | <span class='neutral'></span>
 1205 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, bool p3) internal view {</span>
 1206 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1207 |     | <span class='neutral'>    }</span>
 1208 |     | <span class='neutral'></span>
 1209 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, address p3) internal view {</span>
 1210 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1211 |     | <span class='neutral'>    }</span>
 1212 |     | <span class='neutral'></span>
 1213 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2, uint p3) internal view {</span>
 1214 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1215 |     | <span class='neutral'>    }</span>
 1216 |     | <span class='neutral'></span>
 1217 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2, string memory p3) internal view {</span>
 1218 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint,string)&quot;, p0, p1, p2, p3));</span>
 1219 |     | <span class='neutral'>    }</span>
 1220 |     | <span class='neutral'></span>
 1221 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2, bool p3) internal view {</span>
 1222 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1223 |     | <span class='neutral'>    }</span>
 1224 |     | <span class='neutral'></span>
 1225 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2, address p3) internal view {</span>
 1226 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint,address)&quot;, p0, p1, p2, p3));</span>
 1227 |     | <span class='neutral'>    }</span>
 1228 |     | <span class='neutral'></span>
 1229 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, uint p3) internal view {</span>
 1230 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,uint)&quot;, p0, p1, p2, p3));</span>
 1231 |     | <span class='neutral'>    }</span>
 1232 |     | <span class='neutral'></span>
 1233 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, string memory p3) internal view {</span>
 1234 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1235 |     | <span class='neutral'>    }</span>
 1236 |     | <span class='neutral'></span>
 1237 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, bool p3) internal view {</span>
 1238 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1239 |     | <span class='neutral'>    }</span>
 1240 |     | <span class='neutral'></span>
 1241 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, address p3) internal view {</span>
 1242 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1243 |     | <span class='neutral'>    }</span>
 1244 |     | <span class='neutral'></span>
 1245 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, uint p3) internal view {</span>
 1246 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1247 |     | <span class='neutral'>    }</span>
 1248 |     | <span class='neutral'></span>
 1249 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, string memory p3) internal view {</span>
 1250 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1251 |     | <span class='neutral'>    }</span>
 1252 |     | <span class='neutral'></span>
 1253 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, bool p3) internal view {</span>
 1254 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1255 |     | <span class='neutral'>    }</span>
 1256 |     | <span class='neutral'></span>
 1257 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, address p3) internal view {</span>
 1258 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1259 |     | <span class='neutral'>    }</span>
 1260 |     | <span class='neutral'></span>
 1261 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, uint p3) internal view {</span>
 1262 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,uint)&quot;, p0, p1, p2, p3));</span>
 1263 |     | <span class='neutral'>    }</span>
 1264 |     | <span class='neutral'></span>
 1265 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, string memory p3) internal view {</span>
 1266 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1267 |     | <span class='neutral'>    }</span>
 1268 |     | <span class='neutral'></span>
 1269 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, bool p3) internal view {</span>
 1270 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1271 |     | <span class='neutral'>    }</span>
 1272 |     | <span class='neutral'></span>
 1273 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, address p3) internal view {</span>
 1274 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1275 |     | <span class='neutral'>    }</span>
 1276 |     | <span class='neutral'></span>
 1277 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2, uint p3) internal view {</span>
 1278 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1279 |     | <span class='neutral'>    }</span>
 1280 |     | <span class='neutral'></span>
 1281 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2, string memory p3) internal view {</span>
 1282 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint,string)&quot;, p0, p1, p2, p3));</span>
 1283 |     | <span class='neutral'>    }</span>
 1284 |     | <span class='neutral'></span>
 1285 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2, bool p3) internal view {</span>
 1286 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1287 |     | <span class='neutral'>    }</span>
 1288 |     | <span class='neutral'></span>
 1289 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2, address p3) internal view {</span>
 1290 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint,address)&quot;, p0, p1, p2, p3));</span>
 1291 |     | <span class='neutral'>    }</span>
 1292 |     | <span class='neutral'></span>
 1293 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2, uint p3) internal view {</span>
 1294 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string,uint)&quot;, p0, p1, p2, p3));</span>
 1295 |     | <span class='neutral'>    }</span>
 1296 |     | <span class='neutral'></span>
 1297 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2, string memory p3) internal view {</span>
 1298 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string,string)&quot;, p0, p1, p2, p3));</span>
 1299 |     | <span class='neutral'>    }</span>
 1300 |     | <span class='neutral'></span>
 1301 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2, bool p3) internal view {</span>
 1302 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string,bool)&quot;, p0, p1, p2, p3));</span>
 1303 |     | <span class='neutral'>    }</span>
 1304 |     | <span class='neutral'></span>
 1305 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2, address p3) internal view {</span>
 1306 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string,address)&quot;, p0, p1, p2, p3));</span>
 1307 |     | <span class='neutral'>    }</span>
 1308 |     | <span class='neutral'></span>
 1309 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2, uint p3) internal view {</span>
 1310 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1311 |     | <span class='neutral'>    }</span>
 1312 |     | <span class='neutral'></span>
 1313 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2, string memory p3) internal view {</span>
 1314 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool,string)&quot;, p0, p1, p2, p3));</span>
 1315 |     | <span class='neutral'>    }</span>
 1316 |     | <span class='neutral'></span>
 1317 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2, bool p3) internal view {</span>
 1318 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1319 |     | <span class='neutral'>    }</span>
 1320 |     | <span class='neutral'></span>
 1321 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2, address p3) internal view {</span>
 1322 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool,address)&quot;, p0, p1, p2, p3));</span>
 1323 |     | <span class='neutral'>    }</span>
 1324 |     | <span class='neutral'></span>
 1325 |     | <span class='neutral'>    function log(address p0, uint p1, address p2, uint p3) internal view {</span>
 1326 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address,uint)&quot;, p0, p1, p2, p3));</span>
 1327 |     | <span class='neutral'>    }</span>
 1328 |     | <span class='neutral'></span>
 1329 |     | <span class='neutral'>    function log(address p0, uint p1, address p2, string memory p3) internal view {</span>
 1330 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address,string)&quot;, p0, p1, p2, p3));</span>
 1331 |     | <span class='neutral'>    }</span>
 1332 |     | <span class='neutral'></span>
 1333 |     | <span class='neutral'>    function log(address p0, uint p1, address p2, bool p3) internal view {</span>
 1334 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address,bool)&quot;, p0, p1, p2, p3));</span>
 1335 |     | <span class='neutral'>    }</span>
 1336 |     | <span class='neutral'></span>
 1337 |     | <span class='neutral'>    function log(address p0, uint p1, address p2, address p3) internal view {</span>
 1338 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address,address)&quot;, p0, p1, p2, p3));</span>
 1339 |     | <span class='neutral'>    }</span>
 1340 |     | <span class='neutral'></span>
 1341 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2, uint p3) internal view {</span>
 1342 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1343 |     | <span class='neutral'>    }</span>
 1344 |     | <span class='neutral'></span>
 1345 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2, string memory p3) internal view {</span>
 1346 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint,string)&quot;, p0, p1, p2, p3));</span>
 1347 |     | <span class='neutral'>    }</span>
 1348 |     | <span class='neutral'></span>
 1349 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2, bool p3) internal view {</span>
 1350 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1351 |     | <span class='neutral'>    }</span>
 1352 |     | <span class='neutral'></span>
 1353 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2, address p3) internal view {</span>
 1354 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint,address)&quot;, p0, p1, p2, p3));</span>
 1355 |     | <span class='neutral'>    }</span>
 1356 |     | <span class='neutral'></span>
 1357 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, uint p3) internal view {</span>
 1358 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,uint)&quot;, p0, p1, p2, p3));</span>
 1359 |     | <span class='neutral'>    }</span>
 1360 |     | <span class='neutral'></span>
 1361 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {</span>
 1362 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1363 |     | <span class='neutral'>    }</span>
 1364 |     | <span class='neutral'></span>
 1365 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, bool p3) internal view {</span>
 1366 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1367 |     | <span class='neutral'>    }</span>
 1368 |     | <span class='neutral'></span>
 1369 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, address p3) internal view {</span>
 1370 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1371 |     | <span class='neutral'>    }</span>
 1372 |     | <span class='neutral'></span>
 1373 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, uint p3) internal view {</span>
 1374 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1375 |     | <span class='neutral'>    }</span>
 1376 |     | <span class='neutral'></span>
 1377 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, string memory p3) internal view {</span>
 1378 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1379 |     | <span class='neutral'>    }</span>
 1380 |     | <span class='neutral'></span>
 1381 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, bool p3) internal view {</span>
 1382 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1383 |     | <span class='neutral'>    }</span>
 1384 |     | <span class='neutral'></span>
 1385 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, address p3) internal view {</span>
 1386 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1387 |     | <span class='neutral'>    }</span>
 1388 |     | <span class='neutral'></span>
 1389 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, uint p3) internal view {</span>
 1390 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,uint)&quot;, p0, p1, p2, p3));</span>
 1391 |     | <span class='neutral'>    }</span>
 1392 |     | <span class='neutral'></span>
 1393 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, string memory p3) internal view {</span>
 1394 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1395 |     | <span class='neutral'>    }</span>
 1396 |     | <span class='neutral'></span>
 1397 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, bool p3) internal view {</span>
 1398 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1399 |     | <span class='neutral'>    }</span>
 1400 |     | <span class='neutral'></span>
 1401 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, address p3) internal view {</span>
 1402 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1403 |     | <span class='neutral'>    }</span>
 1404 |     | <span class='neutral'></span>
 1405 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2, uint p3) internal view {</span>
 1406 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1407 |     | <span class='neutral'>    }</span>
 1408 |     | <span class='neutral'></span>
 1409 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2, string memory p3) internal view {</span>
 1410 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint,string)&quot;, p0, p1, p2, p3));</span>
 1411 |     | <span class='neutral'>    }</span>
 1412 |     | <span class='neutral'></span>
 1413 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2, bool p3) internal view {</span>
 1414 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1415 |     | <span class='neutral'>    }</span>
 1416 |     | <span class='neutral'></span>
 1417 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2, address p3) internal view {</span>
 1418 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint,address)&quot;, p0, p1, p2, p3));</span>
 1419 |     | <span class='neutral'>    }</span>
 1420 |     | <span class='neutral'></span>
 1421 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, uint p3) internal view {</span>
 1422 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,uint)&quot;, p0, p1, p2, p3));</span>
 1423 |     | <span class='neutral'>    }</span>
 1424 |     | <span class='neutral'></span>
 1425 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, string memory p3) internal view {</span>
 1426 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1427 |     | <span class='neutral'>    }</span>
 1428 |     | <span class='neutral'></span>
 1429 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, bool p3) internal view {</span>
 1430 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1431 |     | <span class='neutral'>    }</span>
 1432 |     | <span class='neutral'></span>
 1433 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, address p3) internal view {</span>
 1434 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1435 |     | <span class='neutral'>    }</span>
 1436 |     | <span class='neutral'></span>
 1437 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, uint p3) internal view {</span>
 1438 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1439 |     | <span class='neutral'>    }</span>
 1440 |     | <span class='neutral'></span>
 1441 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, string memory p3) internal view {</span>
 1442 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1443 |     | <span class='neutral'>    }</span>
 1444 |     | <span class='neutral'></span>
 1445 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, bool p3) internal view {</span>
 1446 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1447 |     | <span class='neutral'>    }</span>
 1448 |     | <span class='neutral'></span>
 1449 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, address p3) internal view {</span>
 1450 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1451 |     | <span class='neutral'>    }</span>
 1452 |     | <span class='neutral'></span>
 1453 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, uint p3) internal view {</span>
 1454 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,uint)&quot;, p0, p1, p2, p3));</span>
 1455 |     | <span class='neutral'>    }</span>
 1456 |     | <span class='neutral'></span>
 1457 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, string memory p3) internal view {</span>
 1458 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1459 |     | <span class='neutral'>    }</span>
 1460 |     | <span class='neutral'></span>
 1461 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, bool p3) internal view {</span>
 1462 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1463 |     | <span class='neutral'>    }</span>
 1464 |     | <span class='neutral'></span>
 1465 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, address p3) internal view {</span>
 1466 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1467 |     | <span class='neutral'>    }</span>
 1468 |     | <span class='neutral'></span>
 1469 |     | <span class='neutral'>    function log(address p0, address p1, uint p2, uint p3) internal view {</span>
 1470 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1471 |     | <span class='neutral'>    }</span>
 1472 |     | <span class='neutral'></span>
 1473 |     | <span class='neutral'>    function log(address p0, address p1, uint p2, string memory p3) internal view {</span>
 1474 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint,string)&quot;, p0, p1, p2, p3));</span>
 1475 |     | <span class='neutral'>    }</span>
 1476 |     | <span class='neutral'></span>
 1477 |     | <span class='neutral'>    function log(address p0, address p1, uint p2, bool p3) internal view {</span>
 1478 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1479 |     | <span class='neutral'>    }</span>
 1480 |     | <span class='neutral'></span>
 1481 |     | <span class='neutral'>    function log(address p0, address p1, uint p2, address p3) internal view {</span>
 1482 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint,address)&quot;, p0, p1, p2, p3));</span>
 1483 |     | <span class='neutral'>    }</span>
 1484 |     | <span class='neutral'></span>
 1485 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, uint p3) internal view {</span>
 1486 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,uint)&quot;, p0, p1, p2, p3));</span>
 1487 |     | <span class='neutral'>    }</span>
 1488 |     | <span class='neutral'></span>
 1489 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, string memory p3) internal view {</span>
 1490 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1491 |     | <span class='neutral'>    }</span>
 1492 |     | <span class='neutral'></span>
 1493 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, bool p3) internal view {</span>
 1494 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1495 |     | <span class='neutral'>    }</span>
 1496 |     | <span class='neutral'></span>
 1497 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, address p3) internal view {</span>
 1498 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1499 |     | <span class='neutral'>    }</span>
 1500 |     | <span class='neutral'></span>
 1501 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, uint p3) internal view {</span>
 1502 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1503 |     | <span class='neutral'>    }</span>
 1504 |     | <span class='neutral'></span>
 1505 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, string memory p3) internal view {</span>
 1506 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1507 |     | <span class='neutral'>    }</span>
 1508 |     | <span class='neutral'></span>
 1509 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, bool p3) internal view {</span>
 1510 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1511 |     | <span class='neutral'>    }</span>
 1512 |     | <span class='neutral'></span>
 1513 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, address p3) internal view {</span>
 1514 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1515 |     | <span class='neutral'>    }</span>
 1516 |     | <span class='neutral'></span>
 1517 |     | <span class='neutral'>    function log(address p0, address p1, address p2, uint p3) internal view {</span>
 1518 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,uint)&quot;, p0, p1, p2, p3));</span>
 1519 |     | <span class='neutral'>    }</span>
 1520 |     | <span class='neutral'></span>
 1521 |     | <span class='neutral'>    function log(address p0, address p1, address p2, string memory p3) internal view {</span>
 1522 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1523 |     | <span class='neutral'>    }</span>
 1524 |     | <span class='neutral'></span>
 1525 |     | <span class='neutral'>    function log(address p0, address p1, address p2, bool p3) internal view {</span>
 1526 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1527 |     | <span class='neutral'>    }</span>
 1528 |     | <span class='neutral'></span>
 1529 |     | <span class='neutral'>    function log(address p0, address p1, address p2, address p3) internal view {</span>
 1530 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1531 |     | <span class='neutral'>    }</span>
 1532 |     | <span class='neutral'></span>
 1533 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/lib/forge-std/src/console2.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
    2 |     | <span class='neutral'>pragma solidity &gt;=0.4.22 &lt;0.9.0;</span>
    3 |     | <span class='neutral'></span>
    4 |     | <span class='neutral'>/// @dev The original console.sol uses `int` and `uint` for computing function selectors, but it should</span>
    5 |     | <span class='neutral'>/// use `int256` and `uint256`. This modified version fixes that. This version is recommended</span>
    6 |     | <span class='neutral'>/// over `console.sol` if you don&#39;t need compatibility with Hardhat as the logs will show up in</span>
    7 |     | <span class='neutral'>/// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.</span>
    8 |     | <span class='neutral'>/// Reference: https://github.com/NomicFoundation/hardhat/issues/2178</span>
    9 |     | <span class='neutral'>library console2 {</span>
   10 |     | <span class='neutral'>    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);</span>
   11 |     | <span class='neutral'></span>
   12 |     | <span class='neutral'>    function _sendLogPayload(bytes memory payload) private view {</span>
   13 |     | <span class='neutral'>        uint256 payloadLength = payload.length;</span>
   14 |     | <span class='neutral'>        address consoleAddress = CONSOLE_ADDRESS;</span>
   15 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   16 |     | <span class='neutral'>        assembly {</span>
   17 |     | <span class='neutral'>            let payloadStart := add(payload, 32)</span>
   18 |     | <span class='neutral'>            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)</span>
   19 |     | <span class='neutral'>        }</span>
   20 |     | <span class='neutral'>    }</span>
   21 |     | <span class='neutral'></span>
   22 |     | <span class='neutral'>    function log() internal view {</span>
   23 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log()&quot;));</span>
   24 |     | <span class='neutral'>    }</span>
   25 |     | <span class='neutral'></span>
   26 |     | <span class='neutral'>    function logInt(int256 p0) internal view {</span>
   27 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(int256)&quot;, p0));</span>
   28 |     | <span class='neutral'>    }</span>
   29 |     | <span class='neutral'></span>
   30 |     | <span class='neutral'>    function logUint(uint256 p0) internal view {</span>
   31 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256)&quot;, p0));</span>
   32 |     | <span class='neutral'>    }</span>
   33 |     | <span class='neutral'></span>
   34 |     | <span class='neutral'>    function logString(string memory p0) internal view {</span>
   35 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
   36 |     | <span class='neutral'>    }</span>
   37 |     | <span class='neutral'></span>
   38 |     | <span class='neutral'>    function logBool(bool p0) internal view {</span>
   39 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
   40 |     | <span class='neutral'>    }</span>
   41 |     | <span class='neutral'></span>
   42 |     | <span class='neutral'>    function logAddress(address p0) internal view {</span>
   43 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
   44 |     | <span class='neutral'>    }</span>
   45 |     | <span class='neutral'></span>
   46 |     | <span class='neutral'>    function logBytes(bytes memory p0) internal view {</span>
   47 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes)&quot;, p0));</span>
   48 |     | <span class='neutral'>    }</span>
   49 |     | <span class='neutral'></span>
   50 |     | <span class='neutral'>    function logBytes1(bytes1 p0) internal view {</span>
   51 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes1)&quot;, p0));</span>
   52 |     | <span class='neutral'>    }</span>
   53 |     | <span class='neutral'></span>
   54 |     | <span class='neutral'>    function logBytes2(bytes2 p0) internal view {</span>
   55 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes2)&quot;, p0));</span>
   56 |     | <span class='neutral'>    }</span>
   57 |     | <span class='neutral'></span>
   58 |     | <span class='neutral'>    function logBytes3(bytes3 p0) internal view {</span>
   59 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes3)&quot;, p0));</span>
   60 |     | <span class='neutral'>    }</span>
   61 |     | <span class='neutral'></span>
   62 |     | <span class='neutral'>    function logBytes4(bytes4 p0) internal view {</span>
   63 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes4)&quot;, p0));</span>
   64 |     | <span class='neutral'>    }</span>
   65 |     | <span class='neutral'></span>
   66 |     | <span class='neutral'>    function logBytes5(bytes5 p0) internal view {</span>
   67 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes5)&quot;, p0));</span>
   68 |     | <span class='neutral'>    }</span>
   69 |     | <span class='neutral'></span>
   70 |     | <span class='neutral'>    function logBytes6(bytes6 p0) internal view {</span>
   71 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes6)&quot;, p0));</span>
   72 |     | <span class='neutral'>    }</span>
   73 |     | <span class='neutral'></span>
   74 |     | <span class='neutral'>    function logBytes7(bytes7 p0) internal view {</span>
   75 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes7)&quot;, p0));</span>
   76 |     | <span class='neutral'>    }</span>
   77 |     | <span class='neutral'></span>
   78 |     | <span class='neutral'>    function logBytes8(bytes8 p0) internal view {</span>
   79 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes8)&quot;, p0));</span>
   80 |     | <span class='neutral'>    }</span>
   81 |     | <span class='neutral'></span>
   82 |     | <span class='neutral'>    function logBytes9(bytes9 p0) internal view {</span>
   83 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes9)&quot;, p0));</span>
   84 |     | <span class='neutral'>    }</span>
   85 |     | <span class='neutral'></span>
   86 |     | <span class='neutral'>    function logBytes10(bytes10 p0) internal view {</span>
   87 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes10)&quot;, p0));</span>
   88 |     | <span class='neutral'>    }</span>
   89 |     | <span class='neutral'></span>
   90 |     | <span class='neutral'>    function logBytes11(bytes11 p0) internal view {</span>
   91 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes11)&quot;, p0));</span>
   92 |     | <span class='neutral'>    }</span>
   93 |     | <span class='neutral'></span>
   94 |     | <span class='neutral'>    function logBytes12(bytes12 p0) internal view {</span>
   95 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes12)&quot;, p0));</span>
   96 |     | <span class='neutral'>    }</span>
   97 |     | <span class='neutral'></span>
   98 |     | <span class='neutral'>    function logBytes13(bytes13 p0) internal view {</span>
   99 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes13)&quot;, p0));</span>
  100 |     | <span class='neutral'>    }</span>
  101 |     | <span class='neutral'></span>
  102 |     | <span class='neutral'>    function logBytes14(bytes14 p0) internal view {</span>
  103 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes14)&quot;, p0));</span>
  104 |     | <span class='neutral'>    }</span>
  105 |     | <span class='neutral'></span>
  106 |     | <span class='neutral'>    function logBytes15(bytes15 p0) internal view {</span>
  107 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes15)&quot;, p0));</span>
  108 |     | <span class='neutral'>    }</span>
  109 |     | <span class='neutral'></span>
  110 |     | <span class='neutral'>    function logBytes16(bytes16 p0) internal view {</span>
  111 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes16)&quot;, p0));</span>
  112 |     | <span class='neutral'>    }</span>
  113 |     | <span class='neutral'></span>
  114 |     | <span class='neutral'>    function logBytes17(bytes17 p0) internal view {</span>
  115 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes17)&quot;, p0));</span>
  116 |     | <span class='neutral'>    }</span>
  117 |     | <span class='neutral'></span>
  118 |     | <span class='neutral'>    function logBytes18(bytes18 p0) internal view {</span>
  119 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes18)&quot;, p0));</span>
  120 |     | <span class='neutral'>    }</span>
  121 |     | <span class='neutral'></span>
  122 |     | <span class='neutral'>    function logBytes19(bytes19 p0) internal view {</span>
  123 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes19)&quot;, p0));</span>
  124 |     | <span class='neutral'>    }</span>
  125 |     | <span class='neutral'></span>
  126 |     | <span class='neutral'>    function logBytes20(bytes20 p0) internal view {</span>
  127 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes20)&quot;, p0));</span>
  128 |     | <span class='neutral'>    }</span>
  129 |     | <span class='neutral'></span>
  130 |     | <span class='neutral'>    function logBytes21(bytes21 p0) internal view {</span>
  131 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes21)&quot;, p0));</span>
  132 |     | <span class='neutral'>    }</span>
  133 |     | <span class='neutral'></span>
  134 |     | <span class='neutral'>    function logBytes22(bytes22 p0) internal view {</span>
  135 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes22)&quot;, p0));</span>
  136 |     | <span class='neutral'>    }</span>
  137 |     | <span class='neutral'></span>
  138 |     | <span class='neutral'>    function logBytes23(bytes23 p0) internal view {</span>
  139 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes23)&quot;, p0));</span>
  140 |     | <span class='neutral'>    }</span>
  141 |     | <span class='neutral'></span>
  142 |     | <span class='neutral'>    function logBytes24(bytes24 p0) internal view {</span>
  143 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes24)&quot;, p0));</span>
  144 |     | <span class='neutral'>    }</span>
  145 |     | <span class='neutral'></span>
  146 |     | <span class='neutral'>    function logBytes25(bytes25 p0) internal view {</span>
  147 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes25)&quot;, p0));</span>
  148 |     | <span class='neutral'>    }</span>
  149 |     | <span class='neutral'></span>
  150 |     | <span class='neutral'>    function logBytes26(bytes26 p0) internal view {</span>
  151 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes26)&quot;, p0));</span>
  152 |     | <span class='neutral'>    }</span>
  153 |     | <span class='neutral'></span>
  154 |     | <span class='neutral'>    function logBytes27(bytes27 p0) internal view {</span>
  155 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes27)&quot;, p0));</span>
  156 |     | <span class='neutral'>    }</span>
  157 |     | <span class='neutral'></span>
  158 |     | <span class='neutral'>    function logBytes28(bytes28 p0) internal view {</span>
  159 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes28)&quot;, p0));</span>
  160 |     | <span class='neutral'>    }</span>
  161 |     | <span class='neutral'></span>
  162 |     | <span class='neutral'>    function logBytes29(bytes29 p0) internal view {</span>
  163 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes29)&quot;, p0));</span>
  164 |     | <span class='neutral'>    }</span>
  165 |     | <span class='neutral'></span>
  166 |     | <span class='neutral'>    function logBytes30(bytes30 p0) internal view {</span>
  167 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes30)&quot;, p0));</span>
  168 |     | <span class='neutral'>    }</span>
  169 |     | <span class='neutral'></span>
  170 |     | <span class='neutral'>    function logBytes31(bytes31 p0) internal view {</span>
  171 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes31)&quot;, p0));</span>
  172 |     | <span class='neutral'>    }</span>
  173 |     | <span class='neutral'></span>
  174 |     | <span class='neutral'>    function logBytes32(bytes32 p0) internal view {</span>
  175 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes32)&quot;, p0));</span>
  176 |     | <span class='neutral'>    }</span>
  177 |     | <span class='neutral'></span>
  178 |     | <span class='neutral'>    function log(uint256 p0) internal view {</span>
  179 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256)&quot;, p0));</span>
  180 |     | <span class='neutral'>    }</span>
  181 |     | <span class='neutral'></span>
  182 |     | <span class='neutral'>    function log(string memory p0) internal view {</span>
  183 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
  184 |     | <span class='neutral'>    }</span>
  185 |     | <span class='neutral'></span>
  186 |     | <span class='neutral'>    function log(bool p0) internal view {</span>
  187 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
  188 |     | <span class='neutral'>    }</span>
  189 |     | <span class='neutral'></span>
  190 |     | <span class='neutral'>    function log(address p0) internal view {</span>
  191 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
  192 |     | <span class='neutral'>    }</span>
  193 |     | <span class='neutral'></span>
  194 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1) internal view {</span>
  195 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256)&quot;, p0, p1));</span>
  196 |     | <span class='neutral'>    }</span>
  197 |     | <span class='neutral'></span>
  198 |     | <span class='neutral'>    function log(uint256 p0, string memory p1) internal view {</span>
  199 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string)&quot;, p0, p1));</span>
  200 |     | <span class='neutral'>    }</span>
  201 |     | <span class='neutral'></span>
  202 |     | <span class='neutral'>    function log(uint256 p0, bool p1) internal view {</span>
  203 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool)&quot;, p0, p1));</span>
  204 |     | <span class='neutral'>    }</span>
  205 |     | <span class='neutral'></span>
  206 |     | <span class='neutral'>    function log(uint256 p0, address p1) internal view {</span>
  207 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address)&quot;, p0, p1));</span>
  208 |     | <span class='neutral'>    }</span>
  209 |     | <span class='neutral'></span>
  210 |     | <span class='neutral'>    function log(string memory p0, uint256 p1) internal view {</span>
  211 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256)&quot;, p0, p1));</span>
  212 |     | <span class='neutral'>    }</span>
  213 |     | <span class='neutral'></span>
  214 |     | <span class='neutral'>    function log(string memory p0, string memory p1) internal view {</span>
  215 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string)&quot;, p0, p1));</span>
  216 |     | <span class='neutral'>    }</span>
  217 |     | <span class='neutral'></span>
  218 |     | <span class='neutral'>    function log(string memory p0, bool p1) internal view {</span>
  219 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool)&quot;, p0, p1));</span>
  220 |     | <span class='neutral'>    }</span>
  221 |     | <span class='neutral'></span>
  222 |     | <span class='neutral'>    function log(string memory p0, address p1) internal view {</span>
  223 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address)&quot;, p0, p1));</span>
  224 |     | <span class='neutral'>    }</span>
  225 |     | <span class='neutral'></span>
  226 |     | <span class='neutral'>    function log(bool p0, uint256 p1) internal view {</span>
  227 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256)&quot;, p0, p1));</span>
  228 |     | <span class='neutral'>    }</span>
  229 |     | <span class='neutral'></span>
  230 |     | <span class='neutral'>    function log(bool p0, string memory p1) internal view {</span>
  231 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string)&quot;, p0, p1));</span>
  232 |     | <span class='neutral'>    }</span>
  233 |     | <span class='neutral'></span>
  234 |     | <span class='neutral'>    function log(bool p0, bool p1) internal view {</span>
  235 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool)&quot;, p0, p1));</span>
  236 |     | <span class='neutral'>    }</span>
  237 |     | <span class='neutral'></span>
  238 |     | <span class='neutral'>    function log(bool p0, address p1) internal view {</span>
  239 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address)&quot;, p0, p1));</span>
  240 |     | <span class='neutral'>    }</span>
  241 |     | <span class='neutral'></span>
  242 |     | <span class='neutral'>    function log(address p0, uint256 p1) internal view {</span>
  243 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256)&quot;, p0, p1));</span>
  244 |     | <span class='neutral'>    }</span>
  245 |     | <span class='neutral'></span>
  246 |     | <span class='neutral'>    function log(address p0, string memory p1) internal view {</span>
  247 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string)&quot;, p0, p1));</span>
  248 |     | <span class='neutral'>    }</span>
  249 |     | <span class='neutral'></span>
  250 |     | <span class='neutral'>    function log(address p0, bool p1) internal view {</span>
  251 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool)&quot;, p0, p1));</span>
  252 |     | <span class='neutral'>    }</span>
  253 |     | <span class='neutral'></span>
  254 |     | <span class='neutral'>    function log(address p0, address p1) internal view {</span>
  255 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address)&quot;, p0, p1));</span>
  256 |     | <span class='neutral'>    }</span>
  257 |     | <span class='neutral'></span>
  258 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2) internal view {</span>
  259 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256)&quot;, p0, p1, p2));</span>
  260 |     | <span class='neutral'>    }</span>
  261 |     | <span class='neutral'></span>
  262 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2) internal view {</span>
  263 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string)&quot;, p0, p1, p2));</span>
  264 |     | <span class='neutral'>    }</span>
  265 |     | <span class='neutral'></span>
  266 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2) internal view {</span>
  267 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool)&quot;, p0, p1, p2));</span>
  268 |     | <span class='neutral'>    }</span>
  269 |     | <span class='neutral'></span>
  270 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2) internal view {</span>
  271 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address)&quot;, p0, p1, p2));</span>
  272 |     | <span class='neutral'>    }</span>
  273 |     | <span class='neutral'></span>
  274 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2) internal view {</span>
  275 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256)&quot;, p0, p1, p2));</span>
  276 |     | <span class='neutral'>    }</span>
  277 |     | <span class='neutral'></span>
  278 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2) internal view {</span>
  279 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string)&quot;, p0, p1, p2));</span>
  280 |     | <span class='neutral'>    }</span>
  281 |     | <span class='neutral'></span>
  282 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2) internal view {</span>
  283 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool)&quot;, p0, p1, p2));</span>
  284 |     | <span class='neutral'>    }</span>
  285 |     | <span class='neutral'></span>
  286 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2) internal view {</span>
  287 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address)&quot;, p0, p1, p2));</span>
  288 |     | <span class='neutral'>    }</span>
  289 |     | <span class='neutral'></span>
  290 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2) internal view {</span>
  291 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256)&quot;, p0, p1, p2));</span>
  292 |     | <span class='neutral'>    }</span>
  293 |     | <span class='neutral'></span>
  294 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2) internal view {</span>
  295 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string)&quot;, p0, p1, p2));</span>
  296 |     | <span class='neutral'>    }</span>
  297 |     | <span class='neutral'></span>
  298 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2) internal view {</span>
  299 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool)&quot;, p0, p1, p2));</span>
  300 |     | <span class='neutral'>    }</span>
  301 |     | <span class='neutral'></span>
  302 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2) internal view {</span>
  303 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address)&quot;, p0, p1, p2));</span>
  304 |     | <span class='neutral'>    }</span>
  305 |     | <span class='neutral'></span>
  306 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2) internal view {</span>
  307 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256)&quot;, p0, p1, p2));</span>
  308 |     | <span class='neutral'>    }</span>
  309 |     | <span class='neutral'></span>
  310 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2) internal view {</span>
  311 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string)&quot;, p0, p1, p2));</span>
  312 |     | <span class='neutral'>    }</span>
  313 |     | <span class='neutral'></span>
  314 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2) internal view {</span>
  315 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool)&quot;, p0, p1, p2));</span>
  316 |     | <span class='neutral'>    }</span>
  317 |     | <span class='neutral'></span>
  318 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2) internal view {</span>
  319 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address)&quot;, p0, p1, p2));</span>
  320 |     | <span class='neutral'>    }</span>
  321 |     | <span class='neutral'></span>
  322 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2) internal view {</span>
  323 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256)&quot;, p0, p1, p2));</span>
  324 |     | <span class='neutral'>    }</span>
  325 |     | <span class='neutral'></span>
  326 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2) internal view {</span>
  327 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string)&quot;, p0, p1, p2));</span>
  328 |     | <span class='neutral'>    }</span>
  329 |     | <span class='neutral'></span>
  330 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2) internal view {</span>
  331 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool)&quot;, p0, p1, p2));</span>
  332 |     | <span class='neutral'>    }</span>
  333 |     | <span class='neutral'></span>
  334 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2) internal view {</span>
  335 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address)&quot;, p0, p1, p2));</span>
  336 |     | <span class='neutral'>    }</span>
  337 |     | <span class='neutral'></span>
  338 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2) internal view {</span>
  339 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256)&quot;, p0, p1, p2));</span>
  340 |     | <span class='neutral'>    }</span>
  341 |     | <span class='neutral'></span>
  342 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2) internal view {</span>
  343 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string)&quot;, p0, p1, p2));</span>
  344 |     | <span class='neutral'>    }</span>
  345 |     | <span class='neutral'></span>
  346 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2) internal view {</span>
  347 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool)&quot;, p0, p1, p2));</span>
  348 |     | <span class='neutral'>    }</span>
  349 |     | <span class='neutral'></span>
  350 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2) internal view {</span>
  351 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address)&quot;, p0, p1, p2));</span>
  352 |     | <span class='neutral'>    }</span>
  353 |     | <span class='neutral'></span>
  354 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2) internal view {</span>
  355 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256)&quot;, p0, p1, p2));</span>
  356 |     | <span class='neutral'>    }</span>
  357 |     | <span class='neutral'></span>
  358 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2) internal view {</span>
  359 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string)&quot;, p0, p1, p2));</span>
  360 |     | <span class='neutral'>    }</span>
  361 |     | <span class='neutral'></span>
  362 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2) internal view {</span>
  363 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool)&quot;, p0, p1, p2));</span>
  364 |     | <span class='neutral'>    }</span>
  365 |     | <span class='neutral'></span>
  366 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2) internal view {</span>
  367 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address)&quot;, p0, p1, p2));</span>
  368 |     | <span class='neutral'>    }</span>
  369 |     | <span class='neutral'></span>
  370 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2) internal view {</span>
  371 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256)&quot;, p0, p1, p2));</span>
  372 |     | <span class='neutral'>    }</span>
  373 |     | <span class='neutral'></span>
  374 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2) internal view {</span>
  375 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string)&quot;, p0, p1, p2));</span>
  376 |     | <span class='neutral'>    }</span>
  377 |     | <span class='neutral'></span>
  378 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2) internal view {</span>
  379 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool)&quot;, p0, p1, p2));</span>
  380 |     | <span class='neutral'>    }</span>
  381 |     | <span class='neutral'></span>
  382 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2) internal view {</span>
  383 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address)&quot;, p0, p1, p2));</span>
  384 |     | <span class='neutral'>    }</span>
  385 |     | <span class='neutral'></span>
  386 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2) internal view {</span>
  387 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256)&quot;, p0, p1, p2));</span>
  388 |     | <span class='neutral'>    }</span>
  389 |     | <span class='neutral'></span>
  390 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2) internal view {</span>
  391 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string)&quot;, p0, p1, p2));</span>
  392 |     | <span class='neutral'>    }</span>
  393 |     | <span class='neutral'></span>
  394 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2) internal view {</span>
  395 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool)&quot;, p0, p1, p2));</span>
  396 |     | <span class='neutral'>    }</span>
  397 |     | <span class='neutral'></span>
  398 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2) internal view {</span>
  399 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address)&quot;, p0, p1, p2));</span>
  400 |     | <span class='neutral'>    }</span>
  401 |     | <span class='neutral'></span>
  402 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2) internal view {</span>
  403 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256)&quot;, p0, p1, p2));</span>
  404 |     | <span class='neutral'>    }</span>
  405 |     | <span class='neutral'></span>
  406 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2) internal view {</span>
  407 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string)&quot;, p0, p1, p2));</span>
  408 |     | <span class='neutral'>    }</span>
  409 |     | <span class='neutral'></span>
  410 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2) internal view {</span>
  411 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool)&quot;, p0, p1, p2));</span>
  412 |     | <span class='neutral'>    }</span>
  413 |     | <span class='neutral'></span>
  414 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2) internal view {</span>
  415 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address)&quot;, p0, p1, p2));</span>
  416 |     | <span class='neutral'>    }</span>
  417 |     | <span class='neutral'></span>
  418 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2) internal view {</span>
  419 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256)&quot;, p0, p1, p2));</span>
  420 |     | <span class='neutral'>    }</span>
  421 |     | <span class='neutral'></span>
  422 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2) internal view {</span>
  423 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string)&quot;, p0, p1, p2));</span>
  424 |     | <span class='neutral'>    }</span>
  425 |     | <span class='neutral'></span>
  426 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2) internal view {</span>
  427 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool)&quot;, p0, p1, p2));</span>
  428 |     | <span class='neutral'>    }</span>
  429 |     | <span class='neutral'></span>
  430 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2) internal view {</span>
  431 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address)&quot;, p0, p1, p2));</span>
  432 |     | <span class='neutral'>    }</span>
  433 |     | <span class='neutral'></span>
  434 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2) internal view {</span>
  435 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256)&quot;, p0, p1, p2));</span>
  436 |     | <span class='neutral'>    }</span>
  437 |     | <span class='neutral'></span>
  438 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2) internal view {</span>
  439 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string)&quot;, p0, p1, p2));</span>
  440 |     | <span class='neutral'>    }</span>
  441 |     | <span class='neutral'></span>
  442 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2) internal view {</span>
  443 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool)&quot;, p0, p1, p2));</span>
  444 |     | <span class='neutral'>    }</span>
  445 |     | <span class='neutral'></span>
  446 |     | <span class='neutral'>    function log(bool p0, address p1, address p2) internal view {</span>
  447 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address)&quot;, p0, p1, p2));</span>
  448 |     | <span class='neutral'>    }</span>
  449 |     | <span class='neutral'></span>
  450 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2) internal view {</span>
  451 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256)&quot;, p0, p1, p2));</span>
  452 |     | <span class='neutral'>    }</span>
  453 |     | <span class='neutral'></span>
  454 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2) internal view {</span>
  455 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string)&quot;, p0, p1, p2));</span>
  456 |     | <span class='neutral'>    }</span>
  457 |     | <span class='neutral'></span>
  458 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2) internal view {</span>
  459 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool)&quot;, p0, p1, p2));</span>
  460 |     | <span class='neutral'>    }</span>
  461 |     | <span class='neutral'></span>
  462 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2) internal view {</span>
  463 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address)&quot;, p0, p1, p2));</span>
  464 |     | <span class='neutral'>    }</span>
  465 |     | <span class='neutral'></span>
  466 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2) internal view {</span>
  467 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256)&quot;, p0, p1, p2));</span>
  468 |     | <span class='neutral'>    }</span>
  469 |     | <span class='neutral'></span>
  470 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2) internal view {</span>
  471 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string)&quot;, p0, p1, p2));</span>
  472 |     | <span class='neutral'>    }</span>
  473 |     | <span class='neutral'></span>
  474 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2) internal view {</span>
  475 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool)&quot;, p0, p1, p2));</span>
  476 |     | <span class='neutral'>    }</span>
  477 |     | <span class='neutral'></span>
  478 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2) internal view {</span>
  479 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address)&quot;, p0, p1, p2));</span>
  480 |     | <span class='neutral'>    }</span>
  481 |     | <span class='neutral'></span>
  482 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2) internal view {</span>
  483 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256)&quot;, p0, p1, p2));</span>
  484 |     | <span class='neutral'>    }</span>
  485 |     | <span class='neutral'></span>
  486 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2) internal view {</span>
  487 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string)&quot;, p0, p1, p2));</span>
  488 |     | <span class='neutral'>    }</span>
  489 |     | <span class='neutral'></span>
  490 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2) internal view {</span>
  491 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool)&quot;, p0, p1, p2));</span>
  492 |     | <span class='neutral'>    }</span>
  493 |     | <span class='neutral'></span>
  494 |     | <span class='neutral'>    function log(address p0, bool p1, address p2) internal view {</span>
  495 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address)&quot;, p0, p1, p2));</span>
  496 |     | <span class='neutral'>    }</span>
  497 |     | <span class='neutral'></span>
  498 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2) internal view {</span>
  499 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256)&quot;, p0, p1, p2));</span>
  500 |     | <span class='neutral'>    }</span>
  501 |     | <span class='neutral'></span>
  502 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2) internal view {</span>
  503 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string)&quot;, p0, p1, p2));</span>
  504 |     | <span class='neutral'>    }</span>
  505 |     | <span class='neutral'></span>
  506 |     | <span class='neutral'>    function log(address p0, address p1, bool p2) internal view {</span>
  507 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool)&quot;, p0, p1, p2));</span>
  508 |     | <span class='neutral'>    }</span>
  509 |     | <span class='neutral'></span>
  510 |     | <span class='neutral'>    function log(address p0, address p1, address p2) internal view {</span>
  511 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address)&quot;, p0, p1, p2));</span>
  512 |     | <span class='neutral'>    }</span>
  513 |     | <span class='neutral'></span>
  514 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {</span>
  515 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  516 |     | <span class='neutral'>    }</span>
  517 |     | <span class='neutral'></span>
  518 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {</span>
  519 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
  520 |     | <span class='neutral'>    }</span>
  521 |     | <span class='neutral'></span>
  522 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {</span>
  523 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  524 |     | <span class='neutral'>    }</span>
  525 |     | <span class='neutral'></span>
  526 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {</span>
  527 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
  528 |     | <span class='neutral'>    }</span>
  529 |     | <span class='neutral'></span>
  530 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {</span>
  531 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
  532 |     | <span class='neutral'>    }</span>
  533 |     | <span class='neutral'></span>
  534 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {</span>
  535 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
  536 |     | <span class='neutral'>    }</span>
  537 |     | <span class='neutral'></span>
  538 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {</span>
  539 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
  540 |     | <span class='neutral'>    }</span>
  541 |     | <span class='neutral'></span>
  542 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {</span>
  543 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
  544 |     | <span class='neutral'>    }</span>
  545 |     | <span class='neutral'></span>
  546 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {</span>
  547 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  548 |     | <span class='neutral'>    }</span>
  549 |     | <span class='neutral'></span>
  550 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {</span>
  551 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
  552 |     | <span class='neutral'>    }</span>
  553 |     | <span class='neutral'></span>
  554 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {</span>
  555 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
  556 |     | <span class='neutral'>    }</span>
  557 |     | <span class='neutral'></span>
  558 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {</span>
  559 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
  560 |     | <span class='neutral'>    }</span>
  561 |     | <span class='neutral'></span>
  562 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {</span>
  563 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
  564 |     | <span class='neutral'>    }</span>
  565 |     | <span class='neutral'></span>
  566 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {</span>
  567 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
  568 |     | <span class='neutral'>    }</span>
  569 |     | <span class='neutral'></span>
  570 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {</span>
  571 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
  572 |     | <span class='neutral'>    }</span>
  573 |     | <span class='neutral'></span>
  574 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, address p3) internal view {</span>
  575 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
  576 |     | <span class='neutral'>    }</span>
  577 |     | <span class='neutral'></span>
  578 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {</span>
  579 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  580 |     | <span class='neutral'>    }</span>
  581 |     | <span class='neutral'></span>
  582 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {</span>
  583 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
  584 |     | <span class='neutral'>    }</span>
  585 |     | <span class='neutral'></span>
  586 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {</span>
  587 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  588 |     | <span class='neutral'>    }</span>
  589 |     | <span class='neutral'></span>
  590 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {</span>
  591 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
  592 |     | <span class='neutral'>    }</span>
  593 |     | <span class='neutral'></span>
  594 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {</span>
  595 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
  596 |     | <span class='neutral'>    }</span>
  597 |     | <span class='neutral'></span>
  598 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {</span>
  599 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,string)&quot;, p0, p1, p2, p3));</span>
  600 |     | <span class='neutral'>    }</span>
  601 |     | <span class='neutral'></span>
  602 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {</span>
  603 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  604 |     | <span class='neutral'>    }</span>
  605 |     | <span class='neutral'></span>
  606 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {</span>
  607 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,address)&quot;, p0, p1, p2, p3));</span>
  608 |     | <span class='neutral'>    }</span>
  609 |     | <span class='neutral'></span>
  610 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {</span>
  611 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  612 |     | <span class='neutral'>    }</span>
  613 |     | <span class='neutral'></span>
  614 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {</span>
  615 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  616 |     | <span class='neutral'>    }</span>
  617 |     | <span class='neutral'></span>
  618 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {</span>
  619 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  620 |     | <span class='neutral'>    }</span>
  621 |     | <span class='neutral'></span>
  622 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2, address p3) internal view {</span>
  623 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  624 |     | <span class='neutral'>    }</span>
  625 |     | <span class='neutral'></span>
  626 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {</span>
  627 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
  628 |     | <span class='neutral'>    }</span>
  629 |     | <span class='neutral'></span>
  630 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {</span>
  631 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,string)&quot;, p0, p1, p2, p3));</span>
  632 |     | <span class='neutral'>    }</span>
  633 |     | <span class='neutral'></span>
  634 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2, bool p3) internal view {</span>
  635 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  636 |     | <span class='neutral'>    }</span>
  637 |     | <span class='neutral'></span>
  638 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2, address p3) internal view {</span>
  639 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,address)&quot;, p0, p1, p2, p3));</span>
  640 |     | <span class='neutral'>    }</span>
  641 |     | <span class='neutral'></span>
  642 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {</span>
  643 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  644 |     | <span class='neutral'>    }</span>
  645 |     | <span class='neutral'></span>
  646 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {</span>
  647 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
  648 |     | <span class='neutral'>    }</span>
  649 |     | <span class='neutral'></span>
  650 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {</span>
  651 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  652 |     | <span class='neutral'>    }</span>
  653 |     | <span class='neutral'></span>
  654 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {</span>
  655 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
  656 |     | <span class='neutral'>    }</span>
  657 |     | <span class='neutral'></span>
  658 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {</span>
  659 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
  660 |     | <span class='neutral'>    }</span>
  661 |     | <span class='neutral'></span>
  662 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {</span>
  663 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  664 |     | <span class='neutral'>    }</span>
  665 |     | <span class='neutral'></span>
  666 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {</span>
  667 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  668 |     | <span class='neutral'>    }</span>
  669 |     | <span class='neutral'></span>
  670 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2, address p3) internal view {</span>
  671 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  672 |     | <span class='neutral'>    }</span>
  673 |     | <span class='neutral'></span>
  674 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {</span>
  675 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  676 |     | <span class='neutral'>    }</span>
  677 |     | <span class='neutral'></span>
  678 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {</span>
  679 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  680 |     | <span class='neutral'>    }</span>
  681 |     | <span class='neutral'></span>
  682 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, bool p3) internal view {</span>
  683 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  684 |     | <span class='neutral'>    }</span>
  685 |     | <span class='neutral'></span>
  686 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, address p3) internal view {</span>
  687 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  688 |     | <span class='neutral'>    }</span>
  689 |     | <span class='neutral'></span>
  690 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {</span>
  691 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
  692 |     | <span class='neutral'>    }</span>
  693 |     | <span class='neutral'></span>
  694 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, string memory p3) internal view {</span>
  695 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  696 |     | <span class='neutral'>    }</span>
  697 |     | <span class='neutral'></span>
  698 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, bool p3) internal view {</span>
  699 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  700 |     | <span class='neutral'>    }</span>
  701 |     | <span class='neutral'></span>
  702 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, address p3) internal view {</span>
  703 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  704 |     | <span class='neutral'>    }</span>
  705 |     | <span class='neutral'></span>
  706 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {</span>
  707 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  708 |     | <span class='neutral'>    }</span>
  709 |     | <span class='neutral'></span>
  710 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {</span>
  711 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
  712 |     | <span class='neutral'>    }</span>
  713 |     | <span class='neutral'></span>
  714 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {</span>
  715 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  716 |     | <span class='neutral'>    }</span>
  717 |     | <span class='neutral'></span>
  718 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, address p3) internal view {</span>
  719 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
  720 |     | <span class='neutral'>    }</span>
  721 |     | <span class='neutral'></span>
  722 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {</span>
  723 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
  724 |     | <span class='neutral'>    }</span>
  725 |     | <span class='neutral'></span>
  726 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {</span>
  727 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,string)&quot;, p0, p1, p2, p3));</span>
  728 |     | <span class='neutral'>    }</span>
  729 |     | <span class='neutral'></span>
  730 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2, bool p3) internal view {</span>
  731 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,bool)&quot;, p0, p1, p2, p3));</span>
  732 |     | <span class='neutral'>    }</span>
  733 |     | <span class='neutral'></span>
  734 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2, address p3) internal view {</span>
  735 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,address)&quot;, p0, p1, p2, p3));</span>
  736 |     | <span class='neutral'>    }</span>
  737 |     | <span class='neutral'></span>
  738 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {</span>
  739 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  740 |     | <span class='neutral'>    }</span>
  741 |     | <span class='neutral'></span>
  742 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, string memory p3) internal view {</span>
  743 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,string)&quot;, p0, p1, p2, p3));</span>
  744 |     | <span class='neutral'>    }</span>
  745 |     | <span class='neutral'></span>
  746 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, bool p3) internal view {</span>
  747 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
  748 |     | <span class='neutral'>    }</span>
  749 |     | <span class='neutral'></span>
  750 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, address p3) internal view {</span>
  751 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,address)&quot;, p0, p1, p2, p3));</span>
  752 |     | <span class='neutral'>    }</span>
  753 |     | <span class='neutral'></span>
  754 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, uint256 p3) internal view {</span>
  755 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
  756 |     | <span class='neutral'>    }</span>
  757 |     | <span class='neutral'></span>
  758 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, string memory p3) internal view {</span>
  759 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,string)&quot;, p0, p1, p2, p3));</span>
  760 |     | <span class='neutral'>    }</span>
  761 |     | <span class='neutral'></span>
  762 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, bool p3) internal view {</span>
  763 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,bool)&quot;, p0, p1, p2, p3));</span>
  764 |     | <span class='neutral'>    }</span>
  765 |     | <span class='neutral'></span>
  766 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, address p3) internal view {</span>
  767 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,address)&quot;, p0, p1, p2, p3));</span>
  768 |     | <span class='neutral'>    }</span>
  769 |     | <span class='neutral'></span>
  770 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {</span>
  771 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  772 |     | <span class='neutral'>    }</span>
  773 |     | <span class='neutral'></span>
  774 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {</span>
  775 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
  776 |     | <span class='neutral'>    }</span>
  777 |     | <span class='neutral'></span>
  778 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {</span>
  779 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  780 |     | <span class='neutral'>    }</span>
  781 |     | <span class='neutral'></span>
  782 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {</span>
  783 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
  784 |     | <span class='neutral'>    }</span>
  785 |     | <span class='neutral'></span>
  786 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {</span>
  787 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
  788 |     | <span class='neutral'>    }</span>
  789 |     | <span class='neutral'></span>
  790 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {</span>
  791 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
  792 |     | <span class='neutral'>    }</span>
  793 |     | <span class='neutral'></span>
  794 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {</span>
  795 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
  796 |     | <span class='neutral'>    }</span>
  797 |     | <span class='neutral'></span>
  798 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {</span>
  799 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
  800 |     | <span class='neutral'>    }</span>
  801 |     | <span class='neutral'></span>
  802 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {</span>
  803 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  804 |     | <span class='neutral'>    }</span>
  805 |     | <span class='neutral'></span>
  806 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {</span>
  807 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
  808 |     | <span class='neutral'>    }</span>
  809 |     | <span class='neutral'></span>
  810 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {</span>
  811 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
  812 |     | <span class='neutral'>    }</span>
  813 |     | <span class='neutral'></span>
  814 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2, address p3) internal view {</span>
  815 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
  816 |     | <span class='neutral'>    }</span>
  817 |     | <span class='neutral'></span>
  818 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {</span>
  819 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
  820 |     | <span class='neutral'>    }</span>
  821 |     | <span class='neutral'></span>
  822 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {</span>
  823 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
  824 |     | <span class='neutral'>    }</span>
  825 |     | <span class='neutral'></span>
  826 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2, bool p3) internal view {</span>
  827 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
  828 |     | <span class='neutral'>    }</span>
  829 |     | <span class='neutral'></span>
  830 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2, address p3) internal view {</span>
  831 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
  832 |     | <span class='neutral'>    }</span>
  833 |     | <span class='neutral'></span>
  834 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {</span>
  835 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  836 |     | <span class='neutral'>    }</span>
  837 |     | <span class='neutral'></span>
  838 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {</span>
  839 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
  840 |     | <span class='neutral'>    }</span>
  841 |     | <span class='neutral'></span>
  842 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {</span>
  843 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  844 |     | <span class='neutral'>    }</span>
  845 |     | <span class='neutral'></span>
  846 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {</span>
  847 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
  848 |     | <span class='neutral'>    }</span>
  849 |     | <span class='neutral'></span>
  850 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {</span>
  851 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
  852 |     | <span class='neutral'>    }</span>
  853 |     | <span class='neutral'></span>
  854 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {</span>
  855 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,string)&quot;, p0, p1, p2, p3));</span>
  856 |     | <span class='neutral'>    }</span>
  857 |     | <span class='neutral'></span>
  858 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {</span>
  859 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  860 |     | <span class='neutral'>    }</span>
  861 |     | <span class='neutral'></span>
  862 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {</span>
  863 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,address)&quot;, p0, p1, p2, p3));</span>
  864 |     | <span class='neutral'>    }</span>
  865 |     | <span class='neutral'></span>
  866 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {</span>
  867 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  868 |     | <span class='neutral'>    }</span>
  869 |     | <span class='neutral'></span>
  870 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {</span>
  871 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  872 |     | <span class='neutral'>    }</span>
  873 |     | <span class='neutral'></span>
  874 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {</span>
  875 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  876 |     | <span class='neutral'>    }</span>
  877 |     | <span class='neutral'></span>
  878 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, address p3) internal view {</span>
  879 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  880 |     | <span class='neutral'>    }</span>
  881 |     | <span class='neutral'></span>
  882 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {</span>
  883 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
  884 |     | <span class='neutral'>    }</span>
  885 |     | <span class='neutral'></span>
  886 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {</span>
  887 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,string)&quot;, p0, p1, p2, p3));</span>
  888 |     | <span class='neutral'>    }</span>
  889 |     | <span class='neutral'></span>
  890 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, bool p3) internal view {</span>
  891 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  892 |     | <span class='neutral'>    }</span>
  893 |     | <span class='neutral'></span>
  894 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, address p3) internal view {</span>
  895 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,address)&quot;, p0, p1, p2, p3));</span>
  896 |     | <span class='neutral'>    }</span>
  897 |     | <span class='neutral'></span>
  898 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {</span>
  899 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  900 |     | <span class='neutral'>    }</span>
  901 |     | <span class='neutral'></span>
  902 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {</span>
  903 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
  904 |     | <span class='neutral'>    }</span>
  905 |     | <span class='neutral'></span>
  906 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {</span>
  907 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  908 |     | <span class='neutral'>    }</span>
  909 |     | <span class='neutral'></span>
  910 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2, address p3) internal view {</span>
  911 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
  912 |     | <span class='neutral'>    }</span>
  913 |     | <span class='neutral'></span>
  914 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {</span>
  915 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
  916 |     | <span class='neutral'>    }</span>
  917 |     | <span class='neutral'></span>
  918 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {</span>
  919 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  920 |     | <span class='neutral'>    }</span>
  921 |     | <span class='neutral'></span>
  922 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {</span>
  923 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  924 |     | <span class='neutral'>    }</span>
  925 |     | <span class='neutral'></span>
  926 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, address p3) internal view {</span>
  927 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  928 |     | <span class='neutral'>    }</span>
  929 |     | <span class='neutral'></span>
  930 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {</span>
  931 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  932 |     | <span class='neutral'>    }</span>
  933 |     | <span class='neutral'></span>
  934 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {</span>
  935 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  936 |     | <span class='neutral'>    }</span>
  937 |     | <span class='neutral'></span>
  938 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, bool p3) internal view {</span>
  939 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  940 |     | <span class='neutral'>    }</span>
  941 |     | <span class='neutral'></span>
  942 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, address p3) internal view {</span>
  943 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  944 |     | <span class='neutral'>    }</span>
  945 |     | <span class='neutral'></span>
  946 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, uint256 p3) internal view {</span>
  947 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
  948 |     | <span class='neutral'>    }</span>
  949 |     | <span class='neutral'></span>
  950 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, string memory p3) internal view {</span>
  951 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  952 |     | <span class='neutral'>    }</span>
  953 |     | <span class='neutral'></span>
  954 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, bool p3) internal view {</span>
  955 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  956 |     | <span class='neutral'>    }</span>
  957 |     | <span class='neutral'></span>
  958 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, address p3) internal view {</span>
  959 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  960 |     | <span class='neutral'>    }</span>
  961 |     | <span class='neutral'></span>
  962 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {</span>
  963 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  964 |     | <span class='neutral'>    }</span>
  965 |     | <span class='neutral'></span>
  966 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {</span>
  967 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
  968 |     | <span class='neutral'>    }</span>
  969 |     | <span class='neutral'></span>
  970 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2, bool p3) internal view {</span>
  971 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  972 |     | <span class='neutral'>    }</span>
  973 |     | <span class='neutral'></span>
  974 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2, address p3) internal view {</span>
  975 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
  976 |     | <span class='neutral'>    }</span>
  977 |     | <span class='neutral'></span>
  978 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {</span>
  979 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
  980 |     | <span class='neutral'>    }</span>
  981 |     | <span class='neutral'></span>
  982 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {</span>
  983 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,string)&quot;, p0, p1, p2, p3));</span>
  984 |     | <span class='neutral'>    }</span>
  985 |     | <span class='neutral'></span>
  986 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, bool p3) internal view {</span>
  987 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,bool)&quot;, p0, p1, p2, p3));</span>
  988 |     | <span class='neutral'>    }</span>
  989 |     | <span class='neutral'></span>
  990 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, address p3) internal view {</span>
  991 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,address)&quot;, p0, p1, p2, p3));</span>
  992 |     | <span class='neutral'>    }</span>
  993 |     | <span class='neutral'></span>
  994 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, uint256 p3) internal view {</span>
  995 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  996 |     | <span class='neutral'>    }</span>
  997 |     | <span class='neutral'></span>
  998 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, string memory p3) internal view {</span>
  999 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1000 |     | <span class='neutral'>    }</span>
 1001 |     | <span class='neutral'></span>
 1002 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, bool p3) internal view {</span>
 1003 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1004 |     | <span class='neutral'>    }</span>
 1005 |     | <span class='neutral'></span>
 1006 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, address p3) internal view {</span>
 1007 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1008 |     | <span class='neutral'>    }</span>
 1009 |     | <span class='neutral'></span>
 1010 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, uint256 p3) internal view {</span>
 1011 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1012 |     | <span class='neutral'>    }</span>
 1013 |     | <span class='neutral'></span>
 1014 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, string memory p3) internal view {</span>
 1015 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1016 |     | <span class='neutral'>    }</span>
 1017 |     | <span class='neutral'></span>
 1018 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, bool p3) internal view {</span>
 1019 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1020 |     | <span class='neutral'>    }</span>
 1021 |     | <span class='neutral'></span>
 1022 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, address p3) internal view {</span>
 1023 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1024 |     | <span class='neutral'>    }</span>
 1025 |     | <span class='neutral'></span>
 1026 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {</span>
 1027 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1028 |     | <span class='neutral'>    }</span>
 1029 |     | <span class='neutral'></span>
 1030 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {</span>
 1031 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1032 |     | <span class='neutral'>    }</span>
 1033 |     | <span class='neutral'></span>
 1034 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {</span>
 1035 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1036 |     | <span class='neutral'>    }</span>
 1037 |     | <span class='neutral'></span>
 1038 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {</span>
 1039 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1040 |     | <span class='neutral'>    }</span>
 1041 |     | <span class='neutral'></span>
 1042 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {</span>
 1043 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1044 |     | <span class='neutral'>    }</span>
 1045 |     | <span class='neutral'></span>
 1046 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {</span>
 1047 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
 1048 |     | <span class='neutral'>    }</span>
 1049 |     | <span class='neutral'></span>
 1050 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {</span>
 1051 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
 1052 |     | <span class='neutral'>    }</span>
 1053 |     | <span class='neutral'></span>
 1054 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2, address p3) internal view {</span>
 1055 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
 1056 |     | <span class='neutral'>    }</span>
 1057 |     | <span class='neutral'></span>
 1058 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {</span>
 1059 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1060 |     | <span class='neutral'>    }</span>
 1061 |     | <span class='neutral'></span>
 1062 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {</span>
 1063 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
 1064 |     | <span class='neutral'>    }</span>
 1065 |     | <span class='neutral'></span>
 1066 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, bool p3) internal view {</span>
 1067 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1068 |     | <span class='neutral'>    }</span>
 1069 |     | <span class='neutral'></span>
 1070 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, address p3) internal view {</span>
 1071 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
 1072 |     | <span class='neutral'>    }</span>
 1073 |     | <span class='neutral'></span>
 1074 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {</span>
 1075 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1076 |     | <span class='neutral'>    }</span>
 1077 |     | <span class='neutral'></span>
 1078 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, string memory p3) internal view {</span>
 1079 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
 1080 |     | <span class='neutral'>    }</span>
 1081 |     | <span class='neutral'></span>
 1082 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, bool p3) internal view {</span>
 1083 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
 1084 |     | <span class='neutral'>    }</span>
 1085 |     | <span class='neutral'></span>
 1086 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, address p3) internal view {</span>
 1087 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
 1088 |     | <span class='neutral'>    }</span>
 1089 |     | <span class='neutral'></span>
 1090 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {</span>
 1091 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1092 |     | <span class='neutral'>    }</span>
 1093 |     | <span class='neutral'></span>
 1094 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {</span>
 1095 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1096 |     | <span class='neutral'>    }</span>
 1097 |     | <span class='neutral'></span>
 1098 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {</span>
 1099 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1100 |     | <span class='neutral'>    }</span>
 1101 |     | <span class='neutral'></span>
 1102 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2, address p3) internal view {</span>
 1103 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1104 |     | <span class='neutral'>    }</span>
 1105 |     | <span class='neutral'></span>
 1106 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {</span>
 1107 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1108 |     | <span class='neutral'>    }</span>
 1109 |     | <span class='neutral'></span>
 1110 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {</span>
 1111 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1112 |     | <span class='neutral'>    }</span>
 1113 |     | <span class='neutral'></span>
 1114 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {</span>
 1115 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1116 |     | <span class='neutral'>    }</span>
 1117 |     | <span class='neutral'></span>
 1118 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, address p3) internal view {</span>
 1119 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1120 |     | <span class='neutral'>    }</span>
 1121 |     | <span class='neutral'></span>
 1122 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {</span>
 1123 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1124 |     | <span class='neutral'>    }</span>
 1125 |     | <span class='neutral'></span>
 1126 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {</span>
 1127 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1128 |     | <span class='neutral'>    }</span>
 1129 |     | <span class='neutral'></span>
 1130 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, bool p3) internal view {</span>
 1131 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1132 |     | <span class='neutral'>    }</span>
 1133 |     | <span class='neutral'></span>
 1134 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, address p3) internal view {</span>
 1135 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1136 |     | <span class='neutral'>    }</span>
 1137 |     | <span class='neutral'></span>
 1138 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, uint256 p3) internal view {</span>
 1139 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1140 |     | <span class='neutral'>    }</span>
 1141 |     | <span class='neutral'></span>
 1142 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, string memory p3) internal view {</span>
 1143 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1144 |     | <span class='neutral'>    }</span>
 1145 |     | <span class='neutral'></span>
 1146 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, bool p3) internal view {</span>
 1147 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1148 |     | <span class='neutral'>    }</span>
 1149 |     | <span class='neutral'></span>
 1150 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, address p3) internal view {</span>
 1151 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1152 |     | <span class='neutral'>    }</span>
 1153 |     | <span class='neutral'></span>
 1154 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {</span>
 1155 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1156 |     | <span class='neutral'>    }</span>
 1157 |     | <span class='neutral'></span>
 1158 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {</span>
 1159 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1160 |     | <span class='neutral'>    }</span>
 1161 |     | <span class='neutral'></span>
 1162 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, bool p3) internal view {</span>
 1163 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1164 |     | <span class='neutral'>    }</span>
 1165 |     | <span class='neutral'></span>
 1166 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, address p3) internal view {</span>
 1167 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1168 |     | <span class='neutral'>    }</span>
 1169 |     | <span class='neutral'></span>
 1170 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {</span>
 1171 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1172 |     | <span class='neutral'>    }</span>
 1173 |     | <span class='neutral'></span>
 1174 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {</span>
 1175 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1176 |     | <span class='neutral'>    }</span>
 1177 |     | <span class='neutral'></span>
 1178 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, bool p3) internal view {</span>
 1179 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1180 |     | <span class='neutral'>    }</span>
 1181 |     | <span class='neutral'></span>
 1182 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, address p3) internal view {</span>
 1183 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1184 |     | <span class='neutral'>    }</span>
 1185 |     | <span class='neutral'></span>
 1186 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, uint256 p3) internal view {</span>
 1187 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1188 |     | <span class='neutral'>    }</span>
 1189 |     | <span class='neutral'></span>
 1190 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, string memory p3) internal view {</span>
 1191 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1192 |     | <span class='neutral'>    }</span>
 1193 |     | <span class='neutral'></span>
 1194 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, bool p3) internal view {</span>
 1195 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1196 |     | <span class='neutral'>    }</span>
 1197 |     | <span class='neutral'></span>
 1198 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, address p3) internal view {</span>
 1199 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1200 |     | <span class='neutral'>    }</span>
 1201 |     | <span class='neutral'></span>
 1202 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, uint256 p3) internal view {</span>
 1203 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1204 |     | <span class='neutral'>    }</span>
 1205 |     | <span class='neutral'></span>
 1206 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, string memory p3) internal view {</span>
 1207 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1208 |     | <span class='neutral'>    }</span>
 1209 |     | <span class='neutral'></span>
 1210 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, bool p3) internal view {</span>
 1211 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1212 |     | <span class='neutral'>    }</span>
 1213 |     | <span class='neutral'></span>
 1214 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, address p3) internal view {</span>
 1215 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1216 |     | <span class='neutral'>    }</span>
 1217 |     | <span class='neutral'></span>
 1218 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {</span>
 1219 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1220 |     | <span class='neutral'>    }</span>
 1221 |     | <span class='neutral'></span>
 1222 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, string memory p3) internal view {</span>
 1223 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1224 |     | <span class='neutral'>    }</span>
 1225 |     | <span class='neutral'></span>
 1226 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, bool p3) internal view {</span>
 1227 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1228 |     | <span class='neutral'>    }</span>
 1229 |     | <span class='neutral'></span>
 1230 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, address p3) internal view {</span>
 1231 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1232 |     | <span class='neutral'>    }</span>
 1233 |     | <span class='neutral'></span>
 1234 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, uint256 p3) internal view {</span>
 1235 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1236 |     | <span class='neutral'>    }</span>
 1237 |     | <span class='neutral'></span>
 1238 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, string memory p3) internal view {</span>
 1239 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1240 |     | <span class='neutral'>    }</span>
 1241 |     | <span class='neutral'></span>
 1242 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, bool p3) internal view {</span>
 1243 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1244 |     | <span class='neutral'>    }</span>
 1245 |     | <span class='neutral'></span>
 1246 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, address p3) internal view {</span>
 1247 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1248 |     | <span class='neutral'>    }</span>
 1249 |     | <span class='neutral'></span>
 1250 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, uint256 p3) internal view {</span>
 1251 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1252 |     | <span class='neutral'>    }</span>
 1253 |     | <span class='neutral'></span>
 1254 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, string memory p3) internal view {</span>
 1255 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1256 |     | <span class='neutral'>    }</span>
 1257 |     | <span class='neutral'></span>
 1258 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, bool p3) internal view {</span>
 1259 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1260 |     | <span class='neutral'>    }</span>
 1261 |     | <span class='neutral'></span>
 1262 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, address p3) internal view {</span>
 1263 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1264 |     | <span class='neutral'>    }</span>
 1265 |     | <span class='neutral'></span>
 1266 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, uint256 p3) internal view {</span>
 1267 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1268 |     | <span class='neutral'>    }</span>
 1269 |     | <span class='neutral'></span>
 1270 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, string memory p3) internal view {</span>
 1271 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1272 |     | <span class='neutral'>    }</span>
 1273 |     | <span class='neutral'></span>
 1274 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, bool p3) internal view {</span>
 1275 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1276 |     | <span class='neutral'>    }</span>
 1277 |     | <span class='neutral'></span>
 1278 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, address p3) internal view {</span>
 1279 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1280 |     | <span class='neutral'>    }</span>
 1281 |     | <span class='neutral'></span>
 1282 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {</span>
 1283 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1284 |     | <span class='neutral'>    }</span>
 1285 |     | <span class='neutral'></span>
 1286 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {</span>
 1287 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1288 |     | <span class='neutral'>    }</span>
 1289 |     | <span class='neutral'></span>
 1290 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {</span>
 1291 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1292 |     | <span class='neutral'>    }</span>
 1293 |     | <span class='neutral'></span>
 1294 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, address p3) internal view {</span>
 1295 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1296 |     | <span class='neutral'>    }</span>
 1297 |     | <span class='neutral'></span>
 1298 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {</span>
 1299 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1300 |     | <span class='neutral'>    }</span>
 1301 |     | <span class='neutral'></span>
 1302 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {</span>
 1303 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
 1304 |     | <span class='neutral'>    }</span>
 1305 |     | <span class='neutral'></span>
 1306 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2, bool p3) internal view {</span>
 1307 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
 1308 |     | <span class='neutral'>    }</span>
 1309 |     | <span class='neutral'></span>
 1310 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2, address p3) internal view {</span>
 1311 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
 1312 |     | <span class='neutral'>    }</span>
 1313 |     | <span class='neutral'></span>
 1314 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {</span>
 1315 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1316 |     | <span class='neutral'>    }</span>
 1317 |     | <span class='neutral'></span>
 1318 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, string memory p3) internal view {</span>
 1319 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
 1320 |     | <span class='neutral'>    }</span>
 1321 |     | <span class='neutral'></span>
 1322 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, bool p3) internal view {</span>
 1323 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1324 |     | <span class='neutral'>    }</span>
 1325 |     | <span class='neutral'></span>
 1326 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, address p3) internal view {</span>
 1327 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
 1328 |     | <span class='neutral'>    }</span>
 1329 |     | <span class='neutral'></span>
 1330 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, uint256 p3) internal view {</span>
 1331 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1332 |     | <span class='neutral'>    }</span>
 1333 |     | <span class='neutral'></span>
 1334 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, string memory p3) internal view {</span>
 1335 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
 1336 |     | <span class='neutral'>    }</span>
 1337 |     | <span class='neutral'></span>
 1338 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, bool p3) internal view {</span>
 1339 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
 1340 |     | <span class='neutral'>    }</span>
 1341 |     | <span class='neutral'></span>
 1342 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, address p3) internal view {</span>
 1343 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
 1344 |     | <span class='neutral'>    }</span>
 1345 |     | <span class='neutral'></span>
 1346 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {</span>
 1347 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1348 |     | <span class='neutral'>    }</span>
 1349 |     | <span class='neutral'></span>
 1350 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {</span>
 1351 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1352 |     | <span class='neutral'>    }</span>
 1353 |     | <span class='neutral'></span>
 1354 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2, bool p3) internal view {</span>
 1355 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1356 |     | <span class='neutral'>    }</span>
 1357 |     | <span class='neutral'></span>
 1358 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2, address p3) internal view {</span>
 1359 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1360 |     | <span class='neutral'>    }</span>
 1361 |     | <span class='neutral'></span>
 1362 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {</span>
 1363 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1364 |     | <span class='neutral'>    }</span>
 1365 |     | <span class='neutral'></span>
 1366 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {</span>
 1367 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1368 |     | <span class='neutral'>    }</span>
 1369 |     | <span class='neutral'></span>
 1370 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, bool p3) internal view {</span>
 1371 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1372 |     | <span class='neutral'>    }</span>
 1373 |     | <span class='neutral'></span>
 1374 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, address p3) internal view {</span>
 1375 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1376 |     | <span class='neutral'>    }</span>
 1377 |     | <span class='neutral'></span>
 1378 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, uint256 p3) internal view {</span>
 1379 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1380 |     | <span class='neutral'>    }</span>
 1381 |     | <span class='neutral'></span>
 1382 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, string memory p3) internal view {</span>
 1383 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1384 |     | <span class='neutral'>    }</span>
 1385 |     | <span class='neutral'></span>
 1386 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, bool p3) internal view {</span>
 1387 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1388 |     | <span class='neutral'>    }</span>
 1389 |     | <span class='neutral'></span>
 1390 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, address p3) internal view {</span>
 1391 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1392 |     | <span class='neutral'>    }</span>
 1393 |     | <span class='neutral'></span>
 1394 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, uint256 p3) internal view {</span>
 1395 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1396 |     | <span class='neutral'>    }</span>
 1397 |     | <span class='neutral'></span>
 1398 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, string memory p3) internal view {</span>
 1399 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1400 |     | <span class='neutral'>    }</span>
 1401 |     | <span class='neutral'></span>
 1402 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, bool p3) internal view {</span>
 1403 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1404 |     | <span class='neutral'>    }</span>
 1405 |     | <span class='neutral'></span>
 1406 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, address p3) internal view {</span>
 1407 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1408 |     | <span class='neutral'>    }</span>
 1409 |     | <span class='neutral'></span>
 1410 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {</span>
 1411 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1412 |     | <span class='neutral'>    }</span>
 1413 |     | <span class='neutral'></span>
 1414 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, string memory p3) internal view {</span>
 1415 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1416 |     | <span class='neutral'>    }</span>
 1417 |     | <span class='neutral'></span>
 1418 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, bool p3) internal view {</span>
 1419 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1420 |     | <span class='neutral'>    }</span>
 1421 |     | <span class='neutral'></span>
 1422 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, address p3) internal view {</span>
 1423 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1424 |     | <span class='neutral'>    }</span>
 1425 |     | <span class='neutral'></span>
 1426 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, uint256 p3) internal view {</span>
 1427 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1428 |     | <span class='neutral'>    }</span>
 1429 |     | <span class='neutral'></span>
 1430 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, string memory p3) internal view {</span>
 1431 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1432 |     | <span class='neutral'>    }</span>
 1433 |     | <span class='neutral'></span>
 1434 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, bool p3) internal view {</span>
 1435 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1436 |     | <span class='neutral'>    }</span>
 1437 |     | <span class='neutral'></span>
 1438 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, address p3) internal view {</span>
 1439 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1440 |     | <span class='neutral'>    }</span>
 1441 |     | <span class='neutral'></span>
 1442 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, uint256 p3) internal view {</span>
 1443 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1444 |     | <span class='neutral'>    }</span>
 1445 |     | <span class='neutral'></span>
 1446 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, string memory p3) internal view {</span>
 1447 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1448 |     | <span class='neutral'>    }</span>
 1449 |     | <span class='neutral'></span>
 1450 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, bool p3) internal view {</span>
 1451 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1452 |     | <span class='neutral'>    }</span>
 1453 |     | <span class='neutral'></span>
 1454 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, address p3) internal view {</span>
 1455 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1456 |     | <span class='neutral'>    }</span>
 1457 |     | <span class='neutral'></span>
 1458 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, uint256 p3) internal view {</span>
 1459 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1460 |     | <span class='neutral'>    }</span>
 1461 |     | <span class='neutral'></span>
 1462 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, string memory p3) internal view {</span>
 1463 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1464 |     | <span class='neutral'>    }</span>
 1465 |     | <span class='neutral'></span>
 1466 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, bool p3) internal view {</span>
 1467 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1468 |     | <span class='neutral'>    }</span>
 1469 |     | <span class='neutral'></span>
 1470 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, address p3) internal view {</span>
 1471 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1472 |     | <span class='neutral'>    }</span>
 1473 |     | <span class='neutral'></span>
 1474 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, uint256 p3) internal view {</span>
 1475 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1476 |     | <span class='neutral'>    }</span>
 1477 |     | <span class='neutral'></span>
 1478 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, string memory p3) internal view {</span>
 1479 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1480 |     | <span class='neutral'>    }</span>
 1481 |     | <span class='neutral'></span>
 1482 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, bool p3) internal view {</span>
 1483 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1484 |     | <span class='neutral'>    }</span>
 1485 |     | <span class='neutral'></span>
 1486 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, address p3) internal view {</span>
 1487 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1488 |     | <span class='neutral'>    }</span>
 1489 |     | <span class='neutral'></span>
 1490 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, uint256 p3) internal view {</span>
 1491 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1492 |     | <span class='neutral'>    }</span>
 1493 |     | <span class='neutral'></span>
 1494 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, string memory p3) internal view {</span>
 1495 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1496 |     | <span class='neutral'>    }</span>
 1497 |     | <span class='neutral'></span>
 1498 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, bool p3) internal view {</span>
 1499 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1500 |     | <span class='neutral'>    }</span>
 1501 |     | <span class='neutral'></span>
 1502 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, address p3) internal view {</span>
 1503 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1504 |     | <span class='neutral'>    }</span>
 1505 |     | <span class='neutral'></span>
 1506 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, uint256 p3) internal view {</span>
 1507 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1508 |     | <span class='neutral'>    }</span>
 1509 |     | <span class='neutral'></span>
 1510 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, string memory p3) internal view {</span>
 1511 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1512 |     | <span class='neutral'>    }</span>
 1513 |     | <span class='neutral'></span>
 1514 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, bool p3) internal view {</span>
 1515 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1516 |     | <span class='neutral'>    }</span>
 1517 |     | <span class='neutral'></span>
 1518 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, address p3) internal view {</span>
 1519 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1520 |     | <span class='neutral'>    }</span>
 1521 |     | <span class='neutral'></span>
 1522 |     | <span class='neutral'>    function log(address p0, address p1, address p2, uint256 p3) internal view {</span>
 1523 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1524 |     | <span class='neutral'>    }</span>
 1525 |     | <span class='neutral'></span>
 1526 |     | <span class='neutral'>    function log(address p0, address p1, address p2, string memory p3) internal view {</span>
 1527 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1528 |     | <span class='neutral'>    }</span>
 1529 |     | <span class='neutral'></span>
 1530 |     | <span class='neutral'>    function log(address p0, address p1, address p2, bool p3) internal view {</span>
 1531 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1532 |     | <span class='neutral'>    }</span>
 1533 |     | <span class='neutral'></span>
 1534 |     | <span class='neutral'>    function log(address p0, address p1, address p2, address p3) internal view {</span>
 1535 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1536 |     | <span class='neutral'>    }</span>
 1537 |     | <span class='neutral'></span>
 1538 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/node_modules/hardhat/console.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
    2 |     | <span class='neutral'>pragma solidity &gt;= 0.4.22 &lt;0.9.0;</span>
    3 |     | <span class='unexecuted'></span>
    4 |     | <span class='neutral'>library console {</span>
    5 |     | <span class='neutral'>	address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);</span>
    6 |     | <span class='neutral'></span>
    7 |     | <span class='neutral'>	function _sendLogPayload(bytes memory payload) private view {</span>
    8 |     | <span class='neutral'>		uint256 payloadLength = payload.length;</span>
    9 |     | <span class='neutral'>		address consoleAddress = CONSOLE_ADDRESS;</span>
   10 |     | <span class='neutral'>		assembly {</span>
   11 |     | <span class='neutral'>			let payloadStart := add(payload, 32)</span>
   12 |     | <span class='neutral'>			let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)</span>
   13 |     | <span class='neutral'>		}</span>
   14 |     | <span class='neutral'>	}</span>
   15 |     | <span class='neutral'></span>
   16 |     | <span class='neutral'>	function log() internal view {</span>
   17 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log()&quot;));</span>
   18 |     | <span class='neutral'>	}</span>
   19 |     | <span class='neutral'></span>
   20 |     | <span class='neutral'>	function logInt(int256 p0) internal view {</span>
   21 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(int256)&quot;, p0));</span>
   22 |     | <span class='neutral'>	}</span>
   23 |     | <span class='neutral'></span>
   24 |     | <span class='neutral'>	function logUint(uint256 p0) internal view {</span>
   25 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256)&quot;, p0));</span>
   26 |     | <span class='neutral'>	}</span>
   27 |     | <span class='neutral'></span>
   28 |     | <span class='neutral'>	function logString(string memory p0) internal view {</span>
   29 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
   30 |     | <span class='neutral'>	}</span>
   31 |     | <span class='neutral'></span>
   32 |     | <span class='neutral'>	function logBool(bool p0) internal view {</span>
   33 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
   34 |     | <span class='neutral'>	}</span>
   35 |     | <span class='neutral'></span>
   36 |     | <span class='neutral'>	function logAddress(address p0) internal view {</span>
   37 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
   38 |     | <span class='neutral'>	}</span>
   39 |     | <span class='neutral'></span>
   40 |     | <span class='neutral'>	function logBytes(bytes memory p0) internal view {</span>
   41 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes)&quot;, p0));</span>
   42 |     | <span class='neutral'>	}</span>
   43 |     | <span class='neutral'></span>
   44 |     | <span class='neutral'>	function logBytes1(bytes1 p0) internal view {</span>
   45 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes1)&quot;, p0));</span>
   46 |     | <span class='neutral'>	}</span>
   47 |     | <span class='neutral'></span>
   48 |     | <span class='neutral'>	function logBytes2(bytes2 p0) internal view {</span>
   49 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes2)&quot;, p0));</span>
   50 |     | <span class='neutral'>	}</span>
   51 |     | <span class='neutral'></span>
   52 |     | <span class='neutral'>	function logBytes3(bytes3 p0) internal view {</span>
   53 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes3)&quot;, p0));</span>
   54 |     | <span class='neutral'>	}</span>
   55 |     | <span class='neutral'></span>
   56 |     | <span class='neutral'>	function logBytes4(bytes4 p0) internal view {</span>
   57 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes4)&quot;, p0));</span>
   58 |     | <span class='neutral'>	}</span>
   59 |     | <span class='neutral'></span>
   60 |     | <span class='neutral'>	function logBytes5(bytes5 p0) internal view {</span>
   61 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes5)&quot;, p0));</span>
   62 |     | <span class='neutral'>	}</span>
   63 |     | <span class='neutral'></span>
   64 |     | <span class='neutral'>	function logBytes6(bytes6 p0) internal view {</span>
   65 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes6)&quot;, p0));</span>
   66 |     | <span class='neutral'>	}</span>
   67 |     | <span class='neutral'></span>
   68 |     | <span class='neutral'>	function logBytes7(bytes7 p0) internal view {</span>
   69 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes7)&quot;, p0));</span>
   70 |     | <span class='neutral'>	}</span>
   71 |     | <span class='neutral'></span>
   72 |     | <span class='neutral'>	function logBytes8(bytes8 p0) internal view {</span>
   73 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes8)&quot;, p0));</span>
   74 |     | <span class='neutral'>	}</span>
   75 |     | <span class='neutral'></span>
   76 |     | <span class='neutral'>	function logBytes9(bytes9 p0) internal view {</span>
   77 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes9)&quot;, p0));</span>
   78 |     | <span class='neutral'>	}</span>
   79 |     | <span class='neutral'></span>
   80 |     | <span class='neutral'>	function logBytes10(bytes10 p0) internal view {</span>
   81 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes10)&quot;, p0));</span>
   82 |     | <span class='neutral'>	}</span>
   83 |     | <span class='neutral'></span>
   84 |     | <span class='neutral'>	function logBytes11(bytes11 p0) internal view {</span>
   85 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes11)&quot;, p0));</span>
   86 |     | <span class='neutral'>	}</span>
   87 |     | <span class='neutral'></span>
   88 |     | <span class='neutral'>	function logBytes12(bytes12 p0) internal view {</span>
   89 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes12)&quot;, p0));</span>
   90 |     | <span class='neutral'>	}</span>
   91 |     | <span class='neutral'></span>
   92 |     | <span class='neutral'>	function logBytes13(bytes13 p0) internal view {</span>
   93 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes13)&quot;, p0));</span>
   94 |     | <span class='neutral'>	}</span>
   95 |     | <span class='neutral'></span>
   96 |     | <span class='neutral'>	function logBytes14(bytes14 p0) internal view {</span>
   97 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes14)&quot;, p0));</span>
   98 |     | <span class='neutral'>	}</span>
   99 |     | <span class='neutral'></span>
  100 |     | <span class='neutral'>	function logBytes15(bytes15 p0) internal view {</span>
  101 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes15)&quot;, p0));</span>
  102 |     | <span class='neutral'>	}</span>
  103 |     | <span class='neutral'></span>
  104 |     | <span class='neutral'>	function logBytes16(bytes16 p0) internal view {</span>
  105 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes16)&quot;, p0));</span>
  106 |     | <span class='neutral'>	}</span>
  107 |     | <span class='neutral'></span>
  108 |     | <span class='neutral'>	function logBytes17(bytes17 p0) internal view {</span>
  109 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes17)&quot;, p0));</span>
  110 |     | <span class='neutral'>	}</span>
  111 |     | <span class='neutral'></span>
  112 |     | <span class='neutral'>	function logBytes18(bytes18 p0) internal view {</span>
  113 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes18)&quot;, p0));</span>
  114 |     | <span class='neutral'>	}</span>
  115 |     | <span class='neutral'></span>
  116 |     | <span class='neutral'>	function logBytes19(bytes19 p0) internal view {</span>
  117 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes19)&quot;, p0));</span>
  118 |     | <span class='neutral'>	}</span>
  119 |     | <span class='neutral'></span>
  120 |     | <span class='neutral'>	function logBytes20(bytes20 p0) internal view {</span>
  121 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes20)&quot;, p0));</span>
  122 |     | <span class='neutral'>	}</span>
  123 |     | <span class='neutral'></span>
  124 |     | <span class='neutral'>	function logBytes21(bytes21 p0) internal view {</span>
  125 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes21)&quot;, p0));</span>
  126 |     | <span class='neutral'>	}</span>
  127 |     | <span class='neutral'></span>
  128 |     | <span class='neutral'>	function logBytes22(bytes22 p0) internal view {</span>
  129 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes22)&quot;, p0));</span>
  130 |     | <span class='neutral'>	}</span>
  131 |     | <span class='neutral'></span>
  132 |     | <span class='neutral'>	function logBytes23(bytes23 p0) internal view {</span>
  133 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes23)&quot;, p0));</span>
  134 |     | <span class='neutral'>	}</span>
  135 |     | <span class='neutral'></span>
  136 |     | <span class='neutral'>	function logBytes24(bytes24 p0) internal view {</span>
  137 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes24)&quot;, p0));</span>
  138 |     | <span class='neutral'>	}</span>
  139 |     | <span class='neutral'></span>
  140 |     | <span class='neutral'>	function logBytes25(bytes25 p0) internal view {</span>
  141 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes25)&quot;, p0));</span>
  142 |     | <span class='neutral'>	}</span>
  143 |     | <span class='neutral'></span>
  144 |     | <span class='neutral'>	function logBytes26(bytes26 p0) internal view {</span>
  145 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes26)&quot;, p0));</span>
  146 |     | <span class='neutral'>	}</span>
  147 |     | <span class='neutral'></span>
  148 |     | <span class='neutral'>	function logBytes27(bytes27 p0) internal view {</span>
  149 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes27)&quot;, p0));</span>
  150 |     | <span class='neutral'>	}</span>
  151 |     | <span class='neutral'></span>
  152 |     | <span class='neutral'>	function logBytes28(bytes28 p0) internal view {</span>
  153 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes28)&quot;, p0));</span>
  154 |     | <span class='neutral'>	}</span>
  155 |     | <span class='neutral'></span>
  156 |     | <span class='neutral'>	function logBytes29(bytes29 p0) internal view {</span>
  157 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes29)&quot;, p0));</span>
  158 |     | <span class='neutral'>	}</span>
  159 |     | <span class='neutral'></span>
  160 |     | <span class='neutral'>	function logBytes30(bytes30 p0) internal view {</span>
  161 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes30)&quot;, p0));</span>
  162 |     | <span class='neutral'>	}</span>
  163 |     | <span class='neutral'></span>
  164 |     | <span class='neutral'>	function logBytes31(bytes31 p0) internal view {</span>
  165 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes31)&quot;, p0));</span>
  166 |     | <span class='neutral'>	}</span>
  167 |     | <span class='neutral'></span>
  168 |     | <span class='neutral'>	function logBytes32(bytes32 p0) internal view {</span>
  169 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bytes32)&quot;, p0));</span>
  170 |     | <span class='neutral'>	}</span>
  171 |     | <span class='neutral'></span>
  172 |     | <span class='neutral'>	function log(uint256 p0) internal view {</span>
  173 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256)&quot;, p0));</span>
  174 |     | <span class='neutral'>	}</span>
  175 |     | <span class='neutral'></span>
  176 |     | <span class='neutral'>	function log(string memory p0) internal view {</span>
  177 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
  178 |     | <span class='neutral'>	}</span>
  179 |     | <span class='neutral'></span>
  180 |     | <span class='neutral'>	function log(bool p0) internal view {</span>
  181 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
  182 |     | <span class='neutral'>	}</span>
  183 |     | <span class='neutral'></span>
  184 |     | <span class='neutral'>	function log(address p0) internal view {</span>
  185 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
  186 |     | <span class='neutral'>	}</span>
  187 |     | <span class='neutral'></span>
  188 |     | <span class='neutral'>	function log(uint256 p0, uint256 p1) internal view {</span>
  189 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256)&quot;, p0, p1));</span>
  190 |     | <span class='neutral'>	}</span>
  191 |     | <span class='neutral'></span>
  192 |     | <span class='neutral'>	function log(uint256 p0, string memory p1) internal view {</span>
  193 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string)&quot;, p0, p1));</span>
  194 |     | <span class='neutral'>	}</span>
  195 |     | <span class='neutral'></span>
  196 |     | <span class='neutral'>	function log(uint256 p0, bool p1) internal view {</span>
  197 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool)&quot;, p0, p1));</span>
  198 |     | <span class='neutral'>	}</span>
  199 |     | <span class='neutral'></span>
  200 |     | <span class='neutral'>	function log(uint256 p0, address p1) internal view {</span>
  201 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address)&quot;, p0, p1));</span>
  202 |     | <span class='neutral'>	}</span>
  203 |     | <span class='neutral'></span>
  204 |     | <span class='neutral'>	function log(string memory p0, uint256 p1) internal view {</span>
  205 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256)&quot;, p0, p1));</span>
  206 |     | <span class='neutral'>	}</span>
  207 |     | <span class='neutral'></span>
  208 |     | <span class='neutral'>	function log(string memory p0, string memory p1) internal view {</span>
  209 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,string)&quot;, p0, p1));</span>
  210 |     | <span class='neutral'>	}</span>
  211 |     | <span class='neutral'></span>
  212 |     | <span class='neutral'>	function log(string memory p0, bool p1) internal view {</span>
  213 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool)&quot;, p0, p1));</span>
  214 |     | <span class='neutral'>	}</span>
  215 |     | <span class='neutral'></span>
  216 |     | <span class='neutral'>	function log(string memory p0, address p1) internal view {</span>
  217 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,address)&quot;, p0, p1));</span>
  218 |     | <span class='neutral'>	}</span>
  219 |     | <span class='neutral'></span>
  220 |     | <span class='neutral'>	function log(bool p0, uint256 p1) internal view {</span>
  221 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256)&quot;, p0, p1));</span>
  222 |     | <span class='neutral'>	}</span>
  223 |     | <span class='neutral'></span>
  224 |     | <span class='neutral'>	function log(bool p0, string memory p1) internal view {</span>
  225 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string)&quot;, p0, p1));</span>
  226 |     | <span class='neutral'>	}</span>
  227 |     | <span class='neutral'></span>
  228 |     | <span class='neutral'>	function log(bool p0, bool p1) internal view {</span>
  229 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool)&quot;, p0, p1));</span>
  230 |     | <span class='neutral'>	}</span>
  231 |     | <span class='neutral'></span>
  232 |     | <span class='neutral'>	function log(bool p0, address p1) internal view {</span>
  233 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address)&quot;, p0, p1));</span>
  234 |     | <span class='neutral'>	}</span>
  235 |     | <span class='neutral'></span>
  236 |     | <span class='neutral'>	function log(address p0, uint256 p1) internal view {</span>
  237 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256)&quot;, p0, p1));</span>
  238 |     | <span class='neutral'>	}</span>
  239 |     | <span class='neutral'></span>
  240 |     | <span class='neutral'>	function log(address p0, string memory p1) internal view {</span>
  241 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,string)&quot;, p0, p1));</span>
  242 |     | <span class='neutral'>	}</span>
  243 |     | <span class='neutral'></span>
  244 |     | <span class='neutral'>	function log(address p0, bool p1) internal view {</span>
  245 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool)&quot;, p0, p1));</span>
  246 |     | <span class='neutral'>	}</span>
  247 |     | <span class='neutral'></span>
  248 |     | <span class='neutral'>	function log(address p0, address p1) internal view {</span>
  249 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,address)&quot;, p0, p1));</span>
  250 |     | <span class='neutral'>	}</span>
  251 |     | <span class='neutral'></span>
  252 |     | <span class='neutral'>	function log(uint256 p0, uint256 p1, uint256 p2) internal view {</span>
  253 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256)&quot;, p0, p1, p2));</span>
  254 |     | <span class='neutral'>	}</span>
  255 |     | <span class='neutral'></span>
  256 |     | <span class='neutral'>	function log(uint256 p0, uint256 p1, string memory p2) internal view {</span>
  257 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string)&quot;, p0, p1, p2));</span>
  258 |     | <span class='neutral'>	}</span>
  259 |     | <span class='neutral'></span>
  260 |     | <span class='neutral'>	function log(uint256 p0, uint256 p1, bool p2) internal view {</span>
  261 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool)&quot;, p0, p1, p2));</span>
  262 |     | <span class='neutral'>	}</span>
  263 |     | <span class='neutral'></span>
  264 |     | <span class='neutral'>	function log(uint256 p0, uint256 p1, address p2) internal view {</span>
  265 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address)&quot;, p0, p1, p2));</span>
  266 |     | <span class='neutral'>	}</span>
  267 |     | <span class='neutral'></span>
  268 |     | <span class='neutral'>	function log(uint256 p0, string memory p1, uint256 p2) internal view {</span>
  269 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256)&quot;, p0, p1, p2));</span>
  270 |     | <span class='neutral'>	}</span>
  271 |     | <span class='neutral'></span>
  272 |     | <span class='neutral'>	function log(uint256 p0, string memory p1, string memory p2) internal view {</span>
  273 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string)&quot;, p0, p1, p2));</span>
  274 |     | <span class='neutral'>	}</span>
  275 |     | <span class='neutral'></span>
  276 |     | <span class='neutral'>	function log(uint256 p0, string memory p1, bool p2) internal view {</span>
  277 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool)&quot;, p0, p1, p2));</span>
  278 |     | <span class='neutral'>	}</span>
  279 |     | <span class='neutral'></span>
  280 |     | <span class='neutral'>	function log(uint256 p0, string memory p1, address p2) internal view {</span>
  281 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address)&quot;, p0, p1, p2));</span>
  282 |     | <span class='neutral'>	}</span>
  283 |     | <span class='neutral'></span>
  284 |     | <span class='neutral'>	function log(uint256 p0, bool p1, uint256 p2) internal view {</span>
  285 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256)&quot;, p0, p1, p2));</span>
  286 |     | <span class='neutral'>	}</span>
  287 |     | <span class='neutral'></span>
  288 |     | <span class='neutral'>	function log(uint256 p0, bool p1, string memory p2) internal view {</span>
  289 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string)&quot;, p0, p1, p2));</span>
  290 |     | <span class='neutral'>	}</span>
  291 |     | <span class='neutral'></span>
  292 |     | <span class='neutral'>	function log(uint256 p0, bool p1, bool p2) internal view {</span>
  293 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool)&quot;, p0, p1, p2));</span>
  294 |     | <span class='neutral'>	}</span>
  295 |     | <span class='neutral'></span>
  296 |     | <span class='neutral'>	function log(uint256 p0, bool p1, address p2) internal view {</span>
  297 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address)&quot;, p0, p1, p2));</span>
  298 |     | <span class='neutral'>	}</span>
  299 |     | <span class='neutral'></span>
  300 |     | <span class='neutral'>	function log(uint256 p0, address p1, uint256 p2) internal view {</span>
  301 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256)&quot;, p0, p1, p2));</span>
  302 |     | <span class='neutral'>	}</span>
  303 |     | <span class='neutral'></span>
  304 |     | <span class='neutral'>	function log(uint256 p0, address p1, string memory p2) internal view {</span>
  305 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string)&quot;, p0, p1, p2));</span>
  306 |     | <span class='neutral'>	}</span>
  307 |     | <span class='neutral'></span>
  308 |     | <span class='neutral'>	function log(uint256 p0, address p1, bool p2) internal view {</span>
  309 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool)&quot;, p0, p1, p2));</span>
  310 |     | <span class='neutral'>	}</span>
  311 |     | <span class='neutral'></span>
  312 |     | <span class='neutral'>	function log(uint256 p0, address p1, address p2) internal view {</span>
  313 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address)&quot;, p0, p1, p2));</span>
  314 |     | <span class='neutral'>	}</span>
  315 |     | <span class='neutral'></span>
  316 |     | <span class='neutral'>	function log(string memory p0, uint256 p1, uint256 p2) internal view {</span>
  317 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256)&quot;, p0, p1, p2));</span>
  318 |     | <span class='neutral'>	}</span>
  319 |     | <span class='neutral'></span>
  320 |     | <span class='neutral'>	function log(string memory p0, uint256 p1, string memory p2) internal view {</span>
  321 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string)&quot;, p0, p1, p2));</span>
  322 |     | <span class='neutral'>	}</span>
  323 |     | <span class='neutral'></span>
  324 |     | <span class='neutral'>	function log(string memory p0, uint256 p1, bool p2) internal view {</span>
  325 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool)&quot;, p0, p1, p2));</span>
  326 |     | <span class='neutral'>	}</span>
  327 |     | <span class='neutral'></span>
  328 |     | <span class='neutral'>	function log(string memory p0, uint256 p1, address p2) internal view {</span>
  329 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address)&quot;, p0, p1, p2));</span>
  330 |     | <span class='neutral'>	}</span>
  331 |     | <span class='neutral'></span>
  332 |     | <span class='neutral'>	function log(string memory p0, string memory p1, uint256 p2) internal view {</span>
  333 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256)&quot;, p0, p1, p2));</span>
  334 |     | <span class='neutral'>	}</span>
  335 |     | <span class='neutral'></span>
  336 |     | <span class='neutral'>	function log(string memory p0, string memory p1, string memory p2) internal view {</span>
  337 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string)&quot;, p0, p1, p2));</span>
  338 |     | <span class='neutral'>	}</span>
  339 |     | <span class='neutral'></span>
  340 |     | <span class='neutral'>	function log(string memory p0, string memory p1, bool p2) internal view {</span>
  341 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool)&quot;, p0, p1, p2));</span>
  342 |     | <span class='neutral'>	}</span>
  343 |     | <span class='neutral'></span>
  344 |     | <span class='neutral'>	function log(string memory p0, string memory p1, address p2) internal view {</span>
  345 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address)&quot;, p0, p1, p2));</span>
  346 |     | <span class='neutral'>	}</span>
  347 |     | <span class='neutral'></span>
  348 |     | <span class='neutral'>	function log(string memory p0, bool p1, uint256 p2) internal view {</span>
  349 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256)&quot;, p0, p1, p2));</span>
  350 |     | <span class='neutral'>	}</span>
  351 |     | <span class='neutral'></span>
  352 |     | <span class='neutral'>	function log(string memory p0, bool p1, string memory p2) internal view {</span>
  353 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string)&quot;, p0, p1, p2));</span>
  354 |     | <span class='neutral'>	}</span>
  355 |     | <span class='neutral'></span>
  356 |     | <span class='neutral'>	function log(string memory p0, bool p1, bool p2) internal view {</span>
  357 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool)&quot;, p0, p1, p2));</span>
  358 |     | <span class='neutral'>	}</span>
  359 |     | <span class='neutral'></span>
  360 |     | <span class='neutral'>	function log(string memory p0, bool p1, address p2) internal view {</span>
  361 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address)&quot;, p0, p1, p2));</span>
  362 |     | <span class='neutral'>	}</span>
  363 |     | <span class='neutral'></span>
  364 |     | <span class='neutral'>	function log(string memory p0, address p1, uint256 p2) internal view {</span>
  365 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256)&quot;, p0, p1, p2));</span>
  366 |     | <span class='neutral'>	}</span>
  367 |     | <span class='neutral'></span>
  368 |     | <span class='neutral'>	function log(string memory p0, address p1, string memory p2) internal view {</span>
  369 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string)&quot;, p0, p1, p2));</span>
  370 |     | <span class='neutral'>	}</span>
  371 |     | <span class='neutral'></span>
  372 |     | <span class='neutral'>	function log(string memory p0, address p1, bool p2) internal view {</span>
  373 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool)&quot;, p0, p1, p2));</span>
  374 |     | <span class='neutral'>	}</span>
  375 |     | <span class='neutral'></span>
  376 |     | <span class='neutral'>	function log(string memory p0, address p1, address p2) internal view {</span>
  377 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address)&quot;, p0, p1, p2));</span>
  378 |     | <span class='neutral'>	}</span>
  379 |     | <span class='neutral'></span>
  380 |     | <span class='neutral'>	function log(bool p0, uint256 p1, uint256 p2) internal view {</span>
  381 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256)&quot;, p0, p1, p2));</span>
  382 |     | <span class='neutral'>	}</span>
  383 |     | <span class='neutral'></span>
  384 |     | <span class='neutral'>	function log(bool p0, uint256 p1, string memory p2) internal view {</span>
  385 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string)&quot;, p0, p1, p2));</span>
  386 |     | <span class='neutral'>	}</span>
  387 |     | <span class='neutral'></span>
  388 |     | <span class='neutral'>	function log(bool p0, uint256 p1, bool p2) internal view {</span>
  389 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool)&quot;, p0, p1, p2));</span>
  390 |     | <span class='neutral'>	}</span>
  391 |     | <span class='neutral'></span>
  392 |     | <span class='neutral'>	function log(bool p0, uint256 p1, address p2) internal view {</span>
  393 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address)&quot;, p0, p1, p2));</span>
  394 |     | <span class='neutral'>	}</span>
  395 |     | <span class='neutral'></span>
  396 |     | <span class='neutral'>	function log(bool p0, string memory p1, uint256 p2) internal view {</span>
  397 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256)&quot;, p0, p1, p2));</span>
  398 |     | <span class='neutral'>	}</span>
  399 |     | <span class='neutral'></span>
  400 |     | <span class='neutral'>	function log(bool p0, string memory p1, string memory p2) internal view {</span>
  401 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string)&quot;, p0, p1, p2));</span>
  402 |     | <span class='neutral'>	}</span>
  403 |     | <span class='neutral'></span>
  404 |     | <span class='neutral'>	function log(bool p0, string memory p1, bool p2) internal view {</span>
  405 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool)&quot;, p0, p1, p2));</span>
  406 |     | <span class='neutral'>	}</span>
  407 |     | <span class='neutral'></span>
  408 |     | <span class='neutral'>	function log(bool p0, string memory p1, address p2) internal view {</span>
  409 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address)&quot;, p0, p1, p2));</span>
  410 |     | <span class='neutral'>	}</span>
  411 |     | <span class='neutral'></span>
  412 |     | <span class='neutral'>	function log(bool p0, bool p1, uint256 p2) internal view {</span>
  413 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256)&quot;, p0, p1, p2));</span>
  414 |     | <span class='neutral'>	}</span>
  415 |     | <span class='neutral'></span>
  416 |     | <span class='neutral'>	function log(bool p0, bool p1, string memory p2) internal view {</span>
  417 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string)&quot;, p0, p1, p2));</span>
  418 |     | <span class='neutral'>	}</span>
  419 |     | <span class='neutral'></span>
  420 |     | <span class='neutral'>	function log(bool p0, bool p1, bool p2) internal view {</span>
  421 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool)&quot;, p0, p1, p2));</span>
  422 |     | <span class='neutral'>	}</span>
  423 |     | <span class='neutral'></span>
  424 |     | <span class='neutral'>	function log(bool p0, bool p1, address p2) internal view {</span>
  425 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address)&quot;, p0, p1, p2));</span>
  426 |     | <span class='neutral'>	}</span>
  427 |     | <span class='neutral'></span>
  428 |     | <span class='neutral'>	function log(bool p0, address p1, uint256 p2) internal view {</span>
  429 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256)&quot;, p0, p1, p2));</span>
  430 |     | <span class='neutral'>	}</span>
  431 |     | <span class='neutral'></span>
  432 |     | <span class='neutral'>	function log(bool p0, address p1, string memory p2) internal view {</span>
  433 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string)&quot;, p0, p1, p2));</span>
  434 |     | <span class='neutral'>	}</span>
  435 |     | <span class='neutral'></span>
  436 |     | <span class='neutral'>	function log(bool p0, address p1, bool p2) internal view {</span>
  437 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool)&quot;, p0, p1, p2));</span>
  438 |     | <span class='neutral'>	}</span>
  439 |     | <span class='neutral'></span>
  440 |     | <span class='neutral'>	function log(bool p0, address p1, address p2) internal view {</span>
  441 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address)&quot;, p0, p1, p2));</span>
  442 |     | <span class='neutral'>	}</span>
  443 |     | <span class='neutral'></span>
  444 |     | <span class='neutral'>	function log(address p0, uint256 p1, uint256 p2) internal view {</span>
  445 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256)&quot;, p0, p1, p2));</span>
  446 |     | <span class='neutral'>	}</span>
  447 |     | <span class='neutral'></span>
  448 |     | <span class='neutral'>	function log(address p0, uint256 p1, string memory p2) internal view {</span>
  449 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string)&quot;, p0, p1, p2));</span>
  450 |     | <span class='neutral'>	}</span>
  451 |     | <span class='neutral'></span>
  452 |     | <span class='neutral'>	function log(address p0, uint256 p1, bool p2) internal view {</span>
  453 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool)&quot;, p0, p1, p2));</span>
  454 |     | <span class='neutral'>	}</span>
  455 |     | <span class='neutral'></span>
  456 |     | <span class='neutral'>	function log(address p0, uint256 p1, address p2) internal view {</span>
  457 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address)&quot;, p0, p1, p2));</span>
  458 |     | <span class='neutral'>	}</span>
  459 |     | <span class='neutral'></span>
  460 |     | <span class='neutral'>	function log(address p0, string memory p1, uint256 p2) internal view {</span>
  461 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256)&quot;, p0, p1, p2));</span>
  462 |     | <span class='neutral'>	}</span>
  463 |     | <span class='neutral'></span>
  464 |     | <span class='neutral'>	function log(address p0, string memory p1, string memory p2) internal view {</span>
  465 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string)&quot;, p0, p1, p2));</span>
  466 |     | <span class='neutral'>	}</span>
  467 |     | <span class='neutral'></span>
  468 |     | <span class='neutral'>	function log(address p0, string memory p1, bool p2) internal view {</span>
  469 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool)&quot;, p0, p1, p2));</span>
  470 |     | <span class='neutral'>	}</span>
  471 |     | <span class='neutral'></span>
  472 |     | <span class='neutral'>	function log(address p0, string memory p1, address p2) internal view {</span>
  473 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address)&quot;, p0, p1, p2));</span>
  474 |     | <span class='neutral'>	}</span>
  475 |     | <span class='neutral'></span>
  476 |     | <span class='neutral'>	function log(address p0, bool p1, uint256 p2) internal view {</span>
  477 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256)&quot;, p0, p1, p2));</span>
  478 |     | <span class='neutral'>	}</span>
  479 |     | <span class='neutral'></span>
  480 |     | <span class='neutral'>	function log(address p0, bool p1, string memory p2) internal view {</span>
  481 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string)&quot;, p0, p1, p2));</span>
  482 |     | <span class='neutral'>	}</span>
  483 |     | <span class='neutral'></span>
  484 |     | <span class='neutral'>	function log(address p0, bool p1, bool p2) internal view {</span>
  485 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool)&quot;, p0, p1, p2));</span>
  486 |     | <span class='neutral'>	}</span>
  487 |     | <span class='neutral'></span>
  488 |     | <span class='neutral'>	function log(address p0, bool p1, address p2) internal view {</span>
  489 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address)&quot;, p0, p1, p2));</span>
  490 |     | <span class='neutral'>	}</span>
  491 |     | <span class='neutral'></span>
  492 |     | <span class='neutral'>	function log(address p0, address p1, uint256 p2) internal view {</span>
  493 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256)&quot;, p0, p1, p2));</span>
  494 |     | <span class='neutral'>	}</span>
  495 |     | <span class='neutral'></span>
  496 |     | <span class='neutral'>	function log(address p0, address p1, string memory p2) internal view {</span>
  497 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string)&quot;, p0, p1, p2));</span>
  498 |     | <span class='neutral'>	}</span>
  499 |     | <span class='neutral'></span>
  500 |     | <span class='neutral'>	function log(address p0, address p1, bool p2) internal view {</span>
  501 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool)&quot;, p0, p1, p2));</span>
  502 |     | <span class='neutral'>	}</span>
  503 |     | <span class='neutral'></span>
  504 |     | <span class='neutral'>	function log(address p0, address p1, address p2) internal view {</span>
  505 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address)&quot;, p0, p1, p2));</span>
  506 |     | <span class='neutral'>	}</span>
  507 |     | <span class='neutral'></span>
  508 |     | <span class='neutral'>	function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {</span>
  509 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  510 |     | <span class='neutral'>	}</span>
  511 |     | <span class='neutral'></span>
  512 |     | <span class='neutral'>	function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {</span>
  513 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
  514 |     | <span class='neutral'>	}</span>
  515 |     | <span class='neutral'></span>
  516 |     | <span class='neutral'>	function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {</span>
  517 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  518 |     | <span class='neutral'>	}</span>
  519 |     | <span class='neutral'></span>
  520 |     | <span class='neutral'>	function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {</span>
  521 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
  522 |     | <span class='neutral'>	}</span>
  523 |     | <span class='neutral'></span>
  524 |     | <span class='neutral'>	function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {</span>
  525 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
  526 |     | <span class='neutral'>	}</span>
  527 |     | <span class='neutral'></span>
  528 |     | <span class='neutral'>	function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {</span>
  529 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
  530 |     | <span class='neutral'>	}</span>
  531 |     | <span class='neutral'></span>
  532 |     | <span class='neutral'>	function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {</span>
  533 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
  534 |     | <span class='neutral'>	}</span>
  535 |     | <span class='neutral'></span>
  536 |     | <span class='neutral'>	function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {</span>
  537 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
  538 |     | <span class='neutral'>	}</span>
  539 |     | <span class='neutral'></span>
  540 |     | <span class='neutral'>	function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {</span>
  541 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  542 |     | <span class='neutral'>	}</span>
  543 |     | <span class='neutral'></span>
  544 |     | <span class='neutral'>	function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {</span>
  545 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
  546 |     | <span class='neutral'>	}</span>
  547 |     | <span class='neutral'></span>
  548 |     | <span class='neutral'>	function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {</span>
  549 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
  550 |     | <span class='neutral'>	}</span>
  551 |     | <span class='neutral'></span>
  552 |     | <span class='neutral'>	function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {</span>
  553 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
  554 |     | <span class='neutral'>	}</span>
  555 |     | <span class='neutral'></span>
  556 |     | <span class='neutral'>	function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {</span>
  557 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
  558 |     | <span class='neutral'>	}</span>
  559 |     | <span class='neutral'></span>
  560 |     | <span class='neutral'>	function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {</span>
  561 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
  562 |     | <span class='neutral'>	}</span>
  563 |     | <span class='neutral'></span>
  564 |     | <span class='neutral'>	function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {</span>
  565 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
  566 |     | <span class='neutral'>	}</span>
  567 |     | <span class='neutral'></span>
  568 |     | <span class='neutral'>	function log(uint256 p0, uint256 p1, address p2, address p3) internal view {</span>
  569 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
  570 |     | <span class='neutral'>	}</span>
  571 |     | <span class='neutral'></span>
  572 |     | <span class='neutral'>	function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {</span>
  573 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  574 |     | <span class='neutral'>	}</span>
  575 |     | <span class='neutral'></span>
  576 |     | <span class='neutral'>	function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {</span>
  577 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
  578 |     | <span class='neutral'>	}</span>
  579 |     | <span class='neutral'></span>
  580 |     | <span class='neutral'>	function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {</span>
  581 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  582 |     | <span class='neutral'>	}</span>
  583 |     | <span class='neutral'></span>
  584 |     | <span class='neutral'>	function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {</span>
  585 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
  586 |     | <span class='neutral'>	}</span>
  587 |     | <span class='neutral'></span>
  588 |     | <span class='neutral'>	function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {</span>
  589 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
  590 |     | <span class='neutral'>	}</span>
  591 |     | <span class='neutral'></span>
  592 |     | <span class='neutral'>	function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {</span>
  593 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,string)&quot;, p0, p1, p2, p3));</span>
  594 |     | <span class='neutral'>	}</span>
  595 |     | <span class='neutral'></span>
  596 |     | <span class='neutral'>	function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {</span>
  597 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  598 |     | <span class='neutral'>	}</span>
  599 |     | <span class='neutral'></span>
  600 |     | <span class='neutral'>	function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {</span>
  601 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,address)&quot;, p0, p1, p2, p3));</span>
  602 |     | <span class='neutral'>	}</span>
  603 |     | <span class='neutral'></span>
  604 |     | <span class='neutral'>	function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {</span>
  605 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  606 |     | <span class='neutral'>	}</span>
  607 |     | <span class='neutral'></span>
  608 |     | <span class='neutral'>	function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {</span>
  609 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  610 |     | <span class='neutral'>	}</span>
  611 |     | <span class='neutral'></span>
  612 |     | <span class='neutral'>	function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {</span>
  613 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  614 |     | <span class='neutral'>	}</span>
  615 |     | <span class='neutral'></span>
  616 |     | <span class='neutral'>	function log(uint256 p0, string memory p1, bool p2, address p3) internal view {</span>
  617 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  618 |     | <span class='neutral'>	}</span>
  619 |     | <span class='neutral'></span>
  620 |     | <span class='neutral'>	function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {</span>
  621 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
  622 |     | <span class='neutral'>	}</span>
  623 |     | <span class='neutral'></span>
  624 |     | <span class='neutral'>	function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {</span>
  625 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,string)&quot;, p0, p1, p2, p3));</span>
  626 |     | <span class='neutral'>	}</span>
  627 |     | <span class='neutral'></span>
  628 |     | <span class='neutral'>	function log(uint256 p0, string memory p1, address p2, bool p3) internal view {</span>
  629 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  630 |     | <span class='neutral'>	}</span>
  631 |     | <span class='neutral'></span>
  632 |     | <span class='neutral'>	function log(uint256 p0, string memory p1, address p2, address p3) internal view {</span>
  633 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,address)&quot;, p0, p1, p2, p3));</span>
  634 |     | <span class='neutral'>	}</span>
  635 |     | <span class='neutral'></span>
  636 |     | <span class='neutral'>	function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {</span>
  637 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  638 |     | <span class='neutral'>	}</span>
  639 |     | <span class='neutral'></span>
  640 |     | <span class='neutral'>	function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {</span>
  641 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
  642 |     | <span class='neutral'>	}</span>
  643 |     | <span class='neutral'></span>
  644 |     | <span class='neutral'>	function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {</span>
  645 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  646 |     | <span class='neutral'>	}</span>
  647 |     | <span class='neutral'></span>
  648 |     | <span class='neutral'>	function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {</span>
  649 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
  650 |     | <span class='neutral'>	}</span>
  651 |     | <span class='neutral'></span>
  652 |     | <span class='neutral'>	function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {</span>
  653 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
  654 |     | <span class='neutral'>	}</span>
  655 |     | <span class='neutral'></span>
  656 |     | <span class='neutral'>	function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {</span>
  657 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  658 |     | <span class='neutral'>	}</span>
  659 |     | <span class='neutral'></span>
  660 |     | <span class='neutral'>	function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {</span>
  661 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  662 |     | <span class='neutral'>	}</span>
  663 |     | <span class='neutral'></span>
  664 |     | <span class='neutral'>	function log(uint256 p0, bool p1, string memory p2, address p3) internal view {</span>
  665 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  666 |     | <span class='neutral'>	}</span>
  667 |     | <span class='neutral'></span>
  668 |     | <span class='neutral'>	function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {</span>
  669 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  670 |     | <span class='neutral'>	}</span>
  671 |     | <span class='neutral'></span>
  672 |     | <span class='neutral'>	function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {</span>
  673 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  674 |     | <span class='neutral'>	}</span>
  675 |     | <span class='neutral'></span>
  676 |     | <span class='neutral'>	function log(uint256 p0, bool p1, bool p2, bool p3) internal view {</span>
  677 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  678 |     | <span class='neutral'>	}</span>
  679 |     | <span class='neutral'></span>
  680 |     | <span class='neutral'>	function log(uint256 p0, bool p1, bool p2, address p3) internal view {</span>
  681 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  682 |     | <span class='neutral'>	}</span>
  683 |     | <span class='neutral'></span>
  684 |     | <span class='neutral'>	function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {</span>
  685 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
  686 |     | <span class='neutral'>	}</span>
  687 |     | <span class='neutral'></span>
  688 |     | <span class='neutral'>	function log(uint256 p0, bool p1, address p2, string memory p3) internal view {</span>
  689 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  690 |     | <span class='neutral'>	}</span>
  691 |     | <span class='neutral'></span>
  692 |     | <span class='neutral'>	function log(uint256 p0, bool p1, address p2, bool p3) internal view {</span>
  693 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  694 |     | <span class='neutral'>	}</span>
  695 |     | <span class='neutral'></span>
  696 |     | <span class='neutral'>	function log(uint256 p0, bool p1, address p2, address p3) internal view {</span>
  697 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  698 |     | <span class='neutral'>	}</span>
  699 |     | <span class='neutral'></span>
  700 |     | <span class='neutral'>	function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {</span>
  701 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  702 |     | <span class='neutral'>	}</span>
  703 |     | <span class='neutral'></span>
  704 |     | <span class='neutral'>	function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {</span>
  705 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
  706 |     | <span class='neutral'>	}</span>
  707 |     | <span class='neutral'></span>
  708 |     | <span class='neutral'>	function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {</span>
  709 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  710 |     | <span class='neutral'>	}</span>
  711 |     | <span class='neutral'></span>
  712 |     | <span class='neutral'>	function log(uint256 p0, address p1, uint256 p2, address p3) internal view {</span>
  713 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
  714 |     | <span class='neutral'>	}</span>
  715 |     | <span class='neutral'></span>
  716 |     | <span class='neutral'>	function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {</span>
  717 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
  718 |     | <span class='neutral'>	}</span>
  719 |     | <span class='neutral'></span>
  720 |     | <span class='neutral'>	function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {</span>
  721 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,string)&quot;, p0, p1, p2, p3));</span>
  722 |     | <span class='neutral'>	}</span>
  723 |     | <span class='neutral'></span>
  724 |     | <span class='neutral'>	function log(uint256 p0, address p1, string memory p2, bool p3) internal view {</span>
  725 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,bool)&quot;, p0, p1, p2, p3));</span>
  726 |     | <span class='neutral'>	}</span>
  727 |     | <span class='neutral'></span>
  728 |     | <span class='neutral'>	function log(uint256 p0, address p1, string memory p2, address p3) internal view {</span>
  729 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,address)&quot;, p0, p1, p2, p3));</span>
  730 |     | <span class='neutral'>	}</span>
  731 |     | <span class='neutral'></span>
  732 |     | <span class='neutral'>	function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {</span>
  733 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  734 |     | <span class='neutral'>	}</span>
  735 |     | <span class='neutral'></span>
  736 |     | <span class='neutral'>	function log(uint256 p0, address p1, bool p2, string memory p3) internal view {</span>
  737 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,string)&quot;, p0, p1, p2, p3));</span>
  738 |     | <span class='neutral'>	}</span>
  739 |     | <span class='neutral'></span>
  740 |     | <span class='neutral'>	function log(uint256 p0, address p1, bool p2, bool p3) internal view {</span>
  741 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
  742 |     | <span class='neutral'>	}</span>
  743 |     | <span class='neutral'></span>
  744 |     | <span class='neutral'>	function log(uint256 p0, address p1, bool p2, address p3) internal view {</span>
  745 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,address)&quot;, p0, p1, p2, p3));</span>
  746 |     | <span class='neutral'>	}</span>
  747 |     | <span class='neutral'></span>
  748 |     | <span class='neutral'>	function log(uint256 p0, address p1, address p2, uint256 p3) internal view {</span>
  749 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
  750 |     | <span class='neutral'>	}</span>
  751 |     | <span class='neutral'></span>
  752 |     | <span class='neutral'>	function log(uint256 p0, address p1, address p2, string memory p3) internal view {</span>
  753 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,string)&quot;, p0, p1, p2, p3));</span>
  754 |     | <span class='neutral'>	}</span>
  755 |     | <span class='neutral'></span>
  756 |     | <span class='neutral'>	function log(uint256 p0, address p1, address p2, bool p3) internal view {</span>
  757 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,bool)&quot;, p0, p1, p2, p3));</span>
  758 |     | <span class='neutral'>	}</span>
  759 |     | <span class='neutral'></span>
  760 |     | <span class='neutral'>	function log(uint256 p0, address p1, address p2, address p3) internal view {</span>
  761 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,address)&quot;, p0, p1, p2, p3));</span>
  762 |     | <span class='neutral'>	}</span>
  763 |     | <span class='neutral'></span>
  764 |     | <span class='neutral'>	function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {</span>
  765 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  766 |     | <span class='neutral'>	}</span>
  767 |     | <span class='neutral'></span>
  768 |     | <span class='neutral'>	function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {</span>
  769 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
  770 |     | <span class='neutral'>	}</span>
  771 |     | <span class='neutral'></span>
  772 |     | <span class='neutral'>	function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {</span>
  773 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  774 |     | <span class='neutral'>	}</span>
  775 |     | <span class='neutral'></span>
  776 |     | <span class='neutral'>	function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {</span>
  777 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
  778 |     | <span class='neutral'>	}</span>
  779 |     | <span class='neutral'></span>
  780 |     | <span class='neutral'>	function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {</span>
  781 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
  782 |     | <span class='neutral'>	}</span>
  783 |     | <span class='neutral'></span>
  784 |     | <span class='neutral'>	function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {</span>
  785 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
  786 |     | <span class='neutral'>	}</span>
  787 |     | <span class='neutral'></span>
  788 |     | <span class='neutral'>	function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {</span>
  789 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
  790 |     | <span class='neutral'>	}</span>
  791 |     | <span class='neutral'></span>
  792 |     | <span class='neutral'>	function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {</span>
  793 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
  794 |     | <span class='neutral'>	}</span>
  795 |     | <span class='neutral'></span>
  796 |     | <span class='neutral'>	function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {</span>
  797 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  798 |     | <span class='neutral'>	}</span>
  799 |     | <span class='neutral'></span>
  800 |     | <span class='neutral'>	function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {</span>
  801 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
  802 |     | <span class='neutral'>	}</span>
  803 |     | <span class='neutral'></span>
  804 |     | <span class='neutral'>	function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {</span>
  805 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
  806 |     | <span class='neutral'>	}</span>
  807 |     | <span class='neutral'></span>
  808 |     | <span class='neutral'>	function log(string memory p0, uint256 p1, bool p2, address p3) internal view {</span>
  809 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
  810 |     | <span class='neutral'>	}</span>
  811 |     | <span class='neutral'></span>
  812 |     | <span class='neutral'>	function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {</span>
  813 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
  814 |     | <span class='neutral'>	}</span>
  815 |     | <span class='neutral'></span>
  816 |     | <span class='neutral'>	function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {</span>
  817 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
  818 |     | <span class='neutral'>	}</span>
  819 |     | <span class='neutral'></span>
  820 |     | <span class='neutral'>	function log(string memory p0, uint256 p1, address p2, bool p3) internal view {</span>
  821 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
  822 |     | <span class='neutral'>	}</span>
  823 |     | <span class='neutral'></span>
  824 |     | <span class='neutral'>	function log(string memory p0, uint256 p1, address p2, address p3) internal view {</span>
  825 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
  826 |     | <span class='neutral'>	}</span>
  827 |     | <span class='neutral'></span>
  828 |     | <span class='neutral'>	function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {</span>
  829 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  830 |     | <span class='neutral'>	}</span>
  831 |     | <span class='neutral'></span>
  832 |     | <span class='neutral'>	function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {</span>
  833 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
  834 |     | <span class='neutral'>	}</span>
  835 |     | <span class='neutral'></span>
  836 |     | <span class='neutral'>	function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {</span>
  837 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  838 |     | <span class='neutral'>	}</span>
  839 |     | <span class='neutral'></span>
  840 |     | <span class='neutral'>	function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {</span>
  841 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
  842 |     | <span class='neutral'>	}</span>
  843 |     | <span class='neutral'></span>
  844 |     | <span class='neutral'>	function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {</span>
  845 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
  846 |     | <span class='neutral'>	}</span>
  847 |     | <span class='neutral'></span>
  848 |     | <span class='neutral'>	function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {</span>
  849 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,string)&quot;, p0, p1, p2, p3));</span>
  850 |     | <span class='neutral'>	}</span>
  851 |     | <span class='neutral'></span>
  852 |     | <span class='neutral'>	function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {</span>
  853 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  854 |     | <span class='neutral'>	}</span>
  855 |     | <span class='neutral'></span>
  856 |     | <span class='neutral'>	function log(string memory p0, string memory p1, string memory p2, address p3) internal view {</span>
  857 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,address)&quot;, p0, p1, p2, p3));</span>
  858 |     | <span class='neutral'>	}</span>
  859 |     | <span class='neutral'></span>
  860 |     | <span class='neutral'>	function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {</span>
  861 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  862 |     | <span class='neutral'>	}</span>
  863 |     | <span class='neutral'></span>
  864 |     | <span class='neutral'>	function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {</span>
  865 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  866 |     | <span class='neutral'>	}</span>
  867 |     | <span class='neutral'></span>
  868 |     | <span class='neutral'>	function log(string memory p0, string memory p1, bool p2, bool p3) internal view {</span>
  869 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  870 |     | <span class='neutral'>	}</span>
  871 |     | <span class='neutral'></span>
  872 |     | <span class='neutral'>	function log(string memory p0, string memory p1, bool p2, address p3) internal view {</span>
  873 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  874 |     | <span class='neutral'>	}</span>
  875 |     | <span class='neutral'></span>
  876 |     | <span class='neutral'>	function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {</span>
  877 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
  878 |     | <span class='neutral'>	}</span>
  879 |     | <span class='neutral'></span>
  880 |     | <span class='neutral'>	function log(string memory p0, string memory p1, address p2, string memory p3) internal view {</span>
  881 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,string)&quot;, p0, p1, p2, p3));</span>
  882 |     | <span class='neutral'>	}</span>
  883 |     | <span class='neutral'></span>
  884 |     | <span class='neutral'>	function log(string memory p0, string memory p1, address p2, bool p3) internal view {</span>
  885 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  886 |     | <span class='neutral'>	}</span>
  887 |     | <span class='neutral'></span>
  888 |     | <span class='neutral'>	function log(string memory p0, string memory p1, address p2, address p3) internal view {</span>
  889 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,address)&quot;, p0, p1, p2, p3));</span>
  890 |     | <span class='neutral'>	}</span>
  891 |     | <span class='neutral'></span>
  892 |     | <span class='neutral'>	function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {</span>
  893 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  894 |     | <span class='neutral'>	}</span>
  895 |     | <span class='neutral'></span>
  896 |     | <span class='neutral'>	function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {</span>
  897 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
  898 |     | <span class='neutral'>	}</span>
  899 |     | <span class='neutral'></span>
  900 |     | <span class='neutral'>	function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {</span>
  901 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  902 |     | <span class='neutral'>	}</span>
  903 |     | <span class='neutral'></span>
  904 |     | <span class='neutral'>	function log(string memory p0, bool p1, uint256 p2, address p3) internal view {</span>
  905 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
  906 |     | <span class='neutral'>	}</span>
  907 |     | <span class='neutral'></span>
  908 |     | <span class='neutral'>	function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {</span>
  909 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
  910 |     | <span class='neutral'>	}</span>
  911 |     | <span class='neutral'></span>
  912 |     | <span class='neutral'>	function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {</span>
  913 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  914 |     | <span class='neutral'>	}</span>
  915 |     | <span class='neutral'></span>
  916 |     | <span class='neutral'>	function log(string memory p0, bool p1, string memory p2, bool p3) internal view {</span>
  917 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  918 |     | <span class='neutral'>	}</span>
  919 |     | <span class='neutral'></span>
  920 |     | <span class='neutral'>	function log(string memory p0, bool p1, string memory p2, address p3) internal view {</span>
  921 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  922 |     | <span class='neutral'>	}</span>
  923 |     | <span class='neutral'></span>
  924 |     | <span class='neutral'>	function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {</span>
  925 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  926 |     | <span class='neutral'>	}</span>
  927 |     | <span class='neutral'></span>
  928 |     | <span class='neutral'>	function log(string memory p0, bool p1, bool p2, string memory p3) internal view {</span>
  929 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  930 |     | <span class='neutral'>	}</span>
  931 |     | <span class='neutral'></span>
  932 |     | <span class='neutral'>	function log(string memory p0, bool p1, bool p2, bool p3) internal view {</span>
  933 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  934 |     | <span class='neutral'>	}</span>
  935 |     | <span class='neutral'></span>
  936 |     | <span class='neutral'>	function log(string memory p0, bool p1, bool p2, address p3) internal view {</span>
  937 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  938 |     | <span class='neutral'>	}</span>
  939 |     | <span class='neutral'></span>
  940 |     | <span class='neutral'>	function log(string memory p0, bool p1, address p2, uint256 p3) internal view {</span>
  941 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
  942 |     | <span class='neutral'>	}</span>
  943 |     | <span class='neutral'></span>
  944 |     | <span class='neutral'>	function log(string memory p0, bool p1, address p2, string memory p3) internal view {</span>
  945 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  946 |     | <span class='neutral'>	}</span>
  947 |     | <span class='neutral'></span>
  948 |     | <span class='neutral'>	function log(string memory p0, bool p1, address p2, bool p3) internal view {</span>
  949 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  950 |     | <span class='neutral'>	}</span>
  951 |     | <span class='neutral'></span>
  952 |     | <span class='neutral'>	function log(string memory p0, bool p1, address p2, address p3) internal view {</span>
  953 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  954 |     | <span class='neutral'>	}</span>
  955 |     | <span class='neutral'></span>
  956 |     | <span class='neutral'>	function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {</span>
  957 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  958 |     | <span class='neutral'>	}</span>
  959 |     | <span class='neutral'></span>
  960 |     | <span class='neutral'>	function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {</span>
  961 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
  962 |     | <span class='neutral'>	}</span>
  963 |     | <span class='neutral'></span>
  964 |     | <span class='neutral'>	function log(string memory p0, address p1, uint256 p2, bool p3) internal view {</span>
  965 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  966 |     | <span class='neutral'>	}</span>
  967 |     | <span class='neutral'></span>
  968 |     | <span class='neutral'>	function log(string memory p0, address p1, uint256 p2, address p3) internal view {</span>
  969 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
  970 |     | <span class='neutral'>	}</span>
  971 |     | <span class='neutral'></span>
  972 |     | <span class='neutral'>	function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {</span>
  973 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
  974 |     | <span class='neutral'>	}</span>
  975 |     | <span class='neutral'></span>
  976 |     | <span class='neutral'>	function log(string memory p0, address p1, string memory p2, string memory p3) internal view {</span>
  977 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,string)&quot;, p0, p1, p2, p3));</span>
  978 |     | <span class='neutral'>	}</span>
  979 |     | <span class='neutral'></span>
  980 |     | <span class='neutral'>	function log(string memory p0, address p1, string memory p2, bool p3) internal view {</span>
  981 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,bool)&quot;, p0, p1, p2, p3));</span>
  982 |     | <span class='neutral'>	}</span>
  983 |     | <span class='neutral'></span>
  984 |     | <span class='neutral'>	function log(string memory p0, address p1, string memory p2, address p3) internal view {</span>
  985 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,address)&quot;, p0, p1, p2, p3));</span>
  986 |     | <span class='neutral'>	}</span>
  987 |     | <span class='neutral'></span>
  988 |     | <span class='neutral'>	function log(string memory p0, address p1, bool p2, uint256 p3) internal view {</span>
  989 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  990 |     | <span class='neutral'>	}</span>
  991 |     | <span class='neutral'></span>
  992 |     | <span class='neutral'>	function log(string memory p0, address p1, bool p2, string memory p3) internal view {</span>
  993 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,string)&quot;, p0, p1, p2, p3));</span>
  994 |     | <span class='neutral'>	}</span>
  995 |     | <span class='neutral'></span>
  996 |     | <span class='neutral'>	function log(string memory p0, address p1, bool p2, bool p3) internal view {</span>
  997 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
  998 |     | <span class='neutral'>	}</span>
  999 |     | <span class='neutral'></span>
 1000 |     | <span class='neutral'>	function log(string memory p0, address p1, bool p2, address p3) internal view {</span>
 1001 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1002 |     | <span class='neutral'>	}</span>
 1003 |     | <span class='neutral'></span>
 1004 |     | <span class='neutral'>	function log(string memory p0, address p1, address p2, uint256 p3) internal view {</span>
 1005 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1006 |     | <span class='neutral'>	}</span>
 1007 |     | <span class='neutral'></span>
 1008 |     | <span class='neutral'>	function log(string memory p0, address p1, address p2, string memory p3) internal view {</span>
 1009 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1010 |     | <span class='neutral'>	}</span>
 1011 |     | <span class='neutral'></span>
 1012 |     | <span class='neutral'>	function log(string memory p0, address p1, address p2, bool p3) internal view {</span>
 1013 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1014 |     | <span class='neutral'>	}</span>
 1015 |     | <span class='neutral'></span>
 1016 |     | <span class='neutral'>	function log(string memory p0, address p1, address p2, address p3) internal view {</span>
 1017 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1018 |     | <span class='neutral'>	}</span>
 1019 |     | <span class='neutral'></span>
 1020 |     | <span class='neutral'>	function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {</span>
 1021 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1022 |     | <span class='neutral'>	}</span>
 1023 |     | <span class='neutral'></span>
 1024 |     | <span class='neutral'>	function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {</span>
 1025 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1026 |     | <span class='neutral'>	}</span>
 1027 |     | <span class='neutral'></span>
 1028 |     | <span class='neutral'>	function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {</span>
 1029 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1030 |     | <span class='neutral'>	}</span>
 1031 |     | <span class='neutral'></span>
 1032 |     | <span class='neutral'>	function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {</span>
 1033 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1034 |     | <span class='neutral'>	}</span>
 1035 |     | <span class='neutral'></span>
 1036 |     | <span class='neutral'>	function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {</span>
 1037 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1038 |     | <span class='neutral'>	}</span>
 1039 |     | <span class='neutral'></span>
 1040 |     | <span class='neutral'>	function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {</span>
 1041 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
 1042 |     | <span class='neutral'>	}</span>
 1043 |     | <span class='neutral'></span>
 1044 |     | <span class='neutral'>	function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {</span>
 1045 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
 1046 |     | <span class='neutral'>	}</span>
 1047 |     | <span class='neutral'></span>
 1048 |     | <span class='neutral'>	function log(bool p0, uint256 p1, string memory p2, address p3) internal view {</span>
 1049 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
 1050 |     | <span class='neutral'>	}</span>
 1051 |     | <span class='neutral'></span>
 1052 |     | <span class='neutral'>	function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {</span>
 1053 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1054 |     | <span class='neutral'>	}</span>
 1055 |     | <span class='neutral'></span>
 1056 |     | <span class='neutral'>	function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {</span>
 1057 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
 1058 |     | <span class='neutral'>	}</span>
 1059 |     | <span class='neutral'></span>
 1060 |     | <span class='neutral'>	function log(bool p0, uint256 p1, bool p2, bool p3) internal view {</span>
 1061 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1062 |     | <span class='neutral'>	}</span>
 1063 |     | <span class='neutral'></span>
 1064 |     | <span class='neutral'>	function log(bool p0, uint256 p1, bool p2, address p3) internal view {</span>
 1065 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
 1066 |     | <span class='neutral'>	}</span>
 1067 |     | <span class='neutral'></span>
 1068 |     | <span class='neutral'>	function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {</span>
 1069 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1070 |     | <span class='neutral'>	}</span>
 1071 |     | <span class='neutral'></span>
 1072 |     | <span class='neutral'>	function log(bool p0, uint256 p1, address p2, string memory p3) internal view {</span>
 1073 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
 1074 |     | <span class='neutral'>	}</span>
 1075 |     | <span class='neutral'></span>
 1076 |     | <span class='neutral'>	function log(bool p0, uint256 p1, address p2, bool p3) internal view {</span>
 1077 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
 1078 |     | <span class='neutral'>	}</span>
 1079 |     | <span class='neutral'></span>
 1080 |     | <span class='neutral'>	function log(bool p0, uint256 p1, address p2, address p3) internal view {</span>
 1081 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
 1082 |     | <span class='neutral'>	}</span>
 1083 |     | <span class='neutral'></span>
 1084 |     | <span class='neutral'>	function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {</span>
 1085 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1086 |     | <span class='neutral'>	}</span>
 1087 |     | <span class='neutral'></span>
 1088 |     | <span class='neutral'>	function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {</span>
 1089 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1090 |     | <span class='neutral'>	}</span>
 1091 |     | <span class='neutral'></span>
 1092 |     | <span class='neutral'>	function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {</span>
 1093 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1094 |     | <span class='neutral'>	}</span>
 1095 |     | <span class='neutral'></span>
 1096 |     | <span class='neutral'>	function log(bool p0, string memory p1, uint256 p2, address p3) internal view {</span>
 1097 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1098 |     | <span class='neutral'>	}</span>
 1099 |     | <span class='neutral'></span>
 1100 |     | <span class='neutral'>	function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {</span>
 1101 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1102 |     | <span class='neutral'>	}</span>
 1103 |     | <span class='neutral'></span>
 1104 |     | <span class='neutral'>	function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {</span>
 1105 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1106 |     | <span class='neutral'>	}</span>
 1107 |     | <span class='neutral'></span>
 1108 |     | <span class='neutral'>	function log(bool p0, string memory p1, string memory p2, bool p3) internal view {</span>
 1109 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1110 |     | <span class='neutral'>	}</span>
 1111 |     | <span class='neutral'></span>
 1112 |     | <span class='neutral'>	function log(bool p0, string memory p1, string memory p2, address p3) internal view {</span>
 1113 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1114 |     | <span class='neutral'>	}</span>
 1115 |     | <span class='neutral'></span>
 1116 |     | <span class='neutral'>	function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {</span>
 1117 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1118 |     | <span class='neutral'>	}</span>
 1119 |     | <span class='neutral'></span>
 1120 |     | <span class='neutral'>	function log(bool p0, string memory p1, bool p2, string memory p3) internal view {</span>
 1121 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1122 |     | <span class='neutral'>	}</span>
 1123 |     | <span class='neutral'></span>
 1124 |     | <span class='neutral'>	function log(bool p0, string memory p1, bool p2, bool p3) internal view {</span>
 1125 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1126 |     | <span class='neutral'>	}</span>
 1127 |     | <span class='neutral'></span>
 1128 |     | <span class='neutral'>	function log(bool p0, string memory p1, bool p2, address p3) internal view {</span>
 1129 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1130 |     | <span class='neutral'>	}</span>
 1131 |     | <span class='neutral'></span>
 1132 |     | <span class='neutral'>	function log(bool p0, string memory p1, address p2, uint256 p3) internal view {</span>
 1133 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1134 |     | <span class='neutral'>	}</span>
 1135 |     | <span class='neutral'></span>
 1136 |     | <span class='neutral'>	function log(bool p0, string memory p1, address p2, string memory p3) internal view {</span>
 1137 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1138 |     | <span class='neutral'>	}</span>
 1139 |     | <span class='neutral'></span>
 1140 |     | <span class='neutral'>	function log(bool p0, string memory p1, address p2, bool p3) internal view {</span>
 1141 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1142 |     | <span class='neutral'>	}</span>
 1143 |     | <span class='neutral'></span>
 1144 |     | <span class='neutral'>	function log(bool p0, string memory p1, address p2, address p3) internal view {</span>
 1145 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1146 |     | <span class='neutral'>	}</span>
 1147 |     | <span class='neutral'></span>
 1148 |     | <span class='neutral'>	function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {</span>
 1149 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1150 |     | <span class='neutral'>	}</span>
 1151 |     | <span class='neutral'></span>
 1152 |     | <span class='neutral'>	function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {</span>
 1153 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1154 |     | <span class='neutral'>	}</span>
 1155 |     | <span class='neutral'></span>
 1156 |     | <span class='neutral'>	function log(bool p0, bool p1, uint256 p2, bool p3) internal view {</span>
 1157 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1158 |     | <span class='neutral'>	}</span>
 1159 |     | <span class='neutral'></span>
 1160 |     | <span class='neutral'>	function log(bool p0, bool p1, uint256 p2, address p3) internal view {</span>
 1161 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1162 |     | <span class='neutral'>	}</span>
 1163 |     | <span class='neutral'></span>
 1164 |     | <span class='neutral'>	function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {</span>
 1165 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1166 |     | <span class='neutral'>	}</span>
 1167 |     | <span class='neutral'></span>
 1168 |     | <span class='neutral'>	function log(bool p0, bool p1, string memory p2, string memory p3) internal view {</span>
 1169 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1170 |     | <span class='neutral'>	}</span>
 1171 |     | <span class='neutral'></span>
 1172 |     | <span class='neutral'>	function log(bool p0, bool p1, string memory p2, bool p3) internal view {</span>
 1173 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1174 |     | <span class='neutral'>	}</span>
 1175 |     | <span class='neutral'></span>
 1176 |     | <span class='neutral'>	function log(bool p0, bool p1, string memory p2, address p3) internal view {</span>
 1177 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1178 |     | <span class='neutral'>	}</span>
 1179 |     | <span class='neutral'></span>
 1180 |     | <span class='neutral'>	function log(bool p0, bool p1, bool p2, uint256 p3) internal view {</span>
 1181 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1182 |     | <span class='neutral'>	}</span>
 1183 |     | <span class='neutral'></span>
 1184 |     | <span class='neutral'>	function log(bool p0, bool p1, bool p2, string memory p3) internal view {</span>
 1185 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1186 |     | <span class='neutral'>	}</span>
 1187 |     | <span class='neutral'></span>
 1188 |     | <span class='neutral'>	function log(bool p0, bool p1, bool p2, bool p3) internal view {</span>
 1189 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1190 |     | <span class='neutral'>	}</span>
 1191 |     | <span class='neutral'></span>
 1192 |     | <span class='neutral'>	function log(bool p0, bool p1, bool p2, address p3) internal view {</span>
 1193 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1194 |     | <span class='neutral'>	}</span>
 1195 |     | <span class='neutral'></span>
 1196 |     | <span class='neutral'>	function log(bool p0, bool p1, address p2, uint256 p3) internal view {</span>
 1197 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1198 |     | <span class='neutral'>	}</span>
 1199 |     | <span class='neutral'></span>
 1200 |     | <span class='neutral'>	function log(bool p0, bool p1, address p2, string memory p3) internal view {</span>
 1201 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1202 |     | <span class='neutral'>	}</span>
 1203 |     | <span class='neutral'></span>
 1204 |     | <span class='neutral'>	function log(bool p0, bool p1, address p2, bool p3) internal view {</span>
 1205 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1206 |     | <span class='neutral'>	}</span>
 1207 |     | <span class='neutral'></span>
 1208 |     | <span class='neutral'>	function log(bool p0, bool p1, address p2, address p3) internal view {</span>
 1209 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1210 |     | <span class='neutral'>	}</span>
 1211 |     | <span class='neutral'></span>
 1212 |     | <span class='neutral'>	function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {</span>
 1213 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1214 |     | <span class='neutral'>	}</span>
 1215 |     | <span class='neutral'></span>
 1216 |     | <span class='neutral'>	function log(bool p0, address p1, uint256 p2, string memory p3) internal view {</span>
 1217 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1218 |     | <span class='neutral'>	}</span>
 1219 |     | <span class='neutral'></span>
 1220 |     | <span class='neutral'>	function log(bool p0, address p1, uint256 p2, bool p3) internal view {</span>
 1221 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1222 |     | <span class='neutral'>	}</span>
 1223 |     | <span class='neutral'></span>
 1224 |     | <span class='neutral'>	function log(bool p0, address p1, uint256 p2, address p3) internal view {</span>
 1225 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1226 |     | <span class='neutral'>	}</span>
 1227 |     | <span class='neutral'></span>
 1228 |     | <span class='neutral'>	function log(bool p0, address p1, string memory p2, uint256 p3) internal view {</span>
 1229 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1230 |     | <span class='neutral'>	}</span>
 1231 |     | <span class='neutral'></span>
 1232 |     | <span class='neutral'>	function log(bool p0, address p1, string memory p2, string memory p3) internal view {</span>
 1233 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1234 |     | <span class='neutral'>	}</span>
 1235 |     | <span class='neutral'></span>
 1236 |     | <span class='neutral'>	function log(bool p0, address p1, string memory p2, bool p3) internal view {</span>
 1237 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1238 |     | <span class='neutral'>	}</span>
 1239 |     | <span class='neutral'></span>
 1240 |     | <span class='neutral'>	function log(bool p0, address p1, string memory p2, address p3) internal view {</span>
 1241 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1242 |     | <span class='neutral'>	}</span>
 1243 |     | <span class='neutral'></span>
 1244 |     | <span class='neutral'>	function log(bool p0, address p1, bool p2, uint256 p3) internal view {</span>
 1245 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1246 |     | <span class='neutral'>	}</span>
 1247 |     | <span class='neutral'></span>
 1248 |     | <span class='neutral'>	function log(bool p0, address p1, bool p2, string memory p3) internal view {</span>
 1249 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1250 |     | <span class='neutral'>	}</span>
 1251 |     | <span class='neutral'></span>
 1252 |     | <span class='neutral'>	function log(bool p0, address p1, bool p2, bool p3) internal view {</span>
 1253 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1254 |     | <span class='neutral'>	}</span>
 1255 |     | <span class='neutral'></span>
 1256 |     | <span class='neutral'>	function log(bool p0, address p1, bool p2, address p3) internal view {</span>
 1257 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1258 |     | <span class='neutral'>	}</span>
 1259 |     | <span class='neutral'></span>
 1260 |     | <span class='neutral'>	function log(bool p0, address p1, address p2, uint256 p3) internal view {</span>
 1261 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1262 |     | <span class='neutral'>	}</span>
 1263 |     | <span class='neutral'></span>
 1264 |     | <span class='neutral'>	function log(bool p0, address p1, address p2, string memory p3) internal view {</span>
 1265 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1266 |     | <span class='neutral'>	}</span>
 1267 |     | <span class='neutral'></span>
 1268 |     | <span class='neutral'>	function log(bool p0, address p1, address p2, bool p3) internal view {</span>
 1269 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1270 |     | <span class='neutral'>	}</span>
 1271 |     | <span class='neutral'></span>
 1272 |     | <span class='neutral'>	function log(bool p0, address p1, address p2, address p3) internal view {</span>
 1273 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1274 |     | <span class='neutral'>	}</span>
 1275 |     | <span class='neutral'></span>
 1276 |     | <span class='neutral'>	function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {</span>
 1277 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1278 |     | <span class='neutral'>	}</span>
 1279 |     | <span class='neutral'></span>
 1280 |     | <span class='neutral'>	function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {</span>
 1281 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1282 |     | <span class='neutral'>	}</span>
 1283 |     | <span class='neutral'></span>
 1284 |     | <span class='neutral'>	function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {</span>
 1285 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1286 |     | <span class='neutral'>	}</span>
 1287 |     | <span class='neutral'></span>
 1288 |     | <span class='neutral'>	function log(address p0, uint256 p1, uint256 p2, address p3) internal view {</span>
 1289 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1290 |     | <span class='neutral'>	}</span>
 1291 |     | <span class='neutral'></span>
 1292 |     | <span class='neutral'>	function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {</span>
 1293 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1294 |     | <span class='neutral'>	}</span>
 1295 |     | <span class='neutral'></span>
 1296 |     | <span class='neutral'>	function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {</span>
 1297 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
 1298 |     | <span class='neutral'>	}</span>
 1299 |     | <span class='neutral'></span>
 1300 |     | <span class='neutral'>	function log(address p0, uint256 p1, string memory p2, bool p3) internal view {</span>
 1301 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
 1302 |     | <span class='neutral'>	}</span>
 1303 |     | <span class='neutral'></span>
 1304 |     | <span class='neutral'>	function log(address p0, uint256 p1, string memory p2, address p3) internal view {</span>
 1305 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
 1306 |     | <span class='neutral'>	}</span>
 1307 |     | <span class='neutral'></span>
 1308 |     | <span class='neutral'>	function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {</span>
 1309 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1310 |     | <span class='neutral'>	}</span>
 1311 |     | <span class='neutral'></span>
 1312 |     | <span class='neutral'>	function log(address p0, uint256 p1, bool p2, string memory p3) internal view {</span>
 1313 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
 1314 |     | <span class='neutral'>	}</span>
 1315 |     | <span class='neutral'></span>
 1316 |     | <span class='neutral'>	function log(address p0, uint256 p1, bool p2, bool p3) internal view {</span>
 1317 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1318 |     | <span class='neutral'>	}</span>
 1319 |     | <span class='neutral'></span>
 1320 |     | <span class='neutral'>	function log(address p0, uint256 p1, bool p2, address p3) internal view {</span>
 1321 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
 1322 |     | <span class='neutral'>	}</span>
 1323 |     | <span class='neutral'></span>
 1324 |     | <span class='neutral'>	function log(address p0, uint256 p1, address p2, uint256 p3) internal view {</span>
 1325 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1326 |     | <span class='neutral'>	}</span>
 1327 |     | <span class='neutral'></span>
 1328 |     | <span class='neutral'>	function log(address p0, uint256 p1, address p2, string memory p3) internal view {</span>
 1329 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
 1330 |     | <span class='neutral'>	}</span>
 1331 |     | <span class='neutral'></span>
 1332 |     | <span class='neutral'>	function log(address p0, uint256 p1, address p2, bool p3) internal view {</span>
 1333 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
 1334 |     | <span class='neutral'>	}</span>
 1335 |     | <span class='neutral'></span>
 1336 |     | <span class='neutral'>	function log(address p0, uint256 p1, address p2, address p3) internal view {</span>
 1337 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
 1338 |     | <span class='neutral'>	}</span>
 1339 |     | <span class='neutral'></span>
 1340 |     | <span class='neutral'>	function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {</span>
 1341 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1342 |     | <span class='neutral'>	}</span>
 1343 |     | <span class='neutral'></span>
 1344 |     | <span class='neutral'>	function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {</span>
 1345 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1346 |     | <span class='neutral'>	}</span>
 1347 |     | <span class='neutral'></span>
 1348 |     | <span class='neutral'>	function log(address p0, string memory p1, uint256 p2, bool p3) internal view {</span>
 1349 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1350 |     | <span class='neutral'>	}</span>
 1351 |     | <span class='neutral'></span>
 1352 |     | <span class='neutral'>	function log(address p0, string memory p1, uint256 p2, address p3) internal view {</span>
 1353 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1354 |     | <span class='neutral'>	}</span>
 1355 |     | <span class='neutral'></span>
 1356 |     | <span class='neutral'>	function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {</span>
 1357 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1358 |     | <span class='neutral'>	}</span>
 1359 |     | <span class='neutral'></span>
 1360 |     | <span class='neutral'>	function log(address p0, string memory p1, string memory p2, string memory p3) internal view {</span>
 1361 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1362 |     | <span class='neutral'>	}</span>
 1363 |     | <span class='neutral'></span>
 1364 |     | <span class='neutral'>	function log(address p0, string memory p1, string memory p2, bool p3) internal view {</span>
 1365 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1366 |     | <span class='neutral'>	}</span>
 1367 |     | <span class='neutral'></span>
 1368 |     | <span class='neutral'>	function log(address p0, string memory p1, string memory p2, address p3) internal view {</span>
 1369 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1370 |     | <span class='neutral'>	}</span>
 1371 |     | <span class='neutral'></span>
 1372 |     | <span class='neutral'>	function log(address p0, string memory p1, bool p2, uint256 p3) internal view {</span>
 1373 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1374 |     | <span class='neutral'>	}</span>
 1375 |     | <span class='neutral'></span>
 1376 |     | <span class='neutral'>	function log(address p0, string memory p1, bool p2, string memory p3) internal view {</span>
 1377 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1378 |     | <span class='neutral'>	}</span>
 1379 |     | <span class='neutral'></span>
 1380 |     | <span class='neutral'>	function log(address p0, string memory p1, bool p2, bool p3) internal view {</span>
 1381 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1382 |     | <span class='neutral'>	}</span>
 1383 |     | <span class='neutral'></span>
 1384 |     | <span class='neutral'>	function log(address p0, string memory p1, bool p2, address p3) internal view {</span>
 1385 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1386 |     | <span class='neutral'>	}</span>
 1387 |     | <span class='neutral'></span>
 1388 |     | <span class='neutral'>	function log(address p0, string memory p1, address p2, uint256 p3) internal view {</span>
 1389 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1390 |     | <span class='neutral'>	}</span>
 1391 |     | <span class='neutral'></span>
 1392 |     | <span class='neutral'>	function log(address p0, string memory p1, address p2, string memory p3) internal view {</span>
 1393 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1394 |     | <span class='neutral'>	}</span>
 1395 |     | <span class='neutral'></span>
 1396 |     | <span class='neutral'>	function log(address p0, string memory p1, address p2, bool p3) internal view {</span>
 1397 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1398 |     | <span class='neutral'>	}</span>
 1399 |     | <span class='neutral'></span>
 1400 |     | <span class='neutral'>	function log(address p0, string memory p1, address p2, address p3) internal view {</span>
 1401 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1402 |     | <span class='neutral'>	}</span>
 1403 |     | <span class='neutral'></span>
 1404 |     | <span class='neutral'>	function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {</span>
 1405 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1406 |     | <span class='neutral'>	}</span>
 1407 |     | <span class='neutral'></span>
 1408 |     | <span class='neutral'>	function log(address p0, bool p1, uint256 p2, string memory p3) internal view {</span>
 1409 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1410 |     | <span class='neutral'>	}</span>
 1411 |     | <span class='neutral'></span>
 1412 |     | <span class='neutral'>	function log(address p0, bool p1, uint256 p2, bool p3) internal view {</span>
 1413 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1414 |     | <span class='neutral'>	}</span>
 1415 |     | <span class='neutral'></span>
 1416 |     | <span class='neutral'>	function log(address p0, bool p1, uint256 p2, address p3) internal view {</span>
 1417 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1418 |     | <span class='neutral'>	}</span>
 1419 |     | <span class='neutral'></span>
 1420 |     | <span class='neutral'>	function log(address p0, bool p1, string memory p2, uint256 p3) internal view {</span>
 1421 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1422 |     | <span class='neutral'>	}</span>
 1423 |     | <span class='neutral'></span>
 1424 |     | <span class='neutral'>	function log(address p0, bool p1, string memory p2, string memory p3) internal view {</span>
 1425 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1426 |     | <span class='neutral'>	}</span>
 1427 |     | <span class='neutral'></span>
 1428 |     | <span class='neutral'>	function log(address p0, bool p1, string memory p2, bool p3) internal view {</span>
 1429 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1430 |     | <span class='neutral'>	}</span>
 1431 |     | <span class='neutral'></span>
 1432 |     | <span class='neutral'>	function log(address p0, bool p1, string memory p2, address p3) internal view {</span>
 1433 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1434 |     | <span class='neutral'>	}</span>
 1435 |     | <span class='neutral'></span>
 1436 |     | <span class='neutral'>	function log(address p0, bool p1, bool p2, uint256 p3) internal view {</span>
 1437 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1438 |     | <span class='neutral'>	}</span>
 1439 |     | <span class='neutral'></span>
 1440 |     | <span class='neutral'>	function log(address p0, bool p1, bool p2, string memory p3) internal view {</span>
 1441 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1442 |     | <span class='neutral'>	}</span>
 1443 |     | <span class='neutral'></span>
 1444 |     | <span class='neutral'>	function log(address p0, bool p1, bool p2, bool p3) internal view {</span>
 1445 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1446 |     | <span class='neutral'>	}</span>
 1447 |     | <span class='neutral'></span>
 1448 |     | <span class='neutral'>	function log(address p0, bool p1, bool p2, address p3) internal view {</span>
 1449 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1450 |     | <span class='neutral'>	}</span>
 1451 |     | <span class='neutral'></span>
 1452 |     | <span class='neutral'>	function log(address p0, bool p1, address p2, uint256 p3) internal view {</span>
 1453 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1454 |     | <span class='neutral'>	}</span>
 1455 |     | <span class='neutral'></span>
 1456 |     | <span class='neutral'>	function log(address p0, bool p1, address p2, string memory p3) internal view {</span>
 1457 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1458 |     | <span class='neutral'>	}</span>
 1459 |     | <span class='neutral'></span>
 1460 |     | <span class='neutral'>	function log(address p0, bool p1, address p2, bool p3) internal view {</span>
 1461 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1462 |     | <span class='neutral'>	}</span>
 1463 |     | <span class='neutral'></span>
 1464 |     | <span class='neutral'>	function log(address p0, bool p1, address p2, address p3) internal view {</span>
 1465 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1466 |     | <span class='neutral'>	}</span>
 1467 |     | <span class='neutral'></span>
 1468 |     | <span class='neutral'>	function log(address p0, address p1, uint256 p2, uint256 p3) internal view {</span>
 1469 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1470 |     | <span class='neutral'>	}</span>
 1471 |     | <span class='neutral'></span>
 1472 |     | <span class='neutral'>	function log(address p0, address p1, uint256 p2, string memory p3) internal view {</span>
 1473 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1474 |     | <span class='neutral'>	}</span>
 1475 |     | <span class='neutral'></span>
 1476 |     | <span class='neutral'>	function log(address p0, address p1, uint256 p2, bool p3) internal view {</span>
 1477 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1478 |     | <span class='neutral'>	}</span>
 1479 |     | <span class='neutral'></span>
 1480 |     | <span class='neutral'>	function log(address p0, address p1, uint256 p2, address p3) internal view {</span>
 1481 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1482 |     | <span class='neutral'>	}</span>
 1483 |     | <span class='neutral'></span>
 1484 |     | <span class='neutral'>	function log(address p0, address p1, string memory p2, uint256 p3) internal view {</span>
 1485 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1486 |     | <span class='neutral'>	}</span>
 1487 |     | <span class='neutral'></span>
 1488 |     | <span class='neutral'>	function log(address p0, address p1, string memory p2, string memory p3) internal view {</span>
 1489 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1490 |     | <span class='neutral'>	}</span>
 1491 |     | <span class='neutral'></span>
 1492 |     | <span class='neutral'>	function log(address p0, address p1, string memory p2, bool p3) internal view {</span>
 1493 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1494 |     | <span class='neutral'>	}</span>
 1495 |     | <span class='neutral'></span>
 1496 |     | <span class='neutral'>	function log(address p0, address p1, string memory p2, address p3) internal view {</span>
 1497 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1498 |     | <span class='neutral'>	}</span>
 1499 |     | <span class='neutral'></span>
 1500 |     | <span class='neutral'>	function log(address p0, address p1, bool p2, uint256 p3) internal view {</span>
 1501 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1502 |     | <span class='neutral'>	}</span>
 1503 |     | <span class='neutral'></span>
 1504 |     | <span class='neutral'>	function log(address p0, address p1, bool p2, string memory p3) internal view {</span>
 1505 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1506 |     | <span class='neutral'>	}</span>
 1507 |     | <span class='neutral'></span>
 1508 |     | <span class='neutral'>	function log(address p0, address p1, bool p2, bool p3) internal view {</span>
 1509 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1510 |     | <span class='neutral'>	}</span>
 1511 |     | <span class='neutral'></span>
 1512 |     | <span class='neutral'>	function log(address p0, address p1, bool p2, address p3) internal view {</span>
 1513 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1514 |     | <span class='neutral'>	}</span>
 1515 |     | <span class='neutral'></span>
 1516 |     | <span class='neutral'>	function log(address p0, address p1, address p2, uint256 p3) internal view {</span>
 1517 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1518 |     | <span class='neutral'>	}</span>
 1519 |     | <span class='neutral'></span>
 1520 |     | <span class='neutral'>	function log(address p0, address p1, address p2, string memory p3) internal view {</span>
 1521 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1522 |     | <span class='neutral'>	}</span>
 1523 |     | <span class='neutral'></span>
 1524 |     | <span class='neutral'>	function log(address p0, address p1, address p2, bool p3) internal view {</span>
 1525 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1526 |     | <span class='neutral'>	}</span>
 1527 |     | <span class='neutral'></span>
 1528 |     | <span class='neutral'>	function log(address p0, address p1, address p2, address p3) internal view {</span>
 1529 |     | <span class='neutral'>		_sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1530 |     | <span class='neutral'>	}</span>
 1531 |     | <span class='neutral'></span>
 1532 |     | <span class='neutral'>}</span>
 1533 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/script/PairHashCode.s.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;forge-std/Script.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import {DuoswapV2Pair} from &quot;../contracts/duoswapV2/DuoswapV2Pair.sol&quot;;</span>
  7 |     | <span class='unexecuted'></span>
  8 |     | <span class='neutral'>contract PairHashCodeScript is Script {</span>
  9 |     | <span class='neutral'>    function setUp() public {}</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function run() public view {</span>
 12 |     | <span class='neutral'>        // get bytecode for DuoswapV2Pair</span>
 13 |     | <span class='unexecuted'>        bytes memory bytecode = type(DuoswapV2Pair).creationCode;</span>
 14 |     | <span class='unexecuted'>        bytes32 hash = keccak256(bytes(bytecode));</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>        console2.logBytes32(hash);</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'>}</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>// forge script script/PairHashCode.s.sol:PairHashCodeScript</span>
 21 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/elvisskozdopolj/Documents/GitHub/audit-futureswap-jan2023/test/foundry/DuoswapV2.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {IDOS, DOS, DOSConfig, IDOSConfig, DSafeLib, DOSState, IDOSCore} from &quot;../../contracts/dos/DOS.sol&quot;;</span>
   7 |     | <span class='neutral'>import {Call} from &quot;../../contracts/lib/Call.sol&quot;;</span>
   8 |     | <span class='neutral'>import {DSafeProxy, DSafeLogic} from &quot;../../contracts/dos/DSafeProxy.sol&quot;;</span>
   9 |     | <span class='neutral'>import {IVersionManager, VersionManager, ImmutableVersion} from &quot;../../contracts/dos/VersionManager.sol&quot;;</span>
  10 |     | <span class='neutral'>// import &quot;../src/dos/TransferAndCall2.sol&quot;;</span>
  11 |     | <span class='neutral'>import {DuoswapV2Factory} from &quot;../../contracts/duoswapV2/DuoswapV2Factory.sol&quot;;</span>
  12 |     | <span class='neutral'>import {DuoswapV2Pair} from &quot;../../contracts/duoswapV2/DuoswapV2Pair.sol&quot;;</span>
  13 |     | <span class='neutral'>import {DuoswapV2Router} from &quot;../../contracts/duoswapV2/DuoswapV2Router.sol&quot;;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>import {UniV2Oracle} from &quot;../../contracts/oracles/UniV2Oracle.sol&quot;;</span>
  16 |     | <span class='neutral'>import {ERC20ChainlinkValueOracle} from &quot;../../contracts/oracles/ERC20ChainlinkValueOracle.sol&quot;;</span>
  17 |     | <span class='neutral'>import &quot;@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol&quot;;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span>
  20 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/utils/Strings.sol&quot;;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>import {TestERC20} from &quot;../../contracts/testing/TestERC20.sol&quot;;</span>
  23 |     | <span class='neutral'>import {IWETH9} from &quot;../../contracts/external/interfaces/IWETH9.sol&quot;;</span>
  24 |     | <span class='unexecuted'></span>
  25 |     | <span class='neutral'>contract DuoswapV2Test is Test {</span>
  26 |     | <span class='neutral'>    uint256 mainnetFork;</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='unexecuted'>    VersionManager public versionManager;</span>
  29 |     | <span class='unexecuted'>    DuoswapV2Factory public factory;</span>
  30 |     | <span class='unexecuted'>    DuoswapV2Pair public pair;</span>
  31 |     | <span class='unexecuted'>    DuoswapV2Router public router;</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='unexecuted'>    DOS public dos;</span>
  34 |     | <span class='unexecuted'>    DOSConfig public dosConfig;</span>
  35 |     | <span class='unexecuted'>    DSafeProxy public userSafe;</span>
  36 |     | <span class='unexecuted'>    address public pairSafe;</span>
  37 |     | <span class='unexecuted'>    DSafeLogic public logic;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>    IWETH9 public weth = IWETH9(payable(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2));</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    // Create 2 tokens</span>
  42 |     | <span class='unexecuted'>    TestERC20 public token0;</span>
  43 |     | <span class='unexecuted'>    TestERC20 public token1;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='unexecuted'>    AggregatorV3Interface public oracleAddress =</span>
  46 |     | <span class='unexecuted'>        AggregatorV3Interface(0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6);</span>
  47 |     | <span class='unexecuted'>    string MAINNET_RPC_URL = vm.envString(&quot;MAINNET_RPC_URL&quot;);</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>    ERC20ChainlinkValueOracle public token0Oracle;</span>
  50 |     | <span class='unexecuted'>    ERC20ChainlinkValueOracle public token1Oracle;</span>
  51 |     | <span class='unexecuted'>    UniV2Oracle public pairOracle;</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    function setUp() public {</span>
  54 |     | <span class='unexecuted'>        mainnetFork = vm.createFork(MAINNET_RPC_URL);</span>
  55 |     | <span class='unexecuted'>        vm.selectFork(mainnetFork);</span>
  56 |     | <span class='unexecuted'>        token0 = new TestERC20(&quot;token0&quot;, &quot;t0&quot;, 18);</span>
  57 |     | <span class='unexecuted'>        token1 = new TestERC20(&quot;token1&quot;, &quot;t1&quot;, 18);</span>
  58 |     | <span class='unexecuted'>        address owner = address(this);</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='unexecuted'>        token0Oracle = new ERC20ChainlinkValueOracle(address(oracleAddress), 18, 18, 0, 0, owner);</span>
  61 |     | <span class='unexecuted'>        token1Oracle = new ERC20ChainlinkValueOracle(address(oracleAddress), 18, 18, 0, 0, owner);</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='unexecuted'>        versionManager = new VersionManager(owner);</span>
  64 |     | <span class='unexecuted'>        dosConfig = new DOSConfig(owner);</span>
  65 |     | <span class='unexecuted'>        dos = new DOS(address(dosConfig), address(versionManager));</span>
  66 |     | <span class='unexecuted'>        logic = new DSafeLogic(address(dos));</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>        string memory version = &quot;1.0.0&quot;;</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='unexecuted'>        IDOSConfig(address(dos)).addERC20Info(</span>
  71 |     | <span class='neutral'>            address(token0),</span>
  72 |     | <span class='neutral'>            &quot;token0&quot;,</span>
  73 |     | <span class='neutral'>            &quot;t0&quot;,</span>
  74 |     | <span class='neutral'>            18,</span>
  75 |     | <span class='neutral'>            address(token0Oracle),</span>
  76 |     | <span class='unexecuted'>            9e17,</span>
  77 |     | <span class='neutral'>            9e17,</span>
  78 |     | <span class='neutral'>            0,</span>
  79 |     | <span class='neutral'>            0</span>
  80 |     | <span class='neutral'>        );</span>
  81 |     | <span class='unexecuted'>        IDOSConfig(address(dos)).addERC20Info(</span>
  82 |     | <span class='neutral'>            address(token1),</span>
  83 |     | <span class='neutral'>            &quot;token1&quot;,</span>
  84 |     | <span class='neutral'>            &quot;t1&quot;,</span>
  85 |     | <span class='neutral'>            18,</span>
  86 |     | <span class='neutral'>            address(token1Oracle),</span>
  87 |     | <span class='neutral'>            9e17,</span>
  88 |     | <span class='neutral'>            9e17,</span>
  89 |     | <span class='neutral'>            0,</span>
  90 |     | <span class='neutral'>            0</span>
  91 |     | <span class='neutral'>        );</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>        IDOSConfig(address(dos)).setConfig(</span>
  94 |     | <span class='unexecuted'>            IDOSConfig.Config({</span>
  95 |     | <span class='neutral'>                treasurySafe: address(0),</span>
  96 |     | <span class='neutral'>                treasuryInterestFraction: 0,</span>
  97 |     | <span class='unexecuted'>                maxSolvencyCheckGasCost: 10_000_000,</span>
  98 |     | <span class='unexecuted'>                liqFraction: 8e17,</span>
  99 |     | <span class='unexecuted'>                fractionalReserveLeverage: 10</span>
 100 |     | <span class='neutral'>            })</span>
 101 |     | <span class='neutral'>        );</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='unexecuted'>        versionManager.addVersion(IVersionManager.Status.PRODUCTION, address(logic));</span>
 104 |     | <span class='unexecuted'>        versionManager.markRecommendedVersion(version);</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='unexecuted'>        factory = new DuoswapV2Factory(address(dos), owner);</span>
 107 |     | <span class='unexecuted'>        router = new DuoswapV2Router(address(factory), address(weth), address(dos));</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>    function testCreatePair() public {</span>
 111 |     | <span class='unexecuted'>        pair = DuoswapV2Pair(factory.createPair(address(token0), address(token1)));</span>
 112 |     | <span class='unexecuted'>        assertEq(factory.allPairsLength(), 1);</span>
 113 |     | <span class='unexecuted'>        assertEq(factory.allPairs(0), address(pair));</span>
 114 |     | <span class='unexecuted'>        assertEq(factory.getPair(address(token0), address(token1)), address(pair));</span>
 115 |     | <span class='unexecuted'>        assertEq(factory.getPair(address(token1), address(token0)), address(pair));</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    function testAddLiquidity(uint96 _amount0, uint96 _amount1) public {</span>
 119 |     | <span class='unexecuted'>        uint256 amount0 = uint256(_amount0) + 1e18;</span>
 120 |     | <span class='neutral'>        uint256 amount1 = uint256(_amount1) + 1e18;</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='unexecuted'>        userSafe = DSafeProxy(payable(IDOSConfig(address(dos)).createDSafe()));</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='unexecuted'>        _depositTokens(amount0 * 100, amount1 * 100);</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='unexecuted'>        pair = _createPair(address(token0), address(token1));</span>
 127 |     | <span class='unexecuted'>        pairSafe = pair.dSafe();</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='unexecuted'>        token0.mint(address(userSafe), amount0);</span>
 130 |     | <span class='unexecuted'>        token1.mint(address(userSafe), amount1);</span>
 131 |     | <span class='unexecuted'>        Call[] memory calls = new Call[](1);</span>
 132 |     | <span class='unexecuted'>        IERC20[] memory tokens = new IERC20[](2);</span>
 133 |     | <span class='unexecuted'>        tokens[0] = token0;</span>
 134 |     | <span class='unexecuted'>        tokens[1] = token1;</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>        uint256[] memory amounts = new uint256[](2);</span>
 137 |     | <span class='unexecuted'>        amounts[0] = amount0;</span>
 138 |     | <span class='unexecuted'>        amounts[1] = amount1;</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='unexecuted'>        bytes memory callData = abi.encodeWithSignature(</span>
 141 |     | <span class='neutral'>            &quot;addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256)&quot;,</span>
 142 |     | <span class='neutral'>            address(token0),</span>
 143 |     | <span class='neutral'>            address(token1),</span>
 144 |     | <span class='neutral'>            amount0,</span>
 145 |     | <span class='neutral'>            amount1,</span>
 146 |     | <span class='neutral'>            0,</span>
 147 |     | <span class='neutral'>            0,</span>
 148 |     | <span class='neutral'>            address(userSafe),</span>
 149 |     | <span class='unexecuted'>            block.timestamp</span>
 150 |     | <span class='neutral'>        );</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='unexecuted'>        IDOSCore.Approval[] memory approvals = new IDOSCore.Approval[](2);</span>
 153 |     | <span class='unexecuted'>        approvals[0] = (</span>
 154 |     | <span class='unexecuted'>            IDOSCore.Approval({ercContract: address(tokens[0]), amountOrTokenId: amounts[0]})</span>
 155 |     | <span class='neutral'>        );</span>
 156 |     | <span class='unexecuted'>        approvals[1] = (</span>
 157 |     | <span class='unexecuted'>            IDOSCore.Approval({ercContract: address(tokens[1]), amountOrTokenId: amounts[1]})</span>
 158 |     | <span class='neutral'>        );</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='unexecuted'>        calls[0] = (</span>
 161 |     | <span class='unexecuted'>            Call({</span>
 162 |     | <span class='neutral'>                to: address(dos),</span>
 163 |     | <span class='unexecuted'>                callData: abi.encodeWithSignature(</span>
 164 |     | <span class='neutral'>                    &quot;approveAndCall((address,uint256)[],address,bytes)&quot;,</span>
 165 |     | <span class='neutral'>                    approvals,</span>
 166 |     | <span class='unexecuted'>                    address(router),</span>
 167 |     | <span class='neutral'>                    callData</span>
 168 |     | <span class='neutral'>                ),</span>
 169 |     | <span class='neutral'>                value: 0</span>
 170 |     | <span class='neutral'>            })</span>
 171 |     | <span class='neutral'>        );</span>
 172 |     | <span class='unexecuted'>        DSafeLogic(address(userSafe)).executeBatch(calls);</span>
 173 |     | <span class='neutral'>    }</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>    function testDepositTokens() public {</span>
 176 |     | <span class='neutral'>        // mint tokens</span>
 177 |     | <span class='unexecuted'>        token0.mint(address(this), 1e21);</span>
 178 |     | <span class='unexecuted'>        token1.mint(address(this), 1e21);</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>        // deposit tokens to portfolios</span>
 181 |     | <span class='unexecuted'>        userSafe = DSafeProxy(payable(IDOSConfig(address(dos)).createDSafe()));</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='unexecuted'>        token0.transfer(address(userSafe), 1e21);</span>
 184 |     | <span class='unexecuted'>        token1.transfer(address(userSafe), 1e21);</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='unexecuted'>        uint256 userSafeBalance0 = token0.balanceOf(address(userSafe));</span>
 187 |     | <span class='unexecuted'>        uint256 userSafeBalance1 = token1.balanceOf(address(userSafe));</span>
 188 |     | <span class='unexecuted'>        assertEq(userSafeBalance0, 1e21);</span>
 189 |     | <span class='unexecuted'>        assertEq(userSafeBalance1, 1e21);</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='unexecuted'>        Call[] memory calls = new Call[](4);</span>
 192 |     | <span class='unexecuted'>        calls[0] = (</span>
 193 |     | <span class='unexecuted'>            Call({</span>
 194 |     | <span class='neutral'>                to: address(token0),</span>
 195 |     | <span class='unexecuted'>                callData: abi.encodeWithSignature(</span>
 196 |     | <span class='neutral'>                    &quot;approve(address,uint256)&quot;,</span>
 197 |     | <span class='neutral'>                    address(dos),</span>
 198 |     | <span class='neutral'>                    userSafeBalance0</span>
 199 |     | <span class='neutral'>                ),</span>
 200 |     | <span class='neutral'>                value: 0</span>
 201 |     | <span class='neutral'>            })</span>
 202 |     | <span class='neutral'>        );</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='unexecuted'>        calls[1] = (</span>
 205 |     | <span class='unexecuted'>            Call({</span>
 206 |     | <span class='neutral'>                to: address(token1),</span>
 207 |     | <span class='unexecuted'>                callData: abi.encodeWithSignature(</span>
 208 |     | <span class='neutral'>                    &quot;approve(address,uint256)&quot;,</span>
 209 |     | <span class='neutral'>                    address(dos),</span>
 210 |     | <span class='neutral'>                    userSafeBalance1</span>
 211 |     | <span class='neutral'>                ),</span>
 212 |     | <span class='neutral'>                value: 0</span>
 213 |     | <span class='neutral'>            })</span>
 214 |     | <span class='neutral'>        );</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='unexecuted'>        calls[2] = (</span>
 217 |     | <span class='unexecuted'>            Call({</span>
 218 |     | <span class='neutral'>                to: address(dos),</span>
 219 |     | <span class='unexecuted'>                callData: abi.encodeWithSignature(</span>
 220 |     | <span class='neutral'>                    &quot;depositERC20(address,uint256)&quot;,</span>
 221 |     | <span class='neutral'>                    address(token0),</span>
 222 |     | <span class='unexecuted'>                    1e20</span>
 223 |     | <span class='neutral'>                ),</span>
 224 |     | <span class='neutral'>                value: 0</span>
 225 |     | <span class='neutral'>            })</span>
 226 |     | <span class='neutral'>        );</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='unexecuted'>        calls[3] = (</span>
 229 |     | <span class='unexecuted'>            Call({</span>
 230 |     | <span class='neutral'>                to: address(dos),</span>
 231 |     | <span class='unexecuted'>                callData: abi.encodeWithSignature(</span>
 232 |     | <span class='neutral'>                    &quot;depositERC20(address,uint256)&quot;,</span>
 233 |     | <span class='neutral'>                    address(token1),</span>
 234 |     | <span class='neutral'>                    1e20</span>
 235 |     | <span class='neutral'>                ),</span>
 236 |     | <span class='neutral'>                value: 0</span>
 237 |     | <span class='neutral'>            })</span>
 238 |     | <span class='neutral'>        );</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='unexecuted'>        DSafeLogic(address(userSafe)).executeBatch(calls);</span>
 241 |     | <span class='neutral'>    }</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='neutral'>    function testSwap() public {</span>
 244 |     | <span class='neutral'>        // deposit tokens to portfolios</span>
 245 |     | <span class='unexecuted'>        userSafe = DSafeProxy(payable(IDOSConfig(address(dos)).createDSafe()));</span>
 246 |     | <span class='neutral'></span>
 247 |     | <span class='unexecuted'>        _depositTokens(1e30, 1e30);</span>
 248 |     | <span class='neutral'></span>
 249 |     | <span class='neutral'>        // mint tokens</span>
 250 |     | <span class='unexecuted'>        token0.mint(address(userSafe), 1e21);</span>
 251 |     | <span class='unexecuted'>        token1.mint(address(userSafe), 1e21);</span>
 252 |     | <span class='neutral'></span>
 253 |     | <span class='unexecuted'>        _addLiquidity(1e23, 1e23);</span>
 254 |     | <span class='neutral'></span>
 255 |     | <span class='unexecuted'>        address[] memory path = new address[](2);</span>
 256 |     | <span class='unexecuted'>        path[0] = address(token0);</span>
 257 |     | <span class='unexecuted'>        path[1] = address(token1);</span>
 258 |     | <span class='neutral'>        uint256 swapAmount = 1e21;</span>
 259 |     | <span class='neutral'></span>
 260 |     | <span class='unexecuted'>        int256 userSafeBalance0Before = IDOSConfig(address(dos)).getDAccountERC20(</span>
 261 |     | <span class='neutral'>            address(userSafe),</span>
 262 |     | <span class='neutral'>            token0</span>
 263 |     | <span class='neutral'>        );</span>
 264 |     | <span class='unexecuted'>        int256 userSafeBalance1Before = IDOSConfig(address(dos)).getDAccountERC20(</span>
 265 |     | <span class='neutral'>            address(userSafe),</span>
 266 |     | <span class='neutral'>            token1</span>
 267 |     | <span class='neutral'>        );</span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='unexecuted'>        bytes memory data = abi.encodeWithSignature(</span>
 270 |     | <span class='neutral'>            &quot;swapExactTokensForTokens(uint256,uint256,address[],address,uint256)&quot;,</span>
 271 |     | <span class='neutral'>            swapAmount,</span>
 272 |     | <span class='neutral'>            0,</span>
 273 |     | <span class='neutral'>            path,</span>
 274 |     | <span class='neutral'>            address(userSafe),</span>
 275 |     | <span class='neutral'>            block.timestamp</span>
 276 |     | <span class='neutral'>        );</span>
 277 |     | <span class='neutral'></span>
 278 |     | <span class='neutral'>        IDOSCore.Approval[] memory approvals = new IDOSCore.Approval[](1);</span>
 279 |     | <span class='unexecuted'>        approvals[0] = (</span>
 280 |     | <span class='unexecuted'>            IDOSCore.Approval({ercContract: address(token0), amountOrTokenId: swapAmount})</span>
 281 |     | <span class='neutral'>        );</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='unexecuted'>        bytes memory callData = abi.encodeWithSignature(</span>
 284 |     | <span class='neutral'>            &quot;approveAndCall((address,uint256)[],address,bytes)&quot;,</span>
 285 |     | <span class='neutral'>            approvals,</span>
 286 |     | <span class='neutral'>            address(router),</span>
 287 |     | <span class='neutral'>            data</span>
 288 |     | <span class='neutral'>        );</span>
 289 |     | <span class='unexecuted'>        Call[] memory calls = new Call[](1);</span>
 290 |     | <span class='unexecuted'>        calls[0] = (Call({to: address(dos), callData: callData, value: 0}));</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='unexecuted'>        DSafeLogic(address(userSafe)).executeBatch(calls);</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='unexecuted'>        int256 userSafeBalance0After = IDOSConfig(address(dos)).getDAccountERC20(</span>
 295 |     | <span class='neutral'>            address(userSafe),</span>
 296 |     | <span class='neutral'>            IERC20(token0)</span>
 297 |     | <span class='neutral'>        );</span>
 298 |     | <span class='unexecuted'>        int256 userSafeBalance1After = IDOSConfig(address(dos)).getDAccountERC20(</span>
 299 |     | <span class='neutral'>            address(userSafe),</span>
 300 |     | <span class='neutral'>            IERC20(token1)</span>
 301 |     | <span class='neutral'>        );</span>
 302 |     | <span class='neutral'></span>
 303 |     | <span class='unexecuted'>        int256 userSafeBalance0Diff = userSafeBalance0After - userSafeBalance0Before;</span>
 304 |     | <span class='unexecuted'>        int256 userSafeBalance1Diff = userSafeBalance1After - userSafeBalance1Before;</span>
 305 |     | <span class='neutral'></span>
 306 |     | <span class='neutral'>        assertEq(userSafeBalance0After, userSafeBalance0Before - int256(swapAmount));</span>
 307 |     | <span class='unexecuted'>        assert(userSafeBalance1After &gt; userSafeBalance1Before);</span>
 308 |     | <span class='unexecuted'>        assert(userSafeBalance1Diff &gt; 0);</span>
 309 |     | <span class='unexecuted'>        assert(userSafeBalance0Diff &lt; 0);</span>
 310 |     | <span class='neutral'>    }</span>
 311 |     | <span class='neutral'></span>
 312 |     | <span class='neutral'>    function _addLiquidity(uint256 _amount0, uint256 _amount1) public {</span>
 313 |     | <span class='unexecuted'>        pair = _createPair(address(token0), address(token1));</span>
 314 |     | <span class='unexecuted'>        pairSafe = pair.dSafe();</span>
 315 |     | <span class='neutral'></span>
 316 |     | <span class='unexecuted'>        token0.mint(address(userSafe), _amount0);</span>
 317 |     | <span class='unexecuted'>        token1.mint(address(userSafe), _amount1);</span>
 318 |     | <span class='neutral'></span>
 319 |     | <span class='unexecuted'>        bytes memory callData = abi.encodeWithSignature(</span>
 320 |     | <span class='neutral'>            &quot;addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256)&quot;,</span>
 321 |     | <span class='neutral'>            address(token0),</span>
 322 |     | <span class='neutral'>            address(token1),</span>
 323 |     | <span class='neutral'>            _amount0,</span>
 324 |     | <span class='neutral'>            _amount1,</span>
 325 |     | <span class='neutral'>            0,</span>
 326 |     | <span class='neutral'>            0,</span>
 327 |     | <span class='neutral'>            address(userSafe),</span>
 328 |     | <span class='unexecuted'>            block.timestamp</span>
 329 |     | <span class='neutral'>        );</span>
 330 |     | <span class='neutral'></span>
 331 |     | <span class='unexecuted'>        IDOSCore.Approval[] memory approvals = new IDOSCore.Approval[](2);</span>
 332 |     | <span class='unexecuted'>        approvals[0] = (</span>
 333 |     | <span class='unexecuted'>            IDOSCore.Approval({ercContract: address(token0), amountOrTokenId: _amount0})</span>
 334 |     | <span class='neutral'>        );</span>
 335 |     | <span class='unexecuted'>        approvals[1] = (</span>
 336 |     | <span class='unexecuted'>            IDOSCore.Approval({ercContract: address(token1), amountOrTokenId: _amount1})</span>
 337 |     | <span class='neutral'>        );</span>
 338 |     | <span class='neutral'></span>
 339 |     | <span class='unexecuted'>        Call[] memory calls = new Call[](1);</span>
 340 |     | <span class='neutral'></span>
 341 |     | <span class='unexecuted'>        calls[0] = (</span>
 342 |     | <span class='unexecuted'>            Call({</span>
 343 |     | <span class='unexecuted'>                to: address(dos),</span>
 344 |     | <span class='unexecuted'>                callData: abi.encodeWithSignature(</span>
 345 |     | <span class='neutral'>                    &quot;approveAndCall((address,uint256)[],address,bytes)&quot;,</span>
 346 |     | <span class='neutral'>                    approvals,</span>
 347 |     | <span class='unexecuted'>                    address(router),</span>
 348 |     | <span class='neutral'>                    callData</span>
 349 |     | <span class='neutral'>                ),</span>
 350 |     | <span class='neutral'>                value: 0</span>
 351 |     | <span class='neutral'>            })</span>
 352 |     | <span class='neutral'>        );</span>
 353 |     | <span class='unexecuted'>        DSafeLogic(address(userSafe)).executeBatch(calls);</span>
 354 |     | <span class='neutral'>    }</span>
 355 |     | <span class='neutral'></span>
 356 |     | <span class='unexecuted'>    function _depositTokens(uint256 _amount0, uint256 _amount1) public {</span>
 357 |     | <span class='neutral'>        // mint tokens</span>
 358 |     | <span class='unexecuted'>        token0.mint(address(userSafe), _amount0);</span>
 359 |     | <span class='unexecuted'>        token1.mint(address(userSafe), _amount1);</span>
 360 |     | <span class='neutral'></span>
 361 |     | <span class='unexecuted'>        Call[] memory calls = new Call[](4);</span>
 362 |     | <span class='unexecuted'>        calls[0] = (</span>
 363 |     | <span class='unexecuted'>            Call({</span>
 364 |     | <span class='neutral'>                to: address(token0),</span>
 365 |     | <span class='unexecuted'>                callData: abi.encodeWithSignature(</span>
 366 |     | <span class='neutral'>                    &quot;approve(address,uint256)&quot;,</span>
 367 |     | <span class='unexecuted'>                    address(dos),</span>
 368 |     | <span class='neutral'>                    _amount0</span>
 369 |     | <span class='neutral'>                ),</span>
 370 |     | <span class='neutral'>                value: 0</span>
 371 |     | <span class='neutral'>            })</span>
 372 |     | <span class='neutral'>        );</span>
 373 |     | <span class='neutral'></span>
 374 |     | <span class='unexecuted'>        calls[1] = (</span>
 375 |     | <span class='unexecuted'>            Call({</span>
 376 |     | <span class='neutral'>                to: address(token1),</span>
 377 |     | <span class='unexecuted'>                callData: abi.encodeWithSignature(</span>
 378 |     | <span class='neutral'>                    &quot;approve(address,uint256)&quot;,</span>
 379 |     | <span class='neutral'>                    address(dos),</span>
 380 |     | <span class='neutral'>                    _amount1</span>
 381 |     | <span class='neutral'>                ),</span>
 382 |     | <span class='neutral'>                value: 0</span>
 383 |     | <span class='neutral'>            })</span>
 384 |     | <span class='neutral'>        );</span>
 385 |     | <span class='neutral'></span>
 386 |     | <span class='unexecuted'>        calls[2] = (</span>
 387 |     | <span class='unexecuted'>            Call({</span>
 388 |     | <span class='neutral'>                to: address(dos),</span>
 389 |     | <span class='unexecuted'>                callData: abi.encodeWithSignature(</span>
 390 |     | <span class='neutral'>                    &quot;depositERC20(address,uint256)&quot;,</span>
 391 |     | <span class='neutral'>                    address(token0),</span>
 392 |     | <span class='neutral'>                    _amount0</span>
 393 |     | <span class='neutral'>                ),</span>
 394 |     | <span class='neutral'>                value: 0</span>
 395 |     | <span class='neutral'>            })</span>
 396 |     | <span class='neutral'>        );</span>
 397 |     | <span class='neutral'></span>
 398 |     | <span class='unexecuted'>        calls[3] = (</span>
 399 |     | <span class='unexecuted'>            Call({</span>
 400 |     | <span class='neutral'>                to: address(dos),</span>
 401 |     | <span class='unexecuted'>                callData: abi.encodeWithSignature(</span>
 402 |     | <span class='neutral'>                    &quot;depositERC20(address,uint256)&quot;,</span>
 403 |     | <span class='neutral'>                    address(token1),</span>
 404 |     | <span class='neutral'>                    _amount1</span>
 405 |     | <span class='neutral'>                ),</span>
 406 |     | <span class='neutral'>                value: 0</span>
 407 |     | <span class='neutral'>            })</span>
 408 |     | <span class='neutral'>        );</span>
 409 |     | <span class='neutral'></span>
 410 |     | <span class='unexecuted'>        DSafeLogic(address(userSafe)).executeBatch(calls);</span>
 411 |     | <span class='neutral'>    }</span>
 412 |     | <span class='neutral'></span>
 413 |     | <span class='unexecuted'>    function _createPair(address _token0, address _token1) public returns (DuoswapV2Pair _pair) {</span>
 414 |     | <span class='unexecuted'>        _pair = DuoswapV2Pair(factory.createPair(_token0, _token1));</span>
 415 |     | <span class='unexecuted'>        pairOracle = new UniV2Oracle(address(dos), address(_pair), address(this));</span>
 416 |     | <span class='unexecuted'>        pairOracle.setERC20ValueOracle(address(token0), address(token0Oracle));</span>
 417 |     | <span class='unexecuted'>        pairOracle.setERC20ValueOracle(address(token1), address(token1Oracle));</span>
 418 |     | <span class='unexecuted'>        IDOSConfig(address(dos)).addERC20Info(</span>
 419 |     | <span class='neutral'>            address(_pair),</span>
 420 |     | <span class='neutral'>            &quot;uni-v2&quot;,</span>
 421 |     | <span class='neutral'>            &quot;t0-t1&quot;,</span>
 422 |     | <span class='unexecuted'>            18,</span>
 423 |     | <span class='neutral'>            address(pairOracle),</span>
 424 |     | <span class='unexecuted'>            9e17,</span>
 425 |     | <span class='neutral'>            9e17,</span>
 426 |     | <span class='neutral'>            0,</span>
 427 |     | <span class='neutral'>            0</span>
 428 |     | <span class='neutral'>        );</span>
 429 |     | <span class='unexecuted'>        return _pair;</span>
 430 |     | <span class='neutral'>    }</span>
 431 |     | <span class='neutral'>}</span>
 432 |     | <span class='unexecuted'></span>
 433 |     | <span class='neutral'>contract DuoswapV2ConstructorTest is Test {</span>
 434 |     | <span class='unexecuted'>    address public oracleAddress = 0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6;</span>
 435 |     | <span class='neutral'></span>
 436 |     | <span class='neutral'>    function testBaseDecimalsValidation(uint8 baseDecimals) public {</span>
 437 |     | <span class='unexecuted'>        vm.assume(baseDecimals &lt; 3 || 18 &lt; baseDecimals);</span>
 438 |     | <span class='neutral'></span>
 439 |     | <span class='unexecuted'>        address owner = address(this);</span>
 440 |     | <span class='neutral'>        string memory reason = string.concat(</span>
 441 |     | <span class='neutral'>            &quot;Invalid baseDecimals: must be within [3, 18] range while provided is &quot;,</span>
 442 |     | <span class='unexecuted'>            Strings.toString(baseDecimals)</span>
 443 |     | <span class='neutral'>        );</span>
 444 |     | <span class='unexecuted'>        vm.expectRevert(bytes(reason));</span>
 445 |     | <span class='unexecuted'>        new ERC20ChainlinkValueOracle(address(oracleAddress), baseDecimals, 18, 0, 0, owner);</span>
 446 |     | <span class='neutral'>    }</span>
 447 |     | <span class='neutral'></span>
 448 |     | <span class='neutral'>    function testTokenDecimalsValidation(uint8 tokenDecimals) public {</span>
 449 |     | <span class='unexecuted'>        vm.assume(tokenDecimals &lt; 3 || 18 &lt; tokenDecimals);</span>
 450 |     | <span class='neutral'></span>
 451 |     | <span class='unexecuted'>        address owner = address(this);</span>
 452 |     | <span class='neutral'>        string memory reason = string.concat(</span>
 453 |     | <span class='neutral'>            &quot;Invalid tokenDecimals: must be within [3, 18] range while provided is &quot;,</span>
 454 |     | <span class='unexecuted'>            Strings.toString(tokenDecimals)</span>
 455 |     | <span class='neutral'>        );</span>
 456 |     | <span class='unexecuted'>        vm.expectRevert(bytes(reason));</span>
 457 |     | <span class='unexecuted'>        new ERC20ChainlinkValueOracle(address(oracleAddress), 18, tokenDecimals, 0, 0, owner);</span>
 458 |     | <span class='neutral'>    }</span>
 459 |     | <span class='neutral'>}</span>
 460 |     | <span class='neutral'></span>

</code>
<br />

